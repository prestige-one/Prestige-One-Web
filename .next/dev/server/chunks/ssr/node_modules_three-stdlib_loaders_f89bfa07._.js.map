{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/MD2Loader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/MD2Loader.js"],"sourcesContent":["import { AnimationClip, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Vector3 } from 'three'\n\nconst _normalData = [\n  [-0.525731, 0.0, 0.850651],\n  [-0.442863, 0.238856, 0.864188],\n  [-0.295242, 0.0, 0.955423],\n  [-0.309017, 0.5, 0.809017],\n  [-0.16246, 0.262866, 0.951056],\n  [0.0, 0.0, 1.0],\n  [0.0, 0.850651, 0.525731],\n  [-0.147621, 0.716567, 0.681718],\n  [0.147621, 0.716567, 0.681718],\n  [0.0, 0.525731, 0.850651],\n  [0.309017, 0.5, 0.809017],\n  [0.525731, 0.0, 0.850651],\n  [0.295242, 0.0, 0.955423],\n  [0.442863, 0.238856, 0.864188],\n  [0.16246, 0.262866, 0.951056],\n  [-0.681718, 0.147621, 0.716567],\n  [-0.809017, 0.309017, 0.5],\n  [-0.587785, 0.425325, 0.688191],\n  [-0.850651, 0.525731, 0.0],\n  [-0.864188, 0.442863, 0.238856],\n  [-0.716567, 0.681718, 0.147621],\n  [-0.688191, 0.587785, 0.425325],\n  [-0.5, 0.809017, 0.309017],\n  [-0.238856, 0.864188, 0.442863],\n  [-0.425325, 0.688191, 0.587785],\n  [-0.716567, 0.681718, -0.147621],\n  [-0.5, 0.809017, -0.309017],\n  [-0.525731, 0.850651, 0.0],\n  [0.0, 0.850651, -0.525731],\n  [-0.238856, 0.864188, -0.442863],\n  [0.0, 0.955423, -0.295242],\n  [-0.262866, 0.951056, -0.16246],\n  [0.0, 1.0, 0.0],\n  [0.0, 0.955423, 0.295242],\n  [-0.262866, 0.951056, 0.16246],\n  [0.238856, 0.864188, 0.442863],\n  [0.262866, 0.951056, 0.16246],\n  [0.5, 0.809017, 0.309017],\n  [0.238856, 0.864188, -0.442863],\n  [0.262866, 0.951056, -0.16246],\n  [0.5, 0.809017, -0.309017],\n  [0.850651, 0.525731, 0.0],\n  [0.716567, 0.681718, 0.147621],\n  [0.716567, 0.681718, -0.147621],\n  [0.525731, 0.850651, 0.0],\n  [0.425325, 0.688191, 0.587785],\n  [0.864188, 0.442863, 0.238856],\n  [0.688191, 0.587785, 0.425325],\n  [0.809017, 0.309017, 0.5],\n  [0.681718, 0.147621, 0.716567],\n  [0.587785, 0.425325, 0.688191],\n  [0.955423, 0.295242, 0.0],\n  [1.0, 0.0, 0.0],\n  [0.951056, 0.16246, 0.262866],\n  [0.850651, -0.525731, 0.0],\n  [0.955423, -0.295242, 0.0],\n  [0.864188, -0.442863, 0.238856],\n  [0.951056, -0.16246, 0.262866],\n  [0.809017, -0.309017, 0.5],\n  [0.681718, -0.147621, 0.716567],\n  [0.850651, 0.0, 0.525731],\n  [0.864188, 0.442863, -0.238856],\n  [0.809017, 0.309017, -0.5],\n  [0.951056, 0.16246, -0.262866],\n  [0.525731, 0.0, -0.850651],\n  [0.681718, 0.147621, -0.716567],\n  [0.681718, -0.147621, -0.716567],\n  [0.850651, 0.0, -0.525731],\n  [0.809017, -0.309017, -0.5],\n  [0.864188, -0.442863, -0.238856],\n  [0.951056, -0.16246, -0.262866],\n  [0.147621, 0.716567, -0.681718],\n  [0.309017, 0.5, -0.809017],\n  [0.425325, 0.688191, -0.587785],\n  [0.442863, 0.238856, -0.864188],\n  [0.587785, 0.425325, -0.688191],\n  [0.688191, 0.587785, -0.425325],\n  [-0.147621, 0.716567, -0.681718],\n  [-0.309017, 0.5, -0.809017],\n  [0.0, 0.525731, -0.850651],\n  [-0.525731, 0.0, -0.850651],\n  [-0.442863, 0.238856, -0.864188],\n  [-0.295242, 0.0, -0.955423],\n  [-0.16246, 0.262866, -0.951056],\n  [0.0, 0.0, -1.0],\n  [0.295242, 0.0, -0.955423],\n  [0.16246, 0.262866, -0.951056],\n  [-0.442863, -0.238856, -0.864188],\n  [-0.309017, -0.5, -0.809017],\n  [-0.16246, -0.262866, -0.951056],\n  [0.0, -0.850651, -0.525731],\n  [-0.147621, -0.716567, -0.681718],\n  [0.147621, -0.716567, -0.681718],\n  [0.0, -0.525731, -0.850651],\n  [0.309017, -0.5, -0.809017],\n  [0.442863, -0.238856, -0.864188],\n  [0.16246, -0.262866, -0.951056],\n  [0.238856, -0.864188, -0.442863],\n  [0.5, -0.809017, -0.309017],\n  [0.425325, -0.688191, -0.587785],\n  [0.716567, -0.681718, -0.147621],\n  [0.688191, -0.587785, -0.425325],\n  [0.587785, -0.425325, -0.688191],\n  [0.0, -0.955423, -0.295242],\n  [0.0, -1.0, 0.0],\n  [0.262866, -0.951056, -0.16246],\n  [0.0, -0.850651, 0.525731],\n  [0.0, -0.955423, 0.295242],\n  [0.238856, -0.864188, 0.442863],\n  [0.262866, -0.951056, 0.16246],\n  [0.5, -0.809017, 0.309017],\n  [0.716567, -0.681718, 0.147621],\n  [0.525731, -0.850651, 0.0],\n  [-0.238856, -0.864188, -0.442863],\n  [-0.5, -0.809017, -0.309017],\n  [-0.262866, -0.951056, -0.16246],\n  [-0.850651, -0.525731, 0.0],\n  [-0.716567, -0.681718, -0.147621],\n  [-0.716567, -0.681718, 0.147621],\n  [-0.525731, -0.850651, 0.0],\n  [-0.5, -0.809017, 0.309017],\n  [-0.238856, -0.864188, 0.442863],\n  [-0.262866, -0.951056, 0.16246],\n  [-0.864188, -0.442863, 0.238856],\n  [-0.809017, -0.309017, 0.5],\n  [-0.688191, -0.587785, 0.425325],\n  [-0.681718, -0.147621, 0.716567],\n  [-0.442863, -0.238856, 0.864188],\n  [-0.587785, -0.425325, 0.688191],\n  [-0.309017, -0.5, 0.809017],\n  [-0.147621, -0.716567, 0.681718],\n  [-0.425325, -0.688191, 0.587785],\n  [-0.16246, -0.262866, 0.951056],\n  [0.442863, -0.238856, 0.864188],\n  [0.16246, -0.262866, 0.951056],\n  [0.309017, -0.5, 0.809017],\n  [0.147621, -0.716567, 0.681718],\n  [0.0, -0.525731, 0.850651],\n  [0.425325, -0.688191, 0.587785],\n  [0.587785, -0.425325, 0.688191],\n  [0.688191, -0.587785, 0.425325],\n  [-0.955423, 0.295242, 0.0],\n  [-0.951056, 0.16246, 0.262866],\n  [-1.0, 0.0, 0.0],\n  [-0.850651, 0.0, 0.525731],\n  [-0.955423, -0.295242, 0.0],\n  [-0.951056, -0.16246, 0.262866],\n  [-0.864188, 0.442863, -0.238856],\n  [-0.951056, 0.16246, -0.262866],\n  [-0.809017, 0.309017, -0.5],\n  [-0.864188, -0.442863, -0.238856],\n  [-0.951056, -0.16246, -0.262866],\n  [-0.809017, -0.309017, -0.5],\n  [-0.681718, 0.147621, -0.716567],\n  [-0.681718, -0.147621, -0.716567],\n  [-0.850651, 0.0, -0.525731],\n  [-0.688191, 0.587785, -0.425325],\n  [-0.587785, 0.425325, -0.688191],\n  [-0.425325, 0.688191, -0.587785],\n  [-0.425325, -0.688191, -0.587785],\n  [-0.587785, -0.425325, -0.688191],\n  [-0.688191, -0.587785, -0.425325],\n]\n\nclass MD2Loader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(buffer) {\n    const data = new DataView(buffer)\n\n    // http://tfc.duke.free.fr/coding/md2-specs-en.html\n\n    const header = {}\n    const headerNames = [\n      'ident',\n      'version',\n      'skinwidth',\n      'skinheight',\n      'framesize',\n      'num_skins',\n      'num_vertices',\n      'num_st',\n      'num_tris',\n      'num_glcmds',\n      'num_frames',\n      'offset_skins',\n      'offset_st',\n      'offset_tris',\n      'offset_frames',\n      'offset_glcmds',\n      'offset_end',\n    ]\n\n    for (let i = 0; i < headerNames.length; i++) {\n      header[headerNames[i]] = data.getInt32(i * 4, true)\n    }\n\n    if (header.ident !== 844121161 || header.version !== 8) {\n      console.error('Not a valid MD2 file')\n      return\n    }\n\n    if (header.offset_end !== data.byteLength) {\n      console.error('Corrupted MD2 file')\n      return\n    }\n\n    //\n\n    const geometry = new BufferGeometry()\n\n    // uvs\n\n    const uvsTemp = []\n    let offset = header.offset_st\n\n    for (let i = 0, l = header.num_st; i < l; i++) {\n      const u = data.getInt16(offset + 0, true)\n      const v = data.getInt16(offset + 2, true)\n\n      uvsTemp.push(u / header.skinwidth, 1 - v / header.skinheight)\n\n      offset += 4\n    }\n\n    // triangles\n\n    offset = header.offset_tris\n\n    const vertexIndices = []\n    const uvIndices = []\n\n    for (let i = 0, l = header.num_tris; i < l; i++) {\n      vertexIndices.push(\n        data.getUint16(offset + 0, true),\n        data.getUint16(offset + 2, true),\n        data.getUint16(offset + 4, true),\n      )\n\n      uvIndices.push(\n        data.getUint16(offset + 6, true),\n        data.getUint16(offset + 8, true),\n        data.getUint16(offset + 10, true),\n      )\n\n      offset += 12\n    }\n\n    // frames\n\n    const translation = new Vector3()\n    const scale = new Vector3()\n    const string = []\n\n    const frames = []\n\n    offset = header.offset_frames\n\n    for (let i = 0, l = header.num_frames; i < l; i++) {\n      scale.set(data.getFloat32(offset + 0, true), data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true))\n\n      translation.set(\n        data.getFloat32(offset + 12, true),\n        data.getFloat32(offset + 16, true),\n        data.getFloat32(offset + 20, true),\n      )\n\n      offset += 24\n\n      for (let j = 0; j < 16; j++) {\n        const character = data.getUint8(offset + j, true)\n        if (character === 0) break\n\n        string[j] = character\n      }\n\n      const frame = {\n        name: String.fromCharCode.apply(null, string),\n        vertices: [],\n        normals: [],\n      }\n\n      offset += 16\n\n      for (let j = 0; j < header.num_vertices; j++) {\n        let x = data.getUint8(offset++, true)\n        let y = data.getUint8(offset++, true)\n        let z = data.getUint8(offset++, true)\n        const n = _normalData[data.getUint8(offset++, true)]\n\n        x = x * scale.x + translation.x\n        y = y * scale.y + translation.y\n        z = z * scale.z + translation.z\n\n        frame.vertices.push(x, z, y) // convert to Y-up\n        frame.normals.push(n[0], n[2], n[1]) // convert to Y-up\n      }\n\n      frames.push(frame)\n    }\n\n    // static\n\n    const positions = []\n    const normals = []\n    const uvs = []\n\n    const verticesTemp = frames[0].vertices\n    const normalsTemp = frames[0].normals\n\n    for (let i = 0, l = vertexIndices.length; i < l; i++) {\n      const vertexIndex = vertexIndices[i]\n      let stride = vertexIndex * 3\n\n      //\n\n      const x = verticesTemp[stride]\n      const y = verticesTemp[stride + 1]\n      const z = verticesTemp[stride + 2]\n\n      positions.push(x, y, z)\n\n      //\n\n      const nx = normalsTemp[stride]\n      const ny = normalsTemp[stride + 1]\n      const nz = normalsTemp[stride + 2]\n\n      normals.push(nx, ny, nz)\n\n      //\n\n      const uvIndex = uvIndices[i]\n      stride = uvIndex * 2\n\n      const u = uvsTemp[stride]\n      const v = uvsTemp[stride + 1]\n\n      uvs.push(u, v)\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n    // animation\n\n    const morphPositions = []\n    const morphNormals = []\n\n    for (let i = 0, l = frames.length; i < l; i++) {\n      const frame = frames[i]\n      const attributeName = frame.name\n\n      if (frame.vertices.length > 0) {\n        const positions = []\n\n        for (let j = 0, jl = vertexIndices.length; j < jl; j++) {\n          const vertexIndex = vertexIndices[j]\n          const stride = vertexIndex * 3\n\n          const x = frame.vertices[stride]\n          const y = frame.vertices[stride + 1]\n          const z = frame.vertices[stride + 2]\n\n          positions.push(x, y, z)\n        }\n\n        const positionAttribute = new Float32BufferAttribute(positions, 3)\n        positionAttribute.name = attributeName\n\n        morphPositions.push(positionAttribute)\n      }\n\n      if (frame.normals.length > 0) {\n        const normals = []\n\n        for (let j = 0, jl = vertexIndices.length; j < jl; j++) {\n          const vertexIndex = vertexIndices[j]\n          const stride = vertexIndex * 3\n\n          const nx = frame.normals[stride]\n          const ny = frame.normals[stride + 1]\n          const nz = frame.normals[stride + 2]\n\n          normals.push(nx, ny, nz)\n        }\n\n        const normalAttribute = new Float32BufferAttribute(normals, 3)\n        normalAttribute.name = attributeName\n\n        morphNormals.push(normalAttribute)\n      }\n    }\n\n    geometry.morphAttributes.position = morphPositions\n    geometry.morphAttributes.normal = morphNormals\n    geometry.morphTargetsRelative = false\n\n    geometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences(frames, 10)\n\n    return geometry\n  }\n}\n\nexport { MD2Loader }\n"],"names":["positions","normals"],"mappings":"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"}},
    {"offset": {"line": 1001, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/GLTFLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/GLTFLoader.js"],"sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = /* @__PURE__ */ new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = /* @__PURE__ */ new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n"],"names":["self","res","sourceURI","node","accessor"],"mappings":"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"}},
    {"offset": {"line": 3518, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/FBXLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/FBXLoader.js"],"sourcesContent":["import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  EquirectangularReflectionMapping,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Line,\n  LineBasicMaterial,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  Vector4,\n  VectorKeyframeTrack,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { NURBSCurve } from '../curves/NURBSCurve'\nimport { decodeText } from '../_polyfill/LoaderUtils'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nlet fbxTree\nlet connections\nlet sceneGraph\n\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer)\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer)\n\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error('THREE.FBXLoader: Unknown format.')\n      }\n\n      if (getFbxVersion(FBXText) < 7000) {\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText))\n      }\n\n      fbxTree = new TextParser().parse(FBXText)\n    }\n\n    // console.log( fbxTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree)\n  }\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader\n    this.manager = manager\n  }\n\n  parse() {\n    connections = this.parseConnections()\n\n    const images = this.parseImages()\n    const textures = this.parseTextures(images)\n    const materials = this.parseMaterials(textures)\n    const deformers = this.parseDeformers()\n    const geometryMap = new GeometryParser().parse(deformers)\n\n    this.parseScene(deformers, geometryMap, materials)\n\n    return sceneGraph\n  }\n\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const connectionMap = new Map()\n\n    if ('Connections' in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections\n\n      rawConnections.forEach(function (rawConnection) {\n        const fromID = rawConnection[0]\n        const toID = rawConnection[1]\n        const relationship = rawConnection[2]\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const parentRelationship = { ID: toID, relationship: relationship }\n        connectionMap.get(fromID).parents.push(parentRelationship)\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const childRelationship = { ID: fromID, relationship: relationship }\n        connectionMap.get(toID).children.push(childRelationship)\n      })\n    }\n\n    return connectionMap\n  }\n\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const images = {}\n    const blobs = {}\n\n    if ('Video' in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video\n\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID]\n\n        const id = parseInt(nodeID)\n\n        images[id] = videoNode.RelativeFilename || videoNode.Filename\n\n        // raw image data is in videoNode.Content\n        if ('Content' in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0\n          const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== ''\n\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID])\n\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image\n          }\n        }\n      }\n    }\n\n    for (const id in images) {\n      const filename = images[id]\n\n      if (blobs[filename] !== undefined) images[id] = blobs[filename]\n      else images[id] = images[id].split('\\\\').pop()\n    }\n\n    return images\n  }\n\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(videoNode) {\n    const content = videoNode.Content\n    const fileName = videoNode.RelativeFilename || videoNode.Filename\n    const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase()\n\n    let type\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp'\n        break\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg'\n        break\n\n      case 'png':\n        type = 'image/png'\n        break\n\n      case 'tif':\n        type = 'image/tiff'\n        break\n\n      case 'tga':\n        if (this.manager.getHandler('.tga') === null) {\n          console.warn('FBXLoader: TGA loader not found, skipping ', fileName)\n        }\n\n        type = 'image/tga'\n        break\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.')\n        return\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n\n      return 'data:' + type + ';base64,' + content\n    } else {\n      // Binary Format\n\n      const array = new Uint8Array(content)\n      return window.URL.createObjectURL(new Blob([array], { type: type }))\n    }\n  }\n\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(images) {\n    const textureMap = new Map()\n\n    if ('Texture' in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images)\n        textureMap.set(parseInt(nodeID), texture)\n      }\n    }\n\n    return textureMap\n  }\n\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images)\n\n    texture.ID = textureNode.id\n\n    texture.name = textureNode.attrName\n\n    const wrapModeU = textureNode.WrapModeU\n    const wrapModeV = textureNode.WrapModeV\n\n    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0\n    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0\n\n    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping\n\n    if ('Scaling' in textureNode) {\n      const values = textureNode.Scaling.value\n\n      texture.repeat.x = values[0]\n      texture.repeat.y = values[1]\n    }\n\n    return texture\n  }\n\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(textureNode, images) {\n    let fileName\n\n    const currentPath = this.textureLoader.path\n\n    const children = connections.get(textureNode.id).children\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID]\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        this.textureLoader.setPath(undefined)\n      }\n    }\n\n    let texture\n\n    const extension = textureNode.FileName.slice(-3).toLowerCase()\n\n    if (extension === 'tga') {\n      const loader = this.manager.getHandler('.tga')\n\n      if (loader === null) {\n        console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename)\n        texture = new Texture()\n      } else {\n        loader.setPath(this.textureLoader.path)\n        texture = loader.load(fileName)\n      }\n    } else if (extension === 'psd') {\n      console.warn(\n        'FBXLoader: PSD textures are not supported, creating placeholder texture for',\n        textureNode.RelativeFilename,\n      )\n      texture = new Texture()\n    } else {\n      texture = this.textureLoader.load(fileName)\n    }\n\n    this.textureLoader.setPath(currentPath)\n\n    return texture\n  }\n\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(textureMap) {\n    const materialMap = new Map()\n\n    if ('Material' in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material\n\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap)\n\n        if (material !== null) materialMap.set(parseInt(nodeID), material)\n      }\n    }\n\n    return materialMap\n  }\n\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id\n    const name = materialNode.attrName\n    let type = materialNode.ShadingModel\n\n    // Case where FBX wraps shading model in property object.\n    if (typeof type === 'object') {\n      type = type.value\n    }\n\n    // Ignore unused materials which don't have any connections.\n    if (!connections.has(ID)) return null\n\n    const parameters = this.parseParameters(materialNode, textureMap, ID)\n\n    let material\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new MeshPhongMaterial()\n        break\n      case 'lambert':\n        material = new MeshLambertMaterial()\n        break\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type)\n        material = new MeshPhongMaterial()\n        break\n    }\n\n    material.setValues(parameters)\n    material.name = name\n\n    return material\n  }\n\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {}\n\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value\n    }\n\n    if (materialNode.Diffuse) {\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value)\n    } else if (\n      materialNode.DiffuseColor &&\n      (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value)\n    }\n\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value\n    }\n\n    if (materialNode.Emissive) {\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value)\n    } else if (\n      materialNode.EmissiveColor &&\n      (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports emissive color here instead of in materialNode.Emissive\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value)\n    }\n\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value)\n    }\n\n    if (materialNode.Opacity) {\n      parameters.opacity = parseFloat(materialNode.Opacity.value)\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true\n    }\n\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value\n    }\n\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value\n    }\n\n    if (materialNode.Specular) {\n      parameters.specular = new Color().fromArray(materialNode.Specular.value)\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in materialNode.Specular\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value)\n    }\n\n    const scope = this\n    connections.get(ID).children.forEach(function (child) {\n      const type = child.relationship\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'Maya|TEX_ao_map':\n          parameters.aoMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'DiffuseColor':\n        case 'Maya|TEX_color_map':\n          parameters.map = scope.getTexture(textureMap, child.ID)\n          if (parameters.map !== undefined) {\n            if ('colorSpace' in parameters.map) parameters.map.colorSpace = 'srgb'\n            else parameters.map.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'DisplacementColor':\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.emissiveMap !== undefined) {\n            if ('colorSpace' in parameters.emissiveMap) parameters.emissiveMap.colorSpace = 'srgb'\n            else parameters.emissiveMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'NormalMap':\n        case 'Maya|TEX_normal_map':\n          parameters.normalMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'ReflectionColor':\n          parameters.envMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.envMap !== undefined) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping\n\n            if ('colorSpace' in parameters.envMap) parameters.envMap.colorSpace = 'srgb'\n            else parameters.envMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'SpecularColor':\n          parameters.specularMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.specularMap !== undefined) {\n            if ('colorSpace' in parameters.specularMap) parameters.specularMap.colorSpace = 'srgb'\n            else parameters.specularMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'TransparentColor':\n        case 'TransparencyFactor':\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID)\n          parameters.transparent = true\n          break\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n        case 'SpecularFactor': // AKA specularLevel\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type)\n          break\n      }\n    })\n\n    return parameters\n  }\n\n  // get a texture from the textureMap for use by a material.\n  getTexture(textureMap, id) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.')\n      id = connections.get(id).children[0].ID\n    }\n\n    return textureMap.get(id)\n  }\n\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const skeletons = {}\n    const morphTargets = {}\n\n    if ('Deformer' in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer\n\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID]\n\n        const relationships = connections.get(parseInt(nodeID))\n\n        if (deformerNode.attrType === 'Skin') {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes)\n          skeleton.ID = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.')\n          }\n          skeleton.geometryID = relationships.parents[0].ID\n\n          skeletons[nodeID] = skeleton\n        } else if (deformerNode.attrType === 'BlendShape') {\n          const morphTarget = {\n            id: nodeID,\n          }\n\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes)\n          morphTarget.id = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.')\n          }\n\n          morphTargets[nodeID] = morphTarget\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets,\n    }\n  }\n\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = []\n\n    relationships.children.forEach(function (child) {\n      const boneNode = deformerNodes[child.ID]\n\n      if (boneNode.attrType !== 'Cluster') return\n\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a),\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      }\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a\n        rawBone.weights = boneNode.Weights.a\n      }\n\n      rawBones.push(rawBone)\n    })\n\n    return {\n      rawBones: rawBones,\n      bones: [],\n    }\n  }\n\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = []\n\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i]\n\n      const morphTargetNode = deformerNodes[child.ID]\n\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a,\n      }\n\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return\n\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n        return child.relationship === undefined\n      })[0].ID\n\n      rawMorphTargets.push(rawMorphTarget)\n    }\n\n    return rawMorphTargets\n  }\n\n  // create the main Group() to be returned by the loader\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group()\n\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap)\n\n    const modelNodes = fbxTree.Objects.Model\n\n    const scope = this\n    modelMap.forEach(function (model) {\n      const modelNode = modelNodes[model.ID]\n      scope.setLookAtProperties(model, modelNode)\n\n      const parentConnections = connections.get(model.ID).parents\n\n      parentConnections.forEach(function (connection) {\n        const parent = modelMap.get(connection.ID)\n        if (parent !== undefined) parent.add(model)\n      })\n\n      if (model.parent === null) {\n        sceneGraph.add(model)\n      }\n    })\n\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap)\n\n    this.createAmbientLight()\n\n    sceneGraph.traverse(function (node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld\n        }\n\n        const transform = generateTransform(node.userData.transformData)\n\n        node.applyMatrix4(transform)\n        node.updateWorldMatrix()\n      }\n    })\n\n    const animations = new AnimationParser().parse()\n\n    // if all the models where already combined in a single group, just return that\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations\n      sceneGraph = sceneGraph.children[0]\n    }\n\n    sceneGraph.animations = animations\n  }\n\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = new Map()\n    const modelNodes = fbxTree.Objects.Model\n\n    for (const nodeID in modelNodes) {\n      const id = parseInt(nodeID)\n      const node = modelNodes[nodeID]\n      const relationships = connections.get(id)\n\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName)\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = this.createCamera(relationships)\n            break\n          case 'Light':\n            model = this.createLight(relationships)\n            break\n          case 'Mesh':\n            model = this.createMesh(relationships, geometryMap, materialMap)\n            break\n          case 'NurbsCurve':\n            model = this.createCurve(relationships, geometryMap)\n            break\n          case 'LimbNode':\n          case 'Root':\n            model = new Bone()\n            break\n          case 'Null':\n          default:\n            model = new Group()\n            break\n        }\n\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : ''\n\n        model.ID = id\n      }\n\n      this.getTransformData(model, node)\n      modelMap.set(id, model)\n    }\n\n    return modelMap\n  }\n\n  buildSkeleton(relationships, skeletons, id, name) {\n    let bone = null\n\n    relationships.parents.forEach(function (parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID]\n\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone\n            bone = new Bone()\n\n            bone.matrixWorld.copy(rawBone.transformLink)\n\n            // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : ''\n            bone.ID = id\n\n            skeleton.bones[i] = bone\n\n            // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n            if (subBone !== null) {\n              bone.add(subBone)\n            }\n          }\n        })\n      }\n    })\n\n    return bone\n  }\n\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(relationships) {\n    let model\n    let cameraAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        cameraAttribute = attr\n      }\n    })\n\n    if (cameraAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type = 0\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1\n      }\n\n      let nearClippingPlane = 1\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000\n      }\n\n      let farClippingPlane = 1000\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000\n      }\n\n      let width = window.innerWidth\n      let height = window.innerHeight\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value\n        height = cameraAttribute.AspectHeight.value\n      }\n\n      const aspect = width / height\n\n      let fov = 45\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value\n      }\n\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null\n\n      switch (type) {\n        case 0: // Perspective\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane)\n          if (focalLength !== null) model.setFocalLength(focalLength)\n          break\n\n        case 1: // Orthographic\n          model = new OrthographicCamera(\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            nearClippingPlane,\n            farClippingPlane,\n          )\n          break\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.')\n          model = new Object3D()\n          break\n      }\n    }\n\n    return model\n  }\n\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(relationships) {\n    let model\n    let lightAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        lightAttribute = attr\n      }\n    })\n\n    if (lightAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type\n\n      // LightType can be undefined for Point lights\n      if (lightAttribute.LightType === undefined) {\n        type = 0\n      } else {\n        type = lightAttribute.LightType.value\n      }\n\n      let color = 0xffffff\n\n      if (lightAttribute.Color !== undefined) {\n        color = new Color().fromArray(lightAttribute.Color.value)\n      }\n\n      let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100\n\n      // light disabled\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0\n      }\n\n      let distance = 0\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value\n        }\n      }\n\n      // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n      const decay = 1\n\n      switch (type) {\n        case 0: // Point\n          model = new PointLight(color, intensity, distance, decay)\n          break\n\n        case 1: // Directional\n          model = new DirectionalLight(color, intensity)\n          break\n\n        case 2: // Spot\n          let angle = Math.PI / 3\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value)\n          }\n\n          let penumbra = 0\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value)\n            penumbra = Math.max(penumbra, 1)\n          }\n\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay)\n          break\n\n        default:\n          console.warn(\n            'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.',\n          )\n          model = new PointLight(color, intensity)\n          break\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true\n      }\n    }\n\n    return model\n  }\n\n  createMesh(relationships, geometryMap, materialMap) {\n    let model\n    let geometry = null\n    let material = null\n    const materials = []\n\n    // get geometry and materials(s) from connections\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID)\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID))\n      }\n    })\n\n    if (materials.length > 1) {\n      material = materials\n    } else if (materials.length > 0) {\n      material = materials[0]\n    } else {\n      material = new MeshPhongMaterial({ color: 0xcccccc })\n      materials.push(material)\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = true\n      })\n    }\n\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material)\n      model.normalizeSkinWeights()\n    } else {\n      model = new Mesh(geometry, material)\n    }\n\n    return model\n  }\n\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID)\n\n      return geo\n    }, null)\n\n    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n    const material = new LineBasicMaterial({ color: 0x3300ff, linewidth: 1 })\n    return new Line(geometry, material)\n  }\n\n  // parse the model node for transform data\n  getTransformData(model, modelNode) {\n    const transformData = {}\n\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    else transformData.eulerOrder = 'ZYX'\n\n    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value\n\n    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value\n    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value\n    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value\n\n    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value\n\n    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value\n    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value\n\n    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value\n    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value\n\n    model.userData.transformData = transformData\n  }\n\n  setLookAtProperties(model, modelNode) {\n    if ('LookAtProperty' in modelNode) {\n      const children = connections.get(model.ID).children\n\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID]\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value\n\n            // DirectionalLight, SpotLight\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos)\n              sceneGraph.add(model.target)\n            } else {\n              // Cameras and other Object3Ds\n\n              model.lookAt(new Vector3().fromArray(pos))\n            }\n          }\n        }\n      })\n    }\n  }\n\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes()\n\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID]\n\n      const parents = connections.get(parseInt(skeleton.ID)).parents\n\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID\n          const geoRelationships = connections.get(geoID)\n\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID)\n\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID])\n            }\n          })\n        }\n      })\n    }\n  }\n\n  parsePoseNodes() {\n    const bindMatrices = {}\n\n    if ('Pose' in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose\n\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a)\n            })\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a)\n          }\n        }\n      }\n    }\n\n    return bindMatrices\n  }\n\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  createAmbientLight() {\n    if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value\n      const r = ambientColor[0]\n      const g = ambientColor[1]\n      const b = ambientColor[2]\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        const color = new Color(r, g, b)\n        sceneGraph.add(new AmbientLight(color, 1))\n      }\n    }\n  }\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = new Map()\n\n    if ('Geometry' in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry\n\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID))\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers)\n\n        geometryMap.set(parseInt(nodeID), geo)\n      }\n    }\n\n    return geometryMap\n  }\n\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return this.parseMeshGeometry(relationships, geoNode, deformers)\n        break\n\n      case 'NurbsCurve':\n        return this.parseNurbsGeometry(geoNode)\n        break\n    }\n  }\n\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons\n    const morphTargets = []\n\n    const modelNodes = relationships.parents.map(function (parent) {\n      return fbxTree.Objects.Model[parent.ID]\n    })\n\n    // don't create geometry if it is not associated with any models\n    if (modelNodes.length === 0) return\n\n    const skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID]\n\n      return skeleton\n    }, null)\n\n    relationships.children.forEach(function (child) {\n      if (deformers.morphTargets[child.ID] !== undefined) {\n        morphTargets.push(deformers.morphTargets[child.ID])\n      }\n    })\n\n    // Assume one model and get the preRotation from that\n    // if there is more than one model associated with the geometry this may cause problems\n    const modelNode = modelNodes[0]\n\n    const transformData = {}\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value\n    if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value\n    if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value\n\n    const transform = generateTransform(transformData)\n\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform)\n  }\n\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry()\n    if (geoNode.attrName) geo.name = geoNode.attrName\n\n    const geoInfo = this.parseGeoNode(geoNode, skeleton)\n    const buffers = this.genBuffers(geoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3)\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    geo.setAttribute('position', positionAttribute)\n\n    if (buffers.colors.length > 0) {\n      geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3))\n    }\n\n    if (skeleton) {\n      geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4))\n\n      geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4))\n\n      // used later to bind the skeleton to the model\n      geo.FBX_Deformer = skeleton\n    }\n\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform)\n\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3)\n      normalAttribute.applyNormalMatrix(normalMatrix)\n\n      geo.setAttribute('normal', normalAttribute)\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      if (UV1 === 'uv2') i++\n      const name = i === 0 ? 'uv' : `uv${i}`\n\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2))\n    })\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      let prevMaterialIndex = buffers.materialIndex[0]\n      let startIndex = 0\n\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex)\n\n          prevMaterialIndex = currentIndex\n          startIndex = i\n        }\n      })\n\n      // the loop above doesn't add the last group, do that here.\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1]\n        const lastIndex = lastGroup.start + lastGroup.count\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex)\n        }\n      }\n\n      // case where there are multiple materials but the whole geometry is only\n      // using one of them\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0])\n      }\n    }\n\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform)\n\n    return geo\n  }\n\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {}\n\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : []\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : []\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0])\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0])\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0])\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = []\n\n      let i = 0\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]))\n        }\n\n        i++\n      }\n    }\n\n    geoInfo.weightTable = {}\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton\n\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = []\n\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j],\n          })\n        })\n      })\n    }\n\n    return geoInfo\n  }\n\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: [],\n    }\n\n    let polygonIndex = 0\n    let faceLength = 0\n    let displayedWeightsWarning = false\n\n    // these will hold data for a single face\n    let facePositionIndexes = []\n    let faceNormals = []\n    let faceColors = []\n    let faceUVs = []\n    let faceWeights = []\n    let faceWeightIndices = []\n\n    const scope = this\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      let materialIndex\n      let endOfFace = false\n\n      // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1 // equivalent to ( x * -1 ) - 1\n        endOfFace = true\n      }\n\n      let weightIndices = []\n      let weights = []\n\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2)\n\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color)\n\n        faceColors.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight)\n            weightIndices.push(wt.id)\n          })\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn(\n              'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.',\n            )\n            displayedWeightsWarning = true\n          }\n\n          const wIndex = [0, 0, 0, 0]\n          const Weight = [0, 0, 0, 0]\n\n          weights.forEach(function (weight, weightIndex) {\n            let currentWeight = weight\n            let currentIndex = weightIndices[weightIndex]\n\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight\n                currentWeight = comparedWeight\n\n                const tmp = wIndex[comparedWeightIndex]\n                wIndex[comparedWeightIndex] = currentIndex\n                currentIndex = tmp\n              }\n            })\n          })\n\n          weightIndices = wIndex\n          weights = Weight\n        }\n\n        // if the weight array is shorter than 4 pad with 0s\n        while (weights.length < 4) {\n          weights.push(0)\n          weightIndices.push(0)\n        }\n\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i])\n          faceWeightIndices.push(weightIndices[i])\n        }\n      }\n\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal)\n\n        faceNormals.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0]\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv)\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = []\n          }\n\n          faceUVs[i].push(data[0])\n          faceUVs[i].push(data[1])\n        })\n      }\n\n      faceLength++\n\n      if (endOfFace) {\n        scope.genFace(\n          buffers,\n          geoInfo,\n          facePositionIndexes,\n          materialIndex,\n          faceNormals,\n          faceColors,\n          faceUVs,\n          faceWeights,\n          faceWeightIndices,\n          faceLength,\n        )\n\n        polygonIndex++\n        faceLength = 0\n\n        // reset arrays for the next face\n        facePositionIndexes = []\n        faceNormals = []\n        faceColors = []\n        faceUVs = []\n        faceWeights = []\n        faceWeightIndices = []\n      }\n    })\n\n    return buffers\n  }\n\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(\n    buffers,\n    geoInfo,\n    facePositionIndexes,\n    materialIndex,\n    faceNormals,\n    faceColors,\n    faceUVs,\n    faceWeights,\n    faceWeightIndices,\n    faceLength,\n  ) {\n    for (let i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]])\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0])\n        buffers.vertexWeights.push(faceWeights[1])\n        buffers.vertexWeights.push(faceWeights[2])\n        buffers.vertexWeights.push(faceWeights[3])\n\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3])\n\n        buffers.vertexWeights.push(faceWeights[i * 4])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[0])\n        buffers.weightsIndices.push(faceWeightIndices[1])\n        buffers.weightsIndices.push(faceWeightIndices[2])\n        buffers.weightsIndices.push(faceWeightIndices[3])\n\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[i * 4])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3])\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0])\n        buffers.colors.push(faceColors[1])\n        buffers.colors.push(faceColors[2])\n\n        buffers.colors.push(faceColors[(i - 1) * 3])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2])\n\n        buffers.colors.push(faceColors[i * 3])\n        buffers.colors.push(faceColors[i * 3 + 1])\n        buffers.colors.push(faceColors[i * 3 + 2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0])\n        buffers.normal.push(faceNormals[1])\n        buffers.normal.push(faceNormals[2])\n\n        buffers.normal.push(faceNormals[(i - 1) * 3])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2])\n\n        buffers.normal.push(faceNormals[i * 3])\n        buffers.normal.push(faceNormals[i * 3 + 1])\n        buffers.normal.push(faceNormals[i * 3 + 2])\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = []\n\n          buffers.uvs[j].push(faceUVs[j][0])\n          buffers.uvs[j].push(faceUVs[j][1])\n\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2])\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1])\n\n          buffers.uvs[j].push(faceUVs[j][i * 2])\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1])\n        })\n      }\n    }\n  }\n\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0) return\n\n    parentGeo.morphTargetsRelative = true\n\n    parentGeo.morphAttributes.position = []\n    // parentGeo.morphAttributes.normal = []; // not implemented\n\n    const scope = this\n    morphTargets.forEach(function (morphTarget) {\n      morphTarget.rawTargets.forEach(function (rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID]\n\n        if (morphGeoNode !== undefined) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name)\n        }\n      })\n    })\n  }\n\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []\n\n    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : []\n    const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : []\n\n    const length = parentGeo.attributes.position.count * 3\n    const morphPositions = new Float32Array(length)\n\n    for (let i = 0; i < indices.length; i++) {\n      const morphIndex = indices[i] * 3\n\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3]\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1]\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2]\n    }\n\n    // TODO: add morph normal support\n    const morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: morphPositions,\n    }\n\n    const morphBuffers = this.genBuffers(morphGeoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3)\n    positionAttribute.name = name || morphGeoNode.attrName\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    parentGeo.morphAttributes.position.push(positionAttribute)\n  }\n\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType\n    const referenceType = NormalNode.ReferenceInformationType\n    const buffer = NormalNode.Normals.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType\n    const referenceType = UVNode.ReferenceInformationType\n    const buffer = UVNode.UV.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType\n    const referenceType = ColorNode.ReferenceInformationType\n    const buffer = ColorNode.Colors.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType\n    const referenceType = MaterialNode.ReferenceInformationType\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType,\n      }\n    }\n\n    const materialIndexBuffer = MaterialNode.Materials.a\n\n    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n    const materialIndices = []\n\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i)\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(geoNode) {\n    if (NURBSCurve === undefined) {\n      console.error(\n        'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.',\n      )\n      return new BufferGeometry()\n    }\n\n    const order = parseInt(geoNode.Order)\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id)\n      return new BufferGeometry()\n    }\n\n    const degree = order - 1\n\n    const knots = geoNode.KnotVector.a\n    const controlPoints = []\n    const pointsValues = geoNode.Points.a\n\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i))\n    }\n\n    let startKnot, endKnot\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0])\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree\n      endKnot = knots.length - 1 - startKnot\n\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i])\n      }\n    }\n\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot)\n    const points = curve.getPoints(controlPoints.length * 12)\n\n    return new BufferGeometry().setFromPoints(points)\n  }\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = []\n\n    const rawClips = this.parseClips()\n\n    if (rawClips !== undefined) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key]\n\n        const clip = this.addClip(rawClip)\n\n        animationClips.push(clip)\n      }\n    }\n\n    return animationClips\n  }\n\n  parseClips() {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (fbxTree.Objects.AnimationCurve === undefined) return undefined\n\n    const curveNodesMap = this.parseAnimationCurveNodes()\n\n    this.parseAnimationCurves(curveNodesMap)\n\n    const layersMap = this.parseAnimationLayers(curveNodesMap)\n    const rawClips = this.parseAnimStacks(layersMap)\n\n    return rawClips\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode\n\n    const curveNodesMap = new Map()\n\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID]\n\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {},\n        }\n\n        curveNodesMap.set(curveNode.id, curveNode)\n      }\n    }\n\n    return curveNodesMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve\n\n    // TODO: Many values are identical up to roundoff error, but won't be optimised\n    // e.g. position times: [0, 0.4, 0. 8]\n    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n    // clearly, this should be optimised to\n    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n    // this shows up in nearly every FBX file, and generally time array is length > 100\n\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a,\n      }\n\n      const relationships = connections.get(animationCurve.id)\n\n      if (relationships !== undefined) {\n        const animationCurveID = relationships.parents[0].ID\n        const animationCurveRelationship = relationships.parents[0].relationship\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve\n        }\n      }\n    }\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer\n\n    const layersMap = new Map()\n\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = []\n\n      const connection = connections.get(parseInt(nodeID))\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        const children = connection.children\n\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID)\n\n            // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n            if (\n              curveNode.curves.x !== undefined ||\n              curveNode.curves.y !== undefined ||\n              curveNode.curves.z !== undefined\n            ) {\n              if (layerCurveNodes[i] === undefined) {\n                const modelID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                if (modelID !== undefined) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()]\n\n                  if (rawModel === undefined) {\n                    console.warn('THREE.FBXLoader: Encountered a unused curve.', child)\n                    return\n                  }\n\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1],\n                  }\n\n                  sceneGraph.traverse(function (child) {\n                    if (child.ID === rawModel.id) {\n                      node.transform = child.matrix\n\n                      if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder\n                    }\n                  })\n\n                  if (!node.transform) node.transform = new Matrix4()\n\n                  // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                  // animation value as well\n                  if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value\n                  if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value\n\n                  layerCurveNodes[i] = node\n                }\n              }\n\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode\n            } else if (curveNode.curves.morph !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                const deformerID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                const morpherID = connections.get(deformerID).parents[0].ID\n                const geoID = connections.get(morpherID).parents[0].ID\n\n                // assuming geometry is not used in more than one model\n                const modelID = connections.get(geoID).parents[0].ID\n\n                const rawModel = fbxTree.Objects.Model[modelID]\n\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName,\n                }\n\n                layerCurveNodes[i] = node\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode\n            }\n          }\n        })\n\n        layersMap.set(parseInt(nodeID), layerCurveNodes)\n      }\n    }\n\n    return layersMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack\n\n    // connect the stacks (clips) up to the layers\n    const rawClips = {}\n\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn(\n          'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.',\n        )\n      }\n\n      const layer = layersMap.get(children[0].ID)\n\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer,\n      }\n    }\n\n    return rawClips\n  }\n\n  addClip(rawClip) {\n    let tracks = []\n\n    const scope = this\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks))\n    })\n\n    return new AnimationClip(rawClip.name, -1, tracks)\n  }\n\n  generateTracks(rawTracks) {\n    const tracks = []\n\n    let initialPosition = new Vector3()\n    let initialRotation = new Quaternion()\n    let initialScale = new Vector3()\n\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale)\n\n    initialPosition = initialPosition.toArray()\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray()\n    initialScale = initialScale.toArray()\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(\n        rawTracks.modelName,\n        rawTracks.T.curves,\n        initialPosition,\n        'position',\n      )\n      if (positionTrack !== undefined) tracks.push(positionTrack)\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(\n        rawTracks.modelName,\n        rawTracks.R.curves,\n        initialRotation,\n        rawTracks.preRotation,\n        rawTracks.postRotation,\n        rawTracks.eulerOrder,\n      )\n      if (rotationTrack !== undefined) tracks.push(rotationTrack)\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale')\n      if (scaleTrack !== undefined) tracks.push(scaleTrack)\n    }\n\n    if (rawTracks.DeformPercent !== undefined) {\n      const morphTrack = this.generateMorphTrack(rawTracks)\n      if (morphTrack !== undefined) tracks.push(morphTrack)\n    }\n\n    return tracks\n  }\n\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    return new VectorKeyframeTrack(modelName + '.' + type, times, values)\n  }\n\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n    if (curves.x !== undefined) {\n      this.interpolateRotations(curves.x)\n      curves.x.values = curves.x.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.y !== undefined) {\n      this.interpolateRotations(curves.y)\n      curves.y.values = curves.y.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.z !== undefined) {\n      this.interpolateRotations(curves.z)\n      curves.z.values = curves.z.values.map(MathUtils.degToRad)\n    }\n\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    if (preRotation !== undefined) {\n      preRotation = preRotation.map(MathUtils.degToRad)\n      preRotation.push(eulerOrder)\n\n      preRotation = new Euler().fromArray(preRotation)\n      preRotation = new Quaternion().setFromEuler(preRotation)\n    }\n\n    if (postRotation !== undefined) {\n      postRotation = postRotation.map(MathUtils.degToRad)\n      postRotation.push(eulerOrder)\n\n      postRotation = new Euler().fromArray(postRotation)\n      postRotation = new Quaternion().setFromEuler(postRotation).invert()\n    }\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n\n    const quaternionValues = []\n\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder)\n\n      quaternion.setFromEuler(euler)\n\n      if (preRotation !== undefined) quaternion.premultiply(preRotation)\n      if (postRotation !== undefined) quaternion.multiply(postRotation)\n\n      quaternion.toArray(quaternionValues, (i / 3) * 4)\n    }\n\n    return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues)\n  }\n\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph\n    const values = curves.values.map(function (val) {\n      return val / 100\n    })\n\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName]\n\n    return new NumberKeyframeTrack(\n      rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']',\n      curves.times,\n      values,\n    )\n  }\n\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(curves) {\n    let times = []\n\n    // first join together the times for each axis, if defined\n    if (curves.x !== undefined) times = times.concat(curves.x.times)\n    if (curves.y !== undefined) times = times.concat(curves.y.times)\n    if (curves.z !== undefined) times = times.concat(curves.z.times)\n\n    // then sort them\n    times = times.sort(function (a, b) {\n      return a - b\n    })\n\n    // and remove duplicates\n    if (times.length > 1) {\n      let targetIndex = 1\n      let lastValue = times[0]\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i]\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue\n          lastValue = currentValue\n          targetIndex++\n        }\n      }\n\n      times = times.slice(0, targetIndex)\n    }\n\n    return times\n  }\n\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue\n\n    const values = []\n\n    let xIndex = -1\n    let yIndex = -1\n    let zIndex = -1\n\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time)\n      if (curves.y) yIndex = curves.y.times.indexOf(time)\n      if (curves.z) zIndex = curves.z.times.indexOf(time)\n\n      // if there is an x value defined for this frame, use that\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex]\n        values.push(xValue)\n        prevValue[0] = xValue\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0])\n      }\n\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex]\n        values.push(yValue)\n        prevValue[1] = yValue\n      } else {\n        values.push(prevValue[1])\n      }\n\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex]\n        values.push(zValue)\n        prevValue[2] = zValue\n      } else {\n        values.push(prevValue[2])\n      }\n    })\n\n    return values\n  }\n\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(curve) {\n    for (let i = 1; i < curve.values.length; i++) {\n      const initialValue = curve.values[i - 1]\n      const valuesSpan = curve.values[i] - initialValue\n\n      const absoluteSpan = Math.abs(valuesSpan)\n\n      if (absoluteSpan >= 180) {\n        const numSubIntervals = absoluteSpan / 180\n\n        const step = valuesSpan / numSubIntervals\n        let nextValue = initialValue + step\n\n        const initialTime = curve.times[i - 1]\n        const timeSpan = curve.times[i] - initialTime\n        const interval = timeSpan / numSubIntervals\n        let nextTime = initialTime + interval\n\n        const interpolatedTimes = []\n        const interpolatedValues = []\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime)\n          nextTime += interval\n\n          interpolatedValues.push(nextValue)\n          nextValue += step\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes)\n        curve.values = inject(curve.values, i, interpolatedValues)\n      }\n    }\n  }\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2]\n  }\n\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1]\n  }\n\n  getCurrentProp() {\n    return this.currentProp\n  }\n\n  pushStack(node) {\n    this.nodeStack.push(node)\n    this.currentIndent += 1\n  }\n\n  popStack() {\n    this.nodeStack.pop()\n    this.currentIndent -= 1\n  }\n\n  setCurrentProp(val, name) {\n    this.currentProp = val\n    this.currentPropName = name\n  }\n\n  parse(text) {\n    this.currentIndent = 0\n\n    this.allNodes = new FBXTree()\n    this.nodeStack = []\n    this.currentProp = []\n    this.currentPropName = ''\n\n    const scope = this\n\n    const split = text.split(/[\\r\\n]+/)\n\n    split.forEach(function (line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/)\n      const matchEmpty = line.match(/^[\\s\\t]*$/)\n\n      if (matchComment || matchEmpty) return\n\n      const matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '')\n      const matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)')\n      const matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}')\n\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning)\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i])\n      } else if (matchEnd) {\n        scope.popStack()\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        // large arrays are split over multiple lines terminated with a ',' character\n        // if this is encountered the line needs to be joined to the previous line\n        scope.parseNodePropertyContinued(line)\n      }\n    })\n\n    return this.allNodes\n  }\n\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '')\n\n    const nodeAttrs = property[2].split(',').map(function (attr) {\n      return attr.trim().replace(/^\"/, '').replace(/\"$/, '')\n    })\n\n    const node = { name: nodeName }\n    const attrs = this.parseNodeAttr(nodeAttrs)\n\n    const currentNode = this.getCurrentNode()\n\n    // a top node\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node)\n    } else {\n      // a subnode\n\n      // if the subnode already exists, append it\n      if (nodeName in currentNode) {\n        // special case Pose needs PoseNodes as an array\n        if (nodeName === 'PoseNode') {\n          currentNode.PoseNode.push(node)\n        } else if (currentNode[nodeName].id !== undefined) {\n          currentNode[nodeName] = {}\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName]\n        }\n\n        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node\n      } else if (typeof attrs.id === 'number') {\n        currentNode[nodeName] = {}\n        currentNode[nodeName][attrs.id] = node\n      } else if (nodeName !== 'Properties70') {\n        if (nodeName === 'PoseNode') currentNode[nodeName] = [node]\n        else currentNode[nodeName] = node\n      }\n    }\n\n    if (typeof attrs.id === 'number') node.id = attrs.id\n    if (attrs.name !== '') node.attrName = attrs.name\n    if (attrs.type !== '') node.attrType = attrs.type\n\n    this.pushStack(node)\n  }\n\n  parseNodeAttr(attrs) {\n    let id = attrs[0]\n\n    if (attrs[0] !== '') {\n      id = parseInt(attrs[0])\n\n      if (isNaN(id)) {\n        id = attrs[0]\n      }\n    }\n\n    let name = '',\n      type = ''\n\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, '')\n      type = attrs[2]\n    }\n\n    return { id: id, name: name, type: type }\n  }\n\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim()\n    let propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim()\n\n    // for special case: base64 image data follows \"Content: ,\" line\n    //\tContent: ,\n    //\t \"/9j/4RDaRXhpZgAATU0A...\"\n    if (propName === 'Content' && propValue === ',') {\n      propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim()\n    }\n\n    const currentNode = this.getCurrentNode()\n    const parentName = currentNode.name\n\n    if (parentName === 'Properties70') {\n      this.parseNodeSpecialProperty(line, propName, propValue)\n      return\n    }\n\n    // Connections\n    if (propName === 'C') {\n      const connProps = propValue.split(',').slice(1)\n      const from = parseInt(connProps[0])\n      const to = parseInt(connProps[1])\n\n      let rest = propValue.split(',').slice(3)\n\n      rest = rest.map(function (elem) {\n        return elem.trim().replace(/^\"/, '')\n      })\n\n      propName = 'connections'\n      propValue = [from, to]\n      append(propValue, rest)\n\n      if (currentNode[propName] === undefined) {\n        currentNode[propName] = []\n      }\n    }\n\n    // Node\n    if (propName === 'Node') currentNode.id = propValue\n\n    // connections\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue)\n    } else {\n      if (propName !== 'a') currentNode[propName] = propValue\n      else currentNode.a = propValue\n    }\n\n    this.setCurrentProp(currentNode, propName)\n\n    // convert string to array, unless it ends in ',' in which case more will be added to it\n    if (propName === 'a' && propValue.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(propValue)\n    }\n  }\n\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode()\n\n    currentNode.a += line\n\n    // if the line doesn't end in ',' we have reached the end of the property value\n    // so convert the string to an array\n    if (line.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(currentNode.a)\n    }\n  }\n\n  // parse \"Property70\"\n  parseNodeSpecialProperty(line, propName, propValue) {\n    // split this\n    // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n    // into array like below\n    // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n    const props = propValue.split('\",').map(function (prop) {\n      return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_')\n    })\n\n    const innerPropName = props[0]\n    const innerPropType1 = props[1]\n    const innerPropType2 = props[2]\n    const innerPropFlag = props[3]\n    let innerPropValue = props[4]\n\n    // cast values where needed, otherwise leave as strings\n    switch (innerPropType1) {\n      case 'int':\n      case 'enum':\n      case 'bool':\n      case 'ULongLong':\n      case 'double':\n      case 'Number':\n      case 'FieldOfView':\n        innerPropValue = parseFloat(innerPropValue)\n        break\n\n      case 'Color':\n      case 'ColorRGB':\n      case 'Vector3D':\n      case 'Lcl_Translation':\n      case 'Lcl_Rotation':\n      case 'Lcl_Scaling':\n        innerPropValue = parseNumberArray(innerPropValue)\n        break\n    }\n\n    // CAUTION: these props must append to parent's parent\n    this.getPrevNode()[innerPropName] = {\n      type: innerPropType1,\n      type2: innerPropType2,\n      flag: innerPropFlag,\n      value: innerPropValue,\n    }\n\n    this.setCurrentProp(this.getPrevNode(), innerPropName)\n  }\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer)\n    reader.skip(23) // skip magic 23 bytes\n\n    const version = reader.getUint32()\n\n    if (version < 6400) {\n      throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version)\n    }\n\n    const allNodes = new FBXTree()\n\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version)\n      if (node !== null) allNodes.add(node.name, node)\n    }\n\n    return allNodes\n  }\n\n  // Check if reader has reached the end of content.\n  endOfContent(reader) {\n    // footer size: 160bytes + 16-byte alignment padding\n    // - 16bytes: magic\n    // - padding til 16-byte alignment (at least 1byte?)\n    //\t(seems like some exporters embed fixed 15 or 16bytes?)\n    // - 4bytes: magic\n    // - 4bytes: version\n    // - 120bytes: zero\n    // - 16bytes: magic\n    if (reader.size() % 16 === 0) {\n      return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size()\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size()\n    }\n  }\n\n  // recursively parse nodes until the end of the file is reached\n  parseNode(reader, version) {\n    const node = {}\n\n    // The first three data sizes depends on version.\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32()\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32()\n\n    version >= 7500 ? reader.getUint64() : reader.getUint32() // the returned propertyListLen is not used\n\n    const nameLen = reader.getUint8()\n    const name = reader.getString(nameLen)\n\n    // Regards this node as NULL-record if endOffset is zero\n    if (endOffset === 0) return null\n\n    const propertyList = []\n\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader))\n    }\n\n    // Regards the first three elements in propertyList as id, attrName, and attrType\n    const id = propertyList.length > 0 ? propertyList[0] : ''\n    const attrName = propertyList.length > 1 ? propertyList[1] : ''\n    const attrType = propertyList.length > 2 ? propertyList[2] : ''\n\n    // check if this node represents just a single property\n    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false\n\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version)\n\n      if (subNode !== null) this.parseSubNode(name, node, subNode)\n    }\n\n    node.propertyList = propertyList // raw property list used by parent\n\n    if (typeof id === 'number') node.id = id\n    if (attrName !== '') node.attrName = attrName\n    if (attrType !== '') node.attrType = attrType\n    if (name !== '') node.name = name\n\n    return node\n  }\n\n  parseSubNode(name, node, subNode) {\n    // special case: child node is single property\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0]\n\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode\n\n        subNode.a = value\n      } else {\n        node[subNode.name] = value\n      }\n    } else if (name === 'Connections' && subNode.name === 'C') {\n      const array = []\n\n      subNode.propertyList.forEach(function (property, i) {\n        // first Connection is FBX type (OO, OP, etc.). We'll discard these\n        if (i !== 0) array.push(property)\n      })\n\n      if (node.connections === undefined) {\n        node.connections = []\n      }\n\n      node.connections.push(array)\n    } else if (subNode.name === 'Properties70') {\n      const keys = Object.keys(subNode)\n\n      keys.forEach(function (key) {\n        node[key] = subNode[key]\n      })\n    } else if (name === 'Properties70' && subNode.name === 'P') {\n      let innerPropName = subNode.propertyList[0]\n      let innerPropType1 = subNode.propertyList[1]\n      const innerPropType2 = subNode.propertyList[2]\n      const innerPropFlag = subNode.propertyList[3]\n      let innerPropValue\n\n      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_')\n      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_')\n\n      if (\n        innerPropType1 === 'Color' ||\n        innerPropType1 === 'ColorRGB' ||\n        innerPropType1 === 'Vector' ||\n        innerPropType1 === 'Vector3D' ||\n        innerPropType1.indexOf('Lcl_') === 0\n      ) {\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]]\n      } else {\n        innerPropValue = subNode.propertyList[4]\n      }\n\n      // this will be copied to parent, see above\n      node[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue,\n      }\n    } else if (node[subNode.name] === undefined) {\n      if (typeof subNode.id === 'number') {\n        node[subNode.name] = {}\n        node[subNode.name][subNode.id] = subNode\n      } else {\n        node[subNode.name] = subNode\n      }\n    } else {\n      if (subNode.name === 'PoseNode') {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]]\n        }\n\n        node[subNode.name].push(subNode)\n      } else if (node[subNode.name][subNode.id] === undefined) {\n        node[subNode.name][subNode.id] = subNode\n      }\n    }\n  }\n\n  parseProperty(reader) {\n    const type = reader.getString(1)\n    let length\n\n    switch (type) {\n      case 'C':\n        return reader.getBoolean()\n\n      case 'D':\n        return reader.getFloat64()\n\n      case 'F':\n        return reader.getFloat32()\n\n      case 'I':\n        return reader.getInt32()\n\n      case 'L':\n        return reader.getInt64()\n\n      case 'R':\n        length = reader.getUint32()\n        return reader.getArrayBuffer(length)\n\n      case 'S':\n        length = reader.getUint32()\n        return reader.getString(length)\n\n      case 'Y':\n        return reader.getInt16()\n\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'f':\n      case 'i':\n      case 'l':\n        const arrayLength = reader.getUint32()\n        const encoding = reader.getUint32() // 0: non-compressed, 1: compressed\n        const compressedLength = reader.getUint32()\n\n        if (encoding === 0) {\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader.getBooleanArray(arrayLength)\n\n            case 'd':\n              return reader.getFloat64Array(arrayLength)\n\n            case 'f':\n              return reader.getFloat32Array(arrayLength)\n\n            case 'i':\n              return reader.getInt32Array(arrayLength)\n\n            case 'l':\n              return reader.getInt64Array(arrayLength)\n          }\n        }\n\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)))\n        const reader2 = new BinaryReader(data.buffer)\n\n        switch (type) {\n          case 'b':\n          case 'c':\n            return reader2.getBooleanArray(arrayLength)\n\n          case 'd':\n            return reader2.getFloat64Array(arrayLength)\n\n          case 'f':\n            return reader2.getFloat32Array(arrayLength)\n\n          case 'i':\n            return reader2.getInt32Array(arrayLength)\n\n          case 'l':\n            return reader2.getInt64Array(arrayLength)\n        }\n\n      default:\n        throw new Error('THREE.FBXLoader: Unknown property type ' + type)\n    }\n  }\n}\n\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer)\n    this.offset = 0\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true\n  }\n\n  getOffset() {\n    return this.offset\n  }\n\n  size() {\n    return this.dv.buffer.byteLength\n  }\n\n  skip(length) {\n    this.offset += length\n  }\n\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1\n  }\n\n  getBooleanArray(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean())\n    }\n\n    return a\n  }\n\n  getUint8() {\n    const value = this.dv.getUint8(this.offset)\n    this.offset += 1\n    return value\n  }\n\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian)\n    this.offset += 2\n    return value\n  }\n\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getInt32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32())\n    }\n\n    return a\n  }\n\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    // calculate negative value\n    if (high & 0x80000000) {\n      high = ~high & 0xffffffff\n      low = ~low & 0xffffffff\n\n      if (low === 0xffffffff) high = (high + 1) & 0xffffffff\n\n      low = (low + 1) & 0xffffffff\n\n      return -(high * 0x100000000 + low)\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getInt64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64())\n    }\n\n    return a\n  }\n\n  // Note: see getInt64() comment\n  getUint64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getFloat32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32())\n    }\n\n    return a\n  }\n\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian)\n    this.offset += 8\n    return value\n  }\n\n  getFloat64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64())\n    }\n\n    return a\n  }\n\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size)\n    this.offset += size\n    return value\n  }\n\n  getString(size) {\n    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n    let a = []\n\n    for (let i = 0; i < size; i++) {\n      a[i] = this.getUint8()\n    }\n\n    const nullByte = a.indexOf(0)\n    if (nullByte >= 0) a = a.slice(0, nullByte)\n\n    return decodeText(new Uint8Array(a))\n  }\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n  add(key, val) {\n    this[key] = val\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0'\n\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length)\n}\n\nfunction isFbxFormatASCII(text) {\n  const CORRECT = [\n    'K',\n    'a',\n    'y',\n    'd',\n    'a',\n    'r',\n    'a',\n    '\\\\',\n    'F',\n    'B',\n    'X',\n    '\\\\',\n    'B',\n    'i',\n    'n',\n    'a',\n    'r',\n    'y',\n    '\\\\',\n    '\\\\',\n  ]\n\n  let cursor = 0\n\n  function read(offset) {\n    const result = text[offset - 1]\n    text = text.slice(cursor + offset)\n    cursor++\n    return result\n  }\n\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1)\n    if (num === CORRECT[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/\n  const match = text.match(versionRegExp)\n\n  if (match) {\n    const version = parseInt(match[1])\n    return version\n  }\n\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.')\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158000\n}\n\nconst dataArray = []\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index\n\n  switch (infoObject.mappingType) {\n    case 'ByPolygonVertex':\n      index = polygonVertexIndex\n      break\n    case 'ByPolygon':\n      index = polygonIndex\n      break\n    case 'ByVertice':\n      index = vertexIndex\n      break\n    case 'AllSame':\n      index = infoObject.indices[0]\n      break\n    default:\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType)\n  }\n\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index]\n\n  const from = index * infoObject.dataSize\n  const to = from + infoObject.dataSize\n\n  return slice(dataArray, infoObject.buffer, from, to)\n}\n\nconst tempEuler = /* @__PURE__ */ new Euler()\nconst tempVec = /* @__PURE__ */ new Vector3()\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4()\n  const lPreRotationM = new Matrix4()\n  const lRotationM = new Matrix4()\n  const lPostRotationM = new Matrix4()\n\n  const lScalingM = new Matrix4()\n  const lScalingPivotM = new Matrix4()\n  const lScalingOffsetM = new Matrix4()\n  const lRotationOffsetM = new Matrix4()\n  const lRotationPivotM = new Matrix4()\n\n  const lParentGX = new Matrix4()\n  const lParentLX = new Matrix4()\n  const lGlobalT = new Matrix4()\n\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0\n\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation))\n\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n    lPostRotationM.invert()\n  }\n\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale))\n\n  // Pivots and offsets\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset))\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot))\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset))\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot))\n\n  // parent transform\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix)\n    lParentGX.copy(transformData.parentMatrixWorld)\n  }\n\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM)\n  // Global Rotation\n  const lParentGRM = new Matrix4()\n  lParentGRM.extractRotation(lParentGX)\n\n  // Global Shear*Scaling\n  const lParentTM = new Matrix4()\n  lParentTM.copyPosition(lParentGX)\n\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX)\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM)\n  const lLSM = lScalingM\n\n  const lGlobalRS = new Matrix4()\n\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM)\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM)\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX))\n    const lParentLSM_inv = lParentLSM.clone().invert()\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv)\n\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM)\n  }\n\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert()\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert()\n  // Calculate the local transform matrix\n  let lTransform = lTranslationM\n    .clone()\n    .multiply(lRotationOffsetM)\n    .multiply(lRotationPivotM)\n    .multiply(lPreRotationM)\n    .multiply(lRotationM)\n    .multiply(lPostRotationM)\n    .multiply(lRotationPivotM_inv)\n    .multiply(lScalingOffsetM)\n    .multiply(lScalingPivotM)\n    .multiply(lScalingM)\n    .multiply(lScalingPivotM_inv)\n\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform)\n\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo)\n  lGlobalT.copyPosition(lGlobalTranslation)\n\n  lTransform = lGlobalT.clone().multiply(lGlobalRS)\n\n  // from global to local\n  lTransform.premultiply(lParentGX.invert())\n\n  return lTransform\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder(order) {\n  order = order || 0\n\n  const enums = [\n    'ZYX', // -> XYZ extrinsic\n    'YZX', // -> XZY extrinsic\n    'XZY', // -> YZX extrinsic\n    'ZXY', // -> YXZ extrinsic\n    'YXZ', // -> ZXY extrinsic\n    'XYZ', // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ]\n\n  if (order === 6) {\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.')\n    return enums[0]\n  }\n\n  return enums[order]\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray(value) {\n  const array = value.split(',').map(function (val) {\n    return parseFloat(val)\n  })\n\n  return array\n}\n\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === undefined) from = 0\n  if (to === undefined) to = buffer.byteLength\n\n  return decodeText(new Uint8Array(buffer, from, to))\n}\n\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i]\n  }\n}\n\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i]\n  }\n\n  return a\n}\n\n// inject array a2 into array a1 at index\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index))\n}\n\nexport { FBXLoader }\n"],"names":["child","material","skeleton"],"mappings":"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"}},
    {"offset": {"line": 5899, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/FontLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/FontLoader.ts"],"sourcesContent":["import { Loader, FileLoader, ShapePath } from 'three'\n\nimport type { LoadingManager, Shape } from 'three'\n\ntype Options = {\n  lineHeight: number\n  letterSpacing: number\n}\n\nexport class FontLoader extends Loader {\n  constructor(manager?: LoadingManager) {\n    super(manager)\n  }\n\n  public load(\n    url: string,\n    onLoad?: (responseFont: Font) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): void {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== 'string') throw new Error('unsupported data type')\n\n        const json = JSON.parse(response)\n\n        const font = this.parse(json)\n\n        if (onLoad) onLoad(font)\n      },\n      onProgress,\n      onError as (event: unknown) => void,\n    )\n  }\n\n  loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Font> {\n    // @ts-ignore\n    return super.loadAsync(url, onProgress)\n  }\n\n  public parse(json: FontData): Font {\n    return new Font(json)\n  }\n}\n\ntype Glyph = {\n  _cachedOutline: string[]\n  ha: number\n  o: string\n}\n\ntype FontData = {\n  boundingBox: { yMax: number; yMin: number }\n  familyName: string\n  glyphs: { [k: string]: Glyph }\n  resolution: number\n  underlineThickness: number\n}\n\nexport class Font {\n  public data: FontData\n  public isFont = true\n  public type = 'Font'\n\n  constructor(data: FontData) {\n    this.data = data\n  }\n\n  public generateShapes(text: string, size = 100, _options?: Partial<Options>): Shape[] {\n    const shapes: Shape[] = []\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options }\n    const paths = createPaths(text, size, this.data, options)\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false))\n    }\n    return shapes\n  }\n}\n\nfunction createPaths(text: string, size: number, data: FontData, options: Options): ShapePath[] {\n  const chars = Array.from(text)\n  const scale = size / data.resolution\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale\n\n  const paths: ShapePath[] = []\n\n  let offsetX = 0,\n    offsetY = 0\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n\n    if (char === '\\n') {\n      offsetX = 0\n      offsetY -= line_height * options.lineHeight\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data)\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing\n        paths.push(ret.path)\n      }\n    }\n  }\n\n  return paths\n}\n\nfunction createPath(\n  char: string,\n  scale: number,\n  offsetX: number,\n  offsetY: number,\n  data: FontData,\n): { offsetX: number; path: ShapePath } | undefined {\n  const glyph = data.glyphs[char] || data.glyphs['?']\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.')\n    return\n  }\n\n  const path = new ShapePath()\n\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))\n\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++]\n\n      switch (action) {\n        case 'm': // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.moveTo(x, y)\n\n          break\n\n        case 'l': // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.lineTo(x, y)\n\n          break\n\n        case 'q': // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)\n\n          break\n\n        case 'b': // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n          cpx2 = parseInt(outline[i++]) * scale + offsetX\n          cpy2 = parseInt(outline[i++]) * scale + offsetY\n\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)\n\n          break\n      }\n    }\n  }\n\n  return { offsetX: glyph.ha * scale, path }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6036, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/TGALoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/TGALoader.js"],"sourcesContent":["import { DataTextureLoader, LinearMipmapLinearFilter } from 'three'\n\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.')\n          }\n\n          break\n\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.')\n          }\n\n          break\n\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.')\n\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type)\n      }\n\n      // check image width and height\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.')\n      }\n\n      // check image pixel size\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size)\n      }\n    }\n\n    // parse tga image buffer\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      let pixel_data, palettes\n\n      const pixel_size = header.pixel_size >> 3\n      const pixel_total = header.width * header.height * pixel_size\n\n      // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)))\n      }\n\n      // read RLE\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total)\n\n        let c, count, i\n        let shift = 0\n        const pixels = new Uint8Array(pixel_size)\n\n        while (shift < pixel_total) {\n          c = data[offset++]\n          count = (c & 0x7f) + 1\n\n          // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++]\n            }\n\n            // copy pixel array\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size)\n            }\n\n            shift += pixel_size * count\n          } else {\n            // raw pixels\n\n            count *= pixel_size\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++]\n            }\n\n            shift += count\n          }\n        }\n      } else {\n        // raw pixels\n\n        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total))\n      }\n\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes,\n      }\n    }\n\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes\n      let color,\n        i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i]\n          imageData[(x + width * y) * 4 + 3] = 255\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0]\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1]\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2]\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8) // Inversed ?\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255\n          imageData[(x + width * y) * 4 + 2] = image[i + 0]\n          imageData[(x + width * y) * 4 + 1] = image[i + 1]\n          imageData[(x + width * y) * 4 + 0] = image[i + 2]\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0]\n          imageData[(x + width * y) * 4 + 1] = image[i + 1]\n          imageData[(x + width * y) * 4 + 0] = image[i + 2]\n          imageData[(x + width * y) * 4 + 3] = image[i + 3]\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i]\n          imageData[(x + width * y) * 4 + 0] = color\n          imageData[(x + width * y) * 4 + 1] = color\n          imageData[(x + width * y) * 4 + 2] = color\n          imageData[(x + width * y) * 4 + 3] = 255\n        }\n      }\n\n      return imageData\n    }\n\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y\n      const width = header.width\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0]\n          imageData[(x + width * y) * 4 + 1] = image[i + 0]\n          imageData[(x + width * y) * 4 + 2] = image[i + 0]\n          imageData[(x + width * y) * 4 + 3] = image[i + 1]\n        }\n      }\n\n      return imageData\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0\n          x_step = 1\n          x_end = width\n          y_start = 0\n          y_step = 1\n          y_end = height\n          break\n\n        case TGA_ORIGIN_BL:\n          x_start = 0\n          x_step = 1\n          x_end = width\n          y_start = height - 1\n          y_step = -1\n          y_end = -1\n          break\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1\n          x_step = -1\n          x_end = -1\n          y_start = 0\n          y_step = 1\n          y_end = height\n          break\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1\n          x_step = -1\n          x_end = -1\n          y_start = height - 1\n          y_step = -1\n          y_end = -1\n          break\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.')\n            break\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette)\n            break\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image)\n            break\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.')\n            break\n        }\n      }\n\n      // Load image data according to specific method\n      // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n      return data\n    }\n\n    // TGA constants\n\n    const TGA_TYPE_NO_DATA = 0,\n      TGA_TYPE_INDEXED = 1,\n      TGA_TYPE_RGB = 2,\n      TGA_TYPE_GREY = 3,\n      TGA_TYPE_RLE_INDEXED = 9,\n      TGA_TYPE_RLE_RGB = 10,\n      TGA_TYPE_RLE_GREY = 11,\n      TGA_ORIGIN_MASK = 0x30,\n      TGA_ORIGIN_SHIFT = 0x04,\n      TGA_ORIGIN_BL = 0x00,\n      TGA_ORIGIN_BR = 0x01,\n      TGA_ORIGIN_UL = 0x02,\n      TGA_ORIGIN_UR = 0x03\n\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.')\n\n    let offset = 0\n\n    const content = new Uint8Array(buffer),\n      header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | (content[offset++] << 8),\n        colormap_length: content[offset++] | (content[offset++] << 8),\n        colormap_size: content[offset++],\n        origin: [content[offset++] | (content[offset++] << 8), content[offset++] | (content[offset++] << 8)],\n        width: content[offset++] | (content[offset++] << 8),\n        height: content[offset++] | (content[offset++] << 8),\n        pixel_size: content[offset++],\n        flags: content[offset++],\n      }\n\n    // check tga if it is valid format\n\n    tgaCheckHeader(header)\n\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.')\n    }\n\n    // skip the needn't data\n\n    offset += header.id_length\n\n    // get targa information about RLE compression and palette\n\n    let use_rle = false,\n      use_pal = false,\n      use_grey = false\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true\n        use_pal = true\n        break\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true\n        break\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true\n        break\n\n      case TGA_TYPE_RGB:\n        break\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true\n        use_grey = true\n        break\n\n      case TGA_TYPE_GREY:\n        use_grey = true\n        break\n    }\n\n    //\n\n    const imageData = new Uint8Array(header.width * header.height * 4)\n    const result = tgaParse(use_rle, use_pal, header, offset, content)\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes)\n\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter,\n    }\n  }\n}\n\nexport { TGALoader }\n"],"names":["header","use_rle","use_pal","offset","imageData"],"mappings":";;;;;;AAEA,MAAM,kBAAkB,oKAAA,CAAkB;IACxC,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;IACd;IAED,MAAM,MAAA,EAAQ;QAGZ,SAAS,eAAeA,OAAAA,EAAQ;YAC9B,OAAQA,QAAO,UAAA,EAAU;gBAGvB,KAAK;gBACL,KAAK;oBACH,IAAIA,QAAO,eAAA,GAAkB,OAAOA,QAAO,aAAA,KAAkB,MAAMA,QAAO,aAAA,KAAkB,GAAG;wBAC7F,QAAQ,KAAA,CAAM,+DAA+D;oBAC9E;oBAED;gBAIF,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL,KAAK;oBACH,IAAIA,QAAO,aAAA,EAAe;wBACxB,QAAQ,KAAA,CAAM,gEAAgE;oBAC/E;oBAED;gBAIF,KAAK;oBACH,QAAQ,KAAA,CAAM,2BAA2B;gBAI3C;oBACE,QAAQ,KAAA,CAAM,uCAAuCA,QAAO,UAAU;YACzE;YAID,IAAIA,QAAO,KAAA,IAAS,KAAKA,QAAO,MAAA,IAAU,GAAG;gBAC3C,QAAQ,KAAA,CAAM,sCAAsC;YACrD;YAID,IAAIA,QAAO,UAAA,KAAe,KAAKA,QAAO,UAAA,KAAe,MAAMA,QAAO,UAAA,KAAe,MAAMA,QAAO,UAAA,KAAe,IAAI;gBAC/G,QAAQ,KAAA,CAAM,6CAA6CA,QAAO,UAAU;YAC7E;QACF;QAID,SAAS,SAASC,QAAAA,EAASC,QAAAA,EAASF,OAAAA,EAAQG,OAAAA,EAAQ,IAAA,EAAM;YACxD,IAAI,YAAY;YAEhB,MAAM,aAAaH,QAAO,UAAA,IAAc;YACxC,MAAM,cAAcA,QAAO,KAAA,GAAQA,QAAO,MAAA,GAAS;YAInD,IAAIE,UAAS;gBACX,WAAW,KAAK,QAAA,CAASC,SAASA,WAAUH,QAAO,eAAA,GAAA,CAAmBA,QAAO,aAAA,IAAiB,CAAA,CAAI;YACnG;YAID,IAAIC,UAAS;gBACX,aAAa,IAAI,WAAW,WAAW;gBAEvC,IAAI,GAAG,OAAO;gBACd,IAAI,QAAQ;gBACZ,MAAM,SAAS,IAAI,WAAW,UAAU;gBAExC,MAAO,QAAQ,YAAa;oBAC1B,IAAI,IAAA,CAAKE,SAAQ,CAAA;oBACjB,QAAA,CAAS,IAAI,GAAA,IAAQ;oBAIrB,IAAI,IAAI,KAAM;wBAGZ,IAAK,IAAI,GAAG,IAAI,YAAY,EAAE,EAAG;4BAC/B,MAAA,CAAO,CAAC,CAAA,GAAI,IAAA,CAAKA,SAAQ,CAAA;wBAC1B;wBAID,IAAK,IAAI,GAAG,IAAI,OAAO,EAAE,EAAG;4BAC1B,WAAW,GAAA,CAAI,QAAQ,QAAQ,IAAI,UAAU;wBAC9C;wBAED,SAAS,aAAa;oBAClC,OAAiB;wBAGL,SAAS;wBAET,IAAK,IAAI,GAAG,IAAI,OAAO,EAAE,EAAG;4BAC1B,UAAA,CAAW,QAAQ,CAAC,CAAA,GAAI,IAAA,CAAKA,SAAQ,CAAA;wBACtC;wBAED,SAAS;oBACV;gBACF;YACT,OAAa;gBAGL,aAAa,KAAK,QAAA,CAASA,SAASA,WAAUD,WAAUF,QAAO,KAAA,GAAQA,QAAO,MAAA,GAAS,WAAa;YACrG;YAED,OAAO;gBACL;gBACA;YACD;QACF;QAED,SAAS,qBAAqBI,UAAAA,EAAW,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,KAAA,EAAO,QAAA,EAAU;YACxG,MAAM,WAAW;YACjB,IAAI,OACF,IAAI,GACJ,GACA;YACF,MAAM,QAAQ,OAAO,KAAA;YAErB,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,OAAQ;gBAC1C,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,QAAQ,IAAK;oBAC/C,QAAQ,KAAA,CAAM,CAAC,CAAA;oBACfA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI;oBACrCA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,QAAA,CAAS,QAAQ,IAAI,CAAC,CAAA;oBAC3DA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,QAAA,CAAS,QAAQ,IAAI,CAAC,CAAA;oBAC3DA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,QAAA,CAAS,QAAQ,IAAI,CAAC,CAAA;gBAC5D;YACF;YAED,OAAOA;QACR;QAED,SAAS,sBAAsBA,UAAAA,EAAW,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,KAAA,EAAO;YAC/F,IAAI,OACF,IAAI,GACJ,GACA;YACF,MAAM,QAAQ,OAAO,KAAA;YAErB,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,OAAQ;gBAC1C,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,QAAQ,KAAK,EAAG;oBAClD,QAAQ,KAAA,CAAM,IAAI,CAAC,CAAA,GAAA,CAAK,KAAA,CAAM,IAAI,CAAC,CAAA,IAAK,CAAA;oBACxCA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAA,CAAK,QAAQ,KAAA,KAAW;oBACzDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAA,CAAK,QAAQ,GAAA,KAAW;oBACzDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAA,CAAK,QAAQ,EAAA,KAAW;oBACzDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,QAAQ,QAAS,IAAI;gBAC3D;YACF;YAED,OAAOA;QACR;QAED,SAAS,sBAAsBA,UAAAA,EAAW,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,KAAA,EAAO;YAC/F,IAAI,IAAI,GACN,GACA;YACF,MAAM,QAAQ,OAAO,KAAA;YAErB,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,OAAQ;gBAC1C,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,QAAQ,KAAK,EAAG;oBAClDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI;oBACrCA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;gBACjD;YACF;YAED,OAAOA;QACR;QAED,SAAS,sBAAsBA,UAAAA,EAAW,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,KAAA,EAAO;YAC/F,IAAI,IAAI,GACN,GACA;YACF,MAAM,QAAQ,OAAO,KAAA;YAErB,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,OAAQ;gBAC1C,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,QAAQ,KAAK,EAAG;oBAClDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;gBACjD;YACF;YAED,OAAOA;QACR;QAED,SAAS,yBAAyBA,UAAAA,EAAW,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,KAAA,EAAO;YAClG,IAAI,OACF,IAAI,GACJ,GACA;YACF,MAAM,QAAQ,OAAO,KAAA;YAErB,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,OAAQ;gBAC1C,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,QAAQ,IAAK;oBAC/C,QAAQ,KAAA,CAAM,CAAC,CAAA;oBACfA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI;oBACrCA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI;oBACrCA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI;oBACrCA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI;gBACtC;YACF;YAED,OAAOA;QACR;QAED,SAAS,0BAA0BA,UAAAA,EAAW,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS,MAAA,EAAQ,KAAA,EAAO,KAAA,EAAO;YACnG,IAAI,IAAI,GACN,GACA;YACF,MAAM,QAAQ,OAAO,KAAA;YAErB,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,OAAQ;gBAC1C,IAAK,IAAI,SAAS,MAAM,OAAO,KAAK,QAAQ,KAAK,EAAG;oBAClDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;oBAChDA,UAAAA,CAAAA,CAAW,IAAI,QAAQ,CAAA,IAAK,IAAI,CAAC,CAAA,GAAI,KAAA,CAAM,IAAI,CAAC,CAAA;gBACjD;YACF;YAED,OAAOA;QACR;QAED,SAAS,WAAW,IAAA,EAAM,KAAA,EAAO,MAAA,EAAQ,KAAA,EAAO,OAAA,EAAS;YACvD,IAAI,SAAS,SAAS,QAAQ,QAAQ,OAAO;YAE7C,OAAA,CAAS,OAAO,KAAA,GAAQ,eAAA,KAAoB,kBAAgB;gBAC1D;gBACA,KAAK;oBACH,UAAU;oBACV,SAAS;oBACT,QAAQ;oBACR,UAAU;oBACV,SAAS;oBACT,QAAQ;oBACR;gBAEF,KAAK;oBACH,UAAU;oBACV,SAAS;oBACT,QAAQ;oBACR,UAAU,SAAS;oBACnB,SAAS,CAAA;oBACT,QAAQ,CAAA;oBACR;gBAEF,KAAK;oBACH,UAAU,QAAQ;oBAClB,SAAS,CAAA;oBACT,QAAQ,CAAA;oBACR,UAAU;oBACV,SAAS;oBACT,QAAQ;oBACR;gBAEF,KAAK;oBACH,UAAU,QAAQ;oBAClB,SAAS,CAAA;oBACT,QAAQ,CAAA;oBACR,UAAU,SAAS;oBACnB,SAAS,CAAA;oBACT,QAAQ,CAAA;oBACR;YACH;YAED,IAAI,UAAU;gBACZ,OAAQ,OAAO,UAAA,EAAU;oBACvB,KAAK;wBACH,yBAAyB,MAAM,SAAS,QAAQ,OAAO,SAAS,QAAQ,OAAO,KAAK;wBACpF;oBAEF,KAAK;wBACH,0BAA0B,MAAM,SAAS,QAAQ,OAAO,SAAS,QAAQ,OAAO,KAAK;wBACrF;oBAEF;wBACE,QAAQ,KAAA,CAAM,wCAAwC;wBACtD;gBACH;YACT,OAAa;gBACL,OAAQ,OAAO,UAAA,EAAU;oBACvB,KAAK;wBACH,qBAAqB,MAAM,SAAS,QAAQ,OAAO,SAAS,QAAQ,OAAO,OAAO,OAAO;wBACzF;oBAEF,KAAK;wBACH,sBAAsB,MAAM,SAAS,QAAQ,OAAO,SAAS,QAAQ,OAAO,KAAK;wBACjF;oBAEF,KAAK;wBACH,sBAAsB,MAAM,SAAS,QAAQ,OAAO,SAAS,QAAQ,OAAO,KAAK;wBACjF;oBAEF,KAAK;wBACH,sBAAsB,MAAM,SAAS,QAAQ,OAAO,SAAS,QAAQ,OAAO,KAAK;wBACjF;oBAEF;wBACE,QAAQ,KAAA,CAAM,wCAAwC;wBACtD;gBACH;YACF;YAKD,OAAO;QACR;QAID,MAAM,mBAAmB,GACvB,mBAAmB,GACnB,eAAe,GACf,gBAAgB,GAChB,uBAAuB,GACvB,mBAAmB,IACnB,oBAAoB,IACpB,kBAAkB,IAClB,mBAAmB,GACnB,gBAAgB,GAChB,gBAAgB,GAChB,gBAAgB,GAChB,gBAAgB;QAElB,IAAI,OAAO,MAAA,GAAS,IAAI,QAAQ,KAAA,CAAM,qDAAqD;QAE3F,IAAI,SAAS;QAEb,MAAM,UAAU,IAAI,WAAW,MAAM,GACnC,SAAS;YACP,WAAW,OAAA,CAAQ,QAAQ,CAAA;YAC3B,eAAe,OAAA,CAAQ,QAAQ,CAAA;YAC/B,YAAY,OAAA,CAAQ,QAAQ,CAAA;YAC5B,gBAAgB,OAAA,CAAQ,QAAQ,CAAA,GAAK,OAAA,CAAQ,QAAQ,CAAA,IAAK;YAC1D,iBAAiB,OAAA,CAAQ,QAAQ,CAAA,GAAK,OAAA,CAAQ,QAAQ,CAAA,IAAK;YAC3D,eAAe,OAAA,CAAQ,QAAQ,CAAA;YAC/B,QAAQ;gBAAC,OAAA,CAAQ,QAAQ,CAAA,GAAK,OAAA,CAAQ,QAAQ,CAAA,IAAK;gBAAI,OAAA,CAAQ,QAAQ,CAAA,GAAK,OAAA,CAAQ,QAAQ,CAAA,IAAK,CAAE;aAAA;YACnG,OAAO,OAAA,CAAQ,QAAQ,CAAA,GAAK,OAAA,CAAQ,QAAQ,CAAA,IAAK;YACjD,QAAQ,OAAA,CAAQ,QAAQ,CAAA,GAAK,OAAA,CAAQ,QAAQ,CAAA,IAAK;YAClD,YAAY,OAAA,CAAQ,QAAQ,CAAA;YAC5B,OAAO,OAAA,CAAQ,QAAQ,CAAA;QACxB;QAIH,eAAe,MAAM;QAErB,IAAI,OAAO,SAAA,GAAY,SAAS,OAAO,MAAA,EAAQ;YAC7C,QAAQ,KAAA,CAAM,2BAA2B;QAC1C;QAID,UAAU,OAAO,SAAA;QAIjB,IAAI,UAAU,OACZ,UAAU,OACV,WAAW;QAEb,OAAQ,OAAO,UAAA,EAAU;YACvB,KAAK;gBACH,UAAU;gBACV,UAAU;gBACV;YAEF,KAAK;gBACH,UAAU;gBACV;YAEF,KAAK;gBACH,UAAU;gBACV;YAEF,KAAK;gBACH;YAEF,KAAK;gBACH,UAAU;gBACV,WAAW;gBACX;YAEF,KAAK;gBACH,WAAW;gBACX;QACH;QAID,MAAM,YAAY,IAAI,WAAW,OAAO,KAAA,GAAQ,OAAO,MAAA,GAAS,CAAC;QACjE,MAAM,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,OAAO;QACjE,WAAW,WAAW,OAAO,KAAA,EAAO,OAAO,MAAA,EAAQ,OAAO,UAAA,EAAY,OAAO,QAAQ;QAErF,OAAO;YACL,MAAM;YACN,OAAO,OAAO,KAAA;YACd,QAAQ,OAAO,MAAA;YACf,OAAO;YACP,iBAAiB;YACjB,WAAW,2KAAA;QACZ;IACF;AACH"}},
    {"offset": {"line": 6331, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/LUTCubeLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/LUTCubeLoader.js"],"sourcesContent":["// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf\n\nimport { Loader, FileLoader, Vector3, DataTexture, UnsignedByteType, ClampToEdgeWrapping, LinearFilter } from 'three'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nexport class LUTCubeLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('text')\n    loader.load(\n      url,\n      (text) => {\n        try {\n          onLoad(this.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          this.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(str) {\n    // Remove empty lines and comments\n    str = str\n      .replace(/^#.*?(\\n|\\r)/gm, '')\n      .replace(/^\\s*?(\\n|\\r)/gm, '')\n      .trim()\n\n    let title = null\n    let size = null\n    const domainMin = new Vector3(0, 0, 0)\n    const domainMax = new Vector3(1, 1, 1)\n\n    const lines = str.split(/[\\n\\r]+/g)\n    let data = null\n\n    let currIndex = 0\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trim()\n      const split = line.split(/\\s/g)\n\n      switch (split[0]) {\n        case 'TITLE':\n          title = line.substring(7, line.length - 1)\n          break\n        case 'LUT_3D_SIZE':\n          // TODO: A .CUBE LUT file specifies floating point values and could be represented with\n          // more precision than can be captured with Uint8Array.\n          const sizeToken = split[1]\n          size = parseFloat(sizeToken)\n          data = new Uint8Array(size * size * size * 4)\n          break\n        case 'DOMAIN_MIN':\n          domainMin.x = parseFloat(split[1])\n          domainMin.y = parseFloat(split[2])\n          domainMin.z = parseFloat(split[3])\n          break\n        case 'DOMAIN_MAX':\n          domainMax.x = parseFloat(split[1])\n          domainMax.y = parseFloat(split[2])\n          domainMax.z = parseFloat(split[3])\n          break\n        default:\n          const r = parseFloat(split[0])\n          const g = parseFloat(split[1])\n          const b = parseFloat(split[2])\n\n          if (r > 1.0 || r < 0.0 || g > 1.0 || g < 0.0 || b > 1.0 || b < 0.0) {\n            throw new Error('LUTCubeLoader : Non normalized values not supported.')\n          }\n\n          data[currIndex + 0] = r * 255\n          data[currIndex + 1] = g * 255\n          data[currIndex + 2] = b * 255\n          data[currIndex + 3] = 255\n          currIndex += 4\n      }\n    }\n\n    const texture = new DataTexture()\n    texture.image.data = data\n    texture.image.width = size\n    texture.image.height = size * size\n    texture.type = UnsignedByteType\n    texture.magFilter = LinearFilter\n    texture.minFilter = LinearFilter\n    texture.wrapS = ClampToEdgeWrapping\n    texture.wrapT = ClampToEdgeWrapping\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const texture3D = new Data3DTexture()\n    texture3D.image.data = data\n    texture3D.image.width = size\n    texture3D.image.height = size\n    texture3D.image.depth = size\n    texture3D.type = UnsignedByteType\n    texture3D.magFilter = LinearFilter\n    texture3D.minFilter = LinearFilter\n    texture3D.wrapS = ClampToEdgeWrapping\n    texture3D.wrapT = ClampToEdgeWrapping\n    texture3D.wrapR = ClampToEdgeWrapping\n    texture3D.generateMipmaps = false\n    texture3D.needsUpdate = true\n\n    return {\n      title,\n      size,\n      domainMin,\n      domainMax,\n      texture,\n      texture3D,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6442, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/NRRDLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/NRRDLoader.js"],"sourcesContent":["import { FileLoader, Loader, Matrix4, Vector3 } from 'three'\nimport { gunzipSync } from 'fflate'\nimport { Volume } from '../misc/Volume'\n\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n    let _data = data\n\n    let _dataPointer = 0\n\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0\n\n    const _littleEndian = true\n\n    const headerObject = {}\n\n    function scan(type, chunks) {\n      if (chunks === undefined || chunks === null) {\n        chunks = 1\n      }\n\n      let _chunkSize = 1\n      let _array_type = Uint8Array\n\n      switch (type) {\n        // 1 byte data types\n        case 'uchar':\n          break\n        case 'schar':\n          _array_type = Int8Array\n          break\n        // 2 byte data types\n        case 'ushort':\n          _array_type = Uint16Array\n          _chunkSize = 2\n          break\n        case 'sshort':\n          _array_type = Int16Array\n          _chunkSize = 2\n          break\n        // 4 byte data types\n        case 'uint':\n          _array_type = Uint32Array\n          _chunkSize = 4\n          break\n        case 'sint':\n          _array_type = Int32Array\n          _chunkSize = 4\n          break\n        case 'float':\n          _array_type = Float32Array\n          _chunkSize = 4\n          break\n        case 'complex':\n          _array_type = Float64Array\n          _chunkSize = 8\n          break\n        case 'double':\n          _array_type = Float64Array\n          _chunkSize = 8\n          break\n      }\n\n      // increase the data pointer in-place\n      let _bytes = new _array_type(_data.slice(_dataPointer, (_dataPointer += chunks * _chunkSize)))\n\n      // if required, flip the endianness of the bytes\n      if (_nativeLittleEndian != _littleEndian) {\n        // we need to flip here since the format doesn't match the native endianness\n        _bytes = flipEndianness(_bytes, _chunkSize)\n      }\n\n      if (chunks == 1) {\n        // if only one chunk was requested, just return one value\n        return _bytes[0]\n      }\n\n      // return the byte array\n      return _bytes\n    }\n\n    //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength)\n      for (let i = 0; i < array.byteLength; i += chunkSize) {\n        for (let j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n          const tmp = u8[k]\n          u8[k] = u8[j]\n          u8[j] = tmp\n        }\n      }\n\n      return array\n    }\n\n    //parse the header\n    function parseHeader(header) {\n      let data, field, fn, i, l, m, _i, _len\n      const lines = header.split(/\\r?\\n/)\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i]\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true\n        } else if (l.match(/^#/)) {\n        } else if ((m = l.match(/(.*):(.*)/))) {\n          field = m[1].trim()\n          data = m[2].trim()\n          fn = _fieldFunctions[field]\n          if (fn) {\n            fn.call(headerObject, data)\n          } else {\n            headerObject[field] = data\n          }\n        }\n      }\n\n      if (!headerObject.isNrrd) {\n        throw new Error('Not an NRRD file')\n      }\n\n      if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n        throw new Error('Bzip is not supported')\n      }\n\n      if (!headerObject.vectors) {\n        //if no space direction is set, let's use the identity\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]\n        //apply spacing if defined\n        if (headerObject.spacings) {\n          for (i = 0; i <= 2; i++) {\n            if (!isNaN(headerObject.spacings[i])) {\n              headerObject.vectors[i].multiplyScalar(headerObject.spacings[i])\n            }\n          }\n        }\n      }\n    }\n\n    //parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n    function parseDataAsText(data, start, end) {\n      let number = ''\n      start = start || 0\n      end = end || data.length\n      let value\n      //length of the result is the product of the sizes\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current\n      }, 1)\n\n      let base = 10\n      if (headerObject.encoding === 'hex') {\n        base = 16\n      }\n\n      const result = new headerObject.__array(lengthOfTheResult)\n      let resultIndex = 0\n      let parsingFunction = parseInt\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat\n      }\n\n      for (let i = start; i < end; i++) {\n        value = data[i]\n        //if value is not a space\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value)\n        } else {\n          if (number !== '') {\n            result[resultIndex] = parsingFunction(number, base)\n            resultIndex++\n          }\n\n          number = ''\n        }\n      }\n\n      if (number !== '') {\n        result[resultIndex] = parsingFunction(number, base)\n        resultIndex++\n      }\n\n      return result\n    }\n\n    const _bytes = scan('uchar', data.byteLength)\n    const _length = _bytes.length\n    let _header = null\n    let _data_start = 0\n    let i\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        // we found two line breaks in a row\n        // now we know what the header is\n        _header = this.parseChars(_bytes, 0, i - 2)\n        // this is were the data starts\n        _data_start = i + 1\n        break\n      }\n    }\n\n    // parse the header\n    parseHeader(_header)\n\n    _data = _bytes.subarray(_data_start) // the data without header\n    if (headerObject.encoding.substring(0, 2) === 'gz') {\n      // we need to decompress the datastream\n      // here we start the unzipping and get a typed Uint8Array back\n      _data = gunzipSync(new Uint8Array(_data))\n    } else if (\n      headerObject.encoding === 'ascii' ||\n      headerObject.encoding === 'text' ||\n      headerObject.encoding === 'txt' ||\n      headerObject.encoding === 'hex'\n    ) {\n      _data = parseDataAsText(_data)\n    } else if (headerObject.encoding === 'raw') {\n      //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n      const _copy = new Uint8Array(_data.length)\n\n      for (let i = 0; i < _data.length; i++) {\n        _copy[i] = _data[i]\n      }\n\n      _data = _copy\n    }\n\n    // .. let's use the underlying array buffer\n    _data = _data.buffer\n\n    const volume = new Volume()\n    volume.header = headerObject\n    //\n    // parse the (unzipped) data to a datastream of the correct type\n    //\n    volume.data = new headerObject.__array(_data)\n    // get the min and max intensities\n    const min_max = volume.computeMinMax()\n    const min = min_max[0]\n    const max = min_max[1]\n    // attach the scalar range to the volume\n    volume.windowLow = min\n    volume.windowHigh = max\n\n    // get the image dimensions\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]]\n    volume.xLength = volume.dimensions[0]\n    volume.yLength = volume.dimensions[1]\n    volume.zLength = volume.dimensions[2]\n    // spacing\n    const spacingX = new Vector3(\n      headerObject.vectors[0][0],\n      headerObject.vectors[0][1],\n      headerObject.vectors[0][2],\n    ).length()\n    const spacingY = new Vector3(\n      headerObject.vectors[1][0],\n      headerObject.vectors[1][1],\n      headerObject.vectors[1][2],\n    ).length()\n    const spacingZ = new Vector3(\n      headerObject.vectors[2][0],\n      headerObject.vectors[2][1],\n      headerObject.vectors[2][2],\n    ).length()\n    volume.spacing = [spacingX, spacingY, spacingZ]\n\n    // Create IJKtoRAS matrix\n    volume.matrix = new Matrix4()\n\n    let _spaceX = 1\n    let _spaceY = 1\n    const _spaceZ = 1\n\n    if (headerObject.space == 'left-posterior-superior') {\n      _spaceX = -1\n      _spaceY = -1\n    } else if (headerObject.space === 'left-anterior-superior') {\n      _spaceX = -1\n    }\n\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1)\n    } else {\n      const v = headerObject.vectors\n\n      volume.matrix.set(\n        _spaceX * v[0][0],\n        _spaceX * v[1][0],\n        _spaceX * v[2][0],\n        0,\n        _spaceY * v[0][1],\n        _spaceY * v[1][1],\n        _spaceY * v[2][1],\n        0,\n        _spaceZ * v[0][2],\n        _spaceZ * v[1][2],\n        _spaceZ * v[2][2],\n        0,\n        0,\n        0,\n        0,\n        1,\n      )\n    }\n\n    volume.inverseMatrix = new Matrix4()\n    volume.inverseMatrix.copy(volume.matrix).invert()\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength)\n      .applyMatrix4(volume.matrix)\n      .round()\n      .toArray()\n      .map(Math.abs)\n\n    // .. and set the default threshold\n    // only if the threshold was not already set\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min\n    }\n\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max\n    }\n\n    return volume\n  }\n\n  parseChars(array, start, end) {\n    // without borders, use the whole array\n    if (start === undefined) {\n      start = 0\n    }\n\n    if (end === undefined) {\n      end = array.length\n    }\n\n    let output = ''\n    // create and append the chars\n    let i = 0\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i])\n    }\n\n    return output\n  }\n}\n\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array\n        break\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array\n        break\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array\n        break\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array\n        break\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array\n        break\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array\n        break\n      case 'float':\n        this.__array = Float32Array\n        break\n      case 'double':\n        this.__array = Float64Array\n        break\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data)\n    }\n\n    return (this.type = data)\n  },\n\n  endian: function (data) {\n    return (this.endian = data)\n  },\n\n  encoding: function (data) {\n    return (this.encoding = data)\n  },\n\n  dimension: function (data) {\n    return (this.dim = parseInt(data, 10))\n  },\n\n  sizes: function (data) {\n    let i\n    return (this.sizes = (function () {\n      const _ref = data.split(/\\s+/)\n      const _results = []\n\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i]\n        _results.push(parseInt(i, 10))\n      }\n\n      return _results\n    })())\n  },\n\n  space: function (data) {\n    return (this.space = data)\n  },\n\n  'space origin': function (data) {\n    return (this.space_origin = data.split('(')[1].split(')')[0].split(','))\n  },\n\n  'space directions': function (data) {\n    let f, v\n    const parts = data.match(/\\(.*?\\)/g)\n    return (this.vectors = (function () {\n      const _results = []\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i]\n        _results.push(\n          (function () {\n            const _ref = v.slice(1, -1).split(/,/)\n            const _results2 = []\n\n            for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n              f = _ref[_j]\n              _results2.push(parseFloat(f))\n            }\n\n            return _results2\n          })(),\n        )\n      }\n\n      return _results\n    })())\n  },\n\n  spacings: function (data) {\n    let f\n    const parts = data.split(/\\s+/)\n    return (this.spacings = (function () {\n      const _results = []\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i]\n        _results.push(parseFloat(f))\n      }\n\n      return _results\n    })())\n  },\n}\n\nexport { NRRDLoader }\n"],"names":["_bytes","i","data"],"mappings":"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"}},
    {"offset": {"line": 6831, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/STLLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/STLLoader.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  LoaderUtils,\n  Vector3,\n} from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  const loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  const mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * const mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  const materials = [];\n *  const nGeometryGroups = geometry.groups.length;\n *\n *  const colorMap = ...; // Some logic to index colors.\n *\n *  for (let i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tconst material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  const mesh = new THREE.Mesh(geometry, materials);\n */\n\nclass STLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    function isBinary(data) {\n      const reader = new DataView(data)\n      const face_size = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8\n      const n_faces = reader.getUint32(80, true)\n      const expect = 80 + 32 / 8 + n_faces * face_size\n\n      if (expect === reader.byteLength) {\n        return true\n      }\n\n      // An ASCII STL data must begin with 'solid ' as the first six bytes.\n      // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n      // plentiful.  So, check the first 5 bytes for 'solid'.\n\n      // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n      // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n      // Search for \"solid\" to start anywhere after those prefixes.\n\n      // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n      const solid = [115, 111, 108, 105, 100]\n\n      for (let off = 0; off < 5; off++) {\n        // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n        if (matchDataViewAt(solid, reader, off)) return false\n      }\n\n      // Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n      return true\n    }\n\n    function matchDataViewAt(query, reader, offset) {\n      // Check if each byte in query matches the corresponding byte from the current offset\n\n      for (let i = 0, il = query.length; i < il; i++) {\n        if (query[i] !== reader.getUint8(offset + i, false)) return false\n      }\n\n      return true\n    }\n\n    function parseBinary(data) {\n      const reader = new DataView(data)\n      const faces = reader.getUint32(80, true)\n\n      let r,\n        g,\n        b,\n        hasColors = false,\n        colors\n      let defaultR, defaultG, defaultB, alpha\n\n      // process STL header\n      // check for default color in header (\"COLOR=rgba\" sequence).\n\n      for (let index = 0; index < 80 - 10; index++) {\n        if (\n          reader.getUint32(index, false) == 0x434f4c4f /*COLO*/ &&\n          reader.getUint8(index + 4) == 0x52 /*'R'*/ &&\n          reader.getUint8(index + 5) == 0x3d /*'='*/\n        ) {\n          hasColors = true\n          colors = new Float32Array(faces * 3 * 3)\n\n          defaultR = reader.getUint8(index + 6) / 255\n          defaultG = reader.getUint8(index + 7) / 255\n          defaultB = reader.getUint8(index + 8) / 255\n          alpha = reader.getUint8(index + 9) / 255\n        }\n      }\n\n      const dataOffset = 84\n      const faceLength = 12 * 4 + 2\n\n      const geometry = new BufferGeometry()\n\n      const vertices = new Float32Array(faces * 3 * 3)\n      const normals = new Float32Array(faces * 3 * 3)\n\n      for (let face = 0; face < faces; face++) {\n        const start = dataOffset + face * faceLength\n        const normalX = reader.getFloat32(start, true)\n        const normalY = reader.getFloat32(start + 4, true)\n        const normalZ = reader.getFloat32(start + 8, true)\n\n        if (hasColors) {\n          const packedColor = reader.getUint16(start + 48, true)\n\n          if ((packedColor & 0x8000) === 0) {\n            // facet has its own unique color\n\n            r = (packedColor & 0x1f) / 31\n            g = ((packedColor >> 5) & 0x1f) / 31\n            b = ((packedColor >> 10) & 0x1f) / 31\n          } else {\n            r = defaultR\n            g = defaultG\n            b = defaultB\n          }\n        }\n\n        for (let i = 1; i <= 3; i++) {\n          const vertexstart = start + i * 12\n          const componentIdx = face * 3 * 3 + (i - 1) * 3\n\n          vertices[componentIdx] = reader.getFloat32(vertexstart, true)\n          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true)\n          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true)\n\n          normals[componentIdx] = normalX\n          normals[componentIdx + 1] = normalY\n          normals[componentIdx + 2] = normalZ\n\n          if (hasColors) {\n            colors[componentIdx] = r\n            colors[componentIdx + 1] = g\n            colors[componentIdx + 2] = b\n          }\n        }\n      }\n\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new BufferAttribute(normals, 3))\n\n      if (hasColors) {\n        geometry.setAttribute('color', new BufferAttribute(colors, 3))\n        geometry.hasColors = true\n        geometry.alpha = alpha\n      }\n\n      return geometry\n    }\n\n    function parseASCII(data) {\n      const geometry = new BufferGeometry()\n      const patternSolid = /solid([\\s\\S]*?)endsolid/g\n      const patternFace = /facet([\\s\\S]*?)endfacet/g\n      let faceCounter = 0\n\n      const patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source\n      const patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g')\n      const patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g')\n\n      const vertices = []\n      const normals = []\n\n      const normal = new Vector3()\n\n      let result\n\n      let groupCount = 0\n      let startVertex = 0\n      let endVertex = 0\n\n      while ((result = patternSolid.exec(data)) !== null) {\n        startVertex = endVertex\n\n        const solid = result[0]\n\n        while ((result = patternFace.exec(solid)) !== null) {\n          let vertexCountPerFace = 0\n          let normalCountPerFace = 0\n\n          const text = result[0]\n\n          while ((result = patternNormal.exec(text)) !== null) {\n            normal.x = parseFloat(result[1])\n            normal.y = parseFloat(result[2])\n            normal.z = parseFloat(result[3])\n            normalCountPerFace++\n          }\n\n          while ((result = patternVertex.exec(text)) !== null) {\n            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]))\n            normals.push(normal.x, normal.y, normal.z)\n            vertexCountPerFace++\n            endVertex++\n          }\n\n          // every face have to own ONE valid normal\n\n          if (normalCountPerFace !== 1) {\n            console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter)\n          }\n\n          // each face have to own THREE valid vertices\n\n          if (vertexCountPerFace !== 3) {\n            console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter)\n          }\n\n          faceCounter++\n        }\n\n        const start = startVertex\n        const count = endVertex - startVertex\n\n        geometry.addGroup(start, count, groupCount)\n        groupCount++\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n\n      return geometry\n    }\n\n    function ensureString(buffer) {\n      if (typeof buffer !== 'string') {\n        return decodeText(new Uint8Array(buffer))\n      }\n\n      return buffer\n    }\n\n    function ensureBinary(buffer) {\n      if (typeof buffer === 'string') {\n        const array_buffer = new Uint8Array(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n          array_buffer[i] = buffer.charCodeAt(i) & 0xff // implicitly assumes little-endian\n        }\n\n        return array_buffer.buffer || array_buffer\n      } else {\n        return buffer\n      }\n    }\n\n    // start\n\n    const binData = ensureBinary(data)\n\n    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data))\n  }\n}\n\nexport { STLLoader }\n"],"names":["data"],"mappings":"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"}},
    {"offset": {"line": 7030, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/MTLLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/MTLLoader.js"],"sourcesContent":["import {\n  Color,\n  DefaultLoadingManager,\n  FileLoader,\n  FrontSide,\n  Loader,\n  LoaderUtils,\n  MeshPhongMaterial,\n  RepeatWrapping,\n  TextureLoader,\n  Vector2,\n} from 'three'\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setMaterialOptions(value) {\n    this.materialOptions = value\n    return this\n  }\n\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split('\\n')\n    let info = {}\n    const delimiter_pattern = /\\s+/\n    const materialsInfo = {}\n\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i]\n      line = line.trim()\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue\n      }\n\n      const pos = line.indexOf(' ')\n\n      let key = pos >= 0 ? line.substring(0, pos) : line\n      key = key.toLowerCase()\n\n      let value = pos >= 0 ? line.substring(pos + 1) : ''\n      value = value.trim()\n\n      if (key === 'newmtl') {\n        // New material\n\n        info = { name: value }\n        materialsInfo[value] = info\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          const ss = value.split(delimiter_pattern, 3)\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])]\n        } else {\n          info[key] = value\n        }\n      }\n    }\n\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions)\n    materialCreator.setCrossOrigin(this.crossOrigin)\n    materialCreator.setManager(this.manager)\n    materialCreator.setMaterials(materialsInfo)\n    return materialCreator\n  }\n}\n\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nclass MaterialCreator {\n  constructor(baseUrl = '', options = {}) {\n    this.baseUrl = baseUrl\n    this.options = options\n    this.materialsInfo = {}\n    this.materials = {}\n    this.materialsArray = []\n    this.nameLookup = {}\n\n    this.crossOrigin = 'anonymous'\n\n    this.side = this.options.side !== undefined ? this.options.side : FrontSide\n    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping\n  }\n\n  setCrossOrigin(value) {\n    this.crossOrigin = value\n    return this\n  }\n\n  setManager(value) {\n    this.manager = value\n  }\n\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo)\n    this.materials = {}\n    this.materialsArray = []\n    this.nameLookup = {}\n  }\n\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo\n\n    const converted = {}\n\n    for (const mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n\n      const mat = materialsInfo[mn]\n\n      const covmat = {}\n\n      converted[mn] = covmat\n\n      for (const prop in mat) {\n        let save = true\n        let value = mat[prop]\n        const lprop = prop.toLowerCase()\n\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255]\n            }\n\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n\n                save = false\n              }\n            }\n\n            break\n\n          default:\n            break\n        }\n\n        if (save) {\n          covmat[lprop] = value\n        }\n      }\n    }\n\n    return converted\n  }\n\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn)\n    }\n  }\n\n  getIndex(materialName) {\n    return this.nameLookup[materialName]\n  }\n\n  getAsArray() {\n    let index = 0\n\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn)\n      this.nameLookup[mn] = index\n      index++\n    }\n\n    return this.materialsArray\n  }\n\n  create(materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName)\n    }\n\n    return this.materials[materialName]\n  }\n\n  createMaterial_(materialName) {\n    // Create material\n\n    const scope = this\n    const mat = this.materialsInfo[materialName]\n    const params = {\n      name: materialName,\n      side: this.side,\n    }\n\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''\n\n      // Absolute URL\n      if (/^https?:\\/\\//i.test(url)) return url\n\n      return baseUrl + url\n    }\n\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return // Keep the first encountered texture\n\n      const texParams = scope.getTextureParams(value, params)\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url))\n\n      map.repeat.copy(texParams.scale)\n      map.offset.copy(texParams.offset)\n\n      map.wrapS = scope.wrap\n      map.wrapT = scope.wrap\n\n      params[mapType] = map\n    }\n\n    for (const prop in mat) {\n      const value = mat[prop]\n      let n\n\n      if (value === '') continue\n\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n\n          params.color = new Color().fromArray(value)\n\n          break\n\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value)\n\n          break\n\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value)\n\n          break\n\n        case 'map_kd':\n          // Diffuse texture map\n\n          setMapForType('map', value)\n\n          break\n\n        case 'map_ks':\n          // Specular map\n\n          setMapForType('specularMap', value)\n\n          break\n\n        case 'map_ke':\n          // Emissive map\n\n          setMapForType('emissiveMap', value)\n\n          break\n\n        case 'norm':\n          setMapForType('normalMap', value)\n\n          break\n\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n\n          setMapForType('bumpMap', value)\n\n          break\n\n        case 'map_d':\n          // Alpha map\n\n          setMapForType('alphaMap', value)\n          params.transparent = true\n\n          break\n\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n          params.shininess = parseFloat(value)\n\n          break\n\n        case 'd':\n          n = parseFloat(value)\n\n          if (n < 1) {\n            params.opacity = n\n            params.transparent = true\n          }\n\n          break\n\n        case 'tr':\n          n = parseFloat(value)\n\n          if (this.options && this.options.invertTrProperty) n = 1 - n\n\n          if (n > 0) {\n            params.opacity = 1 - n\n            params.transparent = true\n          }\n\n          break\n\n        default:\n          break\n      }\n    }\n\n    this.materials[materialName] = new MeshPhongMaterial(params)\n    return this.materials[materialName]\n  }\n\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0),\n    }\n\n    const items = value.split(/\\s+/)\n    let pos\n\n    pos = items.indexOf('-bm')\n\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1])\n      items.splice(pos, 2)\n    }\n\n    pos = items.indexOf('-s')\n\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]))\n      items.splice(pos, 4) // we expect 3 parameters here!\n    }\n\n    pos = items.indexOf('-o')\n\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]))\n      items.splice(pos, 4) // we expect 3 parameters here!\n    }\n\n    texParams.url = items.join(' ').trim()\n    return texParams\n  }\n\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== undefined ? this.manager : DefaultLoadingManager\n    let loader = manager.getHandler(url)\n\n    if (loader === null) {\n      loader = new TextureLoader(manager)\n    }\n\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin)\n\n    const texture = loader.load(url, onLoad, onProgress, onError)\n\n    if (mapping !== undefined) texture.mapping = mapping\n\n    return texture\n  }\n}\n\nexport { MTLLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7333, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/XLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/XLoader.js"],"sourcesContent":["import {\n  AnimationClip,\n  AnimationMixer,\n  Bone,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  Quaternion,\n  Skeleton,\n  SkinnedMesh,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector2,\n  Vector3,\n} from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nvar XLoader = /* @__PURE__ */ (function () {\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function')\n    }\n  }\n\n  var createClass = (function () {\n    function defineProperties(target, props) {\n      for (let i = 0; i < props.length; i++) {\n        var descriptor = props[i]\n        descriptor.enumerable = descriptor.enumerable || false\n        descriptor.configurable = true\n        if ('value' in descriptor) descriptor.writable = true\n        Object.defineProperty(target, descriptor.key, descriptor)\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps)\n      if (staticProps) defineProperties(Constructor, staticProps)\n      return Constructor\n    }\n  })()\n\n  var XboneInf = function XboneInf() {\n    classCallCheck(this, XboneInf)\n\n    this.boneName = ''\n    this.BoneIndex = 0\n    this.Indeces = []\n    this.Weights = []\n    this.initMatrix = null\n    this.OffsetMatrix = null\n  }\n\n  var XAnimationInfo = function XAnimationInfo() {\n    classCallCheck(this, XAnimationInfo)\n\n    this.animeName = ''\n    this.boneName = ''\n    this.targetBone = null\n    this.keyType = 4\n    this.frameStartLv = 0\n    this.keyFrames = []\n    this.InverseMx = null\n  }\n\n  var XAnimationObj = (function () {\n    function XAnimationObj(_flags) {\n      classCallCheck(this, XAnimationObj)\n\n      this.fps = 30\n      this.name = 'xanimation'\n      this.length = 0\n      this.hierarchy = []\n      this.putFlags = _flags\n      if (this.putFlags.putPos === undefined) {\n        this.putFlags.putPos = true\n      }\n\n      if (this.putFlags.putRot === undefined) {\n        this.putFlags.putRot = true\n      }\n\n      if (this.putFlags.putScl === undefined) {\n        this.putFlags.putScl = true\n      }\n    }\n\n    createClass(XAnimationObj, [\n      {\n        key: 'make',\n        value: function make(XAnimationInfoArray) {\n          for (let i = 0; i < XAnimationInfoArray.length; i++) {\n            this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]))\n          }\n\n          this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time\n        },\n      },\n      {\n        key: 'clone',\n        value: function clone() {\n          return Object.assign({}, this)\n        },\n      },\n      {\n        key: 'makeBonekeys',\n        value: function makeBonekeys(XAnimationInfo) {\n          var refObj = {}\n          refObj.name = XAnimationInfo.boneName\n          refObj.parent = ''\n          refObj.keys = this.keyFrameRefactor(XAnimationInfo)\n          refObj.copy = function () {\n            return Object.assign({}, this)\n          }\n\n          return refObj\n        },\n      },\n      {\n        key: 'keyFrameRefactor',\n        value: function keyFrameRefactor(XAnimationInfo) {\n          var keys = []\n          for (let i = 0; i < XAnimationInfo.keyFrames.length; i++) {\n            var keyframe = {}\n            keyframe.time = XAnimationInfo.keyFrames[i].time * this.fps\n            if (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {\n              keyframe.pos = XAnimationInfo.keyFrames[i].pos\n            }\n\n            if (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {\n              keyframe.rot = XAnimationInfo.keyFrames[i].rot\n            }\n\n            if (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {\n              keyframe.scl = XAnimationInfo.keyFrames[i].scl\n            }\n\n            if (XAnimationInfo.keyFrames[i].matrix) {\n              keyframe.matrix = XAnimationInfo.keyFrames[i].matrix\n              if (this.putFlags.putPos) {\n                keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix)\n              }\n\n              if (this.putFlags.putRot) {\n                keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix)\n              }\n\n              if (this.putFlags.putScl) {\n                keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix)\n              }\n            }\n\n            keys.push(keyframe)\n          }\n\n          return keys\n        },\n      },\n    ])\n    return XAnimationObj\n  })()\n\n  var XKeyFrameInfo = function XKeyFrameInfo() {\n    classCallCheck(this, XKeyFrameInfo)\n\n    this.index = 0\n    this.Frame = 0\n    this.time = 0.0\n    this.matrix = null\n  }\n\n  var XLoader = (function () {\n    function XLoader(manager) {\n      Loader.call(this, manager)\n\n      classCallCheck(this, XLoader)\n\n      this.debug = false\n      this.texloader = new TextureLoader(this.manager)\n      this.url = ''\n      this._putMatLength = 0\n      this._nowMat = null\n      this._nowFrameName = ''\n      this.frameHierarchie = []\n      this.Hierarchies = {}\n      this.HieStack = []\n      this._currentObject = {}\n      this._currentFrame = {}\n      this._data = null\n      this.onLoad = null\n      this.IsUvYReverse = true\n      this.Meshes = []\n      this.animations = []\n      this.animTicksPerSecond = 30\n      this._currentGeo = null\n      this._currentAnime = null\n      this._currentAnimeFrames = null\n    }\n\n    createClass(XLoader, [\n      {\n        key: '_setArgOption',\n        value: function _setArgOption(_arg) {\n          var _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0\n\n          if (!_arg) {\n            return\n          }\n\n          for (let i = _start; i < _arg.length; i++) {\n            switch (i) {\n              case 0:\n                this.url = _arg[i]\n                break\n              case 1:\n                this.options = _arg[i]\n                break\n            }\n          }\n\n          if (this.options === undefined) {\n            this.options = {}\n          }\n        },\n      },\n      {\n        key: 'load',\n        value: function load(_arg, onLoad, onProgress, onError) {\n          var _this = this\n\n          this._setArgOption(_arg)\n          var loader = new FileLoader(this.manager)\n          loader.setPath(this.path)\n          loader.setResponseType('arraybuffer')\n          loader.setRequestHeader(this.requestHeader)\n          loader.setWithCredentials(this.withCredentials)\n          loader.load(\n            this.url,\n            function (response) {\n              try {\n                _this.parse(response, onLoad)\n              } catch (e) {\n                if (onError) {\n                  onError(e)\n                } else {\n                  console.error(e)\n                }\n\n                _this.manager.itemError(_this.url)\n              }\n            },\n            onProgress,\n            onError,\n          )\n        },\n      },\n      {\n        key: '_readLine',\n        value: function _readLine(line) {\n          var readed = 0\n          while (true) {\n            var find = -1\n            find = line.indexOf('//', readed)\n            if (find === -1) {\n              find = line.indexOf('#', readed)\n            }\n\n            if (find > -1 && find < 2) {\n              var foundNewLine = -1\n              foundNewLine = line.indexOf('\\r\\n', readed)\n              if (foundNewLine > 0) {\n                readed = foundNewLine + 2\n              } else {\n                foundNewLine = line.indexOf('\\r', readed)\n                if (foundNewLine > 0) {\n                  readed = foundNewLine + 1\n                } else {\n                  readed = line.indexOf('\\n', readed) + 1\n                }\n              }\n            } else {\n              break\n            }\n          }\n\n          return line.substr(readed)\n        },\n      },\n      {\n        key: '_readLine',\n        value: function _readLine(line) {\n          var readed = 0\n          while (true) {\n            var find = -1\n            find = line.indexOf('//', readed)\n            if (find === -1) {\n              find = line.indexOf('#', readed)\n            }\n\n            if (find > -1 && find < 2) {\n              var foundNewLine = -1\n              foundNewLine = line.indexOf('\\r\\n', readed)\n              if (foundNewLine > 0) {\n                readed = foundNewLine + 2\n              } else {\n                foundNewLine = line.indexOf('\\r', readed)\n                if (foundNewLine > 0) {\n                  readed = foundNewLine + 1\n                } else {\n                  readed = line.indexOf('\\n', readed) + 1\n                }\n              }\n            } else {\n              break\n            }\n          }\n\n          return line.substr(readed)\n        },\n      },\n      {\n        key: '_isBinary',\n        value: function _isBinary(binData) {\n          var reader = new DataView(binData)\n          var face_size = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8\n          var n_faces = reader.getUint32(80, true)\n          var expect = 80 + 32 / 8 + n_faces * face_size\n          if (expect === reader.byteLength) {\n            return true\n          }\n\n          var fileLength = reader.byteLength\n          for (let index = 0; index < fileLength; index++) {\n            if (reader.getUint8(index, false) > 127) {\n              return true\n            }\n          }\n\n          return false\n        },\n      },\n      {\n        key: '_ensureBinary',\n        value: function _ensureBinary(buf) {\n          if (typeof buf === 'string') {\n            var array_buffer = new Uint8Array(buf.length)\n            for (let i = 0; i < buf.length; i++) {\n              array_buffer[i] = buf.charCodeAt(i) & 0xff\n            }\n\n            return array_buffer.buffer || array_buffer\n          } else {\n            return buf\n          }\n        },\n      },\n      {\n        key: '_ensureString',\n        value: function _ensureString(buf) {\n          if (typeof buf !== 'string') {\n            return decodeText(new Uint8Array(buf))\n          } else {\n            return buf\n          }\n        },\n      },\n      {\n        key: 'parse',\n        value: function _parse(data, onLoad) {\n          var binData = this._ensureBinary(data)\n          this._data = this._ensureString(data)\n          this.onLoad = onLoad\n          return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII()\n        },\n      },\n      {\n        key: '_parseBinary',\n        value: function _parseBinary(data) {\n          return this._parseASCII(decodeText(new Uint8Array(data)))\n        },\n      },\n      {\n        key: '_parseASCII',\n        value: function _parseASCII() {\n          var path\n\n          if (this.resourcePath !== '') {\n            path = this.resourcePath\n          } else if (this.path !== '') {\n            path = this.path\n          } else {\n            path = LoaderUtils.extractUrlBase(this.url)\n          }\n\n          this.texloader.setPath(path).setCrossOrigin(this.crossOrigin)\n\n          var endRead = 16\n          this.Hierarchies.children = []\n          this._hierarchieParse(this.Hierarchies, endRead)\n          this._changeRoot()\n          this._currentObject = this.Hierarchies.children.shift()\n          this._mainloop()\n        },\n      },\n      {\n        key: '_hierarchieParse',\n        value: function _hierarchieParse(_parent, _end) {\n          var endRead = _end\n          while (true) {\n            var find1 = this._data.indexOf('{', endRead) + 1\n            var findEnd = this._data.indexOf('}', endRead)\n            var findNext = this._data.indexOf('{', find1) + 1\n            if (find1 > 0 && findEnd > find1) {\n              var _currentObject = {}\n              _currentObject.children = []\n              var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim()\n              var word = nameData.split(/ /g)\n              if (word.length > 0) {\n                _currentObject.type = word[0]\n                if (word.length >= 2) {\n                  _currentObject.name = word[1]\n                } else {\n                  _currentObject.name = word[0] + this.Hierarchies.children.length\n                }\n              } else {\n                _currentObject.name = nameData\n                _currentObject.type = ''\n              }\n\n              if (_currentObject.type === 'Animation') {\n                _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim()\n                var refs = this._hierarchieParse(_currentObject, findEnd + 1)\n                endRead = refs.end\n                _currentObject.children = refs.parent.children\n              } else {\n                var DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd)\n                _currentObject.data = this._data.substr(find1, DataEnder - find1).trim()\n                if (findNext <= 0 || findEnd < findNext) {\n                  endRead = findEnd + 1\n                } else {\n                  var nextStart = Math.max(DataEnder + 1, find1)\n                  var _refs = this._hierarchieParse(_currentObject, nextStart)\n                  endRead = _refs.end\n                  _currentObject.children = _refs.parent.children\n                }\n              }\n\n              _currentObject.parent = _parent\n              if (_currentObject.type != 'template') {\n                _parent.children.push(_currentObject)\n              }\n            } else {\n              endRead = find1 === -1 ? this._data.length : findEnd + 1\n              break\n            }\n          }\n\n          return {\n            parent: _parent,\n            end: endRead,\n          }\n        },\n      },\n      {\n        key: '_mainloop',\n        value: function _mainloop() {\n          var _this2 = this\n\n          this._mainProc()\n          if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {\n            setTimeout(function () {\n              _this2._mainloop()\n            }, 1)\n          } else {\n            setTimeout(function () {\n              _this2.onLoad({\n                models: _this2.Meshes,\n                animations: _this2.animations,\n              })\n            }, 1)\n          }\n        },\n      },\n      {\n        key: '_mainProc',\n        value: function _mainProc() {\n          var breakFlag = false\n          while (true) {\n            if (!this._currentObject.worked) {\n              switch (this._currentObject.type) {\n                case 'template':\n                  break\n                case 'AnimTicksPerSecond':\n                  this.animTicksPerSecond = parseInt(this._currentObject.data)\n                  break\n                case 'Frame':\n                  this._setFrame()\n                  break\n                case 'FrameTransformMatrix':\n                  this._setFrameTransformMatrix()\n                  break\n                case 'Mesh':\n                  this._changeRoot()\n                  this._currentGeo = {}\n                  this._currentGeo.name = this._currentObject.name.trim()\n                  this._currentGeo.parentName = this._getParentName(this._currentObject).trim()\n                  this._currentGeo.VertexSetedBoneCount = []\n                  this._currentGeo.GeometryData = {\n                    vertices: [],\n                    normals: [],\n                    uvs: [],\n                    skinIndices: [],\n                    skinWeights: [],\n                    indices: [],\n                    materialIndices: [],\n                  }\n                  this._currentGeo.Materials = []\n                  this._currentGeo.normalVectors = []\n                  this._currentGeo.BoneInfs = []\n                  this._currentGeo.baseFrame = this._currentFrame\n                  this._makeBoneFrom_CurrentFrame()\n                  this._readVertexDatas()\n                  breakFlag = true\n                  break\n                case 'MeshNormals':\n                  this._readVertexDatas()\n                  break\n                case 'MeshTextureCoords':\n                  this._setMeshTextureCoords()\n                  break\n                case 'VertexDuplicationIndices':\n                  break\n                case 'MeshMaterialList':\n                  this._setMeshMaterialList()\n                  break\n                case 'Material':\n                  this._setMaterial()\n                  break\n                case 'SkinWeights':\n                  this._setSkinWeights()\n                  break\n                case 'AnimationSet':\n                  this._changeRoot()\n                  this._currentAnime = {}\n                  this._currentAnime.name = this._currentObject.name.trim()\n                  this._currentAnime.AnimeFrames = []\n                  break\n                case 'Animation':\n                  if (this._currentAnimeFrames) {\n                    this._currentAnime.AnimeFrames.push(this._currentAnimeFrames)\n                  }\n\n                  this._currentAnimeFrames = new XAnimationInfo()\n                  this._currentAnimeFrames.boneName = this._currentObject.data.trim()\n                  break\n                case 'AnimationKey':\n                  this._readAnimationKey()\n                  breakFlag = true\n                  break\n              }\n\n              this._currentObject.worked = true\n            }\n\n            if (this._currentObject.children.length > 0) {\n              this._currentObject = this._currentObject.children.shift()\n              if (this.debug) {\n                console.log('processing ' + this._currentObject.name)\n              }\n\n              if (breakFlag) break\n            } else {\n              if (this._currentObject.worked) {\n                if (this._currentObject.parent && !this._currentObject.parent.parent) {\n                  this._changeRoot()\n                }\n              }\n\n              if (this._currentObject.parent) {\n                this._currentObject = this._currentObject.parent\n              } else {\n                breakFlag = true\n              }\n\n              if (breakFlag) break\n            }\n          }\n\n          return\n        },\n      },\n      {\n        key: '_changeRoot',\n        value: function _changeRoot() {\n          if (this._currentGeo != null && this._currentGeo.name) {\n            this._makeOutputGeometry()\n          }\n\n          this._currentGeo = {}\n          if (this._currentAnime != null && this._currentAnime.name) {\n            if (this._currentAnimeFrames) {\n              this._currentAnime.AnimeFrames.push(this._currentAnimeFrames)\n              this._currentAnimeFrames = null\n            }\n\n            this._makeOutputAnimation()\n          }\n\n          this._currentAnime = {}\n        },\n      },\n      {\n        key: '_getParentName',\n        value: function _getParentName(_obj) {\n          if (_obj.parent) {\n            if (_obj.parent.name) {\n              return _obj.parent.name\n            } else {\n              return this._getParentName(_obj.parent)\n            }\n          } else {\n            return ''\n          }\n        },\n      },\n      {\n        key: '_setFrame',\n        value: function _setFrame() {\n          this._nowFrameName = this._currentObject.name.trim()\n          this._currentFrame = {}\n          this._currentFrame.name = this._nowFrameName\n          this._currentFrame.children = []\n          if (this._currentObject.parent && this._currentObject.parent.name) {\n            this._currentFrame.parentName = this._currentObject.parent.name\n          }\n\n          this.frameHierarchie.push(this._nowFrameName)\n          this.HieStack[this._nowFrameName] = this._currentFrame\n        },\n      },\n      {\n        key: '_setFrameTransformMatrix',\n        value: function _setFrameTransformMatrix() {\n          this._currentFrame.FrameTransformMatrix = new Matrix4()\n          var data = this._currentObject.data.split(',')\n          this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data)\n          this._makeBoneFrom_CurrentFrame()\n        },\n      },\n      {\n        key: '_makeBoneFrom_CurrentFrame',\n        value: function _makeBoneFrom_CurrentFrame() {\n          if (!this._currentFrame.FrameTransformMatrix) {\n            return\n          }\n\n          var b = new Bone()\n          b.name = this._currentFrame.name\n          b.applyMatrix4(this._currentFrame.FrameTransformMatrix)\n          b.matrixWorld = b.matrix\n          b.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix\n          this._currentFrame.putBone = b\n          if (this._currentFrame.parentName) {\n            for (let frame in this.HieStack) {\n              if (this.HieStack[frame].name === this._currentFrame.parentName) {\n                this.HieStack[frame].putBone.add(this._currentFrame.putBone)\n              }\n            }\n          }\n        },\n      },\n      {\n        key: '_readVertexDatas',\n        value: function _readVertexDatas() {\n          var endRead = 0\n          var mode = 0\n          var mode_local = 0\n          var maxLength = 0\n          while (true) {\n            var changeMode = false\n            if (mode_local === 0) {\n              var refO = this._readInt1(endRead)\n              endRead = refO.endRead\n              mode_local = 1\n              maxLength = this._currentObject.data.indexOf(';;', endRead) + 1\n              if (maxLength <= 0) {\n                maxLength = this._currentObject.data.length\n              }\n            } else {\n              var find = 0\n              switch (mode) {\n                case 0:\n                  find = this._currentObject.data.indexOf(',', endRead) + 1\n                  break\n                case 1:\n                  find = this._currentObject.data.indexOf(';,', endRead) + 1\n                  break\n              }\n\n              if (find === 0 || find > maxLength) {\n                find = maxLength\n                mode_local = 0\n                changeMode = true\n              }\n\n              switch (this._currentObject.type) {\n                case 'Mesh':\n                  switch (mode) {\n                    case 0:\n                      this._readVertex1(this._currentObject.data.substr(endRead, find - endRead))\n                      break\n                    case 1:\n                      this._readFace1(this._currentObject.data.substr(endRead, find - endRead))\n                      break\n                  }\n\n                  break\n                case 'MeshNormals':\n                  switch (mode) {\n                    case 0:\n                      this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead))\n                      break\n                  }\n\n                  break\n              }\n\n              endRead = find + 1\n              if (changeMode) {\n                mode++\n              }\n            }\n\n            if (endRead >= this._currentObject.data.length) {\n              break\n            }\n          }\n        },\n      },\n      {\n        key: '_readInt1',\n        value: function _readInt1(start) {\n          var find = this._currentObject.data.indexOf(';', start)\n          return {\n            refI: parseInt(this._currentObject.data.substr(start, find - start)),\n            endRead: find + 1,\n          }\n        },\n      },\n      {\n        key: '_readVertex1',\n        value: function _readVertex1(line) {\n          var data = this._readLine(line.trim())\n            .substr(0, line.length - 2)\n            .split(';')\n          this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]))\n          this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0)\n          this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0)\n          this._currentGeo.VertexSetedBoneCount.push(0)\n        },\n      },\n      {\n        key: '_readFace1',\n        value: function _readFace1(line) {\n          var data = this._readLine(line.trim())\n            .substr(2, line.length - 4)\n            .split(',')\n          this._currentGeo.GeometryData.indices.push(\n            parseInt(data[0], 10),\n            parseInt(data[1], 10),\n            parseInt(data[2], 10),\n          )\n        },\n      },\n      {\n        key: '_readNormalVector1',\n        value: function _readNormalVector1(line) {\n          var data = this._readLine(line.trim())\n            .substr(0, line.length - 2)\n            .split(';')\n          this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]))\n        },\n      },\n      {\n        key: '_buildGeometry',\n        value: function _buildGeometry() {\n          var bufferGeometry = new BufferGeometry()\n          var position = []\n          var normals = []\n          var uvs = []\n          var skinIndices = []\n          var skinWeights = []\n\n          //\n\n          var data = this._currentGeo.GeometryData\n\n          for (let i = 0, l = data.indices.length; i < l; i++) {\n            var stride2 = data.indices[i] * 2\n            var stride3 = data.indices[i] * 3\n            var stride4 = data.indices[i] * 4\n\n            position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2])\n            normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2])\n            skinIndices.push(\n              data.skinIndices[stride4],\n              data.skinIndices[stride4 + 1],\n              data.skinIndices[stride4 + 2],\n              data.skinIndices[stride4 + 3],\n            )\n            skinWeights.push(\n              data.skinWeights[stride4],\n              data.skinWeights[stride4 + 1],\n              data.skinWeights[stride4 + 2],\n              data.skinWeights[stride4 + 3],\n            )\n            uvs.push(data.uvs[stride2], data.uvs[stride2 + 1])\n          }\n\n          //\n\n          bufferGeometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n          bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n          bufferGeometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n          bufferGeometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4))\n          bufferGeometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4))\n\n          this._computeGroups(bufferGeometry, data.materialIndices)\n\n          return bufferGeometry\n        },\n      },\n      {\n        key: '_computeGroups',\n        value: function _computeGroups(bufferGeometry, materialIndices) {\n          var group\n          var groups = []\n          var materialIndex = undefined\n\n          for (let i = 0; i < materialIndices.length; i++) {\n            var currentMaterialIndex = materialIndices[i]\n\n            if (currentMaterialIndex !== materialIndex) {\n              materialIndex = currentMaterialIndex\n\n              if (group !== undefined) {\n                group.count = i * 3 - group.start\n                groups.push(group)\n              }\n\n              group = {\n                start: i * 3,\n                materialIndex: materialIndex,\n              }\n            }\n          }\n\n          if (group !== undefined) {\n            group.count = i * 3 - group.start\n            groups.push(group)\n          }\n\n          bufferGeometry.groups = groups\n        },\n      },\n      {\n        key: '_setMeshTextureCoords',\n        value: function _setMeshTextureCoords() {\n          var endRead = 0\n          var mode = 0\n          var mode_local = 0\n          while (true) {\n            switch (mode) {\n              case 0:\n                if (mode_local === 0) {\n                  var refO = this._readInt1(0)\n                  endRead = refO.endRead\n                  mode_local = 1\n                } else {\n                  var find = this._currentObject.data.indexOf(',', endRead) + 1\n                  if (find === 0) {\n                    find = this._currentObject.data.length\n                    mode = 2\n                    mode_local = 0\n                  }\n\n                  var line = this._currentObject.data.substr(endRead, find - endRead)\n                  var data = this._readLine(line.trim()).split(';')\n                  if (this.IsUvYReverse) {\n                    this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]))\n                  } else {\n                    this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]))\n                  }\n\n                  endRead = find + 1\n                }\n\n                break\n            }\n\n            if (endRead >= this._currentObject.data.length) {\n              break\n            }\n          }\n        },\n      },\n      {\n        key: '_setMeshMaterialList',\n        value: function _setMeshMaterialList() {\n          var endRead = 0\n          var mode = 0\n          var mode_local = 0\n          while (true) {\n            if (mode_local < 2) {\n              var refO = this._readInt1(endRead)\n              endRead = refO.endRead\n              mode_local++\n            } else {\n              var find = this._currentObject.data.indexOf(';', endRead)\n              if (find === -1) {\n                find = this._currentObject.data.length\n                mode = 3\n                mode_local = 0\n              }\n\n              var line = this._currentObject.data.substr(endRead, find - endRead)\n              var data = this._readLine(line.trim()).split(',')\n              for (let i = 0; i < data.length; i++) {\n                this._currentGeo.GeometryData.materialIndices[i] = parseInt(data[i])\n              }\n\n              endRead = this._currentObject.data.length\n            }\n\n            if (endRead >= this._currentObject.data.length || mode >= 3) {\n              break\n            }\n          }\n        },\n      },\n      {\n        key: '_setMaterial',\n        value: function _setMaterial() {\n          var _nowMat = new MeshPhongMaterial({\n            color: Math.random() * 0xffffff,\n          })\n          _nowMat.side = FrontSide\n          _nowMat.name = this._currentObject.name\n          var endRead = 0\n          var find = this._currentObject.data.indexOf(';;', endRead)\n          var line = this._currentObject.data.substr(endRead, find - endRead)\n          var data = this._readLine(line.trim()).split(';')\n          _nowMat.color.r = parseFloat(data[0])\n          _nowMat.color.g = parseFloat(data[1])\n          _nowMat.color.b = parseFloat(data[2])\n          endRead = find + 2\n          find = this._currentObject.data.indexOf(';', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          _nowMat.shininess = parseFloat(this._readLine(line))\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';;', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data2 = this._readLine(line.trim()).split(';')\n          _nowMat.specular.r = parseFloat(data2[0])\n          _nowMat.specular.g = parseFloat(data2[1])\n          _nowMat.specular.b = parseFloat(data2[2])\n          endRead = find + 2\n          find = this._currentObject.data.indexOf(';;', endRead)\n          if (find === -1) {\n            find = this._currentObject.data.length\n          }\n\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data3 = this._readLine(line.trim()).split(';')\n          _nowMat.emissive.r = parseFloat(data3[0])\n          _nowMat.emissive.g = parseFloat(data3[1])\n          _nowMat.emissive.b = parseFloat(data3[2])\n          var localObject = null\n          while (true) {\n            if (this._currentObject.children.length > 0) {\n              localObject = this._currentObject.children.shift()\n              if (this.debug) {\n                console.log('processing ' + localObject.name)\n              }\n\n              var fileName = localObject.data.substr(1, localObject.data.length - 2)\n              switch (localObject.type) {\n                case 'TextureFilename':\n                  _nowMat.map = this.texloader.load(fileName)\n                  break\n                case 'BumpMapFilename':\n                  _nowMat.bumpMap = this.texloader.load(fileName)\n                  _nowMat.bumpScale = 0.05\n                  break\n                case 'NormalMapFilename':\n                  _nowMat.normalMap = this.texloader.load(fileName)\n                  _nowMat.normalScale = new Vector2(2, 2)\n                  break\n                case 'EmissiveMapFilename':\n                  _nowMat.emissiveMap = this.texloader.load(fileName)\n                  break\n                case 'LightMapFilename':\n                  _nowMat.lightMap = this.texloader.load(fileName)\n                  break\n              }\n            } else {\n              break\n            }\n          }\n\n          this._currentGeo.Materials.push(_nowMat)\n        },\n      },\n      {\n        key: '_setSkinWeights',\n        value: function _setSkinWeights() {\n          var boneInf = new XboneInf()\n          var endRead = 0\n          var find = this._currentObject.data.indexOf(';', endRead)\n          var line = this._currentObject.data.substr(endRead, find - endRead)\n          endRead = find + 1\n          boneInf.boneName = line.substr(1, line.length - 2)\n          boneInf.BoneIndex = this._currentGeo.BoneInfs.length\n          find = this._currentObject.data.indexOf(';', endRead)\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data = this._readLine(line.trim()).split(',')\n          for (let i = 0; i < data.length; i++) {\n            boneInf.Indeces.push(parseInt(data[i]))\n          }\n\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data2 = this._readLine(line.trim()).split(',')\n          for (let _i = 0; _i < data2.length; _i++) {\n            boneInf.Weights.push(parseFloat(data2[_i]))\n          }\n\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';', endRead)\n          if (find <= 0) {\n            find = this._currentObject.data.length\n          }\n\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data3 = this._readLine(line.trim()).split(',')\n          boneInf.OffsetMatrix = new Matrix4()\n          this._ParseMatrixData(boneInf.OffsetMatrix, data3)\n          this._currentGeo.BoneInfs.push(boneInf)\n        },\n      },\n      {\n        key: '_makePutBoneList',\n        value: function _makePutBoneList(_RootName, _bones) {\n          var putting = false\n          for (let frame in this.HieStack) {\n            if (this.HieStack[frame].name === _RootName || putting) {\n              putting = true\n              var b = new Bone()\n              b.name = this.HieStack[frame].name\n              b.applyMatrix4(this.HieStack[frame].FrameTransformMatrix)\n              b.matrixWorld = b.matrix\n              b.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix\n              b.pos = new Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray()\n              b.rotq = new Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray()\n              b.scl = new Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray()\n              if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {\n                for (let i = 0; i < _bones.length; i++) {\n                  if (this.HieStack[frame].parentName === _bones[i].name) {\n                    _bones[i].add(b)\n                    b.parent = i\n                    break\n                  }\n                }\n              }\n\n              _bones.push(b)\n            }\n          }\n        },\n      },\n      {\n        key: '_makeOutputGeometry',\n        value: function _makeOutputGeometry() {\n          var mesh = null\n          if (this._currentGeo.BoneInfs.length > 0) {\n            var putBones = []\n            this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones)\n            for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {\n              var boneIndex = 0\n              for (let bb = 0; bb < putBones.length; bb++) {\n                if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {\n                  boneIndex = bb\n                  putBones[bb].OffsetMatrix = new Matrix4()\n                  putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix)\n                  break\n                }\n              }\n\n              for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {\n                var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi]\n                var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi]\n\n                var stride = nowVertexID * 4\n\n                switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {\n                  case 0:\n                    this._currentGeo.GeometryData.skinIndices[stride] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride] = nowVal\n                    break\n                  case 1:\n                    this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal\n                    break\n                  case 2:\n                    this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal\n                    break\n                  case 3:\n                    this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal\n                    break\n                }\n\n                this._currentGeo.VertexSetedBoneCount[nowVertexID]++\n                if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {\n                  console.log('warn! over 4 bone weight! :' + nowVertexID)\n                }\n              }\n            }\n\n            for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {\n              this._currentGeo.Materials[sk].skinning = true\n            }\n\n            var offsetList = []\n            for (let _bi = 0; _bi < putBones.length; _bi++) {\n              if (putBones[_bi].OffsetMatrix) {\n                offsetList.push(putBones[_bi].OffsetMatrix)\n              } else {\n                offsetList.push(new Matrix4())\n              }\n            }\n\n            var bufferGeometry = this._buildGeometry()\n            mesh = new SkinnedMesh(\n              bufferGeometry,\n              this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials,\n            )\n\n            this._initSkeleton(mesh, putBones, offsetList)\n          } else {\n            var _bufferGeometry = this._buildGeometry()\n            mesh = new Mesh(\n              _bufferGeometry,\n              this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials,\n            )\n          }\n\n          mesh.name = this._currentGeo.name\n          var worldBaseMx = new Matrix4()\n          var currentMxFrame = this._currentGeo.baseFrame.putBone\n          if (currentMxFrame && currentMxFrame.parent) {\n            while (true) {\n              currentMxFrame = currentMxFrame.parent\n              if (currentMxFrame) {\n                worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix)\n              } else {\n                break\n              }\n            }\n\n            mesh.applyMatrix4(worldBaseMx)\n          }\n\n          this.Meshes.push(mesh)\n        },\n      },\n      {\n        key: '_initSkeleton',\n        value: function _initSkeleton(mesh, boneList, boneInverses) {\n          var bones = [],\n            bone,\n            gbone\n          var i, il\n\n          for (i = 0, il = boneList.length; i < il; i++) {\n            gbone = boneList[i]\n\n            bone = new Bone()\n            bones.push(bone)\n\n            bone.name = gbone.name\n            bone.position.fromArray(gbone.pos)\n            bone.quaternion.fromArray(gbone.rotq)\n            if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl)\n          }\n\n          for (i = 0, il = boneList.length; i < il; i++) {\n            gbone = boneList[i]\n\n            if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n              bones[gbone.parent].add(bones[i])\n            } else {\n              mesh.add(bones[i])\n            }\n          }\n\n          mesh.updateMatrixWorld(true)\n\n          var skeleton = new Skeleton(bones, boneInverses)\n          mesh.bind(skeleton, mesh.matrixWorld)\n        },\n      },\n      {\n        key: '_readAnimationKey',\n        value: function _readAnimationKey() {\n          var endRead = 0\n          var find = this._currentObject.data.indexOf(';', endRead)\n          var line = this._currentObject.data.substr(endRead, find - endRead)\n          endRead = find + 1\n          var nowKeyType = parseInt(this._readLine(line))\n          find = this._currentObject.data.indexOf(';', endRead)\n          endRead = find + 1\n          line = this._currentObject.data.substr(endRead)\n          var data = this._readLine(line.trim()).split(';;,')\n          for (let i = 0; i < data.length; i++) {\n            var data2 = data[i].split(';')\n            var keyInfo = new XKeyFrameInfo()\n            keyInfo.type = nowKeyType\n            keyInfo.Frame = parseInt(data2[0])\n            keyInfo.index = this._currentAnimeFrames.keyFrames.length\n            keyInfo.time = keyInfo.Frame\n            if (nowKeyType != 4) {\n              var frameFound = false\n              for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {\n                if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {\n                  keyInfo = this._currentAnimeFrames.keyFrames[mm]\n                  frameFound = true\n                  break\n                }\n              }\n\n              var frameValue = data2[2].split(',')\n              switch (nowKeyType) {\n                case 0:\n                  keyInfo.rot = new Quaternion(\n                    parseFloat(frameValue[1]),\n                    parseFloat(frameValue[2]),\n                    parseFloat(frameValue[3]),\n                    parseFloat(frameValue[0]) * -1,\n                  )\n                  break\n                case 1:\n                  keyInfo.scl = new Vector3(\n                    parseFloat(frameValue[0]),\n                    parseFloat(frameValue[1]),\n                    parseFloat(frameValue[2]),\n                  )\n                  break\n                case 2:\n                  keyInfo.pos = new Vector3(\n                    parseFloat(frameValue[0]),\n                    parseFloat(frameValue[1]),\n                    parseFloat(frameValue[2]),\n                  )\n                  break\n              }\n\n              if (!frameFound) {\n                this._currentAnimeFrames.keyFrames.push(keyInfo)\n              }\n            } else {\n              keyInfo.matrix = new Matrix4()\n              this._ParseMatrixData(keyInfo.matrix, data2[2].split(','))\n              this._currentAnimeFrames.keyFrames.push(keyInfo)\n            }\n          }\n        },\n      },\n      {\n        key: '_makeOutputAnimation',\n        value: function _makeOutputAnimation() {\n          var animationObj = new XAnimationObj(this.options)\n          animationObj.fps = this.animTicksPerSecond\n          animationObj.name = this._currentAnime.name\n          animationObj.make(this._currentAnime.AnimeFrames)\n          this.animations.push(animationObj)\n        },\n      },\n      {\n        key: 'assignAnimation',\n        value: function assignAnimation(_model, _animation) {\n          var model = _model\n          var animation = _animation\n          if (!model) {\n            model = this.Meshes[0]\n          }\n\n          if (!animation) {\n            animation = this.animations[0]\n          }\n\n          if (!model || !animation) {\n            return null\n          }\n\n          var put = {}\n          put.fps = animation.fps\n          put.name = animation.name\n          put.length = animation.length\n          put.hierarchy = []\n          for (let b = 0; b < model.skeleton.bones.length; b++) {\n            var findAnimation = false\n            for (let i = 0; i < animation.hierarchy.length; i++) {\n              if (model.skeleton.bones[b].name === animation.hierarchy[i].name) {\n                findAnimation = true\n                var c_key = animation.hierarchy[i].copy()\n                c_key.parent = -1\n                if (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === 'Bone') {\n                  for (let bb = 0; bb < put.hierarchy.length; bb++) {\n                    if (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {\n                      c_key.parent = bb\n                      c_key.parentName = model.skeleton.bones[b].parent.name\n                    }\n                  }\n                }\n\n                put.hierarchy.push(c_key)\n                break\n              }\n            }\n\n            if (!findAnimation) {\n              var _c_key = animation.hierarchy[0].copy()\n              _c_key.name = model.skeleton.bones[b].name\n              _c_key.parent = -1\n              for (let k = 0; k < _c_key.keys.length; k++) {\n                if (_c_key.keys[k].pos) {\n                  _c_key.keys[k].pos.set(0, 0, 0)\n                }\n\n                if (_c_key.keys[k].scl) {\n                  _c_key.keys[k].scl.set(1, 1, 1)\n                }\n\n                if (_c_key.keys[k].rot) {\n                  _c_key.keys[k].rot.set(0, 0, 0, 1)\n                }\n              }\n\n              put.hierarchy.push(_c_key)\n            }\n          }\n\n          if (!model.geometry.animations) {\n            model.geometry.animations = []\n          }\n\n          model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones))\n          if (!model.animationMixer) {\n            model.animationMixer = new AnimationMixer(model)\n          }\n\n          return put\n        },\n      },\n      {\n        key: '_ParseMatrixData',\n        value: function _ParseMatrixData(targetMatrix, data) {\n          targetMatrix.set(\n            parseFloat(data[0]),\n            parseFloat(data[4]),\n            parseFloat(data[8]),\n            parseFloat(data[12]),\n            parseFloat(data[1]),\n            parseFloat(data[5]),\n            parseFloat(data[9]),\n            parseFloat(data[13]),\n            parseFloat(data[2]),\n            parseFloat(data[6]),\n            parseFloat(data[10]),\n            parseFloat(data[14]),\n            parseFloat(data[3]),\n            parseFloat(data[7]),\n            parseFloat(data[11]),\n            parseFloat(data[15]),\n          )\n        },\n      },\n    ])\n    return XLoader\n  })()\n\n  return XLoader\n})()\n\nexport { XLoader }\n"],"names":["i","XboneInf","XAnimationInfo","XAnimationObj","XKeyFrameInfo","XLoader"],"mappings":"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"}},
    {"offset": {"line": 8540, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/BVHLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/BVHLoader.js"],"sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  FileLoader,\n  Loader,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  Skeleton,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.animateBonePositions = true\n    this.animateBoneRotations = true\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    /*\n\t\t\treads a string array (lines) from a BVH file\n\t\t\tand outputs a skeleton structure including motion data\n\n\t\t\treturns thee root node:\n\t\t\t{ name: '', channels: [], children: [] }\n\t\t*/\n    function readBvh(lines) {\n      // read model structure\n\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.')\n      }\n\n      const list = [] // collects flat array of all bones\n      const root = readNode(lines, nextLine(lines), list)\n\n      // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.')\n      }\n\n      // number of frames\n\n      let tokens = nextLine(lines).split(/[\\s]+/)\n      const numFrames = parseInt(tokens[1])\n\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.')\n      }\n\n      // frame time\n\n      tokens = nextLine(lines).split(/[\\s]+/)\n      const frameTime = parseFloat(tokens[2])\n\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.')\n      }\n\n      // read frame data line by line\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/)\n        readFrameData(tokens, i * frameTime, root)\n      }\n\n      return list\n    }\n\n    /*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n\n      if (bone.type === 'ENDSITE') return\n\n      // add keyframe\n\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion(),\n      }\n\n      bone.frames.push(keyframe)\n\n      const quat = new Quaternion()\n\n      const vx = new Vector3(1, 0, 0)\n      const vy = new Vector3(0, 1, 0)\n      const vz = new Vector3(0, 0, 1)\n\n      // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim())\n            break\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim())\n            break\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim())\n            break\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.')\n        }\n      }\n\n      // parse child nodes\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i])\n      }\n    }\n\n    /*\n\t\t Recursively parses the HIERACHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n    function readNode(lines, firstline, list) {\n      const node = { name: '', type: '', frames: [] }\n      list.push(node)\n\n      // parse node type and name\n\n      let tokens = firstline.split(/[\\s]+/)\n\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE'\n        node.name = 'ENDSITE' // bvh end sites have no name\n      } else {\n        node.name = tokens[1]\n        node.type = tokens[0].toUpperCase()\n      }\n\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name')\n      }\n\n      // parse OFFSET\n\n      tokens = nextLine(lines).split(/[\\s]+/)\n\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0])\n      }\n\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.')\n      }\n\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]))\n\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.')\n      }\n\n      node.offset = offset\n\n      // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/)\n\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.')\n        }\n\n        const numChannels = parseInt(tokens[1])\n        node.channels = tokens.splice(2, numChannels)\n        node.children = []\n      }\n\n      // read children\n\n      while (true) {\n        const line = nextLine(lines)\n\n        if (line === '}') {\n          return node\n        } else {\n          node.children.push(readNode(lines, line, list))\n        }\n      }\n    }\n\n    /*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n    function toTHREEBone(source, list) {\n      const bone = new Bone()\n      list.push(bone)\n\n      bone.position.add(source.offset)\n      bone.name = source.name\n\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list))\n        }\n      }\n\n      return bone\n    }\n\n    /*\n\t\t\tbuilds a AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: a AnimationClip containing position and quaternion tracks\n\t\t*/\n    function toTHREEAnimation(bones) {\n      const tracks = []\n\n      // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i]\n\n        if (bone.type === 'ENDSITE') continue\n\n        // track data\n\n        const times = []\n        const positions = []\n        const rotations = []\n\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j]\n\n          times.push(frame.time)\n\n          // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x)\n          positions.push(frame.position.y + bone.offset.y)\n          positions.push(frame.position.z + bone.offset.z)\n\n          rotations.push(frame.rotation.x)\n          rotations.push(frame.rotation.y)\n          rotations.push(frame.rotation.z)\n          rotations.push(frame.rotation.w)\n        }\n\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions))\n        }\n\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations))\n        }\n      }\n\n      return new AnimationClip('animation', -1, tracks)\n    }\n\n    /*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n    function nextLine(lines) {\n      let line\n      // skip empty lines\n      while ((line = lines.shift().trim()).length === 0) {}\n\n      return line\n    }\n\n    const scope = this\n\n    const lines = text.split(/[\\r\\n]+/g)\n\n    const bones = readBvh(lines)\n\n    const threeBones = []\n    toTHREEBone(bones[0], threeBones)\n\n    const threeClip = toTHREEAnimation(bones)\n\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip,\n    }\n  }\n}\n\nexport { BVHLoader }\n"],"names":["lines","bones"],"mappings":"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"}},
    {"offset": {"line": 8751, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/ColladaLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/ColladaLoader.js"],"sourcesContent":["import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Group,\n  Line,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Scene,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  TextureLoader,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { TGALoader } from '../loaders/TGALoader'\nimport { UV1 } from '../_polyfill/uv1'\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n\n      const array = []\n      const childNodes = xml.childNodes\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i]\n\n        if (child.nodeName === name) {\n          array.push(child)\n        }\n      }\n\n      return array\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i]\n      }\n\n      return array\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i])\n      }\n\n      return array\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i])\n      }\n\n      return array\n    }\n\n    function parseId(text) {\n      return text.substring(1)\n    }\n\n    function generateId() {\n      return 'three_default_' + count++\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0\n    }\n\n    // asset\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0]),\n      }\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'))\n      } else {\n        return 1 // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP'\n    }\n\n    // library\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0]\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName)\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i])\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name]\n        object.build = builder(data[name])\n      }\n    }\n\n    // get\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build\n\n      data.build = builder(data)\n\n      return data.build\n    }\n\n    // animation\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {},\n      }\n\n      let hasChildren = false\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let id\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id')\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'sampler':\n            id = child.getAttribute('id')\n            data.samplers[id] = parseAnimationSampler(child)\n            break\n\n          case 'channel':\n            id = child.getAttribute('target')\n            data.channels[id] = parseAnimationChannel(child)\n            break\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child)\n            hasChildren = true\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'))\n            const semantic = child.getAttribute('semantic')\n            data.inputs[semantic] = id\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {}\n\n      const target = xml.getAttribute('target')\n\n      // parsing SID Addressing Syntax\n\n      let parts = target.split('/')\n\n      const id = parts.shift()\n      let sid = parts.shift()\n\n      // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1\n      const memberSyntax = sid.indexOf('.') !== -1\n\n      if (memberSyntax) {\n        //  member selection access\n\n        parts = sid.split('.')\n        sid = parts.shift()\n        data.member = parts.shift()\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        const indices = sid.split('(')\n        sid = indices.shift()\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''))\n        }\n\n        data.indices = indices\n      }\n\n      data.id = id\n      data.sid = sid\n\n      data.arraySyntax = arraySyntax\n      data.memberSyntax = memberSyntax\n\n      data.sampler = parseId(xml.getAttribute('source'))\n\n      return data\n    }\n\n    function buildAnimation(data) {\n      const tracks = []\n\n      const channels = data.channels\n      const samplers = data.samplers\n      const sources = data.sources\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target]\n          const sampler = samplers[channel.sampler]\n\n          const inputId = sampler.inputs.INPUT\n          const outputId = sampler.inputs.OUTPUT\n\n          const inputSource = sources[inputId]\n          const outputSource = sources[outputId]\n\n          const animation = buildAnimationChannel(channel, inputSource, outputSource)\n\n          createKeyframeTracks(animation, tracks)\n        }\n      }\n\n      return tracks\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation)\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id]\n      const object3D = getNode(node.id)\n\n      const transform = node.transforms[channel.sid]\n      const defaultMatrix = node.matrix.clone().transpose()\n\n      let time, stride\n      let i, il, j, jl\n\n      const data = {}\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i]\n            stride = i * outputSource.stride\n\n            if (data[time] === undefined) data[time] = {}\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride]\n              const index = channel.indices[0] + 4 * channel.indices[1]\n\n              data[time][index] = value\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j]\n              }\n            }\n          }\n\n          break\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix)\n\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes,\n      }\n\n      return animation\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []\n\n      // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({ time: parseFloat(time), value: data[time] })\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort(ascending)\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i])\n      }\n\n      return keyframes\n\n      // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time\n      }\n    }\n\n    const position = new Vector3()\n    const scale = new Vector3()\n    const quaternion = new Quaternion()\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes\n      const name = animation.name\n\n      const times = []\n      const positionData = []\n      const quaternionData = []\n      const scaleData = []\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i]\n\n        const time = keyframe.time\n        const value = keyframe.value\n\n        matrix.fromArray(value).transpose()\n        matrix.decompose(position, quaternion, scale)\n\n        times.push(time)\n        positionData.push(position.x, position.y, position.z)\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w)\n        scaleData.push(scale.x, scale.y, scale.z)\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData))\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData))\n      }\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData))\n\n      return tracks\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe\n\n      let empty = true\n      let i, l\n\n      // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i]\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null // mark as missing\n        } else {\n          empty = false\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i]\n\n          keyframe.value[property] = defaultValue\n        }\n      } else {\n        // filling gaps\n\n        createMissingKeyframes(keyframes, property)\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property)\n          next = getNext(keyframes, i, property)\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property]\n            continue\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property]\n            continue\n          }\n\n          interpolate(keyframe, prev, next, property)\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] !== null) return keyframe\n\n        i--\n      }\n\n      return null\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] !== null) return keyframe\n\n        i++\n      }\n\n      return null\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property]\n        return\n      }\n\n      key.value[property] =\n        ((key.time - prev.time) * (next.value[property] - prev.value[property])) / (next.time - prev.time) +\n        prev.value[property]\n    }\n\n    // animation clips\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: [],\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')))\n            break\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = []\n\n      const name = data.name\n      const duration = data.end - data.start || -1\n      const animations = data.animations\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i])\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j])\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks)\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip)\n    }\n\n    // controller\n\n    function parseController(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'))\n            data.skin = parseSkin(child)\n            break\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'))\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.')\n            break\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent)\n            break\n\n          case 'source':\n            const id = child.getAttribute('id')\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'joints':\n            data.joints = parseJoints(child)\n            break\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic')\n            const id = parseId(child.getAttribute('source'))\n            data.inputs[semantic] = id\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic')\n            const id = parseId(child.getAttribute('source'))\n            const offset = parseInt(child.getAttribute('offset'))\n            data.inputs[semantic] = { id: id, offset: offset }\n            break\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent)\n            break\n\n          case 'v':\n            data.v = parseInts(child.textContent)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id,\n      }\n\n      const geometry = library.geometries[build.id]\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin)\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices\n        geometry.sources.skinWeights = build.skin.weights\n      }\n\n      return build\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4\n\n      const build = {\n        joints: [], // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT,\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT,\n        },\n      }\n\n      const sources = data.sources\n      const vertexWeights = data.vertexWeights\n\n      const vcount = vertexWeights.vcount\n      const v = vertexWeights.v\n      const jointOffset = vertexWeights.inputs.JOINT.offset\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset\n\n      const jointSource = data.sources[data.joints.inputs.JOINT]\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX]\n\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array\n      let stride = 0\n\n      let i, j, l\n\n      // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i] // this is the amount of joints that affect a single vertex\n        const vertexSkinData = []\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset]\n          const weightId = v[stride + weightOffset]\n          const skinWeight = weights[weightId]\n\n          vertexSkinData.push({ index: skinIndex, weight: skinWeight })\n\n          stride += 2\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort(descending)\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j]\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index)\n            build.weights.array.push(d.weight)\n          } else {\n            build.indices.array.push(0)\n            build.weights.array.push(0)\n          }\n        }\n      }\n\n      // setup bind matrix\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose()\n      } else {\n        build.bindMatrix = new Matrix4().identity()\n      }\n\n      // process bones and inverse bind matrix data\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i]\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose()\n\n        build.joints.push({ name: name, boneInverse: boneInverse })\n      }\n\n      return build\n\n      // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController)\n    }\n\n    // image\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent,\n      }\n\n      library.images[xml.getAttribute('id')] = data\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build\n\n      return data.init_from\n    }\n\n    function getImage(id) {\n      const data = library.images[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id)\n\n      return null\n    }\n\n    // effect\n\n    function parseEffect(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child)\n            break\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data)\n            break\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child)\n            break\n\n          case 'extra':\n            data.extra = parseEffectExtra(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid')\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child)\n            break\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child)\n            break\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName\n            data.parameters = parseEffectParameters(child)\n            break\n\n          case 'extra':\n            data.extra = parseEffectExtra(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child)\n            break\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child),\n            }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent)\n            break\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent)\n            break\n\n          case 'texture':\n            data[child.nodeName] = { id: child.getAttribute('texture'), extra: parseEffectParameterTexture(child) }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data)\n            break\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent)\n            break\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent)\n            }\n\n            break\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child)\n            break\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent)\n            break\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectExtraTechniqueBump(xml) {\n      var data = {}\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child),\n            }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildEffect(data) {\n      return data\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect)\n    }\n\n    // material\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'))\n            break\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data\n    }\n\n    function getTextureLoader(image) {\n      let loader\n\n      let extension = image.slice(((image.lastIndexOf('.') - 1) >>> 0) + 2) // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase()\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader\n          break\n\n        default:\n          loader = textureLoader\n      }\n\n      return loader\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url)\n      const technique = effect.profile.technique\n\n      let material\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial()\n          break\n\n        case 'lambert':\n          material = new MeshLambertMaterial()\n          break\n\n        default:\n          material = new MeshBasicMaterial()\n          break\n      }\n\n      material.name = data.name || ''\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id]\n        let image = null\n\n        // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source]\n          image = getImage(surface.init_from)\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).')\n          image = getImage(textureObject.id)\n        }\n\n        // create texture if image is avaiable\n\n        if (image !== null) {\n          const loader = getTextureLoader(image)\n\n          if (loader !== undefined) {\n            const texture = loader.load(image)\n\n            const extra = textureObject.extra\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique\n\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping\n\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0)\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1)\n            } else {\n              texture.wrapS = RepeatWrapping\n              texture.wrapT = RepeatWrapping\n            }\n\n            return texture\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image)\n\n            return null\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id)\n\n          return null\n        }\n      }\n\n      const parameters = technique.parameters\n\n      for (const key in parameters) {\n        const parameter = parameters[key]\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color)\n            if (parameter.texture) material.map = getTexture(parameter.texture)\n            break\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color)\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture)\n            break\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture)\n            break\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture)\n            break\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float\n            break\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color)\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture)\n            break\n        }\n      }\n\n      //\n\n      let transparent = parameters['transparent']\n      let transparency = parameters['transparency']\n\n      // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1,\n        }\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1],\n          },\n        }\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true\n        } else {\n          const color = transparent.data.color\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float\n              break\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float\n              break\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float\n              break\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float\n              break\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque)\n          }\n\n          if (material.opacity < 1) material.transparent = true\n        }\n      }\n\n      //\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique\n\n        for (const k in techniques) {\n          const v = techniques[k]\n\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide\n              break\n\n            case 'bump':\n              material.normalMap = getTexture(v.texture)\n              material.normalScale = new Vector2(1, 1)\n              break\n          }\n        }\n      }\n\n      return material\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial)\n    }\n\n    // camera\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child)\n            break\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child)\n        }\n      }\n\n      return {}\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName\n            data.parameters = parseCameraParameters(child)\n\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildCamera(data) {\n      let camera\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar,\n          )\n          break\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag\n          let xmag = data.optics.parameters.xmag\n          const aspectRatio = data.optics.parameters.aspect_ratio\n\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag\n\n          xmag *= 0.5\n          ymag *= 0.5\n\n          camera = new OrthographicCamera(\n            -xmag,\n            xmag,\n            ymag,\n            -ymag, // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar,\n          )\n          break\n\n        default:\n          camera = new PerspectiveCamera()\n          break\n      }\n\n      camera.name = data.name || ''\n\n      return camera\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id)\n\n      return null\n    }\n\n    // light\n\n    function parseLight(xml) {\n      let data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child)\n            break\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName\n            data.parameters = parseLightParameters(child)\n        }\n      }\n\n      return data\n    }\n\n    function parseLightParameters(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent)\n            data.color = new Color().fromArray(array)\n            break\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent)\n            break\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent)\n            data.distance = f ? Math.sqrt(1 / f) : 0\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildLight(data) {\n      let light\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight()\n          break\n\n        case 'point':\n          light = new PointLight()\n          break\n\n        case 'spot':\n          light = new SpotLight()\n          break\n\n        case 'ambient':\n          light = new AmbientLight()\n          break\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color)\n      if (data.parameters.distance) light.distance = data.parameters.distance\n\n      return light\n    }\n\n    function getLight(id) {\n      const data = library.lights[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id)\n\n      return null\n    }\n\n    // geometry\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: [],\n      }\n\n      const mesh = getElementsByTagName(xml, 'mesh')[0]\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if (mesh === undefined) return\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        const id = child.getAttribute('id')\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child)\n            break\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName)\n            break\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child))\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3,\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent)\n            break\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent)\n            break\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0]\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'))\n            }\n\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'))\n      }\n\n      return data\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false,\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'))\n            const semantic = child.getAttribute('semantic')\n            const offset = parseInt(child.getAttribute('offset'))\n            const set = parseInt(child.getAttribute('set'))\n            const inputname = set > 0 ? semantic + set : semantic\n            primitive.inputs[inputname] = { id: id, offset: offset }\n            primitive.stride = Math.max(primitive.stride, offset + 1)\n            if (semantic === 'TEXCOORD') primitive.hasUV = true\n            break\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent)\n            break\n\n          case 'p':\n            primitive.p = parseInts(child.textContent)\n            break\n        }\n      }\n\n      return primitive\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {}\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i]\n\n        if (build[primitive.type] === undefined) build[primitive.type] = []\n\n        build[primitive.type].push(primitive)\n      }\n\n      return build\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i]\n\n        if (primitive.hasUV === true) {\n          count++\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {}\n\n      const sources = data.sources\n      const vertices = data.vertices\n      const primitives = data.primitives\n\n      if (primitives.length === 0) return {}\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives)\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType)\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices)\n      }\n\n      return build\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {}\n\n      const position = { array: [], stride: 0 }\n      const normal = { array: [], stride: 0 }\n      const uv = { array: [], stride: 0 }\n      const uv1 = { array: [], stride: 0 }\n      const color = { array: [], stride: 0 }\n\n      const skinIndex = { array: [], stride: 4 }\n      const skinWeight = { array: [], stride: 4 }\n\n      const geometry = new BufferGeometry()\n\n      const materialKeys = []\n\n      let start = 0\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p]\n        const inputs = primitive.inputs\n\n        // groups\n\n        let count = 0\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2\n            break\n\n          case 'triangles':\n            count = primitive.count * 3\n            break\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g]\n\n              switch (vc) {\n                case 3:\n                  count += 3 // single triangle\n                  break\n\n                case 4:\n                  count += 6 // quad, subdivided into two triangles\n                  break\n\n                default:\n                  count += (vc - 2) * 3 // polylist with more than four vertices\n                  break\n              }\n            }\n\n            break\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type)\n        }\n\n        geometry.addGroup(start, count, p)\n        start += count\n\n        // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material)\n        }\n\n        // geometry data\n\n        for (const name in inputs) {\n          const input = inputs[name]\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key]\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length\n                    buildGeometryData(primitive, sources[id], input.offset, position.array)\n                    position.stride = sources[id].stride\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array)\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array)\n                    }\n\n                    // see #3803\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n\n                        uv.array.push(0, 0)\n                      }\n                    }\n\n                    break\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array)\n                    normal.stride = sources[id].stride\n                    break\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array)\n                    color.stride = sources[id].stride\n                    break\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array)\n                    uv.stride = sources[id].stride\n                    break\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv1.array)\n                    uv.stride = sources[id].stride\n                    break\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key)\n                }\n              }\n\n              break\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array)\n              normal.stride = sources[input.id].stride\n              break\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array)\n              color.stride = sources[input.id].stride\n              break\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array)\n              uv.stride = sources[input.id].stride\n              break\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv1.array)\n              uv1.stride = sources[input.id].stride\n              break\n          }\n        }\n      }\n\n      // build geometry\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride))\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride))\n      }\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride))\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride))\n      if (uv1.array.length > 0) geometry.setAttribute(UV1, new Float32BufferAttribute(uv1.array, uv1.stride))\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride))\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride))\n      }\n\n      build.data = geometry\n      build.type = primitives[0].type\n      build.materialKeys = materialKeys\n\n      return build\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p\n      const stride = primitive.stride\n      const vcount = primitive.vcount\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride\n        const length = index + sourceStride\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index])\n        }\n      }\n\n      const sourceArray = source.array\n      const sourceStride = source.stride\n\n      if (primitive.vcount !== undefined) {\n        let index = 0\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i]\n\n          if (count === 4) {\n            const a = index + stride * 0\n            const b = index + stride * 1\n            const c = index + stride * 2\n            const d = index + stride * 3\n\n            pushVector(a)\n            pushVector(b)\n            pushVector(d)\n            pushVector(b)\n            pushVector(c)\n            pushVector(d)\n          } else if (count === 3) {\n            const a = index + stride * 0\n            const b = index + stride * 1\n            const c = index + stride * 2\n\n            pushVector(a)\n            pushVector(b)\n            pushVector(c)\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0\n              const b = index + stride * k\n              const c = index + stride * (k + 1)\n\n              pushVector(a)\n              pushVector(b)\n              pushVector(c)\n            }\n          }\n\n          index += stride * count\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i)\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry)\n    }\n\n    // kinematics\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data)\n            break\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build\n\n      return data\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel)\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child)\n            break\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child))\n            break\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0,\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0,\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent)\n            data.axis.fromArray(array)\n            break\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0]\n            const min = child.getElementsByTagName('min')[0]\n\n            data.limits.max = parseFloat(max.textContent)\n            data.limits.min = parseFloat(min.textContent)\n            break\n        }\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true\n      }\n\n      // calculate middle position\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0\n\n      return data\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child))\n            break\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child))\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child))\n            break\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child))\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName,\n      }\n\n      const array = parseFloats(xml.textContent)\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4()\n          data.obj.fromArray(array).transpose()\n          break\n\n        case 'translate':\n          data.obj = new Vector3()\n          data.obj.fromArray(array)\n          break\n\n        case 'rotate':\n          data.obj = new Vector3()\n          data.obj.fromArray(array)\n          data.angle = MathUtils.degToRad(array[3])\n          break\n      }\n\n      return data\n    }\n\n    // physics\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {},\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {}\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')])\n            break\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data)\n            break\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent)\n            break\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0]\n            break\n        }\n      }\n    }\n\n    // scene\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child))\n            break\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop(),\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0]\n            data.axis = param.textContent\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0]\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build\n\n      return data\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene)\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0]\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0]\n      const visualSceneId = Object.keys(library.visualScenes)[0]\n\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return\n\n      const kinematicsModel = getKinematicsModel(kinematicsModelId)\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId)\n      const visualScene = getVisualScene(visualSceneId)\n\n      const bindJointAxis = kinematicsScene.bindJointAxis\n      const jointMap = {}\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]')\n\n        if (targetElement) {\n          // get the parent of the transform element\n\n          const parentVisualElement = targetElement.parentElement\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement)\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name')\n        const joint = kinematicsModel.joints[jointIndex]\n\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition,\n            }\n          }\n        })\n      }\n\n      const m0 = new Matrix4()\n\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex]\n\n          if (jointData) {\n            return jointData.position\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\")\n          }\n        },\n\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex]\n\n          if (jointData) {\n            const joint = jointData.joint\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\n                'THREE.ColladaLoader: Joint ' +\n                jointIndex +\n                ' value ' +\n                value +\n                ' outside of limits (min: ' +\n                joint.limits.min +\n                ', max: ' +\n                joint.limits.max +\n                ').',\n              )\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.')\n            } else {\n              const object = jointData.object\n              const axis = joint.axis\n              const transforms = jointData.transforms\n\n              matrix.identity()\n\n              // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)))\n                      break\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value))\n                      break\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type)\n                      break\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj)\n                      break\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z))\n                      break\n\n                    case 'scale':\n                      matrix.scale(transform.obj)\n                      break\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle))\n                      break\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix)\n              object.matrix.decompose(object.position, object.quaternion, object.scale)\n\n              jointMap[jointIndex].position = value\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.')\n          }\n        },\n      }\n    }\n\n    function buildTransformList(node) {\n      const transforms = []\n\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]')\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let array, vector\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent)\n            const matrix = new Matrix4().fromArray(array).transpose()\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix,\n            })\n            break\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent)\n            vector = new Vector3().fromArray(array)\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n            })\n            break\n\n          case 'rotate':\n            array = parseFloats(child.textContent)\n            vector = new Vector3().fromArray(array)\n            const angle = MathUtils.degToRad(array[3])\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle,\n            })\n            break\n        }\n      }\n\n      return transforms\n    }\n\n    // nodes\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node')\n\n      // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i]\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId())\n        }\n      }\n    }\n\n    const matrix = new Matrix4()\n    const vector = new Vector3()\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {},\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let array\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'))\n            parseNode(child)\n            break\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child))\n            break\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child))\n            break\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'matrix':\n            array = parseFloats(child.textContent)\n            data.matrix.multiply(matrix.fromArray(array).transpose())\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'translate':\n            array = parseFloats(child.textContent)\n            vector.fromArray(array)\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'rotate':\n            array = parseFloats(child.textContent)\n            const angle = MathUtils.degToRad(array[3])\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'scale':\n            array = parseFloats(child.textContent)\n            data.matrix.scale(vector.fromArray(array))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'extra':\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn(\n          'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.',\n          data.id,\n        )\n      } else {\n        library.nodes[data.id] = data\n      }\n\n      return data\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material')\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j]\n              const symbol = instance.getAttribute('symbol')\n              const target = instance.getAttribute('target')\n\n              data.materials[symbol] = parseId(target)\n            }\n\n            break\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent))\n            break\n\n          default:\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = []\n      const sortedBoneData = []\n\n      let i, j, data\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i]\n\n        let root\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton)\n          buildBoneHierarchy(root, joints, boneData)\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          const visualScene = library.visualScenes[skeleton]\n          const children = visualScene.children\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j]\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id)\n              buildBoneHierarchy(root, joints, boneData)\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton)\n        }\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j]\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data\n            data.processed = true\n            break\n          }\n        }\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i]\n\n        if (data.processed === false) {\n          sortedBoneData.push(data)\n          data.processed = true\n        }\n      }\n\n      // setup arrays for skeleton creation\n\n      const bones = []\n      const boneInverses = []\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i]\n\n        bones.push(data.bone)\n        boneInverses.push(data.boneInverse)\n      }\n\n      return new Skeleton(bones, boneInverses)\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse\n\n          // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i]\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse\n              break\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new Matrix4()\n          }\n\n          boneData.push({ bone: object, boneInverse: boneInverse, processed: false })\n        }\n      })\n    }\n\n    function buildNode(data) {\n      const objects = []\n\n      const matrix = data.matrix\n      const nodes = data.nodes\n      const type = data.type\n      const instanceCameras = data.instanceCameras\n      const instanceControllers = data.instanceControllers\n      const instanceLights = data.instanceLights\n      const instanceGeometries = data.instanceGeometries\n      const instanceNodes = data.instanceNodes\n\n      // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]))\n      }\n\n      // instance cameras\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i])\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone())\n        }\n      }\n\n      // instance controllers\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i]\n        const controller = getController(instance.id)\n        const geometries = getGeometry(controller.id)\n        const newObjects = buildObjects(geometries, instance.materials)\n\n        const skeletons = instance.skeletons\n        const joints = controller.skin.joints\n\n        const skeleton = buildSkeleton(skeletons, joints)\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j]\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix)\n            object.normalizeSkinWeights()\n          }\n\n          objects.push(object)\n        }\n      }\n\n      // instance lights\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i])\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone())\n        }\n      }\n\n      // instance geometries\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id)\n        const newObjects = buildObjects(geometries, instance.materials)\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j])\n        }\n      }\n\n      // instance nodes\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone())\n      }\n\n      let object\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0]\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group()\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i])\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name\n      object.matrix.copy(matrix)\n      object.matrix.decompose(object.position, object.quaternion, object.scale)\n\n      return object\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({ color: 0xff00ff })\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = []\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]]\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i])\n          materials.push(fallbackMaterial)\n        } else {\n          materials.push(getMaterial(id))\n        }\n      }\n\n      return materials\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = []\n\n      for (const type in geometries) {\n        const geometry = geometries[type]\n\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials)\n\n        // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial())\n          } else {\n            materials.push(new MeshPhongMaterial())\n          }\n        }\n\n        // regard skinning\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined\n\n        // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials\n\n        // now create a specific 3D object\n\n        let object\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material)\n            break\n\n          case 'linestrips':\n            object = new Line(geometry.data, material)\n            break\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material)\n            } else {\n              object = new Mesh(geometry.data, material)\n            }\n\n            break\n        }\n\n        objects.push(object)\n      }\n\n      return objects\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode)\n    }\n\n    // visual scenes\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: [],\n      }\n\n      prepareNodes(xml)\n\n      const elements = getElementsByTagName(xml, 'node')\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]))\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group()\n      group.name = data.name\n\n      const children = data.children\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n\n        group.add(getNode(child.id))\n      }\n\n      return group\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene)\n    }\n\n    // scenes\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0]\n      return getVisualScene(parseId(instance.getAttribute('url')))\n    }\n\n    function setupAnimations() {\n      const clips = library.clips\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n\n          const tracks = []\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id)\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i])\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks))\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id))\n        }\n      }\n    }\n\n    // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n    function parserErrorToText(parserError) {\n      let result = ''\n      const stack = [parserError]\n\n      while (stack.length) {\n        const node = stack.shift()\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent\n        } else {\n          result += '\\n'\n          stack.push.apply(stack, node.childNodes)\n        }\n      }\n\n      return result.trim()\n    }\n\n    if (text.length === 0) {\n      return { scene: new Scene() }\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml')\n\n    const collada = getElementsByTagName(xml, 'COLLADA')[0]\n\n    const parserError = xml.getElementsByTagName('parsererror')[0]\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n\n      const errorElement = getElementsByTagName(parserError, 'div')[0]\n      let errorText\n\n      if (errorElement) {\n        errorText = errorElement.textContent\n      } else {\n        errorText = parserErrorToText(parserError)\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText)\n\n      return null\n    }\n\n    // metadata\n\n    const version = collada.getAttribute('version')\n    console.log('THREE.ColladaLoader: File version', version)\n\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0])\n    const textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    let tgaLoader\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager)\n      tgaLoader.setPath(this.resourcePath || path)\n    }\n\n    //\n\n    const animations = []\n    let kinematics = {}\n    let count = 0\n\n    //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {},\n    }\n\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation)\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip)\n    parseLibrary(collada, 'library_controllers', 'controller', parseController)\n    parseLibrary(collada, 'library_images', 'image', parseImage)\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect)\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial)\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera)\n    parseLibrary(collada, 'library_lights', 'light', parseLight)\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry)\n    parseLibrary(collada, 'library_nodes', 'node', parseNode)\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene)\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel)\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel)\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene)\n\n    buildLibrary(library.animations, buildAnimation)\n    buildLibrary(library.clips, buildAnimationClip)\n    buildLibrary(library.controllers, buildController)\n    buildLibrary(library.images, buildImage)\n    buildLibrary(library.effects, buildEffect)\n    buildLibrary(library.materials, buildMaterial)\n    buildLibrary(library.cameras, buildCamera)\n    buildLibrary(library.lights, buildLight)\n    buildLibrary(library.geometries, buildGeometry)\n    buildLibrary(library.visualScenes, buildVisualScene)\n\n    setupAnimations()\n    setupKinematics()\n\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0])\n    scene.animations = animations\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0))\n    }\n\n    scene.scale.multiplyScalar(asset.unit)\n\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.')\n        return animations\n      },\n      kinematics: kinematics,\n      library: library,\n      scene: scene,\n    }\n  }\n}\n\nexport { ColladaLoader }\n"],"names":["xml","text","library","animations","technique","count","position","vector","matrix","j","root","object","parserError"],"mappings":"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"}},
    {"offset": {"line": 11126, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/KMZLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/KMZLoader.js"],"sourcesContent":["import { FileLoader, Group, Loader, LoadingManager } from 'three'\nimport { ColladaLoader } from '../loaders/ColladaLoader'\nimport { unzipSync } from 'fflate'\n\nclass KMZLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    function findFile(url) {\n      for (const path in zip) {\n        if (path.substr(-url.length) === url) {\n          return zip[path]\n        }\n      }\n    }\n\n    const manager = new LoadingManager()\n    manager.setURLModifier(function (url) {\n      const image = findFile(url)\n\n      if (image) {\n        console.log('Loading', url)\n\n        const blob = new Blob([image.buffer], { type: 'application/octet-stream' })\n        return URL.createObjectURL(blob)\n      }\n\n      return url\n    })\n\n    //\n\n    const zip = unzipSync(new Uint8Array(data))\n\n    if (zip['doc.kml']) {\n      const xml = new DOMParser().parseFromString(fflate.strFromU8(zip['doc.kml']), 'application/xml')\n      const model = xml.querySelector('Placemark Model Link href')\n\n      if (model) {\n        const loader = new ColladaLoader(manager)\n        return loader.parse(fflate.strFromU8(zip[model.textContent]))\n      }\n    } else {\n      console.warn('KMZLoader: Missing doc.kml file.')\n\n      for (const path in zip) {\n        const extension = path.split('.').pop().toLowerCase()\n\n        if (extension === 'dae') {\n          const loader = new ColladaLoader(manager)\n          return loader.parse(fflate.strFromU8(zip[path]))\n        }\n      }\n    }\n\n    console.error(\"KMZLoader: Couldn't find .dae file.\")\n    return { scene: new Group() }\n  }\n}\n\nexport { KMZLoader }\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;IACd;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,MAAM,SAAS,IAAI,6JAAA,CAAW,MAAM,OAAO;QAC3C,OAAO,OAAA,CAAQ,MAAM,IAAI;QACzB,OAAO,eAAA,CAAgB,aAAa;QACpC,OAAO,gBAAA,CAAiB,MAAM,aAAa;QAC3C,OAAO,kBAAA,CAAmB,MAAM,eAAe;QAC/C,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;YACd,IAAI;gBACF,OAAO,MAAM,KAAA,CAAM,IAAI,CAAC;YACzB,EAAA,OAAQ,GAAP;gBACA,IAAI,SAAS;oBACX,QAAQ,CAAC;gBACrB,OAAiB;oBACL,QAAQ,KAAA,CAAM,CAAC;gBAChB;gBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC5B;QACF,GACD,YACA;IAEH;IAED,MAAM,IAAA,EAAM;QACV,SAAS,SAAS,GAAA,EAAK;YACrB,IAAA,MAAW,QAAQ,IAAK;gBACtB,IAAI,KAAK,MAAA,CAAO,CAAC,IAAI,MAAM,MAAM,KAAK;oBACpC,OAAO,GAAA,CAAI,IAAI,CAAA;gBAChB;YACF;QACF;QAED,MAAM,UAAU,IAAI,iKAAA,CAAgB;QACpC,QAAQ,cAAA,CAAe,SAAU,GAAA,EAAK;YACpC,MAAM,QAAQ,SAAS,GAAG;YAE1B,IAAI,OAAO;gBACT,QAAQ,GAAA,CAAI,WAAW,GAAG;gBAE1B,MAAM,OAAO,IAAI,KAAK;oBAAC,MAAM,MAAM;iBAAA,EAAG;oBAAE,MAAM;gBAAA,CAA4B;gBAC1E,OAAO,IAAI,eAAA,CAAgB,IAAI;YAChC;YAED,OAAO;QACb,CAAK;QAID,MAAM,UAAM,uLAAA,EAAU,IAAI,WAAW,IAAI,CAAC;QAE1C,IAAI,GAAA,CAAI,SAAS,CAAA,EAAG;YAClB,MAAM,MAAM,IAAI,UAAW,EAAC,eAAA,CAAgB,OAAO,SAAA,CAAU,GAAA,CAAI,SAAS,CAAC,GAAG,iBAAiB;YAC/F,MAAM,QAAQ,IAAI,aAAA,CAAc,2BAA2B;YAE3D,IAAI,OAAO;gBACT,MAAM,SAAS,IAAI,4KAAA,CAAc,OAAO;gBACxC,OAAO,OAAO,KAAA,CAAM,OAAO,SAAA,CAAU,GAAA,CAAI,MAAM,WAAW,CAAC,CAAC;YAC7D;QACP,OAAW;YACL,QAAQ,IAAA,CAAK,kCAAkC;YAE/C,IAAA,MAAW,QAAQ,IAAK;gBACtB,MAAM,YAAY,KAAK,KAAA,CAAM,GAAG,EAAE,GAAA,CAAK,EAAC,WAAA,CAAa;gBAErD,IAAI,cAAc,OAAO;oBACvB,MAAM,SAAS,IAAI,4KAAA,CAAc,OAAO;oBACxC,OAAO,OAAO,KAAA,CAAM,OAAO,SAAA,CAAU,GAAA,CAAI,IAAI,CAAC,CAAC;gBAChD;YACF;QACF;QAED,QAAQ,KAAA,CAAM,qCAAqC;QACnD,OAAO;YAAE,OAAO,IAAI,wJAAA;QAAS;IAC9B;AACH"}},
    {"offset": {"line": 11212, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/VRMLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/VRMLoader.js"],"sourcesContent":["import { Loader } from 'three'\nimport { GLTFLoader } from '../loaders/GLTFLoader.js'\n\n// VRM Specification: https://dwango.github.io/vrm/vrm_spec/\n//\n// VRM is based on glTF 2.0 and VRM extension is defined\n// in top-level json.extensions.VRM\n\nclass VRMLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n    this.gltfLoader = new GLTFLoader(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    this.gltfLoader.load(\n      url,\n      function (gltf) {\n        try {\n          scope.parse(gltf, onLoad)\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.gltfLoader.setDRACOLoader(dracoLoader)\n    return this\n  }\n\n  parse(gltf, onLoad) {\n    // const gltfParser = gltf.parser;\n    // const gltfExtensions = gltf.userData.gltfExtensions || {};\n    // const vrmExtension = gltfExtensions.VRM || {};\n\n    // handle VRM Extension here\n\n    onLoad(gltf)\n  }\n}\n\nexport { VRMLoader }\n"],"names":[],"mappings":";;;;;;;;AAQA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,UAAA,GAAa,IAAI,sKAAA,CAAW,OAAO;IACzC;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,IAAA,CAAK,UAAA,CAAW,IAAA,CACd,KACA,SAAU,IAAA,EAAM;YACd,IAAI;gBACF,MAAM,KAAA,CAAM,MAAM,MAAM;YACzB,EAAA,OAAQ,GAAP;gBACA,IAAI,SAAS;oBACX,QAAQ,CAAC;gBACrB,OAAiB;oBACL,QAAQ,KAAA,CAAM,CAAC;gBAChB;gBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC5B;QACF,GACD,YACA;IAEH;IAED,eAAe,WAAA,EAAa;QAC1B,IAAA,CAAK,UAAA,CAAW,cAAA,CAAe,WAAW;QAC1C,OAAO,IAAA;IACR;IAED,MAAM,IAAA,EAAM,MAAA,EAAQ;QAOlB,OAAO,IAAI;IACZ;AACH"}},
    {"offset": {"line": 11254, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/VRMLLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/VRMLLoader.js"],"sourcesContent":["import {\n  BackSide,\n  BoxGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  ConeGeometry,\n  CylinderGeometry,\n  DataTexture,\n  DoubleSide,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  LoaderUtils,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Points,\n  PointsMaterial,\n  Quaternion,\n  RepeatWrapping,\n  Scene,\n  ShapeUtils,\n  SphereGeometry,\n  TextureLoader,\n  Vector2,\n  Vector3,\n} from 'three'\nimport { Lexer, CstParser, createToken } from '../libs/chevrotain'\n\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data, path) {\n    const nodeMap = {}\n\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n\n      const tokenData = createTokens()\n\n      const lexer = new VRMLLexer(tokenData.tokens)\n      const parser = new VRMLParser(tokenData.tokenVocabulary)\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor())\n\n      // lexing\n\n      const lexingResult = lexer.lex(data)\n      parser.input = lexingResult.tokens\n\n      // parsing\n\n      const cstOutput = parser.vrml()\n\n      if (parser.errors.length > 0) {\n        console.error(parser.errors)\n\n        throw Error('THREE.VRMLLoader: Parsing errors detected.')\n      }\n\n      // actions\n\n      const ast = visitor.visit(cstOutput)\n\n      return ast\n    }\n\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n      })\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier,\n      })\n\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = [\n        'Anchor',\n        'Billboard',\n        'Collision',\n        'Group',\n        'Transform', // grouping nodes\n        'Inline',\n        'LOD',\n        'Switch', // special groups\n        'AudioClip',\n        'DirectionalLight',\n        'PointLight',\n        'Script',\n        'Shape',\n        'Sound',\n        'SpotLight',\n        'WorldInfo', // common nodes\n        'CylinderSensor',\n        'PlaneSensor',\n        'ProximitySensor',\n        'SphereSensor',\n        'TimeSensor',\n        'TouchSensor',\n        'VisibilitySensor', // sensors\n        'Box',\n        'Cone',\n        'Cylinder',\n        'ElevationGrid',\n        'Extrusion',\n        'IndexedFaceSet',\n        'IndexedLineSet',\n        'PointSet',\n        'Sphere', // geometries\n        'Color',\n        'Coordinate',\n        'Normal',\n        'TextureCoordinate', // geometric properties\n        'Appearance',\n        'FontStyle',\n        'ImageTexture',\n        'Material',\n        'MovieTexture',\n        'PixelTexture',\n        'TextureTransform', // appearance\n        'ColorInterpolator',\n        'CoordinateInterpolator',\n        'NormalInterpolator',\n        'OrientationInterpolator',\n        'PositionInterpolator',\n        'ScalarInterpolator', // interpolators\n        'Background',\n        'Fog',\n        'NavigationInfo',\n        'Viewpoint', // bindable nodes\n        'Text', // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]\n\n      //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier,\n      })\n\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier,\n      })\n\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier,\n      })\n\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier,\n      })\n\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier,\n      })\n\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier,\n      })\n\n      //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/,\n      })\n      const HexLiteral = createToken({ name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ })\n      const NumberLiteral = createToken({ name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ })\n      const TrueLiteral = createToken({ name: 'TrueLiteral', pattern: /TRUE/ })\n      const FalseLiteral = createToken({ name: 'FalseLiteral', pattern: /FALSE/ })\n      const NullLiteral = createToken({ name: 'NullLiteral', pattern: /NULL/ })\n      const LSquare = createToken({ name: 'LSquare', pattern: /\\[/ })\n      const RSquare = createToken({ name: 'RSquare', pattern: /]/ })\n      const LCurly = createToken({ name: 'LCurly', pattern: /{/ })\n      const RCurly = createToken({ name: 'RCurly', pattern: /}/ })\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED,\n      })\n\n      // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED,\n      })\n\n      const tokens = [\n        WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName,\n        DEF,\n        USE,\n        ROUTE,\n        TO,\n        TrueLiteral,\n        FalseLiteral,\n        NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version,\n        Identifier,\n        RouteIdentifier,\n        StringLiteral,\n        HexLiteral,\n        NumberLiteral,\n        LSquare,\n        RSquare,\n        LCurly,\n        RCurly,\n        Comment,\n      ]\n\n      const tokenVocabulary = {}\n\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i]\n\n        tokenVocabulary[token.name] = token\n      }\n\n      return { tokens: tokens, tokenVocabulary: tokenVocabulary }\n    }\n\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this)\n\n        this.validateVisitor()\n      }\n\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: [],\n          }\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i]\n\n            data.nodes.push(this.visit(node))\n          }\n\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i]\n\n              data.routes.push(this.visit(route))\n            }\n          }\n\n          return data\n        },\n\n        version: function (ctx) {\n          return ctx.Version[0].image\n        },\n\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: [],\n          }\n\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i]\n\n              data.fields.push(this.visit(field))\n            }\n          }\n\n          // DEF\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0])\n          }\n\n          return data\n        },\n\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null,\n          }\n\n          let result\n\n          // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0])\n          }\n\n          // MFValue\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0])\n          }\n\n          data.type = result.type\n          data.values = result.values\n\n          return data\n        },\n\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image\n        },\n\n        use: function (ctx) {\n          return { USE: (ctx.Identifier || ctx.NodeName)[0].image }\n        },\n\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx)\n        },\n\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx)\n        },\n\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image,\n          }\n\n          return data\n        },\n      })\n\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: [],\n        }\n\n        if (ctx.node) {\n          field.type = 'node'\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i]\n\n            field.values.push(scope.visit(node))\n          }\n        }\n\n        if (ctx.use) {\n          field.type = 'use'\n\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i]\n\n            field.values.push(scope.visit(use))\n          }\n        }\n\n        if (ctx.StringLiteral) {\n          field.type = 'string'\n\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i]\n\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''))\n          }\n        }\n\n        if (ctx.NumberLiteral) {\n          field.type = 'number'\n\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i]\n\n            field.values.push(parseFloat(numberLiteral.image))\n          }\n        }\n\n        if (ctx.HexLiteral) {\n          field.type = 'hex'\n\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i]\n\n            field.values.push(hexLiteral.image)\n          }\n        }\n\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean'\n\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i]\n\n            if (trueLiteral.image === 'TRUE') field.values.push(true)\n          }\n        }\n\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean'\n\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i]\n\n            if (falseLiteral.image === 'FALSE') field.values.push(false)\n          }\n        }\n\n        if (ctx.NullLiteral) {\n          field.type = 'null'\n\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null)\n          })\n        }\n\n        return field\n      }\n\n      return new VRMLToASTVisitor()\n    }\n\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n\n      const nodes = tree.nodes\n      const scene = new Scene()\n\n      // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i]\n\n        buildNodeMap(node)\n      }\n\n      // second iteration: build nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i]\n        const object = getNode(node)\n\n        if (object instanceof Object3D) scene.add(object)\n\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object\n      }\n\n      return scene\n    }\n\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node\n      }\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n\n        if (field.type === 'node') {\n          const fieldValues = field.values\n\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j])\n          }\n        }\n      }\n    }\n\n    function getNode(node) {\n      // handle case where a node refers to a different one\n\n      if (node.USE) {\n        return resolveUSE(node.USE)\n      }\n\n      if (node.build !== undefined) return node.build\n\n      node.build = buildNode(node)\n\n      return node.build\n    }\n\n    // node builder\n\n    function buildNode(node) {\n      const nodeName = node.name\n      let build\n\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node)\n          break\n\n        case 'Background':\n          build = buildBackgroundNode(node)\n          break\n\n        case 'Shape':\n          build = buildShapeNode(node)\n          break\n\n        case 'Appearance':\n          build = buildAppearanceNode(node)\n          break\n\n        case 'Material':\n          build = buildMaterialNode(node)\n          break\n\n        case 'ImageTexture':\n          build = buildImageTextureNode(node)\n          break\n\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node)\n          break\n\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node)\n          break\n\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node)\n          break\n\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node)\n          break\n\n        case 'PointSet':\n          build = buildPointSetNode(node)\n          break\n\n        case 'Box':\n          build = buildBoxNode(node)\n          break\n\n        case 'Cone':\n          build = buildConeNode(node)\n          break\n\n        case 'Cylinder':\n          build = buildCylinderNode(node)\n          break\n\n        case 'Sphere':\n          build = buildSphereNode(node)\n          break\n\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node)\n          break\n\n        case 'Extrusion':\n          build = buildExtrusionNode(node)\n          break\n\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node)\n          break\n\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node)\n          break\n\n        case 'Anchor':\n        case 'Billboard':\n\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n\n        case 'Text':\n\n        case 'FontStyle':\n        case 'MovieTexture':\n\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break\n\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName)\n          break\n      }\n\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF\n      }\n\n      return build\n    }\n\n    function buildGroupingNode(node) {\n      const object = new Group()\n\n      //\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break\n\n          case 'bboxSize':\n            // field not supported\n            break\n\n          case 'center':\n            // field not supported\n            break\n\n          case 'children':\n            parseFieldChildren(fieldValues, object)\n            break\n\n          case 'collide':\n            // field not supported\n            break\n\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]).normalize()\n            const angle = fieldValues[3]\n            object.quaternion.setFromAxisAngle(axis, angle)\n            break\n\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'scaleOrientation':\n            // field not supported\n            break\n\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'proxy':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return object\n    }\n\n    function buildBackgroundNode(node) {\n      const group = new Group()\n\n      let groundAngle, groundColor\n      let skyAngle, skyColor\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues\n            break\n\n          case 'groundColor':\n            groundColor = fieldValues\n            break\n\n          case 'backUrl':\n            // field not supported\n            break\n\n          case 'bottomUrl':\n            // field not supported\n            break\n\n          case 'frontUrl':\n            // field not supported\n            break\n\n          case 'leftUrl':\n            // field not supported\n            break\n\n          case 'rightUrl':\n            // field not supported\n            break\n\n          case 'topUrl':\n            // field not supported\n            break\n\n          case 'skyAngle':\n            skyAngle = fieldValues\n            break\n\n          case 'skyColor':\n            skyColor = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const radius = 10000\n\n      // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16)\n        const skyMaterial = new MeshBasicMaterial({ fog: false, side: BackSide, depthWrite: false, depthTest: false })\n\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true)\n          skyMaterial.vertexColors = true\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2])\n        }\n\n        const sky = new Mesh(skyGeometry, skyMaterial)\n        group.add(sky)\n      }\n\n      // ground\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI)\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false,\n          })\n\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false)\n\n          const ground = new Mesh(groundGeometry, groundMaterial)\n          group.add(ground)\n        }\n      }\n\n      // render background group first\n\n      group.renderOrder = -Infinity\n\n      return group\n    }\n\n    function buildShapeNode(node) {\n      const fields = node.fields\n\n      // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({ color: 0x000000 })\n      let geometry\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0])\n            }\n\n            break\n\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0])\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // build 3D object\n\n      let object\n\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type\n\n        if (type === 'points') {\n          // points\n\n          const pointsMaterial = new PointsMaterial({ color: 0xffffff })\n\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive)\n            }\n          }\n\n          object = new Points(geometry, pointsMaterial)\n        } else if (type === 'line') {\n          // lines\n\n          const lineMaterial = new LineBasicMaterial({ color: 0xffffff })\n\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive)\n            }\n          }\n\n          object = new LineSegments(geometry, lineMaterial)\n        } else {\n          // consider meshes\n\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide\n          }\n\n          // check for vertex colors\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true\n          }\n\n          object = new Mesh(geometry, material)\n        }\n      } else {\n        object = new Object3D()\n\n        // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false\n      }\n\n      return object\n    }\n\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial()\n      let transformData\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0])\n\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor)\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor)\n              if (materialData.shininess) material.shininess = materialData.shininess\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor)\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency\n              if (materialData.transparency > 0) material.transparent = true\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n              material = new MeshBasicMaterial({ color: 0x000000 })\n            }\n\n            break\n\n          case 'texture':\n            const textureNode = fieldValues[0]\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode)\n              } else {\n                // MovieTexture not supported yet\n              }\n            }\n\n            break\n\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0])\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // only apply texture transform data if a texture was defined\n\n      if (material.map) {\n        // respect VRML lighting model\n\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1 // ignore transparency\n              break\n\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff) // ignore material color\n              break\n\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff) // ignore material color\n              material.opacity = 1 // ignore transparency\n              break\n\n            default:\n          }\n\n          delete material.map.__type\n        }\n\n        // apply texture transform\n\n        if (transformData) {\n          material.map.center.copy(transformData.center)\n          material.map.rotation = transformData.rotation\n          material.map.repeat.copy(transformData.scale)\n          material.map.offset.copy(transformData.translation)\n        }\n      }\n\n      return material\n    }\n\n    function buildMaterialNode(node) {\n      const materialData = {}\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break\n\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'shininess':\n            materialData.shininess = fieldValues[0]\n            break\n\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'transparency':\n            materialData.transparency = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return materialData\n    }\n\n    function parseHexColor(hex, textureType, color) {\n      let value\n\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex)\n          color.r = value\n          color.g = value\n          color.b = value\n          color.a = 1\n          break\n\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4))\n          color.r = value\n          color.g = value\n          color.b = value\n          color.a = parseInt('0x' + hex.substring(4, 6))\n          break\n\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4))\n          color.g = parseInt('0x' + hex.substring(4, 6))\n          color.b = parseInt('0x' + hex.substring(6, 8))\n          color.a = 1\n          break\n\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4))\n          color.g = parseInt('0x' + hex.substring(4, 6))\n          color.b = parseInt('0x' + hex.substring(6, 8))\n          color.a = parseInt('0x' + hex.substring(8, 10))\n          break\n\n        default:\n      }\n    }\n\n    function getTextureType(num_components) {\n      let type\n\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY\n          break\n\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA\n          break\n\n        case 3:\n          type = TEXTURE_TYPE.RGB\n          break\n\n        case 4:\n          type = TEXTURE_TYPE.RGBA\n          break\n\n        default:\n      }\n\n      return type\n    }\n\n    function buildPixelTextureNode(node) {\n      let texture\n      let wrapS = RepeatWrapping\n      let wrapT = RepeatWrapping\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0]\n            const height = fieldValues[1]\n            const num_components = fieldValues[2]\n\n            const textureType = getTextureType(num_components)\n\n            const data = new Uint8Array(4 * width * height)\n\n            const color = { r: 0, g: 0, b: 0, a: 0 }\n\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color)\n\n              const stride = k * 4\n\n              data[stride + 0] = color.r\n              data[stride + 1] = color.g\n              data[stride + 2] = color.b\n              data[stride + 3] = color.a\n            }\n\n            texture = new DataTexture(data, width, height)\n            texture.needsUpdate = true\n            texture.__type = textureType // needed for material modifications\n            break\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping\n            break\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS\n        texture.wrapT = wrapT\n      }\n\n      return texture\n    }\n\n    function buildImageTextureNode(node) {\n      let texture\n      let wrapS = RepeatWrapping\n      let wrapT = RepeatWrapping\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0]\n            if (url) texture = textureLoader.load(url)\n            break\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping\n            break\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS\n        texture.wrapT = wrapT\n      }\n\n      return texture\n    }\n\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2(),\n      }\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1])\n            break\n\n          case 'rotation':\n            transformData.rotation = fieldValues[0]\n            break\n\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1])\n            break\n\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1])\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return transformData\n    }\n\n    function buildGeometricNode(node) {\n      return node.fields[0].values\n    }\n\n    function buildWorldInfoNode(node) {\n      const worldInfo = {}\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0]\n            break\n\n          case 'info':\n            worldInfo.info = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return worldInfo\n    }\n\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0\n      let colorIndex, coordIndex, normalIndex, texCoordIndex\n      let colorPerVertex = true,\n        normalPerVertex = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          case 'normal':\n            const normalNode = fieldValues[0]\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode)\n            }\n\n            break\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0]\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode)\n            }\n\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'colorIndex':\n            colorIndex = fieldValues\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'convex':\n            // field not supported\n            break\n\n          case 'coordIndex':\n            coordIndex = fieldValues\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'normalIndex':\n            normalIndex = fieldValues\n            break\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0]\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.')\n\n        return new BufferGeometry() // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw)\n\n      let colorAttribute\n      let normalAttribute\n      let uvAttribute\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw)\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3)\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3))\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n            const flattenFaceColors = flattenData(color, colorIndex)\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex)\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors)\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex)\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors)\n          }\n        }\n      }\n\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw)\n            normalAttribute = computeAttributeFromIndexedData(\n              triangulatedCoordIndex,\n              triangulatedNormalIndex,\n              normal,\n              3,\n            )\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3))\n          }\n        } else {\n          // consider face normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n            const flattenFaceNormals = flattenData(normal, normalIndex)\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex)\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals)\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex)\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals)\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle)\n      }\n\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw)\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2)\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2))\n        }\n      }\n\n      const geometry = new BufferGeometry()\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3))\n\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n\n      // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute)\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    function buildIndexedLineSetNode(node) {\n      let color, coord\n      let colorIndex, coordIndex\n      let colorPerVertex = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          case 'colorIndex':\n            colorIndex = fieldValues\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'coordIndex':\n            coordIndex = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // build lines\n\n      let colorAttribute\n\n      const expandedLineIndex = expandLineIndex(coordIndex) // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n            const expandedColorIndex = expandLineIndex(colorIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3) // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3))\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n            const flattenLineColors = flattenData(color, colorIndex) // compute colors for each VRML primitve\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors) // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            const expandedLineColors = expandLineData(color, coordIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors) // compute data on vertex level\n          }\n        }\n      }\n\n      //\n\n      const geometry = new BufferGeometry()\n\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3))\n      geometry.setAttribute('position', positionAttribute)\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n\n      geometry._type = 'line'\n\n      return geometry\n    }\n\n    function buildPointSetNode(node) {\n      let color, coord\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new BufferGeometry()\n\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3))\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3))\n\n      geometry._type = 'points'\n\n      return geometry\n    }\n\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2)\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0]\n            size.y = fieldValues[1]\n            size.z = fieldValues[2]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new BoxGeometry(size.x, size.y, size.z)\n\n      return geometry\n    }\n\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0]\n            break\n\n          case 'bottomRadius':\n            radius = fieldValues[0]\n            break\n\n          case 'height':\n            height = fieldValues[0]\n            break\n\n          case 'side':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded)\n\n      return geometry\n    }\n\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break\n\n          case 'radius':\n            radius = fieldValues[0]\n            break\n\n          case 'height':\n            height = fieldValues[0]\n            break\n\n          case 'side':\n            // field not supported\n            break\n\n          case 'top':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1)\n\n      return geometry\n    }\n\n    function buildSphereNode(node) {\n      let radius = 1\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new SphereGeometry(radius, 16, 16)\n\n      return geometry\n    }\n\n    function buildElevationGridNode(node) {\n      let color\n      let normal\n      let texCoord\n      let height\n\n      let colorPerVertex = true\n      let normalPerVertex = true\n      let solid = true\n      let ccw = true\n      let creaseAngle = 0\n      let xDimension = 2\n      let zDimension = 2\n      let xSpacing = 1\n      let zSpacing = 1\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'normal':\n            const normalNode = fieldValues[0]\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode)\n            }\n\n            break\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0]\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode)\n            }\n\n            break\n\n          case 'height':\n            height = fieldValues\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0]\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'xDimension':\n            xDimension = fieldValues[0]\n            break\n\n          case 'xSpacing':\n            xSpacing = fieldValues[0]\n            break\n\n          case 'zDimension':\n            zDimension = fieldValues[0]\n            break\n\n          case 'zSpacing':\n            zSpacing = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // vertex data\n\n      const vertices = []\n      const normals = []\n      const colors = []\n      const uvs = []\n\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n\n          const index = i * xDimension + j\n\n          // vertices\n\n          const x = xSpacing * i\n          const y = height[index]\n          const z = zSpacing * j\n\n          vertices.push(x, y, z)\n\n          // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0]\n            const g = color[index * 3 + 1]\n            const b = color[index * 3 + 2]\n\n            colors.push(r, g, b)\n          }\n\n          // normals\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0]\n            const yn = normal[index * 3 + 1]\n            const zn = normal[index * 3 + 2]\n\n            normals.push(xn, yn, zn)\n          }\n\n          // uvs\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0]\n            const t = texCoord[index * 2 + 1]\n\n            uvs.push(s, t)\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1))\n          }\n        }\n      }\n\n      // indices\n\n      const indices = []\n\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n          const a = i + j * xDimension\n          const b = i + (j + 1) * xDimension\n          const c = i + 1 + (j + 1) * xDimension\n          const d = i + 1 + j * xDimension\n\n          // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b)\n            indices.push(c, a, d)\n          } else {\n            indices.push(a, b, c)\n            indices.push(c, d, a)\n          }\n        }\n      }\n\n      //\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3))\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2))\n      let colorAttribute\n      let normalAttribute\n\n      // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1)\n\n              const r = color[index * 3 + 0]\n              const g = color[index * 3 + 1]\n              const b = color[index * 3 + 2]\n\n              // one color per quad\n\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n            }\n          }\n\n          colorAttribute = new Float32BufferAttribute(colors, 3)\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3))\n        }\n      }\n\n      // normal attribute\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1)\n\n              const xn = normal[index * 3 + 0]\n              const yn = normal[index * 3 + 1]\n              const zn = normal[index * 3 + 2]\n\n              // one normal per quad\n\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n            }\n          }\n\n          normalAttribute = new Float32BufferAttribute(normals, 3)\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3))\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle)\n      }\n\n      // build geometry\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n      geometry.setAttribute('uv', uvAttribute)\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1]\n      let spine = [0, 0, 0, 0, 1, 0]\n      let scale\n      let orientation\n\n      let beginCap = true\n      let ccw = true\n      let creaseAngle = 0\n      let endCap = true\n      let solid = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0]\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'convex':\n            // field not supported\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'crossSection':\n            crossSection = fieldValues\n            break\n\n          case 'endCap':\n            endCap = fieldValues[0]\n            break\n\n          case 'orientation':\n            orientation = fieldValues\n            break\n\n          case 'scale':\n            scale = fieldValues\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'spine':\n            spine = fieldValues // only extrusion along the Y-axis are supported so far\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const crossSectionClosed =\n        crossSection[0] === crossSection[crossSection.length - 2] &&\n        crossSection[1] === crossSection[crossSection.length - 1]\n\n      // vertices\n\n      const vertices = []\n      const spineVector = new Vector3()\n      const scaling = new Vector3()\n\n      const axis = new Vector3()\n      const vertex = new Vector3()\n      const quaternion = new Quaternion()\n\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i)\n\n        scaling.x = scale ? scale[j + 0] : 1\n        scaling.y = 1\n        scaling.z = scale ? scale[j + 1] : 1\n\n        axis.x = orientation ? orientation[o + 0] : 0\n        axis.y = orientation ? orientation[o + 1] : 0\n        axis.z = orientation ? orientation[o + 2] : 1\n        const angle = orientation ? orientation[o + 3] : 0\n\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0]\n          vertex.y = 0\n          vertex.z = crossSection[k + 1]\n\n          // scale\n\n          vertex.multiply(scaling)\n\n          // rotate\n\n          quaternion.setFromAxisAngle(axis, angle)\n          vertex.applyQuaternion(quaternion)\n\n          // translate\n\n          vertex.add(spineVector)\n\n          vertices.push(vertex.x, vertex.y, vertex.z)\n        }\n      }\n\n      // indices\n\n      const indices = []\n\n      const spineCount = spine.length / 3\n      const crossSectionCount = crossSection.length / 2\n\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount\n          let b = j + 1 + i * crossSectionCount\n          const c = j + (i + 1) * crossSectionCount\n          let d = j + 1 + (i + 1) * crossSectionCount\n\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount\n            d = (i + 1) * crossSectionCount\n          }\n\n          if (ccw === true) {\n            indices.push(a, b, c)\n            indices.push(c, b, d)\n          } else {\n            indices.push(a, c, b)\n            indices.push(c, d, b)\n          }\n        }\n      }\n\n      // triangulate cap\n\n      if (beginCap === true || endCap === true) {\n        const contour = []\n\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]))\n        }\n\n        const faces = ShapeUtils.triangulateShape(contour, [])\n        const capIndices = []\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i]\n\n          capIndices.push(face[0], face[1], face[2])\n        }\n\n        // begin cap\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2])\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1])\n            }\n          }\n        }\n\n        // end cap\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1) // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 2],\n                indexOffset + capIndices[i + 1],\n              )\n            } else {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 1],\n                indexOffset + capIndices[i + 2],\n              )\n            }\n          }\n        }\n      }\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3))\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle)\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n      // no uvs yet\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    // helper functions\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier]\n      const build = getNode(node)\n\n      // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build\n    }\n\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i])\n\n        if (object instanceof Object3D) owner.add(object)\n      }\n    }\n\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []\n\n      // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start]\n        const i2 = index[i + (ccw ? 1 : 2)]\n        const i3 = index[i + (ccw ? 2 : 1)]\n\n        indices.push(i1, i2, i3)\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3\n          start = i + 1\n        }\n      }\n\n      return indices\n    }\n\n    function triangulateFaceData(data, index) {\n      const triangulatedData = []\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        triangulatedData.push(x, y, z)\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3\n          start++\n        }\n      }\n\n      return triangulatedData\n    }\n\n    function flattenData(data, index) {\n      const flattenData = []\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i]\n\n        const stride = i1 * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        flattenData.push(x, y, z)\n      }\n\n      return flattenData\n    }\n\n    function expandLineIndex(index) {\n      const indices = []\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i]\n        const i2 = index[i + 1]\n\n        indices.push(i1, i2)\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2\n        }\n      }\n\n      return indices\n    }\n\n    function expandLineData(data, index) {\n      const triangulatedData = []\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        triangulatedData.push(x, y, z)\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2\n          start++\n        }\n      }\n\n      return triangulatedData\n    }\n\n    const vA = new Vector3()\n    const vB = new Vector3()\n    const vC = new Vector3()\n\n    const uvA = new Vector2()\n    const uvB = new Vector2()\n    const uvC = new Vector2()\n\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []\n\n      // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i]\n        const b = index[i + 1]\n        const c = index[i + 2]\n\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize)\n          uvB.fromArray(data, b * itemSize)\n          uvC.fromArray(data, c * itemSize)\n\n          array.push(uvA.x, uvA.y)\n          array.push(uvB.x, uvB.y)\n          array.push(uvC.x, uvC.y)\n        } else {\n          vA.fromArray(data, a * itemSize)\n          vB.fromArray(data, b * itemSize)\n          vC.fromArray(data, c * itemSize)\n\n          array.push(vA.x, vA.y, vA.z)\n          array.push(vB.x, vB.y, vB.z)\n          array.push(vC.x, vC.y, vC.z)\n        }\n      }\n\n      return new Float32BufferAttribute(array, itemSize)\n    }\n\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = []\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3)\n\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n      }\n\n      return new Float32BufferAttribute(array, 3)\n    }\n\n    function computeAttributeFromLineData(index, lineData) {\n      const array = []\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3)\n\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n      }\n\n      return new Float32BufferAttribute(array, 3)\n    }\n\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      const array2 = new array.constructor(indices.length * itemSize)\n\n      let index = 0,\n        index2 = 0\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++]\n        }\n      }\n\n      return new Float32BufferAttribute(array2, itemSize)\n    }\n\n    const ab = new Vector3()\n    const cb = new Vector3()\n\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = []\n      const vertexNormals = {}\n\n      // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i]\n        const b = index[i + 1]\n        const c = index[i + 2]\n\n        const face = new Face(a, b, c)\n\n        vA.fromArray(coord, a * 3)\n        vB.fromArray(coord, b * 3)\n        vC.fromArray(coord, c * 3)\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        cb.normalize()\n\n        face.normal.copy(cb)\n\n        if (vertexNormals[a] === undefined) vertexNormals[a] = []\n        if (vertexNormals[b] === undefined) vertexNormals[b] = []\n        if (vertexNormals[c] === undefined) vertexNormals[c] = []\n\n        vertexNormals[a].push(face.normal)\n        vertexNormals[b].push(face.normal)\n        vertexNormals[c].push(face.normal)\n\n        faces.push(face)\n      }\n\n      // compute vertex normals and build final geometry\n\n      const normals = []\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i]\n\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle)\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle)\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle)\n\n        vA.fromArray(coord, face.a * 3)\n        vB.fromArray(coord, face.b * 3)\n        vC.fromArray(coord, face.c * 3)\n\n        normals.push(nA.x, nA.y, nA.z)\n        normals.push(nB.x, nB.y, nB.z)\n        normals.push(nC.x, nC.y, nC.z)\n      }\n\n      return new Float32BufferAttribute(normals, 3)\n    }\n\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3()\n\n      if (creaseAngle === 0) {\n        normal.copy(vector)\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i])\n          }\n        }\n      }\n\n      return normal.normalize()\n    }\n\n    function toColorArray(colors) {\n      const array = []\n\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]))\n      }\n\n      return array\n    }\n\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n\n      const thresholds = []\n      const startAngle = topDown === true ? 0 : Math.PI\n\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1]\n        angle = topDown === true ? angle : startAngle - angle\n\n        const point = new Vector3()\n        point.setFromSphericalCoords(radius, angle, 0)\n\n        thresholds.push(point)\n      }\n\n      // generate vertex colors\n\n      const indices = geometry.index\n      const positionAttribute = geometry.attributes.position\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3)\n\n      const position = new Vector3()\n      const color = new Color()\n\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i)\n        position.fromBufferAttribute(positionAttribute, index)\n\n        let thresholdIndexA, thresholdIndexB\n        let t = 1\n\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1\n          thresholdIndexB = j\n\n          const thresholdA = thresholds[thresholdIndexA]\n          const thresholdB = thresholds[thresholdIndexB]\n\n          if (topDown === true) {\n            // interpolation for sky color\n\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y)\n\n              break\n            }\n          } else {\n            // interpolation for ground color\n\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y)\n\n              break\n            }\n          }\n        }\n\n        const colorA = colors[thresholdIndexA]\n        const colorB = colors[thresholdIndexB]\n\n        color.copy(colorA).lerp(colorB, t)\n\n        colorAttribute.setXYZ(index, color.r, color.g, color.b)\n      }\n\n      geometry.setAttribute('color', colorAttribute)\n    }\n\n    //\n\n    const textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.')\n    }\n\n    // create JSON representing the tree structure of the VRML asset\n\n    const tree = generateVRMLTree(data)\n\n    // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree)\n\n    return scene\n  }\n}\n\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens)\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText)\n\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors)\n\n      throw Error('THREE.VRMLLexer: Lexing errors detected.')\n    }\n\n    return lexingResult\n  }\n}\n\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary)\n\n    const $ = this\n\n    const Version = tokenVocabulary['Version']\n    const LCurly = tokenVocabulary['LCurly']\n    const RCurly = tokenVocabulary['RCurly']\n    const LSquare = tokenVocabulary['LSquare']\n    const RSquare = tokenVocabulary['RSquare']\n    const Identifier = tokenVocabulary['Identifier']\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier']\n    const StringLiteral = tokenVocabulary['StringLiteral']\n    const HexLiteral = tokenVocabulary['HexLiteral']\n    const NumberLiteral = tokenVocabulary['NumberLiteral']\n    const TrueLiteral = tokenVocabulary['TrueLiteral']\n    const FalseLiteral = tokenVocabulary['FalseLiteral']\n    const NullLiteral = tokenVocabulary['NullLiteral']\n    const DEF = tokenVocabulary['DEF']\n    const USE = tokenVocabulary['USE']\n    const ROUTE = tokenVocabulary['ROUTE']\n    const TO = tokenVocabulary['TO']\n    const NodeName = tokenVocabulary['NodeName']\n\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version)\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node)\n      })\n      $.MANY(function () {\n        $.SUBRULE($.route)\n      })\n    })\n\n    $.RULE('version', function () {\n      $.CONSUME(Version)\n    })\n\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def)\n      })\n\n      $.CONSUME(NodeName)\n      $.CONSUME(LCurly)\n      $.MANY(function () {\n        $.SUBRULE($.field)\n      })\n      $.CONSUME(RCurly)\n    })\n\n    $.RULE('field', function () {\n      $.CONSUME(Identifier)\n\n      $.OR2([\n        {\n          ALT: function () {\n            $.SUBRULE($.singleFieldValue)\n          },\n        },\n        {\n          ALT: function () {\n            $.SUBRULE($.multiFieldValue)\n          },\n        },\n      ])\n    })\n\n    $.RULE('def', function () {\n      $.CONSUME(DEF)\n      $.OR([\n        {\n          ALT: function () {\n            $.CONSUME(Identifier)\n          },\n        },\n        {\n          ALT: function () {\n            $.CONSUME(NodeName)\n          },\n        },\n      ])\n    })\n\n    $.RULE('use', function () {\n      $.CONSUME(USE)\n      $.OR([\n        {\n          ALT: function () {\n            $.CONSUME(Identifier)\n          },\n        },\n        {\n          ALT: function () {\n            $.CONSUME(NodeName)\n          },\n        },\n      ])\n    })\n\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([\n          {\n            ALT: function () {\n              $.SUBRULE($.node)\n            },\n          },\n          {\n            ALT: function () {\n              $.SUBRULE($.use)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(StringLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(HexLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NumberLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(TrueLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(FalseLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NullLiteral)\n            },\n          },\n        ])\n      })\n    })\n\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare)\n      $.MANY(function () {\n        $.OR([\n          {\n            ALT: function () {\n              $.SUBRULE($.node)\n            },\n          },\n          {\n            ALT: function () {\n              $.SUBRULE($.use)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(StringLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(HexLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NumberLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NullLiteral)\n            },\n          },\n        ])\n      })\n      $.CONSUME(RSquare)\n    })\n\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE)\n      $.CONSUME(RouteIdentifier)\n      $.CONSUME(TO)\n      $.CONSUME2(RouteIdentifier)\n    })\n\n    this.performSelfAnalysis()\n  }\n}\n\nclass Face {\n  constructor(a, b, c) {\n    this.a = a\n    this.b = b\n    this.c = c\n    this.normal = new Vector3()\n  }\n}\n\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4,\n}\n\nexport { VRMLLoader }\n"],"names":["data","tree","scene","flattenData"],"mappings":"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"}},
    {"offset": {"line": 13388, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/KTX2Loader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/KTX2Loader.js"],"sourcesContent":["/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats, as well as some\n * uncompressed DataTexture and Data3DTexture formats.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nimport {\n  CompressedTexture,\n  DataTexture,\n  FileLoader,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RedFormat,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  RGBA_ASTC_4x4_Format,\n  RGBA_ASTC_6x6_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGBAFormat,\n  RGFormat,\n  UnsignedByteType,\n} from 'three'\nimport { WorkerPool } from '../utils/WorkerPool'\nimport {\n  read,\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  VK_FORMAT_UNDEFINED,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UNORM,\n  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n  KHR_DF_PRIMARIES_UNSPECIFIED,\n  KHR_DF_PRIMARIES_BT709,\n  KHR_DF_PRIMARIES_DISPLAYP3,\n} from '../libs/ktx-parse'\nimport { ZSTDDecoder } from '../libs/zstddec'\nimport { CompressedCubeTexture } from '../_polyfill/CompressedCubeTexture'\nimport { CompressedArrayTexture } from '../_polyfill/CompressedArrayTexture'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nconst LinearEncoding = 3000\nconst sRGBEncoding = 3001\n\nconst NoColorSpace = ''\nconst DisplayP3ColorSpace = 'display-p3'\nconst LinearDisplayP3ColorSpace = 'display-p3-linear'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst SRGBColorSpace = 'srgb'\n\nconst _taskCache = new WeakMap()\n\nlet _activeLoaders = 0\n\nlet _zstd\n\nconst KTX2Loader = /* @__PURE__ */ (() => {\n  class KTX2Loader extends Loader {\n    /* CONSTANTS */\n\n    static BasisFormat = {\n      ETC1S: 0,\n      UASTC_4x4: 1,\n    }\n\n    static TranscoderFormat = {\n      ETC1: 0,\n      ETC2: 1,\n      BC1: 2,\n      BC3: 3,\n      BC4: 4,\n      BC5: 5,\n      BC7_M6_OPAQUE_ONLY: 6,\n      BC7_M5: 7,\n      PVRTC1_4_RGB: 8,\n      PVRTC1_4_RGBA: 9,\n      ASTC_4x4: 10,\n      ATC_RGB: 11,\n      ATC_RGBA_INTERPOLATED_ALPHA: 12,\n      RGBA32: 13,\n      RGB565: 14,\n      BGR565: 15,\n      RGBA4444: 16,\n    }\n\n    static EngineFormat = {\n      RGBAFormat: RGBAFormat,\n      RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n      RGBA_BPTC_Format: RGBA_BPTC_Format,\n      RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n      RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n      RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n      RGB_ETC1_Format: RGB_ETC1_Format,\n      RGB_ETC2_Format: RGB_ETC2_Format,\n      RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n      RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n    }\n\n    /* WEB WORKER */\n\n    static BasisWorker = function () {\n      let config\n      let transcoderPending\n      let BasisModule\n\n      /** @type KTX2Loader.EngineFormat */\n      const EngineFormat = _EngineFormat\n      /** @type KTX2Loader.TranscoderFormat */\n      const TranscoderFormat = _TranscoderFormat\n      /** @type KTX2Loader.BasisFormat */\n      const BasisFormat = _BasisFormat\n\n      self.addEventListener('message', function (e) {\n        const message = e.data\n\n        switch (message.type) {\n          case 'init':\n            config = message.config\n            init(message.transcoderBinary)\n            break\n\n          case 'transcode':\n            transcoderPending.then(() => {\n              try {\n                const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer)\n\n                self.postMessage(\n                  { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags },\n                  buffers,\n                )\n              } catch (error) {\n                console.error(error)\n\n                self.postMessage({ type: 'error', id: message.id, error: error.message })\n              }\n            })\n            break\n        }\n      })\n\n      function init(wasmBinary) {\n        transcoderPending = new Promise((resolve) => {\n          BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n          BASIS(BasisModule)\n        }).then(() => {\n          BasisModule.initializeBasis()\n\n          if (BasisModule.KTX2File === undefined) {\n            console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.')\n          }\n        })\n      }\n\n      function transcode(buffer) {\n        const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer))\n\n        function cleanup() {\n          ktx2File.close()\n          ktx2File.delete()\n        }\n\n        if (!ktx2File.isValid()) {\n          cleanup()\n          throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file')\n        }\n\n        const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n        const width = ktx2File.getWidth()\n        const height = ktx2File.getHeight()\n        const layerCount = ktx2File.getLayers() || 1\n        const levelCount = ktx2File.getLevels()\n        const faceCount = ktx2File.getFaces()\n        const hasAlpha = ktx2File.getHasAlpha()\n        const dfdFlags = ktx2File.getDFDFlags()\n\n        const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n        if (!width || !height || !levelCount) {\n          cleanup()\n          throw new Error('THREE.KTX2Loader:\tInvalid texture')\n        }\n\n        if (!ktx2File.startTranscoding()) {\n          cleanup()\n          throw new Error('THREE.KTX2Loader: .startTranscoding failed')\n        }\n\n        const faces = []\n        const buffers = []\n\n        for (let face = 0; face < faceCount; face++) {\n          const mipmaps = []\n\n          for (let mip = 0; mip < levelCount; mip++) {\n            const layerMips = []\n\n            let mipWidth, mipHeight\n\n            for (let layer = 0; layer < layerCount; layer++) {\n              const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face)\n\n              if (\n                face === 0 &&\n                mip === 0 &&\n                layer === 0 &&\n                (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)\n              ) {\n                console.warn('THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.')\n              }\n\n              if (levelCount > 1) {\n                mipWidth = levelInfo.origWidth\n                mipHeight = levelInfo.origHeight\n              } else {\n                // Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with\n                // mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.\n                // See mrdoob/three.js#25908.\n                mipWidth = levelInfo.width\n                mipHeight = levelInfo.height\n              }\n\n              const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat))\n              const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1)\n\n              if (!status) {\n                cleanup()\n                throw new Error('THREE.KTX2Loader: .transcodeImage failed.')\n              }\n\n              layerMips.push(dst)\n            }\n\n            const mipData = concat(layerMips)\n\n            mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight })\n            buffers.push(mipData.buffer)\n          }\n\n          faces.push({ mipmaps, width, height, format: engineFormat })\n        }\n\n        cleanup()\n\n        return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags }\n      }\n\n      //\n\n      // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n      // device capabilities, and texture dimensions. The list below ranks the formats separately\n      // for ETC1S and UASTC.\n      //\n      // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n      // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n      // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n      const FORMAT_OPTIONS = [\n        {\n          if: 'astcSupported',\n          basisFormat: [BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n          engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n          priorityETC1S: Infinity,\n          priorityUASTC: 1,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'bptcSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n          engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n          priorityETC1S: 3,\n          priorityUASTC: 2,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'dxtSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n          engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n          priorityETC1S: 4,\n          priorityUASTC: 5,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'etc2Supported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n          engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n          priorityETC1S: 1,\n          priorityUASTC: 3,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'etc1Supported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ETC1],\n          engineFormat: [EngineFormat.RGB_ETC1_Format],\n          priorityETC1S: 2,\n          priorityUASTC: 4,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'pvrtcSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n          engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n          priorityETC1S: 5,\n          priorityUASTC: 6,\n          needsPowerOfTwo: true,\n        },\n      ]\n\n      const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n        return a.priorityETC1S - b.priorityETC1S\n      })\n      const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n        return a.priorityUASTC - b.priorityUASTC\n      })\n\n      function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n        let transcoderFormat\n        let engineFormat\n\n        const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i]\n\n          if (!config[opt.if]) continue\n          if (!opt.basisFormat.includes(basisFormat)) continue\n          if (hasAlpha && opt.transcoderFormat.length < 2) continue\n          if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n          transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n          engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n          return { transcoderFormat, engineFormat }\n        }\n\n        console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n        transcoderFormat = TranscoderFormat.RGBA32\n        engineFormat = EngineFormat.RGBAFormat\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      function isPowerOfTwo(value) {\n        if (value <= 2) return true\n\n        return (value & (value - 1)) === 0 && value !== 0\n      }\n\n      /** Concatenates N byte arrays. */\n      function concat(arrays) {\n        if (arrays.length === 1) return arrays[0]\n\n        let totalByteLength = 0\n\n        for (let i = 0; i < arrays.length; i++) {\n          const array = arrays[i]\n          totalByteLength += array.byteLength\n        }\n\n        const result = new Uint8Array(totalByteLength)\n\n        let byteOffset = 0\n\n        for (let i = 0; i < arrays.length; i++) {\n          const array = arrays[i]\n          result.set(array, byteOffset)\n\n          byteOffset += array.byteLength\n        }\n\n        return result\n      }\n    }\n\n    constructor(manager) {\n      super(manager)\n\n      this.transcoderPath = ''\n      this.transcoderBinary = null\n      this.transcoderPending = null\n\n      this.workerPool = new WorkerPool()\n      this.workerSourceURL = ''\n      this.workerConfig = null\n\n      if (typeof MSC_TRANSCODER !== 'undefined') {\n        console.warn(\n          'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' +\n            ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.',\n        )\n      }\n    }\n\n    setTranscoderPath(path) {\n      this.transcoderPath = path\n\n      return this\n    }\n\n    setWorkerLimit(num) {\n      this.workerPool.setWorkerLimit(num)\n\n      return this\n    }\n\n    detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n        etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n        etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n        dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n        bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n        pvrtcSupported:\n          renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n          renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      }\n\n      if (renderer.capabilities.isWebGL2) {\n        // https://github.com/mrdoob/three.js/pull/22928\n        this.workerConfig.etc1Supported = false\n      }\n\n      return this\n    }\n\n    init() {\n      if (!this.transcoderPending) {\n        // Load transcoder wrapper.\n        const jsLoader = new FileLoader(this.manager)\n        jsLoader.setPath(this.transcoderPath)\n        jsLoader.setWithCredentials(this.withCredentials)\n        const jsContent = jsLoader.loadAsync('basis_transcoder.js')\n\n        // Load transcoder WASM binary.\n        const binaryLoader = new FileLoader(this.manager)\n        binaryLoader.setPath(this.transcoderPath)\n        binaryLoader.setResponseType('arraybuffer')\n        binaryLoader.setWithCredentials(this.withCredentials)\n        const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm')\n\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n          const fn = KTX2Loader.BasisWorker.toString()\n\n          const body = [\n            '/* constants */',\n            'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat),\n            'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat),\n            'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat),\n            '/* basis_transcoder.js */',\n            jsContent,\n            '/* worker */',\n            fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n          ].join('\\n')\n\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n          this.transcoderBinary = binaryContent\n\n          this.workerPool.setWorkerCreator(() => {\n            const worker = new Worker(this.workerSourceURL)\n            const transcoderBinary = this.transcoderBinary.slice(0)\n\n            worker.postMessage({ type: 'init', config: this.workerConfig, transcoderBinary }, [transcoderBinary])\n\n            return worker\n          })\n        })\n\n        if (_activeLoaders > 0) {\n          // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\n\n          console.warn(\n            'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' +\n              ' Use a single KTX2Loader instance, or call .dispose() on old instances.',\n          )\n        }\n\n        _activeLoaders++\n      }\n\n      return this.transcoderPending\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      if (this.workerConfig === null) {\n        throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.')\n      }\n\n      const loader = new FileLoader(this.manager)\n\n      loader.setResponseType('arraybuffer')\n      loader.setWithCredentials(this.withCredentials)\n\n      loader.load(\n        url,\n        (buffer) => {\n          // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n          // again from this thread.\n          if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer)\n\n            return cachedTask.promise.then(onLoad).catch(onError)\n          }\n\n          this._createTexture(buffer)\n            .then((texture) => (onLoad ? onLoad(texture) : null))\n            .catch(onError)\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    _createTextureFrom(transcodeResult, container) {\n      const { faces, width, height, format, type, error, dfdFlags } = transcodeResult\n\n      if (type === 'error') return Promise.reject(error)\n\n      let texture\n\n      if (container.faceCount === 6) {\n        texture = new CompressedCubeTexture(faces, format, UnsignedByteType)\n      } else {\n        const mipmaps = faces[0].mipmaps\n\n        texture =\n          container.layerCount > 1\n            ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType)\n            : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n      }\n\n      texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.needsUpdate = true\n\n      const colorSpace = parseColorSpace(container)\n      if ('colorSpace' in texture) texture.colorSpace = colorSpace\n      else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n      texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED)\n\n      return texture\n    }\n\n    /**\n     * @param {ArrayBuffer} buffer\n     * @param {object?} config\n     * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n     */\n    async _createTexture(buffer, config = {}) {\n      const container = read(new Uint8Array(buffer))\n\n      if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n        return createRawTexture(container)\n      }\n\n      //\n\n      const taskConfig = config\n      const texturePending = this.init()\n        .then(() => {\n          return this.workerPool.postMessage({ type: 'transcode', buffer, taskConfig: taskConfig }, [buffer])\n        })\n        .then((e) => this._createTextureFrom(e.data, container))\n\n      // Cache the task result.\n      _taskCache.set(buffer, { promise: texturePending })\n\n      return texturePending\n    }\n\n    dispose() {\n      this.workerPool.dispose()\n      if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL)\n\n      _activeLoaders--\n\n      return this\n    }\n  }\n\n  return KTX2Loader\n})()\n\n//\n// Parsing for non-Basis textures. These textures are may have supercompression\n// like Zstd, but they do not require transcoding.\n\nconst UNCOMPRESSED_FORMATS = new Set([RGBAFormat, RGFormat, RedFormat])\n\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format,\n}\n\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType,\n}\n\nasync function createRawTexture(container) {\n  const { vkFormat } = container\n\n  if (FORMAT_MAP[vkFormat] === undefined) {\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.')\n  }\n\n  //\n\n  let zstd\n\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async (resolve) => {\n        const zstd = new ZSTDDecoder()\n        await zstd.init()\n        resolve(zstd)\n      })\n    }\n\n    zstd = await _zstd\n  }\n\n  //\n\n  const mipmaps = []\n\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex)\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex)\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0\n\n    const level = container.levels[levelIndex]\n\n    let levelData\n\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength)\n    } else {\n      throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.')\n    }\n\n    let data\n\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT,\n      )\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT,\n      )\n    } else {\n      data = levelData\n    }\n\n    mipmaps.push({\n      data: data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth,\n    })\n  }\n\n  let texture\n\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture =\n      container.pixelDepth === 0\n        ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight)\n        : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth)\n  } else {\n    if (container.pixelDepth > 0) throw new Error('THREE.KTX2Loader: Unsupported pixelDepth.')\n\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight)\n  }\n\n  texture.mipmaps = mipmaps\n\n  texture.type = TYPE_MAP[vkFormat]\n  texture.format = FORMAT_MAP[vkFormat]\n  texture.needsUpdate = true\n\n  const colorSpace = parseColorSpace(container)\n  if ('colorSpace' in texture) texture.colorSpace = colorSpace\n  else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n  //\n\n  return Promise.resolve(texture)\n}\n\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0]\n\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`)\n    return NoColorSpace\n  }\n}\n\nexport { KTX2Loader }\n"],"names":["jsContent","binaryContent","KTX2Loader","zstd"],"mappings":"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"}},
    {"offset": {"line": 14027, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/LottieLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/LottieLoader.js"],"sourcesContent":["import { FileLoader, Loader, CanvasTexture, NearestFilter } from 'three'\nimport lottie from '../libs/lottie'\n\nclass LottieLoader extends Loader {\n  setQuality(value) {\n    this._quality = value\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const quality = this._quality || 1\n\n    const texture = new CanvasTexture()\n    texture.minFilter = NearestFilter\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (text) {\n        const data = JSON.parse(text)\n\n        // bodymoving uses container.offetWidth and offsetHeight\n        // to define width/height\n\n        const container = document.createElement('div')\n        container.style.width = data.w + 'px'\n        container.style.height = data.h + 'px'\n        document.body.appendChild(container)\n\n        const animation = lottie.loadAnimation({\n          container: container,\n          animType: 'canvas',\n          loop: true,\n          autoplay: true,\n          animationData: data,\n          rendererSettings: { dpr: quality },\n        })\n\n        texture.animation = animation\n        texture.image = animation.container\n\n        animation.addEventListener('enterFrame', function () {\n          texture.needsUpdate = true\n        })\n\n        container.style.display = 'none'\n\n        if (onLoad !== undefined) {\n          onLoad(texture)\n        }\n      },\n      onProgress,\n      onError,\n    )\n\n    return texture\n  }\n}\n\nexport { LottieLoader }\n"],"names":[],"mappings":";;;;;;;;AAGA,MAAM,qBAAqB,yJAAA,CAAO;IAChC,WAAW,KAAA,EAAO;QAChB,IAAA,CAAK,QAAA,GAAW;IACjB;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,UAAU,IAAA,CAAK,QAAA,IAAY;QAEjC,MAAM,UAAU,IAAI,gKAAA,CAAe;QACnC,QAAQ,SAAA,GAAY,gKAAA;QAEpB,MAAM,SAAS,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;QAC1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe;QAE9C,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;YACd,MAAM,OAAO,KAAK,KAAA,CAAM,IAAI;YAK5B,MAAM,YAAY,SAAS,aAAA,CAAc,KAAK;YAC9C,UAAU,KAAA,CAAM,KAAA,GAAQ,KAAK,CAAA,GAAI;YACjC,UAAU,KAAA,CAAM,MAAA,GAAS,KAAK,CAAA,GAAI;YAClC,SAAS,IAAA,CAAK,WAAA,CAAY,SAAS;YAEnC,MAAM,YAAY,4JAAA,CAAO,aAAA,CAAc;gBACrC;gBACA,UAAU;gBACV,MAAM;gBACN,UAAU;gBACV,eAAe;gBACf,kBAAkB;oBAAE,KAAK;gBAAS;YAC5C,CAAS;YAED,QAAQ,SAAA,GAAY;YACpB,QAAQ,KAAA,GAAQ,UAAU,SAAA;YAE1B,UAAU,gBAAA,CAAiB,cAAc,WAAY;gBACnD,QAAQ,WAAA,GAAc;YAChC,CAAS;YAED,UAAU,KAAA,CAAM,OAAA,GAAU;YAE1B,IAAI,WAAW,KAAA,GAAW;gBACxB,OAAO,OAAO;YACf;QACF,GACD,YACA;QAGF,OAAO;IACR;AACH"}},
    {"offset": {"line": 14081, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/TTFLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/TTFLoader.js"],"sourcesContent":["import { FileLoader, Loader } from 'three'\nimport { parse } from '../libs/opentype.js'\n\n/**\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\n\nclass TTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.reversed = false\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(arraybuffer) {\n    function convert(font, reversed) {\n      const round = Math.round\n\n      const glyphs = {}\n      const scale = 100000 / ((font.unitsPerEm || 2048) * 72)\n\n      const glyphIndexMap = font.encoding.cmap.glyphIndexMap\n      const unicodes = Object.keys(glyphIndexMap)\n\n      for (let i = 0; i < unicodes.length; i++) {\n        const unicode = unicodes[i]\n        const glyph = font.glyphs.glyphs[glyphIndexMap[unicode]]\n\n        if (unicode !== undefined) {\n          const token = {\n            ha: round(glyph.advanceWidth * scale),\n            x_min: round(glyph.xMin * scale),\n            x_max: round(glyph.xMax * scale),\n            o: '',\n          }\n\n          if (reversed) {\n            glyph.path.commands = reverseCommands(glyph.path.commands)\n          }\n\n          glyph.path.commands.forEach(function (command) {\n            if (command.type.toLowerCase() === 'c') {\n              command.type = 'b'\n            }\n\n            token.o += command.type.toLowerCase() + ' '\n\n            if (command.x !== undefined && command.y !== undefined) {\n              token.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' '\n            }\n\n            if (command.x1 !== undefined && command.y1 !== undefined) {\n              token.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' '\n            }\n\n            if (command.x2 !== undefined && command.y2 !== undefined) {\n              token.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' '\n            }\n          })\n\n          glyphs[String.fromCodePoint(glyph.unicode)] = token\n        }\n      }\n\n      return {\n        glyphs: glyphs,\n        familyName: font.getEnglishName('fullName'),\n        ascender: round(font.ascender * scale),\n        descender: round(font.descender * scale),\n        underlinePosition: font.tables.post.underlinePosition,\n        underlineThickness: font.tables.post.underlineThickness,\n        boundingBox: {\n          xMin: font.tables.head.xMin,\n          xMax: font.tables.head.xMax,\n          yMin: font.tables.head.yMin,\n          yMax: font.tables.head.yMax,\n        },\n        resolution: 1000,\n        original_font_information: font.tables.name,\n      }\n    }\n\n    function reverseCommands(commands) {\n      const paths = []\n      let path\n\n      commands.forEach(function (c) {\n        if (c.type.toLowerCase() === 'm') {\n          path = [c]\n          paths.push(path)\n        } else if (c.type.toLowerCase() !== 'z') {\n          path.push(c)\n        }\n      })\n\n      const reversed = []\n\n      paths.forEach(function (p) {\n        const result = {\n          type: 'm',\n          x: p[p.length - 1].x,\n          y: p[p.length - 1].y,\n        }\n\n        reversed.push(result)\n\n        for (let i = p.length - 1; i > 0; i--) {\n          const command = p[i]\n          const result = { type: command.type }\n\n          if (command.x2 !== undefined && command.y2 !== undefined) {\n            result.x1 = command.x2\n            result.y1 = command.y2\n            result.x2 = command.x1\n            result.y2 = command.y1\n          } else if (command.x1 !== undefined && command.y1 !== undefined) {\n            result.x1 = command.x1\n            result.y1 = command.y1\n          }\n\n          result.x = p[i - 1].x\n          result.y = p[i - 1].y\n          reversed.push(result)\n        }\n      })\n\n      return reversed\n    }\n\n    return convert(parse(arraybuffer), this.reversed)\n  }\n}\n\nexport { TTFLoader }\n"],"names":["parse","result"],"mappings":";;;;;;;;AASA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QAEb,IAAA,CAAK,QAAA,GAAW;IACjB;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,MAAM,SAAS,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;QAC1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,eAAA,CAAgB,aAAa;QACpC,OAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa;QAC1C,OAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe;QAC9C,OAAO,IAAA,CACL,KACA,SAAU,MAAA,EAAQ;YAChB,IAAI;gBACF,WAAOA,4JAAAA,EAAM,MAAM,CAAC;YACrB,EAAA,OAAQ,GAAP;gBACA,IAAI,SAAS;oBACX,QAAQ,CAAC;gBACrB,OAAiB;oBACL,QAAQ,KAAA,CAAM,CAAC;gBAChB;gBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC5B;QACF,GACD,YACA;IAEH;IAED,MAAM,WAAA,EAAa;QACjB,SAAS,QAAQ,IAAA,EAAM,QAAA,EAAU;YAC/B,MAAM,QAAQ,KAAK,KAAA;YAEnB,MAAM,SAAS,CAAE;YACjB,MAAM,QAAQ,MAAA,CAAA,CAAW,KAAK,UAAA,IAAc,IAAA,IAAQ,EAAA;YAEpD,MAAM,gBAAgB,KAAK,QAAA,CAAS,IAAA,CAAK,aAAA;YACzC,MAAM,WAAW,OAAO,IAAA,CAAK,aAAa;YAE1C,IAAA,IAAS,IAAI,GAAG,IAAI,SAAS,MAAA,EAAQ,IAAK;gBACxC,MAAM,UAAU,QAAA,CAAS,CAAC,CAAA;gBAC1B,MAAM,QAAQ,KAAK,MAAA,CAAO,MAAA,CAAO,aAAA,CAAc,OAAO,CAAC,CAAA;gBAEvD,IAAI,YAAY,KAAA,GAAW;oBACzB,MAAM,QAAQ;wBACZ,IAAI,MAAM,MAAM,YAAA,GAAe,KAAK;wBACpC,OAAO,MAAM,MAAM,IAAA,GAAO,KAAK;wBAC/B,OAAO,MAAM,MAAM,IAAA,GAAO,KAAK;wBAC/B,GAAG;oBACJ;oBAED,IAAI,UAAU;wBACZ,MAAM,IAAA,CAAK,QAAA,GAAW,gBAAgB,MAAM,IAAA,CAAK,QAAQ;oBAC1D;oBAED,MAAM,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,SAAU,OAAA,EAAS;wBAC7C,IAAI,QAAQ,IAAA,CAAK,WAAA,CAAW,MAAO,KAAK;4BACtC,QAAQ,IAAA,GAAO;wBAChB;wBAED,MAAM,CAAA,IAAK,QAAQ,IAAA,CAAK,WAAA,CAAa,IAAG;wBAExC,IAAI,QAAQ,CAAA,KAAM,KAAA,KAAa,QAAQ,CAAA,KAAM,KAAA,GAAW;4BACtD,MAAM,CAAA,IAAK,MAAM,QAAQ,CAAA,GAAI,KAAK,IAAI,MAAM,MAAM,QAAQ,CAAA,GAAI,KAAK,IAAI;wBACxE;wBAED,IAAI,QAAQ,EAAA,KAAO,KAAA,KAAa,QAAQ,EAAA,KAAO,KAAA,GAAW;4BACxD,MAAM,CAAA,IAAK,MAAM,QAAQ,EAAA,GAAK,KAAK,IAAI,MAAM,MAAM,QAAQ,EAAA,GAAK,KAAK,IAAI;wBAC1E;wBAED,IAAI,QAAQ,EAAA,KAAO,KAAA,KAAa,QAAQ,EAAA,KAAO,KAAA,GAAW;4BACxD,MAAM,CAAA,IAAK,MAAM,QAAQ,EAAA,GAAK,KAAK,IAAI,MAAM,MAAM,QAAQ,EAAA,GAAK,KAAK,IAAI;wBAC1E;oBACb,CAAW;oBAED,MAAA,CAAO,OAAO,aAAA,CAAc,MAAM,OAAO,CAAC,CAAA,GAAI;gBAC/C;YACF;YAED,OAAO;gBACL;gBACA,YAAY,KAAK,cAAA,CAAe,UAAU;gBAC1C,UAAU,MAAM,KAAK,QAAA,GAAW,KAAK;gBACrC,WAAW,MAAM,KAAK,SAAA,GAAY,KAAK;gBACvC,mBAAmB,KAAK,MAAA,CAAO,IAAA,CAAK,iBAAA;gBACpC,oBAAoB,KAAK,MAAA,CAAO,IAAA,CAAK,kBAAA;gBACrC,aAAa;oBACX,MAAM,KAAK,MAAA,CAAO,IAAA,CAAK,IAAA;oBACvB,MAAM,KAAK,MAAA,CAAO,IAAA,CAAK,IAAA;oBACvB,MAAM,KAAK,MAAA,CAAO,IAAA,CAAK,IAAA;oBACvB,MAAM,KAAK,MAAA,CAAO,IAAA,CAAK,IAAA;gBACxB;gBACD,YAAY;gBACZ,2BAA2B,KAAK,MAAA,CAAO,IAAA;YACxC;QACF;QAED,SAAS,gBAAgB,QAAA,EAAU;YACjC,MAAM,QAAQ,CAAE,CAAA;YAChB,IAAI;YAEJ,SAAS,OAAA,CAAQ,SAAU,CAAA,EAAG;gBAC5B,IAAI,EAAE,IAAA,CAAK,WAAA,CAAW,MAAO,KAAK;oBAChC,OAAO;wBAAC,CAAC;qBAAA;oBACT,MAAM,IAAA,CAAK,IAAI;gBAChB,OAAA,IAAU,EAAE,IAAA,CAAK,WAAA,CAAW,MAAO,KAAK;oBACvC,KAAK,IAAA,CAAK,CAAC;gBACZ;YACT,CAAO;YAED,MAAM,WAAW,CAAE,CAAA;YAEnB,MAAM,OAAA,CAAQ,SAAU,CAAA,EAAG;gBACzB,MAAM,SAAS;oBACb,MAAM;oBACN,GAAG,CAAA,CAAE,EAAE,MAAA,GAAS,CAAC,CAAA,CAAE,CAAA;oBACnB,GAAG,CAAA,CAAE,EAAE,MAAA,GAAS,CAAC,CAAA,CAAE,CAAA;gBACpB;gBAED,SAAS,IAAA,CAAK,MAAM;gBAEpB,IAAA,IAAS,IAAI,EAAE,MAAA,GAAS,GAAG,IAAI,GAAG,IAAK;oBACrC,MAAM,UAAU,CAAA,CAAE,CAAC,CAAA;oBACnB,MAAMC,UAAS;wBAAE,MAAM,QAAQ,IAAA;oBAAM;oBAErC,IAAI,QAAQ,EAAA,KAAO,KAAA,KAAa,QAAQ,EAAA,KAAO,KAAA,GAAW;wBACxDA,QAAO,EAAA,GAAK,QAAQ,EAAA;wBACpBA,QAAO,EAAA,GAAK,QAAQ,EAAA;wBACpBA,QAAO,EAAA,GAAK,QAAQ,EAAA;wBACpBA,QAAO,EAAA,GAAK,QAAQ,EAAA;oBAChC,OAAA,IAAqB,QAAQ,EAAA,KAAO,KAAA,KAAa,QAAQ,EAAA,KAAO,KAAA,GAAW;wBAC/DA,QAAO,EAAA,GAAK,QAAQ,EAAA;wBACpBA,QAAO,EAAA,GAAK,QAAQ,EAAA;oBACrB;oBAEDA,QAAO,CAAA,GAAI,CAAA,CAAE,IAAI,CAAC,CAAA,CAAE,CAAA;oBACpBA,QAAO,CAAA,GAAI,CAAA,CAAE,IAAI,CAAC,CAAA,CAAE,CAAA;oBACpB,SAAS,IAAA,CAAKA,OAAM;gBACrB;YACT,CAAO;YAED,OAAO;QACR;QAED,OAAO,YAAQD,4JAAAA,EAAM,WAAW,GAAG,IAAA,CAAK,QAAQ;IACjD;AACH"}},
    {"offset": {"line": 14220, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/RGBELoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/RGBELoader.js"],"sourcesContent":["import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter } from 'three'\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            throw new Error('THREE.RGBELoader: Read Error: ' + (msg || ''))\n          case rgbe_write_error:\n            throw new Error('THREE.RGBELoader: Write Error: ' + (msg || ''))\n          case rgbe_format_error:\n            throw new Error('THREE.RGBELoader: Bad File Format: ' + (msg || ''))\n          default:\n          case rgbe_memory_error:\n            throw new Error('THREE.RGBELoader: Memory Error: ' + (msg || ''))\n        }\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128\n\n        lineLimit = !lineLimit ? 1024 : lineLimit\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk\n          len += chunk.length\n          p += chunkSize\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1\n          return s + chunk.slice(0, i)\n        }\n\n        return false\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype: 'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          }\n\n        let line, match\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          rgbe_error(rgbe_read_error, 'no header found')\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          rgbe_error(rgbe_format_error, 'bad initial token')\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE\n        header.programtype = match[1]\n        header.string += line + '\\n'\n\n        while (true) {\n          line = fgets(buffer)\n          if (false === line) break\n          header.string += line + '\\n'\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n'\n            continue // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1])\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1])\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT\n            header.format = match[1] //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS\n            header.height = parseInt(match[1], 10)\n            header.width = parseInt(match[2], 10)\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          rgbe_error(rgbe_format_error, 'missing format specifier')\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          rgbe_error(rgbe_format_error, 'missing image size specifier')\n        }\n\n        return header\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer)\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          rgbe_error(rgbe_format_error, 'wrong scanline width')\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h)\n\n        if (!data_rgba.length) {\n          rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')\n        }\n\n        let offset = 0,\n          pos = 0\n\n        const ptr_end = 4 * scanline_width\n        const rgbeStart = new Uint8Array(4)\n        const scanline_buffer = new Uint8Array(ptr_end)\n        let num_scanlines = h\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            rgbe_error(rgbe_read_error)\n          }\n\n          rgbeStart[0] = buffer[pos++]\n          rgbeStart[1] = buffer[pos++]\n          rgbeStart[2] = buffer[pos++]\n          rgbeStart[3] = buffer[pos++]\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width) {\n            rgbe_error(rgbe_format_error, 'bad rgbe scanline format')\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++]\n            const isEncodedRun = count > 128\n            if (isEncodedRun) count -= 128\n\n            if (0 === count || ptr + count > ptr_end) {\n              rgbe_error(rgbe_format_error, 'bad scanline data')\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++]\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)\n              ptr += count\n              pos += count\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0\n            data_rgba[offset] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off]\n            offset += 4\n          }\n\n          num_scanlines--\n        }\n\n        return data_rgba\n      }\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale\n      destArray[destOffset + 3] = 1\n    }\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504))\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504))\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504))\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1)\n    }\n\n    const byteArray = new Uint8Array(buffer)\n    byteArray.pos = 0\n    const rgbe_header_info = RGBE_ReadHeader(byteArray)\n\n    const w = rgbe_header_info.width,\n      h = rgbe_header_info.height,\n      image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)\n\n    let data, type\n    let numElements\n\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4\n        const floatArray = new Float32Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4)\n        }\n\n        data = floatArray\n        type = FloatType\n        break\n\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4\n        const halfArray = new Uint16Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4)\n        }\n\n        data = halfArray\n        type = HalfFloatType\n        break\n\n      default:\n        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)\n        break\n    }\n\n    return {\n      width: w,\n      height: h,\n      data: data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type: type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n          else texture.encoding = 3000 // LinearEncoding\n          texture.minFilter = LinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.flipY = true\n\n          break\n      }\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { RGBELoader }\n"],"names":["buffer","w","h"],"mappings":";;;;;;AAKA,MAAM,mBAAmB,oKAAA,CAAkB;IACzC,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QAEb,IAAA,CAAK,IAAA,GAAO,gKAAA;IACb;IAAA,8DAAA;IAID,MAAM,MAAA,EAAQ;QACZ,MACE,kBAAkB,GAClB,mBAAmB,GACnB,oBAAoB,GACpB,oBAAoB,GACpB,aAAa,SAAU,eAAA,EAAiB,GAAA,EAAK;YAC3C,OAAQ,iBAAe;gBACrB,KAAK;oBACH,MAAM,IAAI,MAAM,mCAAA,CAAoC,OAAO,EAAA,CAAG;gBAChE,KAAK;oBACH,MAAM,IAAI,MAAM,oCAAA,CAAqC,OAAO,EAAA,CAAG;gBACjE,KAAK;oBACH,MAAM,IAAI,MAAM,wCAAA,CAAyC,OAAO,EAAA,CAAG;gBACrE;gBACA,KAAK;oBACH,MAAM,IAAI,MAAM,qCAAA,CAAsC,OAAO,EAAA,CAAG;YACnE;QACF,GAUD,yBAAyB,GACzB,oBAAoB,GACpB,wBAAwB,GACxB,UAAU,MACV,QAAQ,SAAUA,OAAAA,EAAQ,SAAA,EAAW,OAAA,EAAS;YAC5C,MAAM,YAAY;YAElB,YAAY,CAAC,YAAY,OAAO;YAChC,IAAI,IAAIA,QAAO,GAAA,EACb,IAAI,CAAA,GACJ,MAAM,GACN,IAAI,IACJ,QAAQ,OAAO,YAAA,CAAa,KAAA,CAAM,MAAM,IAAI,YAAYA,QAAO,QAAA,CAAS,GAAG,IAAI,SAAS,CAAC,CAAC;YAE5F,MAAO,IAAA,CAAK,IAAI,MAAM,OAAA,CAAQ,OAAO,CAAA,KAAM,MAAM,aAAa,IAAIA,QAAO,UAAA,CAAY;gBACnF,KAAK;gBACL,OAAO,MAAM,MAAA;gBACb,KAAK;gBACL,SAAS,OAAO,YAAA,CAAa,KAAA,CAAM,MAAM,IAAI,YAAYA,QAAO,QAAA,CAAS,GAAG,IAAI,SAAS,CAAC,CAAC;YAC5F;YAED,IAAI,CAAA,IAAK,GAAG;gBAOV,IAAI,UAAU,SAASA,QAAO,GAAA,IAAO,MAAM,IAAI;gBAC/C,OAAO,IAAI,MAAM,KAAA,CAAM,GAAG,CAAC;YAC5B;YAED,OAAO;QACR,GAED,kBAAkB,SAAUA,OAAAA,EAAQ;YAElC,MAAM,iBAAiB,aACrB,WAAW,qCACX,cAAc,wCACd,YAAY,wBACZ,gBAAgB,qCAEhB,SAAS;gBACP,OAAO;gBAEP,QAAQ;gBAER,UAAU;gBAEV,aAAa;gBAEb,QAAQ;gBAER,OAAO;gBAEP,UAAU;gBAEV,OAAO;gBACP,QAAQ;YACT;YAEH,IAAI,MAAM;YAEV,IAAIA,QAAO,GAAA,IAAOA,QAAO,UAAA,IAAc,CAAA,CAAE,OAAO,MAAMA,OAAM,CAAA,GAAI;gBAC9D,WAAW,iBAAiB,iBAAiB;YAC9C;YAGD,IAAI,CAAA,CAAE,QAAQ,KAAK,KAAA,CAAM,cAAc,CAAA,GAAI;gBACzC,WAAW,mBAAmB,mBAAmB;YAClD;YAED,OAAO,KAAA,IAAS;YAChB,OAAO,WAAA,GAAc,KAAA,CAAM,CAAC,CAAA;YAC5B,OAAO,MAAA,IAAU,OAAO;YAExB,MAAO,KAAM;gBACX,OAAO,MAAMA,OAAM;gBACnB,IAAI,UAAU,MAAM;gBACpB,OAAO,MAAA,IAAU,OAAO;gBAExB,IAAI,QAAQ,KAAK,MAAA,CAAO,CAAC,GAAG;oBAC1B,OAAO,QAAA,IAAY,OAAO;oBAC1B;gBACD;gBAED,IAAK,QAAQ,KAAK,KAAA,CAAM,QAAQ,GAAI;oBAClC,OAAO,KAAA,GAAQ,WAAW,KAAA,CAAM,CAAC,CAAC;gBACnC;gBAED,IAAK,QAAQ,KAAK,KAAA,CAAM,WAAW,GAAI;oBACrC,OAAO,QAAA,GAAW,WAAW,KAAA,CAAM,CAAC,CAAC;gBACtC;gBAED,IAAK,QAAQ,KAAK,KAAA,CAAM,SAAS,GAAI;oBACnC,OAAO,KAAA,IAAS;oBAChB,OAAO,MAAA,GAAS,KAAA,CAAM,CAAC,CAAA;gBACxB;gBAED,IAAK,QAAQ,KAAK,KAAA,CAAM,aAAa,GAAI;oBACvC,OAAO,KAAA,IAAS;oBAChB,OAAO,MAAA,GAAS,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,EAAE;oBACrC,OAAO,KAAA,GAAQ,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,EAAE;gBACrC;gBAED,IAAI,OAAO,KAAA,GAAQ,qBAAqB,OAAO,KAAA,GAAQ,uBAAuB;YAC/E;YAED,IAAI,CAAA,CAAE,OAAO,KAAA,GAAQ,iBAAA,GAAoB;gBACvC,WAAW,mBAAmB,0BAA0B;YACzD;YAED,IAAI,CAAA,CAAE,OAAO,KAAA,GAAQ,qBAAA,GAAwB;gBAC3C,WAAW,mBAAmB,8BAA8B;YAC7D;YAED,OAAO;QACR,GACD,sBAAsB,SAAUA,OAAAA,EAAQC,EAAAA,EAAGC,EAAAA,EAAG;YAC5C,MAAM,iBAAiBD;YAEvB,IAAA,kDAAA;YAEE,iBAAiB,KACjB,iBAAiB,SAAA,sCAAA;YAEjB,MAAMD,OAAAA,CAAO,CAAC,CAAA,IACd,MAAMA,OAAAA,CAAO,CAAC,CAAA,IACdA,OAAAA,CAAO,CAAC,CAAA,GAAI,KACZ;gBAEA,OAAO,IAAI,WAAWA,OAAM;YAC7B;YAED,IAAI,mBAAA,CAAqBA,OAAAA,CAAO,CAAC,CAAA,IAAK,IAAKA,OAAAA,CAAO,CAAC,CAAA,GAAI;gBACrD,WAAW,mBAAmB,sBAAsB;YACrD;YAED,MAAM,YAAY,IAAI,WAAW,IAAIC,KAAIC,EAAC;YAE1C,IAAI,CAAC,UAAU,MAAA,EAAQ;gBACrB,WAAW,mBAAmB,iCAAiC;YAChE;YAED,IAAI,SAAS,GACX,MAAM;YAER,MAAM,UAAU,IAAI;YACpB,MAAM,YAAY,IAAI,WAAW,CAAC;YAClC,MAAM,kBAAkB,IAAI,WAAW,OAAO;YAC9C,IAAI,gBAAgBA;YAGpB,MAAO,gBAAgB,KAAK,MAAMF,QAAO,UAAA,CAAY;gBACnD,IAAI,MAAM,IAAIA,QAAO,UAAA,EAAY;oBAC/B,WAAW,eAAe;gBAC3B;gBAED,SAAA,CAAU,CAAC,CAAA,GAAIA,OAAAA,CAAO,KAAK,CAAA;gBAC3B,SAAA,CAAU,CAAC,CAAA,GAAIA,OAAAA,CAAO,KAAK,CAAA;gBAC3B,SAAA,CAAU,CAAC,CAAA,GAAIA,OAAAA,CAAO,KAAK,CAAA;gBAC3B,SAAA,CAAU,CAAC,CAAA,GAAIA,OAAAA,CAAO,KAAK,CAAA;gBAE3B,IAAI,KAAK,SAAA,CAAU,CAAC,CAAA,IAAK,KAAK,SAAA,CAAU,CAAC,CAAA,IAAA,CAAO,SAAA,CAAU,CAAC,CAAA,IAAK,IAAK,SAAA,CAAU,CAAC,CAAA,KAAM,gBAAgB;oBACpG,WAAW,mBAAmB,0BAA0B;gBACzD;gBAID,IAAI,MAAM,GACR;gBAEF,MAAO,MAAM,WAAW,MAAMA,QAAO,UAAA,CAAY;oBAC/C,QAAQA,OAAAA,CAAO,KAAK,CAAA;oBACpB,MAAM,eAAe,QAAQ;oBAC7B,IAAI,cAAc,SAAS;oBAE3B,IAAI,MAAM,SAAS,MAAM,QAAQ,SAAS;wBACxC,WAAW,mBAAmB,mBAAmB;oBAClD;oBAED,IAAI,cAAc;wBAEhB,MAAM,YAAYA,OAAAA,CAAO,KAAK,CAAA;wBAC9B,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,IAAK;4BAC9B,eAAA,CAAgB,KAAK,CAAA,GAAI;wBAC1B;oBAEf,OAAmB;wBAEL,gBAAgB,GAAA,CAAIA,QAAO,QAAA,CAAS,KAAK,MAAM,KAAK,GAAG,GAAG;wBAC1D,OAAO;wBACP,OAAO;oBACR;gBACF;gBAID,MAAM,IAAI;gBACV,IAAA,IAAS,IAAI,GAAG,IAAI,GAAG,IAAK;oBAC1B,IAAI,MAAM;oBACV,SAAA,CAAU,MAAM,CAAA,GAAI,eAAA,CAAgB,IAAI,GAAG,CAAA;oBAC3C,OAAO;oBACP,SAAA,CAAU,SAAS,CAAC,CAAA,GAAI,eAAA,CAAgB,IAAI,GAAG,CAAA;oBAC/C,OAAO;oBACP,SAAA,CAAU,SAAS,CAAC,CAAA,GAAI,eAAA,CAAgB,IAAI,GAAG,CAAA;oBAC/C,OAAO;oBACP,SAAA,CAAU,SAAS,CAAC,CAAA,GAAI,eAAA,CAAgB,IAAI,GAAG,CAAA;oBAC/C,UAAU;gBACX;gBAED;YACD;YAED,OAAO;QACR;QAEH,MAAM,qBAAqB,SAAU,WAAA,EAAa,YAAA,EAAc,SAAA,EAAW,UAAA,EAAY;YACrF,MAAM,IAAI,WAAA,CAAY,eAAe,CAAC,CAAA;YACtC,MAAM,QAAQ,KAAK,GAAA,CAAI,GAAK,IAAI,GAAK,IAAI;YAEzC,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,WAAA,CAAY,eAAe,CAAC,CAAA,GAAI;YAC5D,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,WAAA,CAAY,eAAe,CAAC,CAAA,GAAI;YAC5D,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,WAAA,CAAY,eAAe,CAAC,CAAA,GAAI;YAC5D,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI;QAC7B;QAED,MAAM,oBAAoB,SAAU,WAAA,EAAa,YAAA,EAAc,SAAA,EAAW,UAAA,EAAY;YACpF,MAAM,IAAI,WAAA,CAAY,eAAe,CAAC,CAAA;YACtC,MAAM,QAAQ,KAAK,GAAA,CAAI,GAAK,IAAI,GAAK,IAAI;YAGzC,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,4JAAA,CAAU,WAAA,CAAY,KAAK,GAAA,CAAI,WAAA,CAAY,eAAe,CAAC,CAAA,GAAI,OAAO,KAAK,CAAC;YACxG,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,4JAAA,CAAU,WAAA,CAAY,KAAK,GAAA,CAAI,WAAA,CAAY,eAAe,CAAC,CAAA,GAAI,OAAO,KAAK,CAAC;YACxG,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,4JAAA,CAAU,WAAA,CAAY,KAAK,GAAA,CAAI,WAAA,CAAY,eAAe,CAAC,CAAA,GAAI,OAAO,KAAK,CAAC;YACxG,SAAA,CAAU,aAAa,CAAC,CAAA,GAAI,4JAAA,CAAU,WAAA,CAAY,CAAC;QACpD;QAED,MAAM,YAAY,IAAI,WAAW,MAAM;QACvC,UAAU,GAAA,GAAM;QAChB,MAAM,mBAAmB,gBAAgB,SAAS;QAElD,MAAM,IAAI,iBAAiB,KAAA,EACzB,IAAI,iBAAiB,MAAA,EACrB,kBAAkB,oBAAoB,UAAU,QAAA,CAAS,UAAU,GAAG,GAAG,GAAG,CAAC;QAE/E,IAAI,MAAM;QACV,IAAI;QAEJ,OAAQ,IAAA,CAAK,IAAA,EAAI;YACf,KAAK,4JAAA;gBACH,cAAc,gBAAgB,MAAA,GAAS;gBACvC,MAAM,aAAa,IAAI,aAAa,cAAc,CAAC;gBAEnD,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,IAAK;oBACpC,mBAAmB,iBAAiB,IAAI,GAAG,YAAY,IAAI,CAAC;gBAC7D;gBAED,OAAO;gBACP,OAAO,4JAAA;gBACP;YAEF,KAAK,gKAAA;gBACH,cAAc,gBAAgB,MAAA,GAAS;gBACvC,MAAM,YAAY,IAAI,YAAY,cAAc,CAAC;gBAEjD,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,IAAK;oBACpC,kBAAkB,iBAAiB,IAAI,GAAG,WAAW,IAAI,CAAC;gBAC3D;gBAED,OAAO;gBACP,OAAO,gKAAA;gBACP;YAEF;gBACE,MAAM,IAAI,MAAM,yCAAyC,IAAA,CAAK,IAAI;QAErE;QAED,OAAO;YACL,OAAO;YACP,QAAQ;YACR;YACA,QAAQ,iBAAiB,MAAA;YACzB,OAAO,iBAAiB,KAAA;YACxB,UAAU,iBAAiB,QAAA;YAC3B;QACD;IACF;IAED,YAAY,KAAA,EAAO;QACjB,IAAA,CAAK,IAAA,GAAO;QACZ,OAAO,IAAA;IACR;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,SAAS,eAAe,OAAA,EAAS,OAAA,EAAS;YACxC,OAAQ,QAAQ,IAAA,EAAI;gBAClB,KAAK,4JAAA;gBACL,KAAK,gKAAA;oBACH,IAAI,gBAAgB,SAAS,QAAQ,UAAA,GAAa;yBAC7C,QAAQ,QAAA,GAAW;oBACxB,QAAQ,SAAA,GAAY,+JAAA;oBACpB,QAAQ,SAAA,GAAY,+JAAA;oBACpB,QAAQ,eAAA,GAAkB;oBAC1B,QAAQ,KAAA,GAAQ;oBAEhB;YACH;YAED,IAAI,QAAQ,OAAO,SAAS,OAAO;QACpC;QAED,OAAO,KAAA,CAAM,KAAK,KAAK,gBAAgB,YAAY,OAAO;IAC3D;AACH"}},
    {"offset": {"line": 14461, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/AssimpLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/AssimpLoader.js"],"sourcesContent":["import {\n  Bone,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Quaternion,\n  Skeleton,\n  SkinnedMesh,\n  TextureLoader,\n  Vector3,\n} from 'three'\n\nclass AssimpLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    var scope = this\n\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    var loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    var Virtulous = {}\n\n    Virtulous.KeyFrame = class {\n      constructor(time, matrix) {\n        this.time = time\n        this.matrix = matrix.clone()\n        this.position = new Vector3()\n        this.quaternion = new Quaternion()\n        this.scale = new Vector3(1, 1, 1)\n        this.matrix.decompose(this.position, this.quaternion, this.scale)\n        this.clone = function () {\n          var n = new Virtulous.KeyFrame(this.time, this.matrix)\n          return n\n        }\n\n        this.lerp = function (nextKey, time) {\n          time -= this.time\n          var dist = nextKey.time - this.time\n          var l = time / dist\n          var l2 = 1 - l\n          var keypos = this.position\n          var keyrot = this.quaternion\n          //      var keyscl =  key.parentspaceScl || key.scl;\n          var key2pos = nextKey.position\n          var key2rot = nextKey.quaternion\n          //  var key2scl =  key2.parentspaceScl || key2.scl;\n          Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l\n          Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l\n          Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l\n          //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n          //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n          //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n          Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w)\n          Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l)\n          return Virtulous.KeyFrame.tempAniMatrix.compose(\n            Virtulous.KeyFrame.tempAniPos,\n            Virtulous.KeyFrame.tempAniQuat,\n            Virtulous.KeyFrame.tempAniScale,\n          )\n        }\n      }\n    }\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3()\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion()\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1)\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4()\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = []\n      this.target = null\n      this.time = 0\n      this.length = 0\n      this._accelTable = {}\n      this.fps = 20\n      this.addKey = function (key) {\n        this.keys.push(key)\n      }\n\n      this.init = function () {\n        this.sortKeys()\n\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time\n        else this.length = 0\n\n        if (!this.fps) return\n\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i\n              break\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i\n              break\n            }\n          }\n        }\n      }\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps\n        this.target = data.node\n        var track = data.hierarchy[0].keys\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data))\n        }\n\n        this.init()\n      }\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys\n        var fps = this.fps\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix))\n        }\n\n        this.init()\n      }\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc)\n      }\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time\n      }\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack()\n        t.target = this.target\n        t.time = this.time\n        t.length = this.length\n\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone())\n        }\n\n        t.init()\n        return t\n      }\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare\n        this.target = compareitor(root, this.target)\n      }\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps\n        time = Math.floor(time)\n        return this._accelTable[time] || 0\n      }\n\n      this.setTime = function (time) {\n        time = Math.abs(time)\n        if (this.length) time = (time % this.length) + 0.05\n        var key0 = null\n        var key1 = null\n\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i]\n            key1 = this.keys[i]\n            break\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i]\n            key1 = this.keys[i + 1]\n            break\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i]\n            key1 = this.keys[0].clone()\n            key1.time += this.length + 0.05\n            break\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false\n          this.target.matrix.copy(key0.lerp(key1, time))\n          this.target.matrixWorldNeedsUpdate = true\n          return\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false\n          this.target.matrix.copy(key0.matrix)\n          this.target.matrixWorldNeedsUpdate = true\n          return\n        }\n      }\n    }\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node\n\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name)\n          if (r) return r\n        }\n\n        return null\n      }\n\n      return find(root, target.name)\n    }\n\n    Virtulous.Animation = function () {\n      this.tracks = []\n      this.length = 0\n\n      this.addTrack = function (track) {\n        this.tracks.push(track)\n        this.length = Math.max(track.length, this.length)\n      }\n\n      this.setTime = function (time) {\n        this.time = time\n\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time)\n      }\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare\n        var n = new Virtulous.Animation()\n        n.target = target\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone()\n          track.reTarget(target, compareitor)\n          n.addTrack(track)\n        }\n\n        return n\n      }\n    }\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234\n    var ASSBIN_CHUNK_AILIGHT = 0x1235\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236\n    var ASSBIN_CHUNK_AIMESH = 0x1237\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238\n    var ASSBIN_CHUNK_AISCENE = 0x1239\n    var ASSBIN_CHUNK_AIBONE = 0x123a\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b\n    var ASSBIN_CHUNK_AINODE = 0x123c\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1\n    var ASSBIN_MESH_HAS_NORMALS = 0x2\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4\n    //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n    var aiLightSource_DIRECTIONAL = 0x1\n    //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n    var aiLightSource_SPOT = 0x3\n    //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n    var aiTextureType_DIFFUSE = 0x1\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n    var aiTextureType_NORMALS = 0x6\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n    var aiTextureType_OPACITY = 0x8\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n    var aiTextureType_LIGHTMAP = 0xa\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n    var BONESPERVERT = 4\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n\n    }\n\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i]\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName)\n          if (boneNode) boneNode.isBone = true\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone()\n      rootBone.matrix.copy(root.matrix)\n      rootBone.matrixWorld.copy(root.matrixWorld)\n      rootBone.position.copy(root.position)\n      rootBone.quaternion.copy(root.quaternion)\n      rootBone.scale.copy(root.scale)\n      scene.nodeCount++\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString()\n\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = []\n      scene.nodeToBoneMap[root.name].push(rootBone)\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene)\n        rootBone.add(child)\n      }\n\n      return rootBone\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = []\n\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i],\n        })\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w\n      })\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0,\n        })\n      }\n\n      if (pairs.length > 4) pairs.length = 4\n      var sum = 0\n\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w\n      }\n\n      sum = Math.sqrt(sum)\n\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum\n        indexes[i] = pairs[i].i\n        weights[i] = pairs[i].w\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root\n\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name)\n\n        if (ret) return ret\n      }\n\n      return undefined\n    }\n\n    class aiMesh {\n      constructor() {\n        this.mPrimitiveTypes = 0\n        this.mNumVertices = 0\n        this.mNumFaces = 0\n        this.mNumBones = 0\n        this.mMaterialIndex = 0\n        this.mVertices = []\n        this.mNormals = []\n        this.mTangents = []\n        this.mBitangents = []\n        this.mColors = [[]]\n        this.mTextureCoords = [[]]\n        this.mFaces = []\n        this.mBones = []\n        this.hookupSkeletons = function (scene) {\n          if (this.mBones.length == 0) return\n\n          var allBones = []\n          var offsetMatrix = []\n          var skeletonRoot = scene.findNode(this.mBones[0].mName)\n\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent\n          }\n\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene)\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene)\n          this.threeNode.add(threeSkeletonRootBone)\n\n          for (let i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName)\n\n            if (bone) {\n              var tbone = bone\n              allBones.push(tbone)\n              //tbone.matrixAutoUpdate = false;\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName)\n              if (!skeletonRoot) return\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene)\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene)\n              this.threeNode.add(threeSkeletonRootBone)\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName)\n              var tbone = bone\n              allBones.push(tbone)\n              //tbone.matrixAutoUpdate = false;\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())\n            }\n          }\n\n          var skeleton = new Skeleton(allBones, offsetMatrix)\n\n          this.threeNode.bind(skeleton, new Matrix4())\n          this.threeNode.material.skinning = true\n        }\n\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode\n          var geometry = new BufferGeometry()\n          var mat\n          if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene)\n          else mat = new MeshLambertMaterial()\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1))\n          geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3))\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3))\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4))\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2))\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2))\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3))\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3))\n          }\n          if (this.mBones.length > 0) {\n            var weights = []\n            var bones = []\n\n            for (let i = 0; i < this.mBones.length; i++) {\n              for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j]\n                if (weight) {\n                  if (!weights[weight.mVertexId]) weights[weight.mVertexId] = []\n                  if (!bones[weight.mVertexId]) bones[weight.mVertexId] = []\n                  weights[weight.mVertexId].push(weight.mWeight)\n                  bones[weight.mVertexId].push(parseInt(i))\n                }\n              }\n            }\n\n            for (let i in bones) {\n              sortWeights(bones[i], weights[i])\n            }\n\n            var _weights = []\n            var _bones = []\n\n            for (let i = 0; i < weights.length; i++) {\n              for (let j = 0; j < 4; j++) {\n                if (weights[i] && bones[i]) {\n                  _weights.push(weights[i][j])\n                  _bones.push(bones[i][j])\n                } else {\n                  _weights.push(0)\n                  _bones.push(0)\n                }\n              }\n            }\n\n            geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT))\n            geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT))\n          }\n\n          var mesh\n\n          if (this.mBones.length == 0) mesh = new Mesh(geometry, mat)\n\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat)\n            mesh.normalizeSkinWeights()\n          }\n\n          this.threeNode = mesh\n          //mesh.matrixAutoUpdate = false;\n          return mesh\n        }\n      }\n    }\n\n    class aiFace {\n      constructor() {\n        this.mNumIndices = 0\n        this.mIndices = []\n      }\n    }\n\n    class aiVector3D {\n      constructor() {\n        this.x = 0\n        this.y = 0\n        this.z = 0\n\n        this.toTHREE = function () {\n          return new Vector3(this.x, this.y, this.z)\n        }\n      }\n    }\n\n    class aiColor3D {\n      constructor() {\n        this.r = 0\n        this.g = 0\n        this.b = 0\n        this.a = 0\n        this.toTHREE = function () {\n          return new Color(this.r, this.g, this.b)\n        }\n      }\n    }\n\n    class aiQuaternion {\n      constructor() {\n        this.x = 0\n        this.y = 0\n        this.z = 0\n        this.w = 0\n        this.toTHREE = function () {\n          return new Quaternion(this.x, this.y, this.z, this.w)\n        }\n      }\n    }\n\n    class aiVertexWeight {\n      constructor() {\n        this.mVertexId = 0\n        this.mWeight = 0\n      }\n    }\n\n    class aiString {\n      constructor() {\n        this.data = []\n        this.toString = function () {\n          var str = ''\n          this.data.forEach(function (i) {\n            str += String.fromCharCode(i)\n          })\n          return str.replace(/[^\\x20-\\x7E]+/g, '')\n        }\n      }\n    }\n\n    class aiVectorKey {\n      constructor() {\n        this.mTime = 0\n        this.mValue = null\n      }\n    }\n\n    class aiQuatKey {\n      constructor() {\n        this.mTime = 0\n        this.mValue = null\n      }\n    }\n\n    class aiNode {\n      constructor() {\n        this.mName = ''\n        this.mTransformation = []\n        this.mNumChildren = 0\n        this.mNumMeshes = 0\n        this.mMeshes = []\n        this.mChildren = []\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode\n          var o = new Object3D()\n          o.name = this.mName\n          o.matrix = this.mTransformation.toTHREE()\n\n          for (let i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene))\n          }\n\n          for (let i = 0; i < this.mMeshes.length; i++) {\n            o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene))\n          }\n\n          this.threeNode = o\n          //o.matrixAutoUpdate = false;\n          o.matrix.decompose(o.position, o.quaternion, o.scale)\n          return o\n        }\n      }\n    }\n\n    class aiBone {\n      constructor() {\n        this.mName = ''\n        this.mNumWeights = 0\n        this.mOffsetMatrix = 0\n      }\n    }\n\n    class aiMaterialProperty {\n      constructor() {\n        this.mKey = ''\n        this.mSemantic = 0\n        this.mIndex = 0\n        this.mData = []\n        this.mDataLength = 0\n        this.mType = 0\n        this.dataAsColor = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          var g = reader.getFloat32(4, true)\n          var b = reader.getFloat32(8, true)\n          //var a = reader.getFloat32(12, true);\n          return new Color(r, g, b)\n        }\n\n        this.dataAsFloat = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          return r\n        }\n\n        this.dataAsBool = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          return !!r\n        }\n\n        this.dataAsString = function () {\n          var s = new aiString()\n          s.data = this.mData\n          return s.toString()\n        }\n\n        this.dataAsMap = function () {\n          var s = new aiString()\n          s.data = this.mData\n          var path = s.toString()\n          path = path.replace(/\\\\/g, '/')\n\n          if (path.indexOf('/') != -1) {\n            path = path.substr(path.lastIndexOf('/') + 1)\n          }\n\n          return textureLoader.load(path)\n        }\n      }\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map',\n    }\n\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map',\n    }\n\n    class aiMaterial {\n      constructor() {\n        this.mNumAllocated = 0\n        this.mNumProperties = 0\n        this.mProperties = []\n        this.toTHREE = function () {\n          var mat = new MeshPhongMaterial()\n\n          for (let i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n              var prop = this.mProperties[i]\n              if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap()\n            }\n          }\n\n          mat.ambient.r = 0.53\n          mat.ambient.g = 0.53\n          mat.ambient.b = 0.53\n          mat.color.r = 1\n          mat.color.g = 1\n          mat.color.b = 1\n          return mat\n        }\n      }\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3()\n      var lm1 = 1 - l\n      v.x = v1.x * l + v2.x * lm1\n      v.y = v1.y * l + v2.y * lm1\n      v.z = v1.z * l + v2.z * lm1\n      return v\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l)\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE()\n\n      var dist = Infinity\n      var key = null\n      var nextKey = null\n\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time)\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist\n          key = keys[i]\n          nextKey = keys[i + 1]\n        }\n      }\n\n      if (!key) {\n        return null\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime\n        var T = key.mTime - time\n        var l = T / dT\n\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l)\n      } else {\n        nextKey = keys[0].clone()\n        nextKey.mTime += lne\n\n        var dT = nextKey.mTime - key.mTime\n        var T = key.mTime - time\n        var l = T / dT\n\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l)\n      }\n    }\n\n    class aiNodeAnim {\n      constructor() {\n        this.mNodeName = ''\n        this.mNumPositionKeys = 0\n        this.mNumRotationKeys = 0\n        this.mNumScalingKeys = 0\n        this.mPositionKeys = []\n        this.mRotationKeys = []\n        this.mScalingKeys = []\n        this.mPreState = ''\n        this.mPostState = ''\n        this.init = function (tps) {\n          if (!tps) tps = 1\n\n          function t(t) {\n            t.mTime /= tps\n          }\n\n          this.mPositionKeys.forEach(t)\n          this.mRotationKeys.forEach(t)\n          this.mScalingKeys.forEach(t)\n        }\n\n        this.sortKeys = function () {\n          function comp(a, b) {\n            return a.mTime - b.mTime\n          }\n\n          this.mPositionKeys.sort(comp)\n          this.mRotationKeys.sort(comp)\n          this.mScalingKeys.sort(comp)\n        }\n\n        this.getLength = function () {\n          return Math.max(\n            Math.max.apply(\n              null,\n              this.mPositionKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n            Math.max.apply(\n              null,\n              this.mRotationKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n            Math.max.apply(\n              null,\n              this.mScalingKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n          )\n        }\n\n        this.toTHREE = function (o) {\n          this.sortKeys()\n          var length = this.getLength()\n          var track = new Virtulous.KeyFrameTrack()\n\n          for (let i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4()\n            var time = i\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp)\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp)\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp)\n            matrix.compose(pos, rotation, scale)\n\n            var key = new Virtulous.KeyFrame(time, matrix)\n            track.addKey(key)\n          }\n\n          track.target = o.findNode(this.mNodeName).toTHREE()\n\n          var tracks = [track]\n\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n              var t2 = track.clone()\n              t2.target = o.nodeToBoneMap[this.mNodeName][i]\n              tracks.push(t2)\n            }\n          }\n\n          return tracks\n        }\n      }\n    }\n\n    class aiAnimation {\n      constructor() {\n        this.mName = ''\n        this.mDuration = 0\n        this.mTicksPerSecond = 0\n        this.mNumChannels = 0\n        this.mChannels = []\n        this.toTHREE = function (root) {\n          var animationHandle = new Virtulous.Animation()\n\n          for (let i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond)\n\n            var tracks = this.mChannels[i].toTHREE(root)\n\n            for (let j in tracks) {\n              tracks[j].init()\n              animationHandle.addTrack(tracks[j])\n            }\n          }\n\n          animationHandle.length = Math.max.apply(\n            null,\n            animationHandle.tracks.map(function (e) {\n              return e.length\n            }),\n          )\n          return animationHandle\n        }\n      }\n    }\n\n    class aiTexture {\n      constructor() {\n        this.mWidth = 0\n        this.mHeight = 0\n        this.texAchFormatHint = []\n        this.pcData = []\n      }\n    }\n\n    class aiLight {\n      constructor() {\n        this.mName = ''\n        this.mType = 0\n        this.mAttenuationConstant = 0\n        this.mAttenuationLinear = 0\n        this.mAttenuationQuadratic = 0\n        this.mAngleInnerCone = 0\n        this.mAngleOuterCone = 0\n        this.mColorDiffuse = null\n        this.mColorSpecular = null\n        this.mColorAmbient = null\n      }\n    }\n\n    class aiCamera {\n      constructor() {\n        this.mName = ''\n        this.mPosition = null\n        this.mLookAt = null\n        this.mUp = null\n        this.mHorizontalFOV = 0\n        this.mClipPlaneNear = 0\n        this.mClipPlaneFar = 0\n        this.mAspect = 0\n      }\n    }\n\n    class aiScene {\n      constructor() {\n        this.versionMajor = 0\n        this.versionMinor = 0\n        this.versionRevision = 0\n        this.compileFlags = 0\n        this.mFlags = 0\n        this.mNumMeshes = 0\n        this.mNumMaterials = 0\n        this.mNumAnimations = 0\n        this.mNumTextures = 0\n        this.mNumLights = 0\n        this.mNumCameras = 0\n        this.mRootNode = null\n        this.mMeshes = []\n        this.mMaterials = []\n        this.mAnimations = []\n        this.mLights = []\n        this.mCameras = []\n        this.nodeToBoneMap = {}\n        this.findNode = function (name, root) {\n          if (!root) {\n            root = this.mRootNode\n          }\n\n          if (root.mName == name) {\n            return root\n          }\n\n          for (let i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i])\n            if (ret) return ret\n          }\n\n          return null\n        }\n\n        this.toTHREE = function () {\n          this.nodeCount = 0\n\n          markBones(this)\n\n          var o = this.mRootNode.toTHREE(this)\n\n          for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this)\n\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this)\n          }\n\n          return { object: o, animation: a }\n        }\n      }\n    }\n\n    class aiMatrix4 {\n      constructor() {\n        this.elements = [[], [], [], []]\n        this.toTHREE = function () {\n          var m = new Matrix4()\n\n          for (let i = 0; i < 4; ++i) {\n            for (let i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i]\n            }\n          }\n\n          return m\n        }\n      }\n    }\n\n    var littleEndian = true\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian)\n      dataview.readOffset += 8\n      return val\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset)\n      dataview.readOffset += 1\n      return val\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian)\n      dataview.readOffset += 2\n      return val\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D()\n      v.x = readFloat(stream)\n      v.y = readFloat(stream)\n      v.z = readFloat(stream)\n      return v\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D()\n      c.r = readFloat(stream)\n      c.g = readFloat(stream)\n      c.b = readFloat(stream)\n      return c\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion()\n      v.w = readFloat(stream)\n      v.x = readFloat(stream)\n      v.y = readFloat(stream)\n      v.z = readFloat(stream)\n      return v\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString()\n      var stringlengthbytes = Read_unsigned_int(stream)\n      stream.ReadBytes(s.data, 1, stringlengthbytes)\n      return s.toString()\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight()\n      w.mVertexId = Read_unsigned_int(stream)\n      w.mWeight = readFloat(stream)\n      return w\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4()\n\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream)\n        }\n      }\n\n      return m\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey()\n      v.mTime = Read_double(stream)\n      v.mValue = Read_aiVector3D(stream)\n      return v\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey()\n      v.mTime = Read_double(stream)\n      v.mValue = Read_aiQuaternion(stream)\n      return v\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream)\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream)\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream)\n    }\n\n    function ReadBounds(stream, T /*p*/, n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR)\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed'\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      var node = new aiNode()\n      node.mParent = parent\n      node.mDepth = depth\n      node.mName = Read_aiString(stream)\n      node.mTransformation = Read_aiMatrix4x4(stream)\n      node.mNumChildren = Read_unsigned_int(stream)\n      node.mNumMeshes = Read_unsigned_int(stream)\n\n      if (node.mNumMeshes) {\n        node.mMeshes = []\n\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream)\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = []\n\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++)\n          node.mChildren[i] = node2\n        }\n      }\n\n      return node\n    }\n\n    // -----------------------------------------------------------------------------------\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      b.mName = Read_aiString(stream)\n      b.mNumWeights = Read_unsigned_int(stream)\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream)\n      // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights)\n      } else {\n        // else write as usual\n\n        b.mWeights = []\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights)\n      }\n\n      return b\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream)\n      mesh.mNumVertices = Read_unsigned_int(stream)\n      mesh.mNumFaces = Read_unsigned_int(stream)\n      mesh.mNumBones = Read_unsigned_int(stream)\n      mesh.mMaterialIndex = Read_unsigned_int(stream)\n      mesh.mNumUVComponents = []\n      // first of all, write bits for all existent vertex components\n      var c = Read_unsigned_int(stream)\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mVertices = []\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mNormals = []\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices)\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mTangents = []\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n          mesh.mBitangents = []\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mColors[n] = []\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4)\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR)\n        }\n      }\n\n      mesh.mTexCoordsBuffers = []\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break\n\n        // write number of UV components\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream)\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mTextureCoords[n] = []\n          //note that assbin always writes 3d texcoords\n          mesh.mTexCoordsBuffers[n] = []\n\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream))\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream))\n            readFloat(stream)\n          }\n        }\n      }\n\n      // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n      if (shortened) {\n        Read_unsigned_int(stream)\n      } else {\n        // else write as usual\n\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = []\n        mesh.mIndexArray = []\n\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = (mesh.mFaces[i] = new aiFace())\n          // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n          f.mNumIndices = Read_uint16_t(stream)\n          f.mIndices = []\n\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream)\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream)\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0])\n            mesh.mIndexArray.push(f.mIndices[1])\n            mesh.mIndexArray.push(f.mIndices[2])\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0])\n            mesh.mIndexArray.push(f.mIndices[1])\n            mesh.mIndexArray.push(f.mIndices[2])\n            mesh.mIndexArray.push(f.mIndices[2])\n            mesh.mIndexArray.push(f.mIndices[3])\n            mesh.mIndexArray.push(f.mIndices[0])\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\")\n          }\n        }\n      }\n\n      // write bones\n      if (mesh.mNumBones) {\n        mesh.mBones = []\n\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone()\n          ReadBinaryBone(stream, mesh.mBones[a])\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      prop.mKey = Read_aiString(stream)\n      prop.mSemantic = Read_unsigned_int(stream)\n      prop.mIndex = Read_unsigned_int(stream)\n      prop.mDataLength = Read_unsigned_int(stream)\n      prop.mType = Read_unsigned_int(stream)\n      prop.mData = []\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength)\n    }\n\n    // -----------------------------------------------------------------------------------\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream)\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties\n        }\n\n        mat.mProperties = []\n\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty()\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i])\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      nd.mNodeName = Read_aiString(stream)\n      nd.mNumPositionKeys = Read_unsigned_int(stream)\n      nd.mNumRotationKeys = Read_unsigned_int(stream)\n      nd.mNumScalingKeys = Read_unsigned_int(stream)\n      nd.mPreState = Read_unsigned_int(stream)\n      nd.mPostState = Read_unsigned_int(stream)\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys)\n        } else {\n          // else write as usual\n\n          nd.mPositionKeys = []\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys)\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys)\n        } else {\n          // else write as usual\n\n          nd.mRotationKeys = []\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys)\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys)\n        } else {\n          // else write as usual\n\n          nd.mScalingKeys = []\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys)\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      anim.mName = Read_aiString(stream)\n      anim.mDuration = Read_double(stream)\n      anim.mTicksPerSecond = Read_double(stream)\n      anim.mNumChannels = Read_unsigned_int(stream)\n\n      if (anim.mNumChannels) {\n        anim.mChannels = []\n\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim()\n          ReadBinaryNodeAnim(stream, anim.mChannels[a])\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      tex.mWidth = Read_unsigned_int(stream)\n      tex.mHeight = Read_unsigned_int(stream)\n      stream.ReadBytes(tex.achFormatHint, 1, 4)\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = []\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth)\n        } else {\n          tex.pcData = []\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4)\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      l.mName = Read_aiString(stream)\n      l.mType = Read_unsigned_int(stream)\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream)\n        l.mAttenuationLinear = readFloat(stream)\n        l.mAttenuationQuadratic = readFloat(stream)\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream)\n      l.mColorSpecular = Read_aiColor3D(stream)\n      l.mColorAmbient = Read_aiColor3D(stream)\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream)\n        l.mAngleOuterCone = readFloat(stream)\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      cam.mName = Read_aiString(stream)\n      cam.mPosition = Read_aiVector3D(stream)\n      cam.mLookAt = Read_aiVector3D(stream)\n      cam.mUp = Read_aiVector3D(stream)\n      cam.mHorizontalFOV = readFloat(stream)\n      cam.mClipPlaneNear = readFloat(stream)\n      cam.mClipPlaneFar = readFloat(stream)\n      cam.mAspect = readFloat(stream)\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      scene.mFlags = Read_unsigned_int(stream)\n      scene.mNumMeshes = Read_unsigned_int(stream)\n      scene.mNumMaterials = Read_unsigned_int(stream)\n      scene.mNumAnimations = Read_unsigned_int(stream)\n      scene.mNumTextures = Read_unsigned_int(stream)\n      scene.mNumLights = Read_unsigned_int(stream)\n      scene.mNumCameras = Read_unsigned_int(stream)\n      // Read node graph\n      scene.mRootNode = new aiNode()\n      scene.mRootNode = ReadBinaryNode(stream, null, 0)\n      // Read all meshes\n      if (scene.mNumMeshes) {\n        scene.mMeshes = []\n\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh()\n          ReadBinaryMesh(stream, scene.mMeshes[i])\n        }\n      }\n\n      // Read materials\n      if (scene.mNumMaterials) {\n        scene.mMaterials = []\n\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial()\n          ReadBinaryMaterial(stream, scene.mMaterials[i])\n        }\n      }\n\n      // Read all animations\n      if (scene.mNumAnimations) {\n        scene.mAnimations = []\n\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation()\n          ReadBinaryAnim(stream, scene.mAnimations[i])\n        }\n      }\n\n      // Read all textures\n      if (scene.mNumTextures) {\n        scene.mTextures = []\n\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture()\n          ReadBinaryTexture(stream, scene.mTextures[i])\n        }\n      }\n\n      // Read lights\n      if (scene.mNumLights) {\n        scene.mLights = []\n\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight()\n          ReadBinaryLight(stream, scene.mLights[i])\n        }\n      }\n\n      // Read cameras\n      if (scene.mNumCameras) {\n        scene.mCameras = []\n\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera()\n          ReadBinaryCamera(stream, scene.mCameras[i])\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0\n    var aiOrigin_BEG = 1\n\n    function extendStream(stream) {\n      stream.readOffset = 0\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off\n        }\n      }\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this)\n      }\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Float32Array(newbuff)\n      }\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint16Array(newbuff)\n      }\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint8Array(newbuff)\n      }\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint32Array(newbuff)\n      }\n    }\n\n    var shortened, compressed\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene()\n      var stream = new DataView(pFiledata)\n      extendStream(stream)\n      stream.Seek(44, aiOrigin_CUR) // signature\n      /*unsigned int versionMajor =*/\n      pScene.versionMajor = Read_unsigned_int(stream)\n      /*unsigned int versionMinor =*/\n      pScene.versionMinor = Read_unsigned_int(stream)\n      /*unsigned int versionRevision =*/\n      pScene.versionRevision = Read_unsigned_int(stream)\n      /*unsigned int compileFlags =*/\n      pScene.compileFlags = Read_unsigned_int(stream)\n      shortened = Read_uint16_t(stream) > 0\n      compressed = Read_uint16_t(stream) > 0\n      if (shortened) throw 'Shortened binaries are not supported!'\n      stream.Seek(256, aiOrigin_CUR) // original filename\n      stream.Seek(128, aiOrigin_CUR) // options\n      stream.Seek(64, aiOrigin_CUR) // padding\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream)\n        var compressedSize = stream.FileSize() - stream.Tell()\n        var compressedData = []\n        stream.Read(compressedData, 1, compressedSize)\n        var uncompressedData = []\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize)\n        var buff = new ArrayBuffer(uncompressedData)\n        ReadBinaryScene(buff, pScene)\n      } else {\n        ReadBinaryScene(stream, pScene)\n      }\n\n      return pScene.toTHREE()\n    }\n\n    return InternReadFile(buffer)\n  }\n}\n\nexport { AssimpLoader }\n"],"names":["time","path","t"],"mappings":"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"}},
    {"offset": {"line": 15853, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/MDDLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/MDDLoader.js"],"sourcesContent":["/**\n * MDD is a special format that stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * number of frames (a single uint32)\n * number of vertices (a single uint32)\n * time values for each frame (sequence of float32)\n * vertex data for each frame (sequence of float32)\n */\n\nimport { AnimationClip, BufferAttribute, FileLoader, Loader, NumberKeyframeTrack } from 'three'\n\nclass MDDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.load(\n      url,\n      function (data) {\n        onLoad(scope.parse(data))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    const view = new DataView(data)\n\n    const totalFrames = view.getUint32(0)\n    const totalPoints = view.getUint32(4)\n\n    let offset = 8\n\n    // animation clip\n\n    const times = new Float32Array(totalFrames)\n    const values = new Float32Array(totalFrames * totalFrames).fill(0)\n\n    for (let i = 0; i < totalFrames; i++) {\n      times[i] = view.getFloat32(offset)\n      offset += 4\n      values[totalFrames * i + i] = 1\n    }\n\n    const track = new NumberKeyframeTrack('.morphTargetInfluences', times, values)\n    const clip = new AnimationClip('default', times[times.length - 1], [track])\n\n    // morph targets\n\n    const morphTargets = []\n\n    for (let i = 0; i < totalFrames; i++) {\n      const morphTarget = new Float32Array(totalPoints * 3)\n\n      for (let j = 0; j < totalPoints; j++) {\n        const stride = j * 3\n\n        morphTarget[stride + 0] = view.getFloat32(offset)\n        offset += 4 // x\n        morphTarget[stride + 1] = view.getFloat32(offset)\n        offset += 4 // y\n        morphTarget[stride + 2] = view.getFloat32(offset)\n        offset += 4 // z\n      }\n\n      const attribute = new BufferAttribute(morphTarget, 3)\n      attribute.name = 'morph_' + i\n\n      morphTargets.push(attribute)\n    }\n\n    return {\n      morphTargets: morphTargets,\n      clip: clip,\n    }\n  }\n}\n\nexport { MDDLoader }\n"],"names":[],"mappings":";;;;;;AAcA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;IACd;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,MAAM,SAAS,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;QAC1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,eAAA,CAAgB,aAAa;QACpC,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;YACd,OAAO,MAAM,KAAA,CAAM,IAAI,CAAC;QACzB,GACD,YACA;IAEH;IAED,MAAM,IAAA,EAAM;QACV,MAAM,OAAO,IAAI,SAAS,IAAI;QAE9B,MAAM,cAAc,KAAK,SAAA,CAAU,CAAC;QACpC,MAAM,cAAc,KAAK,SAAA,CAAU,CAAC;QAEpC,IAAI,SAAS;QAIb,MAAM,QAAQ,IAAI,aAAa,WAAW;QAC1C,MAAM,SAAS,IAAI,aAAa,cAAc,WAAW,EAAE,IAAA,CAAK,CAAC;QAEjE,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,IAAK;YACpC,KAAA,CAAM,CAAC,CAAA,GAAI,KAAK,UAAA,CAAW,MAAM;YACjC,UAAU;YACV,MAAA,CAAO,cAAc,IAAI,CAAC,CAAA,GAAI;QAC/B;QAED,MAAM,QAAQ,IAAI,sKAAA,CAAoB,0BAA0B,OAAO,MAAM;QAC7E,MAAM,OAAO,IAAI,gKAAA,CAAc,WAAW,KAAA,CAAM,MAAM,MAAA,GAAS,CAAC,CAAA,EAAG;YAAC,KAAK;SAAC;QAI1E,MAAM,eAAe,CAAE,CAAA;QAEvB,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,IAAK;YACpC,MAAM,cAAc,IAAI,aAAa,cAAc,CAAC;YAEpD,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,IAAK;gBACpC,MAAM,SAAS,IAAI;gBAEnB,WAAA,CAAY,SAAS,CAAC,CAAA,GAAI,KAAK,UAAA,CAAW,MAAM;gBAChD,UAAU;gBACV,WAAA,CAAY,SAAS,CAAC,CAAA,GAAI,KAAK,UAAA,CAAW,MAAM;gBAChD,UAAU;gBACV,WAAA,CAAY,SAAS,CAAC,CAAA,GAAI,KAAK,UAAA,CAAW,MAAM;gBAChD,UAAU;YACX;YAED,MAAM,YAAY,IAAI,kKAAA,CAAgB,aAAa,CAAC;YACpD,UAAU,IAAA,GAAO,WAAW;YAE5B,aAAa,IAAA,CAAK,SAAS;QAC5B;QAED,OAAO;YACL;YACA;QACD;IACF;AACH"}},
    {"offset": {"line": 15916, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/EXRLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/EXRLoader.js"],"sourcesContent":["import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { version } from '../_polyfill/constants'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n// https://github.com/mrdoob/three.js/pull/25771\nconst hasColorSpace = version >= 152\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n"],"names":["uInt8Array","buffer","comp","offset","type","y","x","tmpOffset","EXRHeader","EXRDecoder"],"mappings":"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"}},
    {"offset": {"line": 17291, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/3MFLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/3MFLoader.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  RepeatWrapping,\n  TextureLoader,\n} from 'three'\nimport { unzipSync } from 'fflate'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n *\n * 3D Manufacturing Format (3MF) specification: https://3mf.io/specification/\n *\n * The following features from the core specification are supported:\n *\n * - 3D Models\n * - Object Resources (Meshes and Components)\n * - Material Resources (Base Materials)\n *\n * 3MF Materials and Properties Extension are only partially supported.\n *\n * - Texture 2D\n * - Texture 2D Groups\n * - Color Groups (Vertex Colors)\n * - Metallic Display Properties (PBR)\n */\n\nclass ThreeMFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n    this.availableExtensions = []\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    const scope = this\n    const textureLoader = new TextureLoader(this.manager)\n\n    function loadDocument(data) {\n      let zip = null\n      let file = null\n\n      let relsName\n      let modelRelsName\n      const modelPartNames = []\n      const printTicketPartNames = []\n      const texturesPartNames = []\n      const otherPartNames = []\n\n      let modelRels\n      const modelParts = {}\n      const printTicketParts = {}\n      const texturesParts = {}\n      const otherParts = {}\n\n      try {\n        zip = unzipSync(new Uint8Array(data))\n      } catch (e) {\n        if (e instanceof ReferenceError) {\n          console.error('THREE.3MFLoader: fflate missing and file is compressed.')\n          return null\n        }\n      }\n\n      for (file in zip) {\n        if (file.match(/\\_rels\\/.rels$/)) {\n          relsName = file\n        } else if (file.match(/3D\\/_rels\\/.*\\.model\\.rels$/)) {\n          modelRelsName = file\n        } else if (file.match(/^3D\\/.*\\.model$/)) {\n          modelPartNames.push(file)\n        } else if (file.match(/^3D\\/Metadata\\/.*\\.xml$/)) {\n          printTicketPartNames.push(file)\n        } else if (file.match(/^3D\\/Textures?\\/.*/)) {\n          texturesPartNames.push(file)\n        } else if (file.match(/^3D\\/Other\\/.*/)) {\n          otherPartNames.push(file)\n        }\n      }\n\n      //\n\n      const relsView = zip[relsName]\n      const relsFileText = decodeText(relsView)\n      const rels = parseRelsXml(relsFileText)\n\n      //\n\n      if (modelRelsName) {\n        const relsView = zip[modelRelsName]\n        const relsFileText = decodeText(relsView)\n        modelRels = parseRelsXml(relsFileText)\n      }\n\n      //\n\n      for (let i = 0; i < modelPartNames.length; i++) {\n        const modelPart = modelPartNames[i]\n        const view = zip[modelPart]\n\n        const fileText = decodeText(view)\n        const xmlData = new DOMParser().parseFromString(fileText, 'application/xml')\n\n        if (xmlData.documentElement.nodeName.toLowerCase() !== 'model') {\n          console.error('THREE.3MFLoader: Error loading 3MF - no 3MF document found: ', modelPart)\n        }\n\n        const modelNode = xmlData.querySelector('model')\n        const extensions = {}\n\n        for (let i = 0; i < modelNode.attributes.length; i++) {\n          const attr = modelNode.attributes[i]\n          if (attr.name.match(/^xmlns:(.+)$/)) {\n            extensions[attr.value] = RegExp.$1\n          }\n        }\n\n        const modelData = parseModelNode(modelNode)\n        modelData['xml'] = modelNode\n\n        if (0 < Object.keys(extensions).length) {\n          modelData['extensions'] = extensions\n        }\n\n        modelParts[modelPart] = modelData\n      }\n\n      //\n\n      for (let i = 0; i < texturesPartNames.length; i++) {\n        const texturesPartName = texturesPartNames[i]\n        texturesParts[texturesPartName] = zip[texturesPartName].buffer\n      }\n\n      return {\n        rels: rels,\n        modelRels: modelRels,\n        model: modelParts,\n        printTicket: printTicketParts,\n        texture: texturesParts,\n        other: otherParts,\n      }\n    }\n\n    function parseRelsXml(relsFileText) {\n      const relationships = []\n\n      const relsXmlData = new DOMParser().parseFromString(relsFileText, 'application/xml')\n\n      const relsNodes = relsXmlData.querySelectorAll('Relationship')\n\n      for (let i = 0; i < relsNodes.length; i++) {\n        const relsNode = relsNodes[i]\n\n        const relationship = {\n          target: relsNode.getAttribute('Target'), //required\n          id: relsNode.getAttribute('Id'), //required\n          type: relsNode.getAttribute('Type'), //required\n        }\n\n        relationships.push(relationship)\n      }\n\n      return relationships\n    }\n\n    function parseMetadataNodes(metadataNodes) {\n      const metadataData = {}\n\n      for (let i = 0; i < metadataNodes.length; i++) {\n        const metadataNode = metadataNodes[i]\n        const name = metadataNode.getAttribute('name')\n        const validNames = [\n          'Title',\n          'Designer',\n          'Description',\n          'Copyright',\n          'LicenseTerms',\n          'Rating',\n          'CreationDate',\n          'ModificationDate',\n        ]\n\n        if (0 <= validNames.indexOf(name)) {\n          metadataData[name] = metadataNode.textContent\n        }\n      }\n\n      return metadataData\n    }\n\n    function parseBasematerialsNode(basematerialsNode) {\n      const basematerialsData = {\n        id: basematerialsNode.getAttribute('id'), // required\n        basematerials: [],\n      }\n\n      const basematerialNodes = basematerialsNode.querySelectorAll('base')\n\n      for (let i = 0; i < basematerialNodes.length; i++) {\n        const basematerialNode = basematerialNodes[i]\n        const basematerialData = parseBasematerialNode(basematerialNode)\n        basematerialData.index = i // the order and count of the material nodes form an implicit 0-based index\n        basematerialsData.basematerials.push(basematerialData)\n      }\n\n      return basematerialsData\n    }\n\n    function parseTexture2DNode(texture2DNode) {\n      const texture2dData = {\n        id: texture2DNode.getAttribute('id'), // required\n        path: texture2DNode.getAttribute('path'), // required\n        contenttype: texture2DNode.getAttribute('contenttype'), // required\n        tilestyleu: texture2DNode.getAttribute('tilestyleu'),\n        tilestylev: texture2DNode.getAttribute('tilestylev'),\n        filter: texture2DNode.getAttribute('filter'),\n      }\n\n      return texture2dData\n    }\n\n    function parseTextures2DGroupNode(texture2DGroupNode) {\n      const texture2DGroupData = {\n        id: texture2DGroupNode.getAttribute('id'), // required\n        texid: texture2DGroupNode.getAttribute('texid'), // required\n        displaypropertiesid: texture2DGroupNode.getAttribute('displaypropertiesid'),\n      }\n\n      const tex2coordNodes = texture2DGroupNode.querySelectorAll('tex2coord')\n\n      const uvs = []\n\n      for (let i = 0; i < tex2coordNodes.length; i++) {\n        const tex2coordNode = tex2coordNodes[i]\n        const u = tex2coordNode.getAttribute('u')\n        const v = tex2coordNode.getAttribute('v')\n\n        uvs.push(parseFloat(u), parseFloat(v))\n      }\n\n      texture2DGroupData['uvs'] = new Float32Array(uvs)\n\n      return texture2DGroupData\n    }\n\n    function parseColorGroupNode(colorGroupNode) {\n      const colorGroupData = {\n        id: colorGroupNode.getAttribute('id'), // required\n        displaypropertiesid: colorGroupNode.getAttribute('displaypropertiesid'),\n      }\n\n      const colorNodes = colorGroupNode.querySelectorAll('color')\n\n      const colors = []\n      const colorObject = new Color()\n\n      for (let i = 0; i < colorNodes.length; i++) {\n        const colorNode = colorNodes[i]\n        const color = colorNode.getAttribute('color')\n\n        colorObject.setStyle(color.substring(0, 7))\n        colorObject.convertSRGBToLinear() // color is in sRGB\n\n        colors.push(colorObject.r, colorObject.g, colorObject.b)\n      }\n\n      colorGroupData['colors'] = new Float32Array(colors)\n\n      return colorGroupData\n    }\n\n    function parseMetallicDisplaypropertiesNode(metallicDisplaypropetiesNode) {\n      const metallicDisplaypropertiesData = {\n        id: metallicDisplaypropetiesNode.getAttribute('id'), // required\n      }\n\n      const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll('pbmetallic')\n\n      const metallicData = []\n\n      for (let i = 0; i < metallicNodes.length; i++) {\n        const metallicNode = metallicNodes[i]\n\n        metallicData.push({\n          name: metallicNode.getAttribute('name'), // required\n          metallicness: parseFloat(metallicNode.getAttribute('metallicness')), // required\n          roughness: parseFloat(metallicNode.getAttribute('roughness')), // required\n        })\n      }\n\n      metallicDisplaypropertiesData.data = metallicData\n\n      return metallicDisplaypropertiesData\n    }\n\n    function parseBasematerialNode(basematerialNode) {\n      const basematerialData = {}\n\n      basematerialData['name'] = basematerialNode.getAttribute('name') // required\n      basematerialData['displaycolor'] = basematerialNode.getAttribute('displaycolor') // required\n      basematerialData['displaypropertiesid'] = basematerialNode.getAttribute('displaypropertiesid')\n\n      return basematerialData\n    }\n\n    function parseMeshNode(meshNode) {\n      const meshData = {}\n\n      const vertices = []\n      const vertexNodes = meshNode.querySelectorAll('vertices vertex')\n\n      for (let i = 0; i < vertexNodes.length; i++) {\n        const vertexNode = vertexNodes[i]\n        const x = vertexNode.getAttribute('x')\n        const y = vertexNode.getAttribute('y')\n        const z = vertexNode.getAttribute('z')\n\n        vertices.push(parseFloat(x), parseFloat(y), parseFloat(z))\n      }\n\n      meshData['vertices'] = new Float32Array(vertices)\n\n      const triangleProperties = []\n      const triangles = []\n      const triangleNodes = meshNode.querySelectorAll('triangles triangle')\n\n      for (let i = 0; i < triangleNodes.length; i++) {\n        const triangleNode = triangleNodes[i]\n        const v1 = triangleNode.getAttribute('v1')\n        const v2 = triangleNode.getAttribute('v2')\n        const v3 = triangleNode.getAttribute('v3')\n        const p1 = triangleNode.getAttribute('p1')\n        const p2 = triangleNode.getAttribute('p2')\n        const p3 = triangleNode.getAttribute('p3')\n        const pid = triangleNode.getAttribute('pid')\n\n        const triangleProperty = {}\n\n        triangleProperty['v1'] = parseInt(v1, 10)\n        triangleProperty['v2'] = parseInt(v2, 10)\n        triangleProperty['v3'] = parseInt(v3, 10)\n\n        triangles.push(triangleProperty['v1'], triangleProperty['v2'], triangleProperty['v3'])\n\n        // optional\n\n        if (p1) {\n          triangleProperty['p1'] = parseInt(p1, 10)\n        }\n\n        if (p2) {\n          triangleProperty['p2'] = parseInt(p2, 10)\n        }\n\n        if (p3) {\n          triangleProperty['p3'] = parseInt(p3, 10)\n        }\n\n        if (pid) {\n          triangleProperty['pid'] = pid\n        }\n\n        if (0 < Object.keys(triangleProperty).length) {\n          triangleProperties.push(triangleProperty)\n        }\n      }\n\n      meshData['triangleProperties'] = triangleProperties\n      meshData['triangles'] = new Uint32Array(triangles)\n\n      return meshData\n    }\n\n    function parseComponentsNode(componentsNode) {\n      const components = []\n\n      const componentNodes = componentsNode.querySelectorAll('component')\n\n      for (let i = 0; i < componentNodes.length; i++) {\n        const componentNode = componentNodes[i]\n        const componentData = parseComponentNode(componentNode)\n        components.push(componentData)\n      }\n\n      return components\n    }\n\n    function parseComponentNode(componentNode) {\n      const componentData = {}\n\n      componentData['objectId'] = componentNode.getAttribute('objectid') // required\n\n      const transform = componentNode.getAttribute('transform')\n\n      if (transform) {\n        componentData['transform'] = parseTransform(transform)\n      }\n\n      return componentData\n    }\n\n    function parseTransform(transform) {\n      const t = []\n      transform.split(' ').forEach(function (s) {\n        t.push(parseFloat(s))\n      })\n\n      const matrix = new Matrix4()\n      matrix.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0.0, 0.0, 0.0, 1.0)\n\n      return matrix\n    }\n\n    function parseObjectNode(objectNode) {\n      const objectData = {\n        type: objectNode.getAttribute('type'),\n      }\n\n      const id = objectNode.getAttribute('id')\n\n      if (id) {\n        objectData['id'] = id\n      }\n\n      const pid = objectNode.getAttribute('pid')\n\n      if (pid) {\n        objectData['pid'] = pid\n      }\n\n      const pindex = objectNode.getAttribute('pindex')\n\n      if (pindex) {\n        objectData['pindex'] = pindex\n      }\n\n      const thumbnail = objectNode.getAttribute('thumbnail')\n\n      if (thumbnail) {\n        objectData['thumbnail'] = thumbnail\n      }\n\n      const partnumber = objectNode.getAttribute('partnumber')\n\n      if (partnumber) {\n        objectData['partnumber'] = partnumber\n      }\n\n      const name = objectNode.getAttribute('name')\n\n      if (name) {\n        objectData['name'] = name\n      }\n\n      const meshNode = objectNode.querySelector('mesh')\n\n      if (meshNode) {\n        objectData['mesh'] = parseMeshNode(meshNode)\n      }\n\n      const componentsNode = objectNode.querySelector('components')\n\n      if (componentsNode) {\n        objectData['components'] = parseComponentsNode(componentsNode)\n      }\n\n      return objectData\n    }\n\n    function parseResourcesNode(resourcesNode) {\n      const resourcesData = {}\n\n      resourcesData['basematerials'] = {}\n      const basematerialsNodes = resourcesNode.querySelectorAll('basematerials')\n\n      for (let i = 0; i < basematerialsNodes.length; i++) {\n        const basematerialsNode = basematerialsNodes[i]\n        const basematerialsData = parseBasematerialsNode(basematerialsNode)\n        resourcesData['basematerials'][basematerialsData['id']] = basematerialsData\n      }\n\n      //\n\n      resourcesData['texture2d'] = {}\n      const textures2DNodes = resourcesNode.querySelectorAll('texture2d')\n\n      for (let i = 0; i < textures2DNodes.length; i++) {\n        const textures2DNode = textures2DNodes[i]\n        const texture2DData = parseTexture2DNode(textures2DNode)\n        resourcesData['texture2d'][texture2DData['id']] = texture2DData\n      }\n\n      //\n\n      resourcesData['colorgroup'] = {}\n      const colorGroupNodes = resourcesNode.querySelectorAll('colorgroup')\n\n      for (let i = 0; i < colorGroupNodes.length; i++) {\n        const colorGroupNode = colorGroupNodes[i]\n        const colorGroupData = parseColorGroupNode(colorGroupNode)\n        resourcesData['colorgroup'][colorGroupData['id']] = colorGroupData\n      }\n\n      //\n\n      resourcesData['pbmetallicdisplayproperties'] = {}\n      const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll('pbmetallicdisplayproperties')\n\n      for (let i = 0; i < pbmetallicdisplaypropertiesNodes.length; i++) {\n        const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[i]\n        const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode(pbmetallicdisplaypropertiesNode)\n        resourcesData['pbmetallicdisplayproperties'][\n          pbmetallicdisplaypropertiesData['id']\n        ] = pbmetallicdisplaypropertiesData\n      }\n\n      //\n\n      resourcesData['texture2dgroup'] = {}\n      const textures2DGroupNodes = resourcesNode.querySelectorAll('texture2dgroup')\n\n      for (let i = 0; i < textures2DGroupNodes.length; i++) {\n        const textures2DGroupNode = textures2DGroupNodes[i]\n        const textures2DGroupData = parseTextures2DGroupNode(textures2DGroupNode)\n        resourcesData['texture2dgroup'][textures2DGroupData['id']] = textures2DGroupData\n      }\n\n      //\n\n      resourcesData['object'] = {}\n      const objectNodes = resourcesNode.querySelectorAll('object')\n\n      for (let i = 0; i < objectNodes.length; i++) {\n        const objectNode = objectNodes[i]\n        const objectData = parseObjectNode(objectNode)\n        resourcesData['object'][objectData['id']] = objectData\n      }\n\n      return resourcesData\n    }\n\n    function parseBuildNode(buildNode) {\n      const buildData = []\n      const itemNodes = buildNode.querySelectorAll('item')\n\n      for (let i = 0; i < itemNodes.length; i++) {\n        const itemNode = itemNodes[i]\n        const buildItem = {\n          objectId: itemNode.getAttribute('objectid'),\n        }\n        const transform = itemNode.getAttribute('transform')\n\n        if (transform) {\n          buildItem['transform'] = parseTransform(transform)\n        }\n\n        buildData.push(buildItem)\n      }\n\n      return buildData\n    }\n\n    function parseModelNode(modelNode) {\n      const modelData = { unit: modelNode.getAttribute('unit') || 'millimeter' }\n      const metadataNodes = modelNode.querySelectorAll('metadata')\n\n      if (metadataNodes) {\n        modelData['metadata'] = parseMetadataNodes(metadataNodes)\n      }\n\n      const resourcesNode = modelNode.querySelector('resources')\n\n      if (resourcesNode) {\n        modelData['resources'] = parseResourcesNode(resourcesNode)\n      }\n\n      const buildNode = modelNode.querySelector('build')\n\n      if (buildNode) {\n        modelData['build'] = parseBuildNode(buildNode)\n      }\n\n      return modelData\n    }\n\n    function buildTexture(texture2dgroup, objects, modelData, textureData) {\n      const texid = texture2dgroup.texid\n      const texture2ds = modelData.resources.texture2d\n      const texture2d = texture2ds[texid]\n\n      if (texture2d) {\n        const data = textureData[texture2d.path]\n        const type = texture2d.contenttype\n\n        const blob = new Blob([data], { type: type })\n        const sourceURI = URL.createObjectURL(blob)\n\n        const texture = textureLoader.load(sourceURI, function () {\n          URL.revokeObjectURL(sourceURI)\n        })\n\n        if ('colorSpace' in texture) texture.colorSpace = 'srgb'\n        else texture.encoding = 3001 // sRGBEncoding\n\n        // texture parameters\n\n        switch (texture2d.tilestyleu) {\n          case 'wrap':\n            texture.wrapS = RepeatWrapping\n            break\n\n          case 'mirror':\n            texture.wrapS = MirroredRepeatWrapping\n            break\n\n          case 'none':\n          case 'clamp':\n            texture.wrapS = ClampToEdgeWrapping\n            break\n\n          default:\n            texture.wrapS = RepeatWrapping\n        }\n\n        switch (texture2d.tilestylev) {\n          case 'wrap':\n            texture.wrapT = RepeatWrapping\n            break\n\n          case 'mirror':\n            texture.wrapT = MirroredRepeatWrapping\n            break\n\n          case 'none':\n          case 'clamp':\n            texture.wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            texture.wrapT = RepeatWrapping\n        }\n\n        switch (texture2d.filter) {\n          case 'auto':\n            texture.magFilter = LinearFilter\n            texture.minFilter = LinearMipmapLinearFilter\n            break\n\n          case 'linear':\n            texture.magFilter = LinearFilter\n            texture.minFilter = LinearFilter\n            break\n\n          case 'nearest':\n            texture.magFilter = NearestFilter\n            texture.minFilter = NearestFilter\n            break\n\n          default:\n            texture.magFilter = LinearFilter\n            texture.minFilter = LinearMipmapLinearFilter\n        }\n\n        return texture\n      } else {\n        return null\n      }\n    }\n\n    function buildBasematerialsMeshes(\n      basematerials,\n      triangleProperties,\n      meshData,\n      objects,\n      modelData,\n      textureData,\n      objectData,\n    ) {\n      const objectPindex = objectData.pindex\n\n      const materialMap = {}\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n        const pindex = triangleProperty.p1 !== undefined ? triangleProperty.p1 : objectPindex\n\n        if (materialMap[pindex] === undefined) materialMap[pindex] = []\n\n        materialMap[pindex].push(triangleProperty)\n      }\n\n      //\n\n      const keys = Object.keys(materialMap)\n      const meshes = []\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const materialIndex = keys[i]\n        const trianglePropertiesProps = materialMap[materialIndex]\n        const basematerialData = basematerials.basematerials[materialIndex]\n        const material = getBuild(basematerialData, objects, modelData, textureData, objectData, buildBasematerial)\n\n        //\n\n        const geometry = new BufferGeometry()\n\n        const positionData = []\n\n        const vertices = meshData.vertices\n\n        for (let j = 0, jl = trianglePropertiesProps.length; j < jl; j++) {\n          const triangleProperty = trianglePropertiesProps[j]\n\n          positionData.push(vertices[triangleProperty.v1 * 3 + 0])\n          positionData.push(vertices[triangleProperty.v1 * 3 + 1])\n          positionData.push(vertices[triangleProperty.v1 * 3 + 2])\n\n          positionData.push(vertices[triangleProperty.v2 * 3 + 0])\n          positionData.push(vertices[triangleProperty.v2 * 3 + 1])\n          positionData.push(vertices[triangleProperty.v2 * 3 + 2])\n\n          positionData.push(vertices[triangleProperty.v3 * 3 + 0])\n          positionData.push(vertices[triangleProperty.v3 * 3 + 1])\n          positionData.push(vertices[triangleProperty.v3 * 3 + 2])\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(positionData, 3))\n\n        //\n\n        const mesh = new Mesh(geometry, material)\n        meshes.push(mesh)\n      }\n\n      return meshes\n    }\n\n    function buildTexturedMesh(\n      texture2dgroup,\n      triangleProperties,\n      meshData,\n      objects,\n      modelData,\n      textureData,\n      objectData,\n    ) {\n      // geometry\n\n      const geometry = new BufferGeometry()\n\n      const positionData = []\n      const uvData = []\n\n      const vertices = meshData.vertices\n      const uvs = texture2dgroup.uvs\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n\n        positionData.push(vertices[triangleProperty.v1 * 3 + 0])\n        positionData.push(vertices[triangleProperty.v1 * 3 + 1])\n        positionData.push(vertices[triangleProperty.v1 * 3 + 2])\n\n        positionData.push(vertices[triangleProperty.v2 * 3 + 0])\n        positionData.push(vertices[triangleProperty.v2 * 3 + 1])\n        positionData.push(vertices[triangleProperty.v2 * 3 + 2])\n\n        positionData.push(vertices[triangleProperty.v3 * 3 + 0])\n        positionData.push(vertices[triangleProperty.v3 * 3 + 1])\n        positionData.push(vertices[triangleProperty.v3 * 3 + 2])\n\n        //\n\n        uvData.push(uvs[triangleProperty.p1 * 2 + 0])\n        uvData.push(uvs[triangleProperty.p1 * 2 + 1])\n\n        uvData.push(uvs[triangleProperty.p2 * 2 + 0])\n        uvData.push(uvs[triangleProperty.p2 * 2 + 1])\n\n        uvData.push(uvs[triangleProperty.p3 * 2 + 0])\n        uvData.push(uvs[triangleProperty.p3 * 2 + 1])\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(positionData, 3))\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvData, 2))\n\n      // material\n\n      const texture = getBuild(texture2dgroup, objects, modelData, textureData, objectData, buildTexture)\n\n      const material = new MeshPhongMaterial({ map: texture, flatShading: true })\n\n      // mesh\n\n      const mesh = new Mesh(geometry, material)\n\n      return mesh\n    }\n\n    function buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects, modelData, objectData) {\n      // geometry\n\n      const geometry = new BufferGeometry()\n\n      const positionData = []\n      const colorData = []\n\n      const vertices = meshData.vertices\n      const colors = colorgroup.colors\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n\n        const v1 = triangleProperty.v1\n        const v2 = triangleProperty.v2\n        const v3 = triangleProperty.v3\n\n        positionData.push(vertices[v1 * 3 + 0])\n        positionData.push(vertices[v1 * 3 + 1])\n        positionData.push(vertices[v1 * 3 + 2])\n\n        positionData.push(vertices[v2 * 3 + 0])\n        positionData.push(vertices[v2 * 3 + 1])\n        positionData.push(vertices[v2 * 3 + 2])\n\n        positionData.push(vertices[v3 * 3 + 0])\n        positionData.push(vertices[v3 * 3 + 1])\n        positionData.push(vertices[v3 * 3 + 2])\n\n        //\n\n        const p1 = triangleProperty.p1 !== undefined ? triangleProperty.p1 : objectData.pindex\n        const p2 = triangleProperty.p2 !== undefined ? triangleProperty.p2 : p1\n        const p3 = triangleProperty.p3 !== undefined ? triangleProperty.p3 : p1\n\n        colorData.push(colors[p1 * 3 + 0])\n        colorData.push(colors[p1 * 3 + 1])\n        colorData.push(colors[p1 * 3 + 2])\n\n        colorData.push(colors[p2 * 3 + 0])\n        colorData.push(colors[p2 * 3 + 1])\n        colorData.push(colors[p2 * 3 + 2])\n\n        colorData.push(colors[p3 * 3 + 0])\n        colorData.push(colors[p3 * 3 + 1])\n        colorData.push(colors[p3 * 3 + 2])\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(positionData, 3))\n      geometry.setAttribute('color', new Float32BufferAttribute(colorData, 3))\n\n      // material\n\n      const material = new MeshPhongMaterial({ vertexColors: true, flatShading: true })\n\n      // mesh\n\n      const mesh = new Mesh(geometry, material)\n\n      return mesh\n    }\n\n    function buildDefaultMesh(meshData) {\n      const geometry = new BufferGeometry()\n      geometry.setIndex(new BufferAttribute(meshData['triangles'], 1))\n      geometry.setAttribute('position', new BufferAttribute(meshData['vertices'], 3))\n\n      const material = new MeshPhongMaterial({ color: 0xaaaaff, flatShading: true })\n\n      const mesh = new Mesh(geometry, material)\n\n      return mesh\n    }\n\n    function buildMeshes(resourceMap, meshData, objects, modelData, textureData, objectData) {\n      const keys = Object.keys(resourceMap)\n      const meshes = []\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const resourceId = keys[i]\n        const triangleProperties = resourceMap[resourceId]\n        const resourceType = getResourceType(resourceId, modelData)\n\n        switch (resourceType) {\n          case 'material':\n            const basematerials = modelData.resources.basematerials[resourceId]\n            const newMeshes = buildBasematerialsMeshes(\n              basematerials,\n              triangleProperties,\n              meshData,\n              objects,\n              modelData,\n              textureData,\n              objectData,\n            )\n\n            for (let j = 0, jl = newMeshes.length; j < jl; j++) {\n              meshes.push(newMeshes[j])\n            }\n\n            break\n\n          case 'texture':\n            const texture2dgroup = modelData.resources.texture2dgroup[resourceId]\n            meshes.push(\n              buildTexturedMesh(\n                texture2dgroup,\n                triangleProperties,\n                meshData,\n                objects,\n                modelData,\n                textureData,\n                objectData,\n              ),\n            )\n            break\n\n          case 'vertexColors':\n            const colorgroup = modelData.resources.colorgroup[resourceId]\n            meshes.push(buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects, modelData, objectData))\n            break\n\n          case 'default':\n            meshes.push(buildDefaultMesh(meshData))\n            break\n\n          default:\n            console.error('THREE.3MFLoader: Unsupported resource type.')\n        }\n      }\n\n      return meshes\n    }\n\n    function getResourceType(pid, modelData) {\n      if (modelData.resources.texture2dgroup[pid] !== undefined) {\n        return 'texture'\n      } else if (modelData.resources.basematerials[pid] !== undefined) {\n        return 'material'\n      } else if (modelData.resources.colorgroup[pid] !== undefined) {\n        return 'vertexColors'\n      } else if (pid === 'default') {\n        return 'default'\n      } else {\n        return undefined\n      }\n    }\n\n    function analyzeObject(modelData, meshData, objectData) {\n      const resourceMap = {}\n\n      const triangleProperties = meshData['triangleProperties']\n\n      const objectPid = objectData.pid\n\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i]\n        let pid = triangleProperty.pid !== undefined ? triangleProperty.pid : objectPid\n\n        if (pid === undefined) pid = 'default'\n\n        if (resourceMap[pid] === undefined) resourceMap[pid] = []\n\n        resourceMap[pid].push(triangleProperty)\n      }\n\n      return resourceMap\n    }\n\n    function buildGroup(meshData, objects, modelData, textureData, objectData) {\n      const group = new Group()\n\n      const resourceMap = analyzeObject(modelData, meshData, objectData)\n      const meshes = buildMeshes(resourceMap, meshData, objects, modelData, textureData, objectData)\n\n      for (let i = 0, l = meshes.length; i < l; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    }\n\n    function applyExtensions(extensions, meshData, modelXml) {\n      if (!extensions) {\n        return\n      }\n\n      const availableExtensions = []\n      const keys = Object.keys(extensions)\n\n      for (let i = 0; i < keys.length; i++) {\n        const ns = keys[i]\n\n        for (let j = 0; j < scope.availableExtensions.length; j++) {\n          const extension = scope.availableExtensions[j]\n\n          if (extension.ns === ns) {\n            availableExtensions.push(extension)\n          }\n        }\n      }\n\n      for (let i = 0; i < availableExtensions.length; i++) {\n        const extension = availableExtensions[i]\n        extension.apply(modelXml, extensions[extension['ns']], meshData)\n      }\n    }\n\n    function getBuild(data, objects, modelData, textureData, objectData, builder) {\n      if (data.build !== undefined) return data.build\n\n      data.build = builder(data, objects, modelData, textureData, objectData)\n\n      return data.build\n    }\n\n    function buildBasematerial(materialData, objects, modelData) {\n      let material\n\n      const displaypropertiesid = materialData.displaypropertiesid\n      const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties\n\n      if (displaypropertiesid !== null && pbmetallicdisplayproperties[displaypropertiesid] !== undefined) {\n        // metallic display property, use StandardMaterial\n\n        const pbmetallicdisplayproperty = pbmetallicdisplayproperties[displaypropertiesid]\n        const metallicData = pbmetallicdisplayproperty.data[materialData.index]\n\n        material = new MeshStandardMaterial({\n          flatShading: true,\n          roughness: metallicData.roughness,\n          metalness: metallicData.metallicness,\n        })\n      } else {\n        // otherwise use PhongMaterial\n\n        material = new MeshPhongMaterial({ flatShading: true })\n      }\n\n      material.name = materialData.name\n\n      // displaycolor MUST be specified with a value of a 6 or 8 digit hexadecimal number, e.g. \"#RRGGBB\" or \"#RRGGBBAA\"\n\n      const displaycolor = materialData.displaycolor\n\n      const color = displaycolor.substring(0, 7)\n      material.color.setStyle(color)\n      material.color.convertSRGBToLinear() // displaycolor is in sRGB\n\n      // process alpha if set\n\n      if (displaycolor.length === 9) {\n        material.opacity = parseInt(displaycolor.charAt(7) + displaycolor.charAt(8), 16) / 255\n      }\n\n      return material\n    }\n\n    function buildComposite(compositeData, objects, modelData, textureData) {\n      const composite = new Group()\n\n      for (let j = 0; j < compositeData.length; j++) {\n        const component = compositeData[j]\n        let build = objects[component.objectId]\n\n        if (build === undefined) {\n          buildObject(component.objectId, objects, modelData, textureData)\n          build = objects[component.objectId]\n        }\n\n        const object3D = build.clone()\n\n        // apply component transform\n\n        const transform = component.transform\n\n        if (transform) {\n          object3D.applyMatrix4(transform)\n        }\n\n        composite.add(object3D)\n      }\n\n      return composite\n    }\n\n    function buildObject(objectId, objects, modelData, textureData) {\n      const objectData = modelData['resources']['object'][objectId]\n\n      if (objectData['mesh']) {\n        const meshData = objectData['mesh']\n\n        const extensions = modelData['extensions']\n        const modelXml = modelData['xml']\n\n        applyExtensions(extensions, meshData, modelXml)\n\n        objects[objectData.id] = getBuild(meshData, objects, modelData, textureData, objectData, buildGroup)\n      } else {\n        const compositeData = objectData['components']\n\n        objects[objectData.id] = getBuild(compositeData, objects, modelData, textureData, objectData, buildComposite)\n      }\n    }\n\n    function buildObjects(data3mf) {\n      const modelsData = data3mf.model\n      const modelRels = data3mf.modelRels\n      const objects = {}\n      const modelsKeys = Object.keys(modelsData)\n      const textureData = {}\n\n      // evaluate model relationships to textures\n\n      if (modelRels) {\n        for (let i = 0, l = modelRels.length; i < l; i++) {\n          const modelRel = modelRels[i]\n          const textureKey = modelRel.target.substring(1)\n\n          if (data3mf.texture[textureKey]) {\n            textureData[modelRel.target] = data3mf.texture[textureKey]\n          }\n        }\n      }\n\n      // start build\n\n      for (let i = 0; i < modelsKeys.length; i++) {\n        const modelsKey = modelsKeys[i]\n        const modelData = modelsData[modelsKey]\n\n        const objectIds = Object.keys(modelData['resources']['object'])\n\n        for (let j = 0; j < objectIds.length; j++) {\n          const objectId = objectIds[j]\n\n          buildObject(objectId, objects, modelData, textureData)\n        }\n      }\n\n      return objects\n    }\n\n    function fetch3DModelPart(rels) {\n      for (let i = 0; i < rels.length; i++) {\n        const rel = rels[i]\n        const extension = rel.target.split('.').pop()\n\n        if (extension.toLowerCase() === 'model') return rel\n      }\n    }\n\n    function build(objects, data3mf) {\n      const group = new Group()\n\n      const relationship = fetch3DModelPart(data3mf['rels'])\n      const buildData = data3mf.model[relationship['target'].substring(1)]['build']\n\n      for (let i = 0; i < buildData.length; i++) {\n        const buildItem = buildData[i]\n        const object3D = objects[buildItem['objectId']]\n\n        // apply transform\n\n        const transform = buildItem['transform']\n\n        if (transform) {\n          object3D.applyMatrix4(transform)\n        }\n\n        group.add(object3D)\n      }\n\n      return group\n    }\n\n    const data3mf = loadDocument(data)\n    const objects = buildObjects(data3mf)\n\n    return build(objects, data3mf)\n  }\n\n  addExtension(extension) {\n    this.availableExtensions.push(extension)\n  }\n}\n\nexport { ThreeMFLoader }\n"],"names":["data","relsView","relsFileText","i","objects","build","data3mf"],"mappings":"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"}},
    {"offset": {"line": 18135, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/XYZLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/XYZLoader.js"],"sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader } from 'three'\n\nclass XYZLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    const lines = text.split('\\n')\n\n    const vertices = []\n    const colors = []\n\n    for (let line of lines) {\n      line = line.trim()\n\n      if (line.charAt(0) === '#') continue // skip comments\n\n      const lineValues = line.split(/\\s+/)\n\n      if (lineValues.length === 3) {\n        // XYZ\n\n        vertices.push(parseFloat(lineValues[0]))\n        vertices.push(parseFloat(lineValues[1]))\n        vertices.push(parseFloat(lineValues[2]))\n      }\n\n      if (lineValues.length === 6) {\n        // XYZRGB\n\n        vertices.push(parseFloat(lineValues[0]))\n        vertices.push(parseFloat(lineValues[1]))\n        vertices.push(parseFloat(lineValues[2]))\n\n        colors.push(parseFloat(lineValues[3]) / 255)\n        colors.push(parseFloat(lineValues[4]) / 255)\n        colors.push(parseFloat(lineValues[5]) / 255)\n      }\n    }\n\n    const geometry = new BufferGeometry()\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n\n    if (colors.length > 0) {\n      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))\n    }\n\n    return geometry\n  }\n}\n\nexport { XYZLoader }\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,MAAM,SAAS,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;QAC1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa;QAC1C,OAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe;QAC9C,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;YACd,IAAI;gBACF,OAAO,MAAM,KAAA,CAAM,IAAI,CAAC;YACzB,EAAA,OAAQ,GAAP;gBACA,IAAI,SAAS;oBACX,QAAQ,CAAC;gBACrB,OAAiB;oBACL,QAAQ,KAAA,CAAM,CAAC;gBAChB;gBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC5B;QACF,GACD,YACA;IAEH;IAED,MAAM,IAAA,EAAM;QACV,MAAM,QAAQ,KAAK,KAAA,CAAM,IAAI;QAE7B,MAAM,WAAW,CAAE,CAAA;QACnB,MAAM,SAAS,CAAE,CAAA;QAEjB,KAAA,IAAS,QAAQ,MAAO;YACtB,OAAO,KAAK,IAAA,CAAM;YAElB,IAAI,KAAK,MAAA,CAAO,CAAC,MAAM,KAAK;YAE5B,MAAM,aAAa,KAAK,KAAA,CAAM,KAAK;YAEnC,IAAI,WAAW,MAAA,KAAW,GAAG;gBAG3B,SAAS,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,CAAC;gBACvC,SAAS,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,CAAC;gBACvC,SAAS,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,CAAC;YACxC;YAED,IAAI,WAAW,MAAA,KAAW,GAAG;gBAG3B,SAAS,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,CAAC;gBACvC,SAAS,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,CAAC;gBACvC,SAAS,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,CAAC;gBAEvC,OAAO,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,IAAI,GAAG;gBAC3C,OAAO,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,IAAI,GAAG;gBAC3C,OAAO,IAAA,CAAK,WAAW,UAAA,CAAW,CAAC,CAAC,IAAI,GAAG;YAC5C;QACF;QAED,MAAM,WAAW,IAAI,iKAAA,CAAgB;QACrC,SAAS,YAAA,CAAa,YAAY,IAAI,yKAAA,CAAuB,UAAU,CAAC,CAAC;QAEzE,IAAI,OAAO,MAAA,GAAS,GAAG;YACrB,SAAS,YAAA,CAAa,SAAS,IAAI,yKAAA,CAAuB,QAAQ,CAAC,CAAC;QACrE;QAED,OAAO;IACR;AACH"}},
    {"offset": {"line": 18197, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/VTKLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/VTKLoader.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils } from 'three'\nimport { unzlibSync } from 'fflate'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nclass VTKLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = []\n\n      // triangles vertices\n      var positions = []\n\n      // red, green, blue colors in the range 0 to 1\n      var colors = []\n\n      // normal vector, one per vertex\n      var normals = []\n\n      var result\n\n      // pattern for detecting the end of a number sequence\n      var patWord = /^[^\\d.\\s-]+/\n\n      // pattern for reading vertices, 3 floats or integers\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g\n\n      // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/\n\n      // indicates start of vertex data section\n      var patPOINTS = /^POINTS /\n\n      // indicates start of polygon connectivity section\n      var patPOLYGONS = /^POLYGONS /\n\n      // indicates start of triangle strips section\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /\n\n      // POINT_DATA number_of_values\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/\n\n      // CELL_DATA number_of_polys\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/\n\n      // Start of color section\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/\n\n      // NORMALS Normals float\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/\n\n      var inPointsSection = false\n      var inPolygonsSection = false\n      var inTriangleStripSection = false\n      var inPointDataSection = false\n      var inCellDataSection = false\n      var inColorSection = false\n      var inNormalsSection = false\n\n      var lines = data.split('\\n')\n\n      for (var i in lines) {\n        var line = lines[i].trim()\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1]\n\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset)\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break\n\n            var x = parseFloat(result[1])\n            var y = parseFloat(result[2])\n            var z = parseFloat(result[3])\n            positions.push(x, y, z)\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1])\n            var inds = result[2].split(/\\s+/)\n\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0])\n              var i1, i2\n              var k = 1\n              // split the polygon in numVertices - 2 triangles\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k])\n                i2 = parseInt(inds[k + 1])\n                indices.push(i0, i1, i2)\n                k++\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1])\n            var inds = result[2].split(/\\s+/)\n\n            if (numVertices >= 3) {\n              var i0, i1, i2\n              // split the polygon in numVertices - 2 triangles\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j])\n                  i1 = parseInt(inds[j + 2])\n                  i2 = parseInt(inds[j + 1])\n                  indices.push(i0, i1, i2)\n                } else {\n                  i0 = parseInt(inds[j])\n                  i1 = parseInt(inds[j + 1])\n                  i2 = parseInt(inds[j + 2])\n                  indices.push(i0, i1, i2)\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break\n\n              var r = parseFloat(result[1])\n              var g = parseFloat(result[2])\n              var b = parseFloat(result[3])\n              colors.push(r, g, b)\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break\n\n              var nx = parseFloat(result[1])\n              var ny = parseFloat(result[2])\n              var nz = parseFloat(result[3])\n              normals.push(nx, ny, nz)\n            }\n          }\n        }\n\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true\n          inPointsSection = false\n          inTriangleStripSection = false\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false\n          inPointsSection = true\n          inTriangleStripSection = false\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false\n          inPointsSection = false\n          inTriangleStripSection = true\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true\n          inPointsSection = false\n          inPolygonsSection = false\n          inTriangleStripSection = false\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true\n          inPointsSection = false\n          inPolygonsSection = false\n          inTriangleStripSection = false\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true\n          inNormalsSection = false\n          inPointsSection = false\n          inPolygonsSection = false\n          inTriangleStripSection = false\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true\n          inColorSection = false\n          inPointsSection = false\n          inPolygonsSection = false\n          inTriangleStripSection = false\n        }\n      }\n\n      var geometry = new BufferGeometry()\n      geometry.setIndex(indices)\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n      }\n\n      if (colors.length !== indices.length) {\n        // stagger\n\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))\n        }\n      } else {\n        // cell\n\n        geometry = geometry.toNonIndexed()\n        var numTriangles = geometry.attributes.position.count / 3\n\n        if (colors.length === numTriangles * 3) {\n          var newColors = []\n\n          for (var i = 0; i < numTriangles; i++) {\n            var r = colors[3 * i + 0]\n            var g = colors[3 * i + 1]\n            var b = colors[3 * i + 2]\n\n            newColors.push(r, g, b)\n            newColors.push(r, g, b)\n            newColors.push(r, g, b)\n          }\n\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3))\n        }\n      }\n\n      return geometry\n    }\n\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s\n      var buffer = new Uint8Array(data)\n      var dataView = new DataView(data)\n\n      // Points and normals, by default, are empty\n      var points = []\n      var normals = []\n      var indices = []\n\n      // Going to make a big array of strings\n      var vtk = []\n      var index = 0\n\n      function findString(buffer, start) {\n        var index = start\n        var c = buffer[index]\n        var s = []\n        while (c !== 10) {\n          s.push(String.fromCharCode(c))\n          index++\n          c = buffer[index]\n        }\n\n        return { start: start, end: index, next: index + 1, parsedString: s.join('') }\n      }\n\n      var state, line\n\n      while (true) {\n        // Get a string\n        state = findString(buffer, index)\n        line = state.parsedString\n\n        if (line.indexOf('DATASET') === 0) {\n          var dataset = line.split(' ')[1]\n\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset)\n        } else if (line.indexOf('POINTS') === 0) {\n          vtk.push(line)\n          // Add the points\n          numberOfPoints = parseInt(line.split(' ')[1], 10)\n\n          // Each point is 3 4-byte floats\n          count = numberOfPoints * 4 * 3\n\n          points = new Float32Array(numberOfPoints * 3)\n\n          pointIndex = state.next\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false)\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false)\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false)\n            pointIndex = pointIndex + 12\n          }\n\n          // increment our next pointer\n          state.next = state.next + count + 1\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10)\n          var size = parseInt(line.split(' ')[2], 10)\n          // 4 byte integers\n          count = size * 4\n\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips)\n          var indicesIndex = 0\n\n          pointIndex = state.next\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false)\n            var strip = []\n            pointIndex += 4\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false))\n              pointIndex += 4\n            }\n\n            // retrieves the n-2 triangles from the triangle strip\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j]\n                indices[indicesIndex++] = strip[j + 2]\n                indices[indicesIndex++] = strip[j + 1]\n              } else {\n                indices[indicesIndex++] = strip[j]\n                indices[indicesIndex++] = strip[j + 1]\n                indices[indicesIndex++] = strip[j + 2]\n              }\n            }\n          }\n\n          // increment our next pointer\n          state.next = state.next + count + 1\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10)\n          var size = parseInt(line.split(' ')[2], 10)\n          // 4 byte integers\n          count = size * 4\n\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips)\n          var indicesIndex = 0\n\n          pointIndex = state.next\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false)\n            var strip = []\n            pointIndex += 4\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false))\n              pointIndex += 4\n            }\n\n            // divide the polygon in n-2 triangle\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0]\n              indices[indicesIndex++] = strip[j]\n              indices[indicesIndex++] = strip[j + 1]\n            }\n          }\n\n          // increment our next pointer\n          state.next = state.next + count + 1\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10)\n\n          // Grab the next line\n          state = findString(buffer, state.next)\n\n          // Now grab the binary data\n          count = numberOfPoints * 4 * 3\n\n          normals = new Float32Array(numberOfPoints * 3)\n          pointIndex = state.next\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false)\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false)\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false)\n            pointIndex += 12\n          }\n\n          // Increment past our data\n          state.next = state.next + count\n        }\n\n        // Increment index\n        index = state.next\n\n        if (index >= buffer.byteLength) {\n          break\n        }\n      }\n\n      var geometry = new BufferGeometry()\n      geometry.setIndex(new BufferAttribute(indices, 1))\n      geometry.setAttribute('position', new BufferAttribute(points, 3))\n\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3))\n      }\n\n      return geometry\n    }\n\n    function Float32Concat(first, second) {\n      const firstLength = first.length,\n        result = new Float32Array(firstLength + second.length)\n\n      result.set(first)\n      result.set(second, firstLength)\n\n      return result\n    }\n\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n        result = new Int32Array(firstLength + second.length)\n\n      result.set(first)\n      result.set(second, firstLength)\n\n      return result\n    }\n\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {}\n\n        if (xml.nodeType === 1) {\n          // element\n\n          // do attributes\n\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {}\n\n              for (var j = 0; j < xml.attributes.length; j++) {\n                var attribute = xml.attributes.item(j)\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim()\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n\n          obj = xml.nodeValue.trim()\n        }\n\n        // do children\n        if (xml.hasChildNodes()) {\n          for (var i = 0; i < xml.childNodes.length; i++) {\n            var item = xml.childNodes.item(i)\n            var nodeName = item.nodeName\n\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item)\n\n              if (tmp !== '') obj[nodeName] = tmp\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName]\n                obj[nodeName] = [old]\n              }\n\n              var tmp = xmlToJson(item)\n\n              if (tmp !== '') obj[nodeName].push(tmp)\n            }\n          }\n        }\n\n        return obj\n      }\n\n      // Taken from Base64-js\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n        var i\n        var lookup = []\n        var revLookup = []\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n        var len = code.length\n\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i]\n        }\n\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i\n        }\n\n        revLookup['-'.charCodeAt(0)] = 62\n        revLookup['_'.charCodeAt(0)] = 63\n\n        var j, l, tmp, placeHolders, arr\n        var len = b64.length\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4')\n        }\n\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n        arr = new Arr((len * 3) / 4 - placeHolders)\n        l = placeHolders > 0 ? len - 4 : len\n\n        var L = 0\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp =\n            (revLookup[b64.charCodeAt(i)] << 18) |\n            (revLookup[b64.charCodeAt(i + 1)] << 12) |\n            (revLookup[b64.charCodeAt(i + 2)] << 6) |\n            revLookup[b64.charCodeAt(i + 3)]\n          arr[L++] = (tmp & 0xff0000) >> 16\n          arr[L++] = (tmp & 0xff00) >> 8\n          arr[L++] = tmp & 0xff\n        }\n\n        if (placeHolders === 2) {\n          tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n          arr[L++] = tmp & 0xff\n        } else if (placeHolders === 1) {\n          tmp =\n            (revLookup[b64.charCodeAt(i)] << 10) |\n            (revLookup[b64.charCodeAt(i + 1)] << 4) |\n            (revLookup[b64.charCodeAt(i + 2)] >> 2)\n          arr[L++] = (tmp >> 8) & 0xff\n          arr[L++] = tmp & 0xff\n        }\n\n        return arr\n      }\n\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0\n\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4\n        }\n\n        // Check the format\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array()\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array()\n          }\n\n          // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n          rawData = ele['#text']\n\n          byteData = Base64toByteArray(rawData)\n\n          blocks = byteData[0]\n          for (var i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | (byteData[i] << (i * numBytes))\n          }\n\n          headerSize = (blocks + 3) * numBytes\n          padding = headerSize % 3 > 0 ? 3 - (headerSize % 3) : 0\n          headerSize = headerSize + padding\n\n          dataOffsets = []\n          currentOffset = headerSize\n          dataOffsets.push(currentOffset)\n\n          // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n          cSizeStart = 3 * numBytes\n\n          for (var i = 0; i < blocks; i++) {\n            var currentBlockSize = byteData[i * numBytes + cSizeStart]\n\n            for (var j = 1; j < numBytes - 1; j++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | (byteData[i * numBytes + cSizeStart + j] << (j * 8))\n            }\n\n            currentOffset = currentOffset + currentBlockSize\n            dataOffsets.push(currentOffset)\n          }\n\n          for (var i = 0; i < dataOffsets.length - 1; i++) {\n            var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1]))\n            content = data.buffer\n\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content)\n              txt = Float32Concat(txt, content)\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content)\n              txt = Int32Concat(txt, content)\n            }\n          }\n\n          delete ele['#text']\n\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true\n              })\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text'])\n\n            //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n            content = content.slice(numBytes).buffer\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el\n              })\n            } else {\n              var content = new Int32Array(0).buffer\n            }\n          }\n\n          delete ele['#text']\n\n          // Get the content and optimize it\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content)\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content)\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content)\n\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true\n              })\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n        return txt\n      }\n\n      // Main part\n      // Get Dom\n      var dom = null\n\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml')\n        } catch (e) {\n          dom = null\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM')\n          dom.async = false\n\n          if (!(dom.loadXML(/* xml */))) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText)\n          }\n        } catch (e) {\n          dom = null\n        }\n      } else {\n        throw new Error('Cannot parse xml string!')\n      }\n\n      // Get the doc\n      var doc = dom.documentElement\n      // Convert to json\n      var json = xmlToJson(doc)\n      var points = []\n      var normals = []\n      var indices = []\n\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece\n        var compressed = json.attributes.hasOwnProperty('compressor')\n\n        // Can be optimized\n        // Loop through the sections\n        var sections = ['PointData', 'Points', 'Strips', 'Polys'] // +['CellData', 'Verts', 'Lines'];\n        var sectionIndex = 0,\n          numberOfSections = sections.length\n\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]]\n\n          // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray\n            } else {\n              var arr = [section.DataArray]\n            }\n\n            var dataArrayIndex = 0,\n              numberOfDataArrays = arr.length\n\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed)\n              }\n\n              dataArrayIndex++\n            }\n\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints)\n                var normalsName = section.attributes.Normals\n\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents\n                      normals = new Float32Array(numberOfPoints * components)\n                      normals.set(arr[i].text, 0)\n                    }\n                  }\n                }\n\n                break\n\n              // if it is points\n              case 'Points':\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints)\n\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents\n                  points = new Float32Array(numberOfPoints * components)\n                  points.set(section.DataArray.text, 0)\n                }\n\n                break\n\n              // if it is strips\n              case 'Strips':\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips)\n\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length)\n                  var offset = new Int32Array(section.DataArray[1].text.length)\n                  connectivity.set(section.DataArray[0].text, 0)\n                  offset.set(section.DataArray[1].text, 0)\n\n                  var size = numberOfStrips + connectivity.length\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips)\n\n                  var indicesIndex = 0\n\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = []\n\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s])\n\n                      if (i > 0) len0 = offset[i - 1]\n                    }\n\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j]\n                        indices[indicesIndex++] = strip[j + 2]\n                        indices[indicesIndex++] = strip[j + 1]\n                      } else {\n                        indices[indicesIndex++] = strip[j]\n                        indices[indicesIndex++] = strip[j + 1]\n                        indices[indicesIndex++] = strip[j + 2]\n                      }\n\n                      if (i > 0) len0 = offset[i - 1]\n                    }\n                  }\n                }\n\n                break\n\n              // if it is polys\n              case 'Polys':\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys)\n\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length)\n                  var offset = new Int32Array(section.DataArray[1].text.length)\n                  connectivity.set(section.DataArray[0].text, 0)\n                  offset.set(section.DataArray[1].text, 0)\n\n                  var size = numberOfPolys + connectivity.length\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys)\n                  var indicesIndex = 0,\n                    connectivityIndex = 0\n                  var i = 0,\n                    len = numberOfPolys,\n                    len0 = 0\n\n                  while (i < len) {\n                    var poly = []\n                    var s = 0,\n                      len1 = offset[i]\n\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++])\n                      s++\n                    }\n\n                    var j = 1\n\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0]\n                      indices[indicesIndex++] = poly[j]\n                      indices[indicesIndex++] = poly[j + 1]\n                      j++\n                    }\n\n                    i++\n                    len0 = offset[i - 1]\n                  }\n                }\n\n                break\n\n              default:\n                break\n            }\n          }\n\n          sectionIndex++\n        }\n\n        var geometry = new BufferGeometry()\n        geometry.setIndex(new BufferAttribute(indices, 1))\n        geometry.setAttribute('position', new BufferAttribute(points, 3))\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3))\n        }\n\n        return geometry\n      } else {\n        throw new Error('Unsupported DATASET type')\n      }\n    }\n\n    // get the 5 first lines of the files to check if there is the key word binary\n    var meta = decodeText(new Uint8Array(data, 0, 250)).split('\\n')\n\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(decodeText(data))\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(decodeText(data))\n    } else {\n      return parseBinary(data)\n    }\n  }\n}\n\nexport { VTKLoader }\n"],"names":["data","buffer","index","s","j","i","len","arr","compressed"],"mappings":"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"}},
    {"offset": {"line": 18844, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/LUT3dlLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/LUT3dlLoader.js"],"sourcesContent":["// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\n// https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258\nimport { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, ClampToEdgeWrapping, LinearFilter } from 'three'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nexport class LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('text')\n    loader.load(\n      url,\n      (text) => {\n        try {\n          onLoad(this.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          this.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str\n      .replace(/^#.*?(\\n|\\r)/gm, '')\n      .replace(/^\\s*?(\\n|\\r)/gm, '')\n      .trim()\n\n    const lines = str.split(/[\\n\\r]+/g)\n\n    // first line is the positions on the grid that are provided by the LUT\n    const gridLines = lines[0]\n      .trim()\n      .split(/\\s+/g)\n      .map((e) => parseFloat(e))\n    const gridStep = gridLines[1] - gridLines[0]\n    const size = gridLines.length\n\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.')\n      }\n    }\n\n    const dataArray = new Array(size * size * size * 4)\n    let index = 0\n    let maxOutputValue = 0.0\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim()\n      const split = line.split(/\\s/g)\n\n      const r = parseFloat(split[0])\n      const g = parseFloat(split[1])\n      const b = parseFloat(split[2])\n      maxOutputValue = Math.max(maxOutputValue, r, g, b)\n\n      const bLayer = index % size\n      const gLayer = Math.floor(index / size) % size\n      const rLayer = Math.floor(index / (size * size)) % size\n\n      // b grows first, then g, then r\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer\n      dataArray[4 * pixelIndex + 0] = r\n      dataArray[4 * pixelIndex + 1] = g\n      dataArray[4 * pixelIndex + 2] = b\n      dataArray[4 * pixelIndex + 3] = 1.0\n      index += 1\n    }\n\n    // Find the apparent bit depth of the stored RGB values and map the\n    // values to [ 0, 255 ].\n    const bits = Math.ceil(Math.log2(maxOutputValue))\n    const maxBitValue = Math.pow(2.0, bits)\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0]\n      const g = dataArray[i + 1]\n      const b = dataArray[i + 2]\n      dataArray[i + 0] = (255 * r) / maxBitValue // r\n      dataArray[i + 1] = (255 * g) / maxBitValue // g\n      dataArray[i + 2] = (255 * b) / maxBitValue // b\n    }\n\n    const data = new Uint8Array(dataArray)\n    const texture = new DataTexture()\n    texture.image.data = data\n    texture.image.width = size\n    texture.image.height = size * size\n    texture.format = RGBAFormat\n    texture.type = UnsignedByteType\n    texture.magFilter = LinearFilter\n    texture.minFilter = LinearFilter\n    texture.wrapS = ClampToEdgeWrapping\n    texture.wrapT = ClampToEdgeWrapping\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const texture3D = new Data3DTexture()\n    texture3D.image.data = data\n    texture3D.image.width = size\n    texture3D.image.height = size\n    texture3D.image.depth = size\n    texture3D.format = RGBAFormat\n    texture3D.type = UnsignedByteType\n    texture3D.magFilter = LinearFilter\n    texture3D.minFilter = LinearFilter\n    texture3D.wrapS = ClampToEdgeWrapping\n    texture3D.wrapT = ClampToEdgeWrapping\n    texture3D.wrapR = ClampToEdgeWrapping\n    texture3D.generateMipmaps = false\n    texture3D.needsUpdate = true\n\n    return {\n      size,\n      texture,\n      texture3D,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 18951, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/DDSLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/DDSLoader.js"],"sourcesContent":["import {\n  CompressedTextureLoader,\n  RGBAFormat,\n  RGBA_S3TC_DXT3_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_S3TC_DXT1_Format,\n} from 'three'\n\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer, loadMipmaps) {\n    const dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 }\n\n    // Adapted from @toji's DDS utils\n    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n    // All values and structures referenced from:\n    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n    const DDS_MAGIC = 0x20534444\n\n    // let DDSD_CAPS = 0x1;\n    // let DDSD_HEIGHT = 0x2;\n    // let DDSD_WIDTH = 0x4;\n    // let DDSD_PITCH = 0x8;\n    // let DDSD_PIXELFORMAT = 0x1000;\n    const DDSD_MIPMAPCOUNT = 0x20000\n    // let DDSD_LINEARSIZE = 0x80000;\n    // let DDSD_DEPTH = 0x800000;\n\n    // let DDSCAPS_COMPLEX = 0x8;\n    // let DDSCAPS_MIPMAP = 0x400000;\n    // let DDSCAPS_TEXTURE = 0x1000;\n\n    const DDSCAPS2_CUBEMAP = 0x200\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\n    // let DDSCAPS2_VOLUME = 0x200000;\n\n    // let DDPF_ALPHAPIXELS = 0x1;\n    // let DDPF_ALPHA = 0x2;\n    const DDPF_FOURCC = 0x4\n    // let DDPF_RGB = 0x40;\n    // let DDPF_YUV = 0x200;\n    // let DDPF_LUMINANCE = 0x20000;\n\n    function fourCCToInt32(value) {\n      return (\n        value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24)\n      )\n    }\n\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff)\n    }\n\n    function loadARGBMip(buffer, dataOffset, width, height) {\n      const dataLength = width * height * 4\n      const srcBuffer = new Uint8Array(buffer, dataOffset, dataLength)\n      const byteArray = new Uint8Array(dataLength)\n      let dst = 0\n      let src = 0\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src]\n          src++\n          const g = srcBuffer[src]\n          src++\n          const r = srcBuffer[src]\n          src++\n          const a = srcBuffer[src]\n          src++\n          byteArray[dst] = r\n          dst++ //r\n          byteArray[dst] = g\n          dst++ //g\n          byteArray[dst] = b\n          dst++ //b\n          byteArray[dst] = a\n          dst++ //a\n        }\n      }\n\n      return byteArray\n    }\n\n    const FOURCC_DXT1 = fourCCToInt32('DXT1')\n    const FOURCC_DXT3 = fourCCToInt32('DXT3')\n    const FOURCC_DXT5 = fourCCToInt32('DXT5')\n    const FOURCC_ETC1 = fourCCToInt32('ETC1')\n\n    const headerLengthInt = 31 // The header length in 32 bit ints\n\n    // Offsets into the header array\n\n    const off_magic = 0\n\n    const off_size = 1\n    const off_flags = 2\n    const off_height = 3\n    const off_width = 4\n\n    const off_mipmapCount = 7\n\n    const off_pfFlags = 20\n    const off_pfFourCC = 21\n    const off_RGBBitCount = 22\n    const off_RBitMask = 23\n    const off_GBitMask = 24\n    const off_BBitMask = 25\n    const off_ABitMask = 26\n\n    // let off_caps = 27;\n    const off_caps2 = 28\n    // let off_caps3 = 29;\n    // let off_caps4 = 30;\n\n    // Parse header\n\n    const header = new Int32Array(buffer, 0, headerLengthInt)\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.')\n      return dds\n    }\n\n    if (!header[off_pfFlags] & DDPF_FOURCC) {\n      console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.')\n      return dds\n    }\n\n    let blockBytes\n\n    const fourCC = header[off_pfFourCC]\n\n    let isRGBAUncompressed = false\n\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8\n        dds.format = RGB_S3TC_DXT1_Format\n        break\n\n      case FOURCC_DXT3:\n        blockBytes = 16\n        dds.format = RGBA_S3TC_DXT3_Format\n        break\n\n      case FOURCC_DXT5:\n        blockBytes = 16\n        dds.format = RGBA_S3TC_DXT5_Format\n        break\n\n      case FOURCC_ETC1:\n        blockBytes = 8\n        dds.format = RGB_ETC1_Format\n        break\n\n      default:\n        if (\n          header[off_RGBBitCount] === 32 &&\n          header[off_RBitMask] & 0xff0000 &&\n          header[off_GBitMask] & 0xff00 &&\n          header[off_BBitMask] & 0xff &&\n          header[off_ABitMask] & 0xff000000\n        ) {\n          isRGBAUncompressed = true\n          blockBytes = 64\n          dds.format = RGBAFormat\n        } else {\n          console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC))\n          return dds\n        }\n    }\n\n    dds.mipmapCount = 1\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount])\n    }\n\n    const caps2 = header[off_caps2]\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false\n    if (\n      dds.isCubemap &&\n      (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) ||\n        !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))\n    ) {\n      console.error('THREE.DDSLoader.parse: Incomplete cubemap faces')\n      return dds\n    }\n\n    dds.width = header[off_width]\n    dds.height = header[off_height]\n\n    let dataOffset = header[off_size] + 4\n\n    // Extract mipmaps buffers\n\n    const faces = dds.isCubemap ? 6 : 1\n\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width\n      let height = dds.height\n\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength\n\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height)\n          dataLength = byteArray.length\n        } else {\n          dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength)\n        }\n\n        const mipmap = { data: byteArray, width: width, height: height }\n        dds.mipmaps.push(mipmap)\n\n        dataOffset += dataLength\n\n        width = Math.max(width >> 1, 1)\n        height = Math.max(height >> 1, 1)\n      }\n    }\n\n    return dds\n  }\n}\n\nexport { DDSLoader }\n"],"names":["buffer","dataOffset"],"mappings":"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"}},
    {"offset": {"line": 19117, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/PVRLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/PVRLoader.js"],"sourcesContent":["import {\n  CompressedTextureLoader,\n  RGBA_PVRTC_2BPPV1_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGB_PVRTC_2BPPV1_Format,\n  RGB_PVRTC_4BPPV1_Format,\n} from 'three'\n\n/*\n *\t PVR v2 (legacy) parser\n *   TODO : Add Support for PVR v3 format\n *   TODO : implement loadMipmaps option\n */\n\nclass PVRLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer, loadMipmaps) {\n    const headerLengthInt = 13\n    const header = new Uint32Array(buffer, 0, headerLengthInt)\n\n    const pvrDatas = {\n      buffer: buffer,\n      header: header,\n      loadMipmaps: loadMipmaps,\n    }\n\n    if (header[0] === 0x03525650) {\n      // PVR v3\n\n      return _parseV3(pvrDatas)\n    } else if (header[11] === 0x21525650) {\n      // PVR v2\n\n      return _parseV2(pvrDatas)\n    } else {\n      console.error('THREE.PVRLoader: Unknown PVR format.')\n    }\n  }\n}\n\nfunction _parseV3(pvrDatas) {\n  const header = pvrDatas.header\n  let bpp, format\n\n  const metaLen = header[12],\n    pixelFormat = header[2],\n    height = header[6],\n    width = header[7],\n    // numSurfs = header[ 9 ],\n    numFaces = header[10],\n    numMipmaps = header[11]\n\n  switch (pixelFormat) {\n    case 0: // PVRTC 2bpp RGB\n      bpp = 2\n      format = RGB_PVRTC_2BPPV1_Format\n      break\n\n    case 1: // PVRTC 2bpp RGBA\n      bpp = 2\n      format = RGBA_PVRTC_2BPPV1_Format\n      break\n\n    case 2: // PVRTC 4bpp RGB\n      bpp = 4\n      format = RGB_PVRTC_4BPPV1_Format\n      break\n\n    case 3: // PVRTC 4bpp RGBA\n      bpp = 4\n      format = RGBA_PVRTC_4BPPV1_Format\n      break\n\n    default:\n      console.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat)\n  }\n\n  pvrDatas.dataPtr = 52 + metaLen\n  pvrDatas.bpp = bpp\n  pvrDatas.format = format\n  pvrDatas.width = width\n  pvrDatas.height = height\n  pvrDatas.numSurfaces = numFaces\n  pvrDatas.numMipmaps = numMipmaps\n  pvrDatas.isCubemap = numFaces === 6\n\n  return _extract(pvrDatas)\n}\n\nfunction _parseV2(pvrDatas) {\n  const header = pvrDatas.header\n\n  const headerLength = header[0],\n    height = header[1],\n    width = header[2],\n    numMipmaps = header[3],\n    flags = header[4],\n    // dataLength = header[ 5 ],\n    // bpp =  header[ 6 ],\n    // bitmaskRed = header[ 7 ],\n    // bitmaskGreen = header[ 8 ],\n    // bitmaskBlue = header[ 9 ],\n    bitmaskAlpha = header[10],\n    // pvrTag = header[ 11 ],\n    numSurfs = header[12]\n\n  const TYPE_MASK = 0xff\n  const PVRTC_2 = 24,\n    PVRTC_4 = 25\n\n  const formatFlags = flags & TYPE_MASK\n\n  let bpp, format\n  const _hasAlpha = bitmaskAlpha > 0\n\n  if (formatFlags === PVRTC_4) {\n    format = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format\n    bpp = 4\n  } else if (formatFlags === PVRTC_2) {\n    format = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format\n    bpp = 2\n  } else {\n    console.error('THREE.PVRLoader: Unknown PVR format:', formatFlags)\n  }\n\n  pvrDatas.dataPtr = headerLength\n  pvrDatas.bpp = bpp\n  pvrDatas.format = format\n  pvrDatas.width = width\n  pvrDatas.height = height\n  pvrDatas.numSurfaces = numSurfs\n  pvrDatas.numMipmaps = numMipmaps + 1\n\n  // guess cubemap type seems tricky in v2\n  // it juste a pvr containing 6 surface (no explicit cubemap type)\n  pvrDatas.isCubemap = numSurfs === 6\n\n  return _extract(pvrDatas)\n}\n\nfunction _extract(pvrDatas) {\n  const pvr = {\n    mipmaps: [],\n    width: pvrDatas.width,\n    height: pvrDatas.height,\n    format: pvrDatas.format,\n    mipmapCount: pvrDatas.numMipmaps,\n    isCubemap: pvrDatas.isCubemap,\n  }\n\n  const buffer = pvrDatas.buffer\n\n  let dataOffset = pvrDatas.dataPtr,\n    dataSize = 0,\n    blockSize = 0,\n    blockWidth = 0,\n    blockHeight = 0,\n    widthBlocks = 0,\n    heightBlocks = 0\n\n  const bpp = pvrDatas.bpp,\n    numSurfs = pvrDatas.numSurfaces\n\n  if (bpp === 2) {\n    blockWidth = 8\n    blockHeight = 4\n  } else {\n    blockWidth = 4\n    blockHeight = 4\n  }\n\n  blockSize = (blockWidth * blockHeight * bpp) / 8\n\n  pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs\n\n  let mipLevel = 0\n\n  while (mipLevel < pvrDatas.numMipmaps) {\n    const sWidth = pvrDatas.width >> mipLevel,\n      sHeight = pvrDatas.height >> mipLevel\n\n    widthBlocks = sWidth / blockWidth\n    heightBlocks = sHeight / blockHeight\n\n    // Clamp to minimum number of blocks\n    if (widthBlocks < 2) widthBlocks = 2\n    if (heightBlocks < 2) heightBlocks = 2\n\n    dataSize = widthBlocks * heightBlocks * blockSize\n\n    for (let surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\n      const byteArray = new Uint8Array(buffer, dataOffset, dataSize)\n\n      const mipmap = {\n        data: byteArray,\n        width: sWidth,\n        height: sHeight,\n      }\n\n      pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap\n\n      dataOffset += dataSize\n    }\n\n    mipLevel++\n  }\n\n  return pvr\n}\n\nexport { PVRLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 19254, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/GCodeLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/GCodeLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n} from 'three'\n\n/**\n * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n *\n * Gcode files are composed by commands used by machines to create objects.\n *\n * @class GCodeLoader\n * @param {Manager} manager Loading manager.\n */\n\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.splitLayer = false\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false }\n    let layers = []\n\n    let currentLayer = undefined\n\n    const pathMaterial = new LineBasicMaterial({ color: 0xff0000 })\n    pathMaterial.name = 'path'\n\n    const extrudingMaterial = new LineBasicMaterial({ color: 0x00ff00 })\n    extrudingMaterial.name = 'extruded'\n\n    function newLayer(line) {\n      currentLayer = { vertex: [], pathVertex: [], z: line.z }\n      layers.push(currentLayer)\n    }\n\n    //Create lie segment between p1 and p2\n    function addSegment(p1, p2) {\n      if (currentLayer === undefined) {\n        newLayer(p1)\n      }\n\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z)\n        currentLayer.vertex.push(p2.x, p2.y, p2.z)\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z)\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z)\n      }\n    }\n\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1\n    }\n\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2\n    }\n\n    let lines = data.replace(/;.+/g, '').split('\\n')\n\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(' ')\n      let cmd = tokens[0].toUpperCase()\n\n      //Argumments\n      let args = {}\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== undefined) {\n          let key = token[0].toLowerCase()\n          let value = parseFloat(token.substring(1))\n          args[key] = value\n        }\n      })\n\n      //Process commands\n      //G0/G1  Linear Movement\n      if (cmd === 'G0' || cmd === 'G1') {\n        let line = {\n          x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n          y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n          z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n          e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n          f: args.f !== undefined ? absolute(state.f, args.f) : state.f,\n        }\n\n        //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0\n\n          if (currentLayer == undefined || line.z != currentLayer.z) {\n            newLayer(line)\n          }\n        }\n\n        addSegment(state, line)\n        state = line\n      } else if (cmd === 'G2' || cmd === 'G3') {\n        //G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n        //console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n      } else if (cmd === 'G90') {\n        //G90: Set to Absolute Positioning\n        state.relative = false\n      } else if (cmd === 'G91') {\n        //G91: Set to state.relative Positioning\n        state.relative = true\n      } else if (cmd === 'G92') {\n        //G92: Set Position\n        let line = state\n        line.x = args.x !== undefined ? args.x : line.x\n        line.y = args.y !== undefined ? args.y : line.y\n        line.z = args.z !== undefined ? args.z : line.z\n        line.e = args.e !== undefined ? args.e : line.e\n        state = line\n      } else {\n        //console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n      }\n    }\n\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3))\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial)\n      segments.name = 'layer' + i\n      object.add(segments)\n    }\n\n    const object = new Group()\n    object.name = 'gcode'\n\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i]\n        addObject(layer.vertex, true, i)\n        addObject(layer.pathVertex, false, i)\n      }\n    } else {\n      const vertex = [],\n        pathVertex = []\n\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i]\n        let layerVertex = layer.vertex\n        let layerPathVertex = layer.pathVertex\n\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j])\n        }\n\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j])\n        }\n      }\n\n      addObject(vertex, true, layers.length)\n      addObject(pathVertex, false, layers.length)\n    }\n\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0))\n\n    return object\n  }\n}\n\nexport { GCodeLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 19413, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/BasisTextureLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/BasisTextureLoader.js"],"sourcesContent":["import {\n  CompressedTexture,\n  FileLoader,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  UnsignedByteType,\n} from 'three'\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap()\n\nconst BasisTextureLoader = /* @__PURE__ */ (() => {\n  class BasisTextureLoader extends Loader {\n    /* CONSTANTS */\n\n    static BasisFormat = {\n      ETC1S: 0,\n      UASTC_4x4: 1,\n    }\n\n    static TranscoderFormat = {\n      ETC1: 0,\n      ETC2: 1,\n      BC1: 2,\n      BC3: 3,\n      BC4: 4,\n      BC5: 5,\n      BC7_M6_OPAQUE_ONLY: 6,\n      BC7_M5: 7,\n      PVRTC1_4_RGB: 8,\n      PVRTC1_4_RGBA: 9,\n      ASTC_4x4: 10,\n      ATC_RGB: 11,\n      ATC_RGBA_INTERPOLATED_ALPHA: 12,\n      RGBA32: 13,\n      RGB565: 14,\n      BGR565: 15,\n      RGBA4444: 16,\n    }\n\n    static EngineFormat = {\n      RGBAFormat: RGBAFormat,\n      RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n      RGBA_BPTC_Format: RGBA_BPTC_Format,\n      RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n      RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n      RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n      RGB_ETC1_Format: RGB_ETC1_Format,\n      RGB_ETC2_Format: RGB_ETC2_Format,\n      RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n      RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n    }\n\n    /* WEB WORKER */\n\n    static BasisWorker = function () {\n      let config\n      let transcoderPending\n      let BasisModule\n\n      const EngineFormat = _EngineFormat\n      const TranscoderFormat = _TranscoderFormat\n      const BasisFormat = _BasisFormat\n\n      onmessage = function (e) {\n        const message = e.data\n\n        switch (message.type) {\n          case 'init':\n            config = message.config\n            init(message.transcoderBinary)\n            break\n\n          case 'transcode':\n            transcoderPending.then(() => {\n              try {\n                const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel\n                  ? transcodeLowLevel(message.taskConfig)\n                  : transcode(message.buffers[0])\n\n                const buffers = []\n\n                for (let i = 0; i < mipmaps.length; ++i) {\n                  buffers.push(mipmaps[i].data.buffer)\n                }\n\n                self.postMessage(\n                  { type: 'transcode', id: message.id, width, height, hasAlpha, mipmaps, format },\n                  buffers,\n                )\n              } catch (error) {\n                console.error(error)\n\n                self.postMessage({ type: 'error', id: message.id, error: error.message })\n              }\n            })\n            break\n        }\n      }\n\n      function init(wasmBinary) {\n        transcoderPending = new Promise((resolve) => {\n          BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n          BASIS(BasisModule)\n        }).then(() => {\n          BasisModule.initializeBasis()\n        })\n      }\n\n      function transcodeLowLevel(taskConfig) {\n        const { basisFormat, width, height, hasAlpha } = taskConfig\n\n        const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n        const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n        assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.')\n\n        const mipmaps = []\n\n        if (basisFormat === BasisFormat.ETC1S) {\n          const transcoder = new BasisModule.LowLevelETC1SImageTranscoder()\n\n          const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData\n\n          try {\n            let ok\n\n            ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData)\n\n            assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.')\n\n            ok = transcoder.decodeTables(tablesData)\n\n            assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.')\n\n            for (let i = 0; i < taskConfig.levels.length; i++) {\n              const level = taskConfig.levels[i]\n              const imageDesc = taskConfig.globalData.imageDescs[i]\n\n              const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n              const dst = new Uint8Array(dstByteLength)\n\n              ok = transcoder.transcodeImage(\n                transcoderFormat,\n                dst,\n                dstByteLength / blockByteLength,\n                level.data,\n                getWidthInBlocks(transcoderFormat, level.width),\n                getHeightInBlocks(transcoderFormat, level.height),\n                level.width,\n                level.height,\n                level.index,\n                imageDesc.rgbSliceByteOffset,\n                imageDesc.rgbSliceByteLength,\n                imageDesc.alphaSliceByteOffset,\n                imageDesc.alphaSliceByteLength,\n                imageDesc.imageFlags,\n                hasAlpha,\n                false,\n                0,\n                0,\n              )\n\n              assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.')\n\n              mipmaps.push({ data: dst, width: level.width, height: level.height })\n            }\n          } finally {\n            transcoder.delete()\n          }\n        } else {\n          for (let i = 0; i < taskConfig.levels.length; i++) {\n            const level = taskConfig.levels[i]\n\n            const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n            const dst = new Uint8Array(dstByteLength)\n\n            const ok = BasisModule.transcodeUASTCImage(\n              transcoderFormat,\n              dst,\n              dstByteLength / blockByteLength,\n              level.data,\n              getWidthInBlocks(transcoderFormat, level.width),\n              getHeightInBlocks(transcoderFormat, level.height),\n              level.width,\n              level.height,\n              level.index,\n              0,\n              level.data.byteLength,\n              0,\n              hasAlpha,\n              false,\n              0,\n              0,\n              -1,\n              -1,\n            )\n\n            assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.')\n\n            mipmaps.push({ data: dst, width: level.width, height: level.height })\n          }\n        }\n\n        return { width, height, hasAlpha, mipmaps, format: engineFormat }\n      }\n\n      function transcode(buffer) {\n        const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer))\n\n        const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n        const width = basisFile.getImageWidth(0, 0)\n        const height = basisFile.getImageHeight(0, 0)\n        const levels = basisFile.getNumLevels(0)\n        const hasAlpha = basisFile.getHasAlpha()\n\n        function cleanup() {\n          basisFile.close()\n          basisFile.delete()\n        }\n\n        const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n        if (!width || !height || !levels) {\n          cleanup()\n          throw new Error('THREE.BasisTextureLoader:\tInvalid texture')\n        }\n\n        if (!basisFile.startTranscoding()) {\n          cleanup()\n          throw new Error('THREE.BasisTextureLoader: .startTranscoding failed')\n        }\n\n        const mipmaps = []\n\n        for (let mip = 0; mip < levels; mip++) {\n          const mipWidth = basisFile.getImageWidth(0, mip)\n          const mipHeight = basisFile.getImageHeight(0, mip)\n          const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat))\n\n          const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha)\n\n          if (!status) {\n            cleanup()\n            throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.')\n          }\n\n          mipmaps.push({ data: dst, width: mipWidth, height: mipHeight })\n        }\n\n        cleanup()\n\n        return { width, height, hasAlpha, mipmaps, format: engineFormat }\n      }\n\n      //\n\n      // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n      // device capabilities, and texture dimensions. The list below ranks the formats separately\n      // for ETC1S and UASTC.\n      //\n      // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n      // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n      // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n      const FORMAT_OPTIONS = [\n        {\n          if: 'astcSupported',\n          basisFormat: [BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n          engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n          priorityETC1S: Infinity,\n          priorityUASTC: 1,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'bptcSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n          engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n          priorityETC1S: 3,\n          priorityUASTC: 2,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'dxtSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n          engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n          priorityETC1S: 4,\n          priorityUASTC: 5,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'etc2Supported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n          engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n          priorityETC1S: 1,\n          priorityUASTC: 3,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'etc1Supported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n          engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n          priorityETC1S: 2,\n          priorityUASTC: 4,\n          needsPowerOfTwo: false,\n        },\n        {\n          if: 'pvrtcSupported',\n          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n          transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n          engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n          priorityETC1S: 5,\n          priorityUASTC: 6,\n          needsPowerOfTwo: true,\n        },\n      ]\n\n      const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n        return a.priorityETC1S - b.priorityETC1S\n      })\n      const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n        return a.priorityUASTC - b.priorityUASTC\n      })\n\n      function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n        let transcoderFormat\n        let engineFormat\n\n        const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i]\n\n          if (!config[opt.if]) continue\n          if (!opt.basisFormat.includes(basisFormat)) continue\n          if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n          transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n          engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n          return { transcoderFormat, engineFormat }\n        }\n\n        console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n        transcoderFormat = TranscoderFormat.RGBA32\n        engineFormat = EngineFormat.RGBAFormat\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      function assert(ok, message) {\n        if (!ok) throw new Error(message)\n      }\n\n      function getWidthInBlocks(transcoderFormat, width) {\n        return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat))\n      }\n\n      function getHeightInBlocks(transcoderFormat, height) {\n        return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat))\n      }\n\n      function getTranscodedImageByteLength(transcoderFormat, width, height) {\n        const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n        if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n          return width * height * blockByteLength\n        }\n\n        if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n          // GL requires extra padding for very small textures:\n          // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n          const paddedWidth = (width + 3) & ~3\n          const paddedHeight = (height + 3) & ~3\n\n          return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8\n        }\n\n        return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength\n      }\n\n      function isPowerOfTwo(value) {\n        if (value <= 2) return true\n\n        return (value & (value - 1)) === 0 && value !== 0\n      }\n    }\n\n    constructor(manager) {\n      super(manager)\n\n      this.transcoderPath = ''\n      this.transcoderBinary = null\n      this.transcoderPending = null\n\n      this.workerLimit = 4\n      this.workerPool = []\n      this.workerNextTaskID = 1\n      this.workerSourceURL = ''\n      this.workerConfig = null\n    }\n\n    setTranscoderPath(path) {\n      this.transcoderPath = path\n\n      return this\n    }\n\n    setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit\n\n      return this\n    }\n\n    detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n        etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n        etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n        dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n        bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n        pvrtcSupported:\n          renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n          renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      }\n\n      return this\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      const loader = new FileLoader(this.manager)\n\n      loader.setResponseType('arraybuffer')\n      loader.setWithCredentials(this.withCredentials)\n\n      const texture = new CompressedTexture()\n\n      loader.load(\n        url,\n        (buffer) => {\n          // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n          // again from this thread.\n          if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer)\n\n            return cachedTask.promise.then(onLoad).catch(onError)\n          }\n\n          this._createTexture([buffer])\n            .then(function (_texture) {\n              texture.copy(_texture)\n              texture.needsUpdate = true\n\n              if (onLoad) onLoad(texture)\n            })\n            .catch(onError)\n        },\n        onProgress,\n        onError,\n      )\n\n      return texture\n    }\n\n    /** Low-level transcoding API, exposed for use by KTX2Loader. */\n    parseInternalAsync(options) {\n      const { levels } = options\n\n      const buffers = new Set()\n\n      for (let i = 0; i < levels.length; i++) {\n        buffers.add(levels[i].data.buffer)\n      }\n\n      return this._createTexture(Array.from(buffers), { ...options, lowLevel: true })\n    }\n\n    /**\n     * @param {ArrayBuffer[]} buffers\n     * @param {object?} config\n     * @return {Promise<CompressedTexture>}\n     */\n    _createTexture(buffers, config = {}) {\n      let worker\n      let taskID\n\n      const taskConfig = config\n      let taskCost = 0\n\n      for (let i = 0; i < buffers.length; i++) {\n        taskCost += buffers[i].byteLength\n      }\n\n      const texturePending = this._allocateWorker(taskCost)\n        .then((_worker) => {\n          worker = _worker\n          taskID = this.workerNextTaskID++\n\n          return new Promise((resolve, reject) => {\n            worker._callbacks[taskID] = { resolve, reject }\n\n            worker.postMessage({ type: 'transcode', id: taskID, buffers: buffers, taskConfig: taskConfig }, buffers)\n          })\n        })\n        .then((message) => {\n          const { mipmaps, width, height, format } = message\n\n          const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n          texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.needsUpdate = true\n\n          return texture\n        })\n\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n      texturePending\n        .catch(() => true)\n        .then(() => {\n          if (worker && taskID) {\n            worker._taskLoad -= taskCost\n            delete worker._callbacks[taskID]\n          }\n        })\n\n      // Cache the task result.\n      _taskCache.set(buffers[0], { promise: texturePending })\n\n      return texturePending\n    }\n\n    _initTranscoder() {\n      if (!this.transcoderPending) {\n        // Load transcoder wrapper.\n        const jsLoader = new FileLoader(this.manager)\n        jsLoader.setPath(this.transcoderPath)\n        jsLoader.setWithCredentials(this.withCredentials)\n        const jsContent = new Promise((resolve, reject) => {\n          jsLoader.load('basis_transcoder.js', resolve, undefined, reject)\n        })\n\n        // Load transcoder WASM binary.\n        const binaryLoader = new FileLoader(this.manager)\n        binaryLoader.setPath(this.transcoderPath)\n        binaryLoader.setResponseType('arraybuffer')\n        binaryLoader.setWithCredentials(this.withCredentials)\n        const binaryContent = new Promise((resolve, reject) => {\n          binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject)\n        })\n\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n          const fn = BasisTextureLoader.BasisWorker.toString()\n\n          const body = [\n            '/* constants */',\n            'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat),\n            'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat),\n            'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat),\n            '/* basis_transcoder.js */',\n            jsContent,\n            '/* worker */',\n            fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n          ].join('\\n')\n\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n          this.transcoderBinary = binaryContent\n        })\n      }\n\n      return this.transcoderPending\n    }\n\n    _allocateWorker(taskCost) {\n      return this._initTranscoder().then(() => {\n        if (this.workerPool.length < this.workerLimit) {\n          const worker = new Worker(this.workerSourceURL)\n\n          worker._callbacks = {}\n          worker._taskLoad = 0\n\n          worker.postMessage({\n            type: 'init',\n            config: this.workerConfig,\n            transcoderBinary: this.transcoderBinary,\n          })\n\n          worker.onmessage = function (e) {\n            const message = e.data\n\n            switch (message.type) {\n              case 'transcode':\n                worker._callbacks[message.id].resolve(message)\n                break\n\n              case 'error':\n                worker._callbacks[message.id].reject(message)\n                break\n\n              default:\n                console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"')\n            }\n          }\n\n          this.workerPool.push(worker)\n        } else {\n          this.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1\n          })\n        }\n\n        const worker = this.workerPool[this.workerPool.length - 1]\n\n        worker._taskLoad += taskCost\n\n        return worker\n      })\n    }\n\n    dispose() {\n      for (let i = 0; i < this.workerPool.length; i++) {\n        this.workerPool[i].terminate()\n      }\n\n      this.workerPool.length = 0\n\n      return this\n    }\n  }\n\n  return BasisTextureLoader\n})()\n\nexport { BasisTextureLoader }\n"],"names":["jsContent","binaryContent","worker","BasisTextureLoader"],"mappings":"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"}},
    {"offset": {"line": 19983, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/TDSLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/TDSLoader.js"],"sourcesContent":["import {\n  AdditiveBlending,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  TextureLoader,\n} from 'three'\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.debug = false\n\n    this.group = null\n    this.position = 0\n\n    this.materials = []\n    this.meshes = []\n  }\n\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n  parse(arraybuffer, path) {\n    this.group = new Group()\n    this.position = 0\n    this.materials = []\n    this.meshes = []\n\n    this.readFile(arraybuffer, path)\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i])\n    }\n\n    return this.group\n  }\n\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer)\n    const chunk = this.readChunk(data)\n\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk)\n\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data)\n          this.debugMessage('3DS file version: ' + version)\n        } else if (next === MDATA) {\n          this.resetPosition(data)\n          this.readMeshData(data, path)\n        } else {\n          this.debugMessage('Unknown main chunk: ' + next.toString(16))\n        }\n\n        next = this.nextChunk(data, chunk)\n      }\n    }\n\n    this.debugMessage('Parsed ' + this.meshes.length + ' meshes')\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data)\n        this.debugMessage('Mesh Version: ' + version)\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data)\n        this.debugMessage('Master scale: ' + scale)\n        this.group.scale.set(scale, scale, scale)\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage('Named Object')\n        this.resetPosition(data)\n        this.readNamedObject(data)\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage('Material')\n        this.resetPosition(data)\n        this.readMaterialEntry(data, path)\n      } else {\n        this.debugMessage('Unknown MDATA chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n  }\n\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n  readNamedObject(data) {\n    const chunk = this.readChunk(data)\n    const name = this.readString(data, 64)\n    chunk.cur = this.position\n\n    let next = this.nextChunk(data, chunk)\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data)\n        const mesh = this.readMesh(data)\n        mesh.name = name\n        this.meshes.push(mesh)\n      } else {\n        this.debugMessage('Unknown named object chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n  }\n\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n    const material = new MeshPhongMaterial()\n\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64)\n        this.debugMessage('   Name: ' + material.name)\n      } else if (next === MAT_WIRE) {\n        this.debugMessage('   Wireframe')\n        material.wireframe = true\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data)\n        material.wireframeLinewidth = value\n        this.debugMessage('   Wireframe Thickness: ' + value)\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide\n        this.debugMessage('   DoubleSided')\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage('   Additive Blending')\n        material.blending = AdditiveBlending\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage('   Diffuse Color')\n        material.color = this.readColor(data)\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage('   Specular Color')\n        material.specular = this.readColor(data)\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage('   Ambient color')\n        material.color = this.readColor(data)\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data)\n        material.shininess = shininess * 100\n        this.debugMessage('   Shininess : ' + shininess)\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data)\n        material.opacity = 1 - transparency\n        this.debugMessage('  Transparency : ' + transparency)\n        material.transparent = material.opacity < 1 ? true : false\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage('   ColorMap')\n        this.resetPosition(data)\n        material.map = this.readMap(data, path)\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage('   BumpMap')\n        this.resetPosition(data)\n        material.bumpMap = this.readMap(data, path)\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage('   OpacityMap')\n        this.resetPosition(data)\n        material.alphaMap = this.readMap(data, path)\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage('   SpecularMap')\n        this.resetPosition(data)\n        material.specularMap = this.readMap(data, path)\n      } else {\n        this.debugMessage('   Unknown material chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    this.materials[material.name] = material\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n  readMesh(data) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n\n    const geometry = new BufferGeometry()\n\n    const material = new MeshPhongMaterial()\n    const mesh = new Mesh(geometry, material)\n    mesh.name = 'mesh'\n\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data)\n\n        this.debugMessage('   Vertex: ' + points)\n\n        //BufferGeometry\n\n        const vertices = []\n\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data))\n          vertices.push(this.readFloat(data))\n          vertices.push(this.readFloat(data))\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data)\n        this.readFaceArray(data, mesh)\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data)\n\n        this.debugMessage('   UV: ' + texels)\n\n        //BufferGeometry\n\n        const uvs = []\n\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data))\n          uvs.push(this.readFloat(data))\n        }\n\n        geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage('   Tranformation Matrix (TODO)')\n\n        const values = []\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data)\n        }\n\n        const matrix = new Matrix4()\n\n        //X Line\n        matrix.elements[0] = values[0]\n        matrix.elements[1] = values[6]\n        matrix.elements[2] = values[3]\n        matrix.elements[3] = values[9]\n\n        //Y Line\n        matrix.elements[4] = values[2]\n        matrix.elements[5] = values[8]\n        matrix.elements[6] = values[5]\n        matrix.elements[7] = values[11]\n\n        //Z Line\n        matrix.elements[8] = values[1]\n        matrix.elements[9] = values[7]\n        matrix.elements[10] = values[4]\n        matrix.elements[11] = values[10]\n\n        //W Line\n        matrix.elements[12] = 0\n        matrix.elements[13] = 0\n        matrix.elements[14] = 0\n        matrix.elements[15] = 1\n\n        matrix.transpose()\n\n        const inverse = new Matrix4()\n        inverse.copy(matrix).invert()\n        geometry.applyMatrix4(inverse)\n\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale)\n      } else {\n        this.debugMessage('   Unknown mesh chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    geometry.computeVertexNormals()\n\n    return mesh\n  }\n\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data)\n    const faces = this.readWord(data)\n\n    this.debugMessage('   Faces: ' + faces)\n\n    const index = []\n\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data))\n\n      this.readWord(data) // visibility\n    }\n\n    mesh.geometry.setIndex(index)\n\n    //The rest of the FACE_ARRAY chunk is subchunks\n\n    let materialIndex = 0\n    let start = 0\n\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data)\n\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage('      Material Group')\n\n        this.resetPosition(data)\n\n        const group = this.readMaterialGroup(data)\n        const count = group.index.length * 3 // assuming successive indices\n\n        mesh.geometry.addGroup(start, count, materialIndex)\n\n        start += count\n        materialIndex++\n\n        const material = this.materials[group.name]\n\n        if (Array.isArray(mesh.material) === false) mesh.material = []\n\n        if (material !== undefined) {\n          mesh.material.push(material)\n        }\n      } else {\n        this.debugMessage('      Unknown face array chunk: ' + subchunk.toString(16))\n      }\n\n      this.endChunk(subchunk)\n    }\n\n    if (mesh.material.length === 1) mesh.material = mesh.material[0] // for backwards compatibility\n\n    this.endChunk(chunk)\n  }\n\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n  readMap(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n    let texture = {}\n\n    const loader = new TextureLoader(this.manager)\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128)\n        texture = loader.load(name)\n\n        this.debugMessage('      File: ' + path + name)\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data)\n        this.debugMessage('      OffsetX: ' + texture.offset.x)\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data)\n        this.debugMessage('      OffsetY: ' + texture.offset.y)\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data)\n        this.debugMessage('      RepeatX: ' + texture.repeat.x)\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data)\n        this.debugMessage('      RepeatY: ' + texture.repeat.y)\n      } else {\n        this.debugMessage('      Unknown map chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    return texture\n  }\n\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n  readMaterialGroup(data) {\n    this.readChunk(data)\n    const name = this.readString(data, 64)\n    const numFaces = this.readWord(data)\n\n    this.debugMessage('         Name: ' + name)\n    this.debugMessage('         Faces: ' + numFaces)\n\n    const index = []\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data))\n    }\n\n    return { name: name, index: index }\n  }\n\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n  readColor(data) {\n    const chunk = this.readChunk(data)\n    const color = new Color()\n\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data)\n      const g = this.readByte(data)\n      const b = this.readByte(data)\n\n      color.setRGB(r / 255, g / 255, b / 255)\n\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b)\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data)\n      const g = this.readFloat(data)\n      const b = this.readFloat(data)\n\n      color.setRGB(r, g, b)\n\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b)\n    } else {\n      this.debugMessage('      Unknown color chunk: ' + chunk.toString(16))\n    }\n\n    this.endChunk(chunk)\n    return color\n  }\n\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n  readChunk(data) {\n    const chunk = {}\n\n    chunk.cur = this.position\n    chunk.id = this.readWord(data)\n    chunk.size = this.readDWord(data)\n    chunk.end = chunk.cur + chunk.size\n    chunk.cur += 6\n\n    return chunk\n  }\n\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n  endChunk(chunk) {\n    this.position = chunk.end\n  }\n\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0\n    }\n\n    this.position = chunk.cur\n\n    try {\n      const next = this.readChunk(data)\n      chunk.cur += next.size\n      return next.id\n    } catch (e) {\n      this.debugMessage('Unable to read chunk at ' + this.position)\n      return 0\n    }\n  }\n\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n  resetPosition() {\n    this.position -= 6\n  }\n\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readByte(data) {\n    const v = data.getUint8(this.position, true)\n    this.position += 1\n    return v\n  }\n\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true)\n      this.position += 4\n      return v\n    } catch (e) {\n      this.debugMessage(e + ' ' + this.position + ' ' + data.byteLength)\n    }\n  }\n\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readInt(data) {\n    const v = data.getInt32(this.position, true)\n    this.position += 4\n    return v\n  }\n\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readShort(data) {\n    const v = data.getInt16(this.position, true)\n    this.position += 2\n    return v\n  }\n\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readDWord(data) {\n    const v = data.getUint32(this.position, true)\n    this.position += 4\n    return v\n  }\n\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readWord(data) {\n    const v = data.getUint16(this.position, true)\n    this.position += 2\n    return v\n  }\n\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n  readString(data, maxLength) {\n    let s = ''\n\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data)\n      if (!c) {\n        break\n      }\n\n      s += String.fromCharCode(c)\n    }\n\n    return s\n  }\n\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readPercentage(data) {\n    const chunk = this.readChunk(data)\n    let value\n\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100\n        break\n\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data)\n        break\n\n      default:\n        this.debugMessage('      Unknown percentage chunk: ' + chunk.toString(16))\n    }\n\n    this.endChunk(chunk)\n\n    return value\n  }\n\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message)\n    }\n  }\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4d4d\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3daa\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xc23d\nconst M3D_VERSION = 0x0002\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010\nconst COLOR_24 = 0x0011\nconst LIN_COLOR_24 = 0x0012\nconst LIN_COLOR_F = 0x0013\nconst INT_PERCENTAGE = 0x0030\nconst FLOAT_PERCENTAGE = 0x0031\nconst MDATA = 0x3d3d\nconst MESH_VERSION = 0x3d3e\nconst MASTER_SCALE = 0x0100\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xafff\nconst MAT_NAME = 0xa000\nconst MAT_AMBIENT = 0xa010\nconst MAT_DIFFUSE = 0xa020\nconst MAT_SPECULAR = 0xa030\nconst MAT_SHININESS = 0xa040\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xa050\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xa081\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xa083\nconst MAT_WIRE = 0xa085\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xa087\nconst MAT_TEXMAP = 0xa200\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xa210\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xa230\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xa204\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xa300\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xa354\nconst MAT_MAP_VSCALE = 0xa356\nconst MAT_MAP_UOFFSET = 0xa358\nconst MAT_MAP_VOFFSET = 0xa35a\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100\nconst POINT_ARRAY = 0x4110\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120\nconst MSH_MAT_GROUP = 0x4130\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140\nconst MESH_MATRIX = 0x4160\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 20613, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/LDrawLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/LDrawLoader.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Matrix4,\n  Mesh,\n  MeshStandardMaterial,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector3,\n  Ray,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0\nconst FINISH_TYPE_CHROME = 1\nconst FINISH_TYPE_PEARLESCENT = 2\nconst FINISH_TYPE_RUBBER = 3\nconst FINISH_TYPE_MATTE_METALLIC = 4\nconst FINISH_TYPE_METAL = 5\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_AS_IS = 0\nconst FILE_LOCATION_TRY_PARTS = 1\nconst FILE_LOCATION_TRY_P = 2\nconst FILE_LOCATION_TRY_MODELS = 3\nconst FILE_LOCATION_TRY_RELATIVE = 4\nconst FILE_LOCATION_TRY_ABSOLUTE = 5\nconst FILE_LOCATION_NOT_FOUND = 6\n\nconst MAIN_COLOUR_CODE = '16'\nconst MAIN_EDGE_COLOUR_CODE = '24'\n\nconst _tempVec0 = /* @__PURE__ */ new Vector3()\nconst _tempVec1 = /* @__PURE__ */ new Vector3()\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color(),\n          },\n          opacity: {\n            value: 1.0,\n          },\n        },\n      ]),\n\n      vertexShader: /* glsl */ `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n\n      fragmentShader: /* glsl */ `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `,\n    })\n\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n      },\n    })\n\n    this.setValues(parameters)\n    this.isLDrawConditionalLineMaterial = true\n  }\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material)\n    this.isConditionalLine = true\n  }\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i]\n    const vertices = face.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    const v2 = vertices[2]\n\n    _tempVec0.subVectors(v1, v0)\n    _tempVec1.subVectors(v2, v1)\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n  }\n}\n\nconst _ray = /* @__PURE__ */ new Ray()\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n  const hashMultiplier = (1 + 1e-10) * 1e2\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n\n    return `${x},${y},${z}`\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`\n  }\n\n  // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize()\n\n    const scalar = v0.dot(targetRay.direction)\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar)\n\n    return targetRay\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction)\n  }\n\n  const hardEdges = new Set()\n  const hardEdgeRays = new Map()\n  const halfEdgeList = {}\n  const normals = []\n\n  // Save the list of hard edges by hash\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i]\n    const vertices = ls.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    hardEdges.add(hashEdge(v0, v1))\n    hardEdges.add(hashEdge(v1, v0))\n\n    // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray())\n      const rh1 = hashRay(ray)\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray)\n        const rh2 = hashRay(ray)\n\n        const info = {\n          ray,\n          distances: [],\n        }\n\n        hardEdgeRays.set(rh1, info)\n        hardEdgeRays.set(rh2, info)\n      }\n\n      // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n      const info = hardEdgeRays.get(rh1)\n      let d0 = info.ray.direction.dot(v0)\n      let d1 = info.ray.direction.dot(v1)\n      if (d0 > d1) {\n        ;[d0, d1] = [d1, d0]\n      }\n\n      info.distances.push(d0, d1)\n    }\n  }\n\n  // track the half edges associated with each triangle\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i]\n    const vertices = tri.vertices\n    const vertCount = vertices.length\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2\n      const next = (i2 + 1) % vertCount\n      const v0 = vertices[index]\n      const v1 = vertices[next]\n      const hash = hashEdge(v0, v1)\n\n      // don't add the triangle if the edge is supposed to be hard\n      if (hardEdges.has(hash)) {\n        continue\n      }\n\n      // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray)\n\n        const rayHash = hashRay(_ray)\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash)\n          const { ray, distances } = info\n          let d0 = ray.direction.dot(v0)\n          let d1 = ray.direction.dot(v1)\n\n          if (d0 > d1) {\n            ;[d0, d1] = [d1, d0]\n          }\n\n          // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n          let found = false\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true\n              break\n            }\n          }\n\n          if (found) {\n            continue\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri,\n      }\n      halfEdgeList[hash] = info\n    }\n  }\n\n  // Iterate until we've tried to connect all faces to share normals\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key]\n      break\n    }\n\n    if (halfEdge === null) {\n      break\n    }\n\n    // Exhaustively find all connected faces\n    const queue = [halfEdge]\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri\n      const vertices = tri.vertices\n      const vertNormals = tri.normals\n      const faceNormal = tri.faceNormal\n\n      // Check if any edge is connected to another triangle edge\n      const vertCount = vertices.length\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2\n        const next = (i2 + 1) % vertCount\n        const v0 = vertices[index]\n        const v1 = vertices[next]\n\n        // delete this triangle from the list so it won't be found again\n        const hash = hashEdge(v0, v1)\n        delete halfEdgeList[hash]\n\n        const reverseHash = hashEdge(v1, v0)\n        const otherInfo = halfEdgeList[reverseHash]\n        if (otherInfo) {\n          const otherTri = otherInfo.tri\n          const otherIndex = otherInfo.index\n          const otherNormals = otherTri.normals\n          const otherVertCount = otherNormals.length\n          const otherFaceNormal = otherTri.faceNormal\n\n          // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue\n          }\n\n          // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo)\n            delete halfEdgeList[reverseHash]\n          }\n\n          // share the first normal\n          const otherNext = (otherIndex + 1) % otherVertCount\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm)\n            vertNormals[index].norm = otherNormals[otherNext].norm\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext]\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = { norm: new Vector3() }\n            normals.push(sharedNormal1.norm)\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1\n            sharedNormal1.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1\n            sharedNormal1.norm.add(otherFaceNormal)\n          }\n\n          // share the second normal\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm)\n            vertNormals[next].norm = otherNormals[otherIndex].norm\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex]\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() }\n            normals.push(sharedNormal2.norm)\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2\n            sharedNormal2.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2\n            sharedNormal2.norm.add(otherFaceNormal)\n          }\n        }\n      }\n    }\n  }\n\n  // The normals of each face have been added up so now we average them by normalizing the vector.\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize()\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part'\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart'\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line\n    this.lineLength = line.length\n    this.currentCharIndex = 0\n    this.currentChar = ' '\n    this.lineNumber = lineNumber\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return\n      }\n\n      this.currentCharIndex++\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++\n\n    // Seek space\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break\n      }\n\n      this.currentCharIndex++\n    }\n\n    const pos1 = this.currentCharIndex\n\n    this.seekNonSpace()\n\n    return this.line.substring(pos0, pos1)\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()))\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength)\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : ''\n  }\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader\n    this._cache = {}\n  }\n\n  cloneResult(original) {\n    const result = {}\n\n    // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null,\n      }\n    })\n\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone()),\n      }\n    })\n\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n      }\n    })\n\n    // none if this is subsequently modified\n    result.type = original.type\n    result.category = original.category\n    result.keywords = original.keywords\n    result.subobjects = original.subobjects\n    result.totalFaces = original.totalFaces\n    result.startingConstructionStep = original.startingConstructionStep\n    result.materials = original.materials\n    result.group = null\n    return result\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false\n    let locationState = FILE_LOCATION_AS_IS\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase()\n            subobjectURL = fileName\n            triedLowerCase = true\n            locationState = FILE_LOCATION_AS_IS\n          }\n\n          break\n      }\n\n      const loader = this.loader\n      const fileLoader = new FileLoader(loader.manager)\n      fileLoader.setPath(loader.partsLibraryPath)\n      fileLoader.setRequestHeader(loader.requestHeader)\n      fileLoader.setWithCredentials(loader.withCredentials)\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL)\n        return text\n      } catch {\n        continue\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.')\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader\n\n    // final results\n    const faces = []\n    const lineSegments = []\n    const conditionalSegments = []\n    const subobjects = []\n    const materials = {}\n\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null\n    }\n\n    let type = 'Model'\n    let category = null\n    let keywords = null\n    let totalFaces = 0\n\n    // split into lines\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    const lines = text.split('\\n')\n    const numLines = lines.length\n\n    let parsingEmbeddedFiles = false\n    let currentEmbeddedFileName = null\n    let currentEmbeddedText = null\n\n    let bfcCertified = false\n    let bfcCCW = true\n    let bfcInverted = false\n    let bfcCull = true\n\n    let startingConstructionStep = false\n\n    // Parse all line commands\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex]\n\n      if (line.length === 0) continue\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText)\n\n          // New embedded text file\n          currentEmbeddedFileName = line.substring(7)\n          currentEmbeddedText = ''\n        } else {\n          currentEmbeddedText += line + '\\n'\n        }\n\n        continue\n      }\n\n      const lp = new LineParser(line, lineIndex + 1)\n      lp.seekNonSpace()\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue\n      }\n\n      // Parse the line type\n      const lineType = lp.getToken()\n\n      let material\n      let colorCode\n      let segment\n      let ccw\n      let doubleSided\n      let v0, v1, v2, v3, c0, c1\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken()\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken()\n                break\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp)\n                if (material) {\n                  materials[material.userData.code] = material\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString())\n                }\n\n                break\n\n              case '!CATEGORY':\n                category = lp.getToken()\n                break\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',')\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = []\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim())\n                  })\n                }\n\n                break\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true\n                  currentEmbeddedFileName = lp.getRemainingString()\n                  currentEmbeddedText = ''\n\n                  bfcCertified = false\n                  bfcCCW = true\n                }\n\n                break\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken()\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY'\n                      bfcCCW = true\n\n                      break\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW'\n\n                      break\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true\n\n                      break\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP'\n\n                      break\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.')\n\n                      break\n                  }\n                }\n\n                break\n\n              case 'STEP':\n                startingConstructionStep = true\n\n                break\n\n              default:\n                // Other meta directives are not implemented\n                break\n            }\n          }\n\n          break\n\n        // Line type 1: Sub-object file\n        case '1':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n\n          const posX = parseFloat(lp.getToken())\n          const posY = parseFloat(lp.getToken())\n          const posZ = parseFloat(lp.getToken())\n          const m0 = parseFloat(lp.getToken())\n          const m1 = parseFloat(lp.getToken())\n          const m2 = parseFloat(lp.getToken())\n          const m3 = parseFloat(lp.getToken())\n          const m4 = parseFloat(lp.getToken())\n          const m5 = parseFloat(lp.getToken())\n          const m6 = parseFloat(lp.getToken())\n          const m7 = parseFloat(lp.getToken())\n          const m8 = parseFloat(lp.getToken())\n\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1)\n\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/')\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName]\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep,\n          })\n\n          bfcInverted = false\n\n          break\n\n        // Line type 2: Line segment\n        case '2':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n          }\n\n          lineSegments.push(segment)\n\n          break\n\n        // Line type 5: Conditional Line segment\n        case '5':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n          c0 = lp.getVector()\n          c1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1],\n          }\n\n          conditionalSegments.push(segment)\n\n          break\n\n        // Line type 3: Triangle\n        case '3':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n          } else {\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null],\n          })\n          totalFaces++\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null],\n            })\n            totalFaces++\n          }\n\n          break\n\n        // Line type 4: Quadrilateral\n        case '4':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n            v3 = lp.getVector()\n          } else {\n            v3 = lp.getVector()\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null],\n          })\n          totalFaces += 2\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null],\n            })\n            totalFaces += 2\n          }\n\n          break\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.')\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText)\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null,\n    }\n  }\n\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase()\n    const result = this._cache[key]\n    if (result === null || result instanceof Promise) {\n      return null\n    }\n\n    if (clone) {\n      return this.cloneResult(result)\n    } else {\n      return result\n    }\n  }\n\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase()\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName)\n        this._cache[key] = info\n        return info\n      })\n    }\n\n    await this._cache[key]\n  }\n\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase()\n    this._cache[key] = this.parse(text, fileName)\n  }\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n  if (isPassthrough) {\n    colorCode = parentColorCode\n  }\n\n  return materialHierarchy[colorCode] || null\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader\n    this.parseCache = new LDrawParsedCache(loader)\n    this._cache = {}\n  }\n\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader\n    const parseCache = this.parseCache\n    const faceMaterials = new Set()\n\n    // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects\n      const promises = []\n\n      // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i]\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false)\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch((error) => {\n              console.warn(error)\n              return null\n            })\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject)\n        })\n\n        promises.push(promise)\n      }\n\n      const group = new Group()\n      group.userData.category = info.category\n      group.userData.keywords = info.keywords\n      info.group = group\n\n      const subobjectInfos = await Promise.all(promises)\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i]\n        const subobjectInfo = subobjectInfos[i]\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue\n        }\n\n        // if the subobject was loaded as a separate group then apply the parent scopes materials\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale)\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep\n          subobjectGroup.name = subobject.fileName\n\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials)\n\n          group.add(subobjectGroup)\n          continue\n        }\n\n        // add the subobject group if it has children in case it has both children and primitives\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group)\n        }\n\n        // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n        const parentLineSegments = info.lineSegments\n        const parentConditionalSegments = info.conditionalSegments\n        const parentFaces = info.faces\n\n        const lineSegments = subobjectInfo.lineSegments\n        const conditionalSegments = subobjectInfo.conditionalSegments\n\n        const faces = subobjectInfo.faces\n        const matrix = subobject.matrix\n        const inverted = subobject.inverted\n        const matrixScaleInverted = matrix.determinant() < 0\n        const colorCode = subobject.colorCode\n\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i]\n          const vertices = ls.vertices\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true)\n\n          parentLineSegments.push(ls)\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i]\n          const vertices = os.vertices\n          const controlPoints = os.controlPoints\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          controlPoints[0].applyMatrix4(matrix)\n          controlPoints[1].applyMatrix4(matrix)\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true)\n\n          parentConditionalSegments.push(os)\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i]\n          const vertices = tri.vertices\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix)\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false)\n          faceMaterials.add(tri.colorCode)\n\n          // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse()\n          }\n\n          parentFaces.push(tri)\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces\n      }\n\n      // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials)\n      }\n\n      return info\n    }\n\n    // Track material use to see if we need to use the normal smooth slow path for hard edges.\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode)\n    }\n\n    await processInfoSubobjects(info)\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1\n      generateFaceNormals(info.faces)\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments)\n    }\n\n    // Add the primitive objects and metadata.\n    const group = info.group\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces))\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2))\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true))\n    }\n\n    return group\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase()\n      const group = await this._cache[key]\n      return group.clone()\n    } else {\n      return null\n    }\n  }\n\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache\n    const key = fileName.toLowerCase()\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName)\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName)\n\n      const info = parseCache.getData(fileName)\n      const promise = this.processIntoMesh(info)\n\n      // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName)\n      }\n\n      // Cache object if it's a part so it can be reused later.\n      if (isPartType(info.type)) {\n        this._cache[key] = promise\n      }\n\n      // return a copy\n      const group = await promise\n      return group.clone()\n    }\n  }\n\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache\n    const info = parseCache.parse(text)\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName)\n    }\n\n    return this.processIntoMesh(info)\n  }\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1\n  }\n\n  return 1\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial)\n\n  if (totalElements === null) {\n    totalElements = elements.length\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3)\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null\n  const materials = []\n\n  const quadArray = new Array(6)\n  const bufferGeometry = new BufferGeometry()\n  let prevMaterial = null\n  let index0 = 0\n  let numGroupVerts = 0\n  let offset = 0\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem]\n    let vertices = elem.vertices\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0]\n      quadArray[1] = vertices[1]\n      quadArray[2] = vertices[2]\n      quadArray[3] = vertices[0]\n      quadArray[4] = vertices[2]\n      quadArray[5] = vertices[3]\n      vertices = quadArray\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j]\n      const index = offset + j * 3\n      positions[index + 0] = v.x\n      positions[index + 1] = v.y\n      positions[index + 2] = v.z\n    }\n\n    // create the normals array if this is a set of faces\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0]\n        const v1 = vertices[1]\n        const v2 = vertices[2]\n        _tempVec0.subVectors(v1, v0)\n        _tempVec1.subVectors(v2, v1)\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n      }\n\n      let elemNormals = elem.normals\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0]\n        quadArray[1] = elemNormals[1]\n        quadArray[2] = elemNormals[2]\n        quadArray[3] = elemNormals[0]\n        quadArray[4] = elemNormals[2]\n        quadArray[5] = elemNormals[3]\n        elemNormals = quadArray\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm\n        }\n\n        const index = offset + j * 3\n        normals[index + 0] = n.x\n        normals[index + 1] = n.y\n        normals[index + 2] = n.z\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1)\n      }\n\n      const material = elem.material\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material)\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial)\n            } else {\n              materials.push(material.userData.edgeMaterial)\n            }\n          } else {\n            materials.push(null)\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode)\n      }\n\n      prevMaterial = elem.colorCode\n      index0 = offset / 3\n      numGroupVerts = vertices.length\n    } else {\n      numGroupVerts += vertices.length\n    }\n\n    offset += 3 * vertices.length\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1)\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3))\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3))\n  }\n\n  let object3d = null\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true\n\n    const controlArray0 = new Float32Array(elements.length * 3 * 2)\n    const controlArray1 = new Float32Array(elements.length * 3 * 2)\n    const directionArray = new Float32Array(elements.length * 3 * 2)\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i]\n      const vertices = os.vertices\n      const controlPoints = os.controlPoints\n      const c0 = controlPoints[0]\n      const c1 = controlPoints[1]\n      const v0 = vertices[0]\n      const v1 = vertices[1]\n      const index = i * 3 * 2\n      controlArray0[index + 0] = c0.x\n      controlArray0[index + 1] = c0.y\n      controlArray0[index + 2] = c0.z\n      controlArray0[index + 3] = c0.x\n      controlArray0[index + 4] = c0.y\n      controlArray0[index + 5] = c0.z\n\n      controlArray1[index + 0] = c1.x\n      controlArray1[index + 1] = c1.y\n      controlArray1[index + 2] = c1.z\n      controlArray1[index + 3] = c1.x\n      controlArray1[index + 4] = c1.y\n      controlArray1[index + 5] = c1.z\n\n      directionArray[index + 0] = v1.x - v0.x\n      directionArray[index + 1] = v1.y - v0.y\n      directionArray[index + 2] = v1.z - v0.z\n      directionArray[index + 3] = v1.x - v0.x\n      directionArray[index + 4] = v1.y - v0.y\n      directionArray[index + 5] = v1.z - v0.z\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false))\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false))\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false))\n  }\n\n  return object3d\n}\n\n//\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Array of THREE.Material\n    this.materials = []\n    this.materialLibrary = {}\n\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n    this.partsCache = new LDrawPartsGeometryCache(this)\n\n    // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n    this.fileMap = {}\n\n    // Initializes the materials library with default materials\n    this.setMaterials([])\n\n    // If this flag is set to true the vertex normals will be smoothed.\n    this.smoothNormals = true\n\n    // The path to load parts from the LDraw parts library from.\n    this.partsLibraryPath = ''\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path\n    return this\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n\n    const text = await fileLoader.loadAsync(url)\n    const colorLineRegex = /^0 !COLOUR/\n    const lines = text.split(/[\\n\\r]/g)\n    const materials = []\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i]\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '')\n        const material = this.parseColorMetaDirective(new LineParser(directive))\n        materials.push(material)\n      }\n    }\n\n    this.setMaterials(materials)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache\n          .parseModel(text, this.materialLibrary)\n          .then((group) => {\n            this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true)\n            this.computeConstructionSteps(group)\n            onLoad(group)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group)\n      onLoad(group)\n    })\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {}\n    this.materials = []\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i])\n    }\n\n    // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')))\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')))\n\n    return this\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap\n\n    return this\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n    const matLib = this.materialLibrary\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material)\n      matLib[material.userData.code] = material\n    }\n\n    return this\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3)\n\n      return this.parseColorMetaDirective(\n        new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''),\n      )\n    }\n\n    return this.materialLibrary[colorCode] || null\n  }\n\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i])\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material)\n        }\n      }\n    })\n\n    // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine\n      const isPassthrough =\n        (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n      if (isPassthrough) {\n        colorCode = parentColorCode\n      }\n\n      let material = null\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode]\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode)\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`)\n        }\n      } else {\n        return colorCode\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial\n        }\n      }\n\n      return material\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE)\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE)\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n\n    let code = null\n\n    // Triangle and line colors\n    let color = 0xff00ff\n    let edgeColor = 0xff00ff\n\n    // Transparency\n    let alpha = 1\n    let isTransparent = false\n    // Self-illumination:\n    let luminance = 0\n\n    let finishType = FINISH_TYPE_DEFAULT\n\n    let edgeMaterial = null\n\n    const name = lineParser.getToken()\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.',\n      )\n    }\n\n    // Parse tag tokens and their parameters\n    let token = null\n    while (true) {\n      token = lineParser.getToken()\n\n      if (!token) {\n        break\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken()\n          break\n\n        case 'VALUE':\n          color = lineParser.getToken()\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2)\n          } else if (!color.startsWith('#')) {\n            throw new Error(\n              'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          break\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken()\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2)\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor)\n            if (!edgeMaterial) {\n              throw new Error(\n                'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.',\n              )\n            }\n\n            // Get the edge material for this triangle material\n            edgeMaterial = edgeMaterial.userData.edgeMaterial\n          }\n\n          break\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken())\n\n          if (isNaN(alpha)) {\n            throw new Error(\n              'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255))\n\n          if (alpha < 1) {\n            isTransparent = true\n          }\n\n          break\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken())\n\n          if (isNaN(luminance)) {\n            throw new Error(\n              'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.',\n            )\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255))\n\n          break\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME\n          break\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT\n          break\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER\n          break\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC\n          break\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL\n          break\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd()\n          break\n\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' +\n              token +\n              '\" while parsing material' +\n              lineParser.getLineNumberString() +\n              '.',\n          )\n      }\n    }\n\n    let material = null\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0 })\n        break\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.25 })\n        break\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({ color: color, roughness: 0, metalness: 1 })\n        break\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.9, metalness: 0 })\n        break\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.8, metalness: 0.4 })\n        break\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.85 })\n        break\n\n      default:\n        // Should not happen\n        break\n    }\n\n    material.transparent = isTransparent\n    material.premultipliedAlpha = true\n    material.opacity = alpha\n    material.depthWrite = !isTransparent\n\n    material.polygonOffset = true\n    material.polygonOffsetFactor = 1\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance)\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent,\n      })\n      edgeMaterial.userData.code = code\n      edgeMaterial.name = name + ' - Edge'\n\n      // This is the material used for conditional edges\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha,\n      })\n    }\n\n    material.userData.code = code\n    material.name = name\n\n    material.userData.edgeMaterial = edgeMaterial\n\n    this.addMaterial(material)\n\n    return material\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n\n    let stepNumber = 0\n\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++\n        }\n\n        c.userData.constructionStep = stepNumber\n      }\n    })\n\n    model.userData.numConstructionSteps = stepNumber + 1\n  }\n}\n\nexport { LDrawLoader }\n"],"names":["info","i","l","fileName","subobject","group"],"mappings":"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"}},
    {"offset": {"line": 22097, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/SVGLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/SVGLoader.js"],"sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nconst SVGLoader = /* @__PURE__ */ (() => {\n  class SVGLoader extends Loader {\n    constructor(manager) {\n      super(manager)\n\n      // Default dots per inch\n      this.defaultDPI = 90\n\n      // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n      this.defaultUnit = 'px'\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      const scope = this\n\n      const loader = new FileLoader(scope.manager)\n      loader.setPath(scope.path)\n      loader.setRequestHeader(scope.requestHeader)\n      loader.setWithCredentials(scope.withCredentials)\n      loader.load(\n        url,\n        function (text) {\n          try {\n            onLoad(scope.parse(text))\n          } catch (e) {\n            if (onError) {\n              onError(e)\n            } else {\n              console.error(e)\n            }\n\n            scope.manager.itemError(url)\n          }\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    parse(text) {\n      const scope = this\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return\n\n        const transform = getNodeTransform(node)\n\n        let isDefsNode = false\n\n        let path = null\n\n        switch (node.nodeName) {\n          case 'svg':\n            style = parseStyle(node, style)\n            break\n\n          case 'style':\n            parseCSSStylesheet(node)\n            break\n\n          case 'g':\n            style = parseStyle(node, style)\n            break\n\n          case 'path':\n            style = parseStyle(node, style)\n            if (node.hasAttribute('d')) path = parsePathNode(node)\n            break\n\n          case 'rect':\n            style = parseStyle(node, style)\n            path = parseRectNode(node)\n            break\n\n          case 'polygon':\n            style = parseStyle(node, style)\n            path = parsePolygonNode(node)\n            break\n\n          case 'polyline':\n            style = parseStyle(node, style)\n            path = parsePolylineNode(node)\n            break\n\n          case 'circle':\n            style = parseStyle(node, style)\n            path = parseCircleNode(node)\n            break\n\n          case 'ellipse':\n            style = parseStyle(node, style)\n            path = parseEllipseNode(node)\n            break\n\n          case 'line':\n            style = parseStyle(node, style)\n            path = parseLineNode(node)\n            break\n\n          case 'defs':\n            isDefsNode = true\n            break\n\n          case 'use':\n            style = parseStyle(node, style)\n\n            const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n            const usedNodeId = href.substring(1)\n            const usedNode = node.viewportElement.getElementById(usedNodeId)\n            if (usedNode) {\n              parseNode(usedNode, style)\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n            }\n\n            break\n\n          default:\n          // console.log( node );\n        }\n\n        if (path) {\n          if (style.fill !== undefined && style.fill !== 'none') {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n          }\n\n          transformPath(path, currentTransform)\n\n          paths.push(path)\n\n          path.userData = { node: node, style: style }\n        }\n\n        const childNodes = node.childNodes\n\n        for (let i = 0; i < childNodes.length; i++) {\n          const node = childNodes[i]\n\n          if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n            // Ignore everything in defs except CSS style definitions\n            // and nested defs, because it is OK by the standard to have\n            // <style/> there.\n            continue\n          }\n\n          parseNode(node, style)\n        }\n\n        if (transform) {\n          transformStack.pop()\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1])\n          } else {\n            currentTransform.identity()\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        const path = new ShapePath()\n\n        const point = new Vector2()\n        const control = new Vector2()\n\n        const firstPoint = new Vector2()\n        let isFirstPoint = true\n        let doSetFirstPoint = false\n\n        const d = node.getAttribute('d')\n\n        if (d === '' || d === 'none') return null\n\n        // console.log( d );\n\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i]\n\n          const type = command.charAt(0)\n          const data = command.slice(1).trim()\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true\n            isFirstPoint = false\n          }\n\n          let numbers\n\n          switch (type) {\n            case 'M':\n              numbers = parseFloats(data)\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'H':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'V':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'L':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'C':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  numbers[j + 5],\n                )\n                control.x = numbers[j + 2]\n                control.y = numbers[j + 3]\n                point.x = numbers[j + 4]\n                point.y = numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'S':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                )\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'T':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'A':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if start point == end point\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n                const start = point.clone()\n                point.x = numbers[j + 5]\n                point.y = numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'm':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'h':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'v':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'l':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'c':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                  point.x + numbers[j + 4],\n                  point.y + numbers[j + 5],\n                )\n                control.x = point.x + numbers[j + 2]\n                control.y = point.y + numbers[j + 3]\n                point.x += numbers[j + 4]\n                point.y += numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 's':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 't':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = point.x + numbers[j + 0]\n                point.y = point.y + numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'a':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if no displacement\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n                const start = point.clone()\n                point.x += numbers[j + 5]\n                point.y += numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Z':\n            case 'z':\n              path.currentPath.autoClose = true\n\n              if (path.currentPath.curves.length > 0) {\n                // Reset point to beginning of Path\n                point.copy(firstPoint)\n                path.currentPath.currentPoint.copy(point)\n                isFirstPoint = true\n              }\n\n              break\n\n            default:\n              console.warn(command)\n          }\n\n          // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n          doSetFirstPoint = false\n        }\n\n        return path\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i]\n\n          if (stylesheet.type !== 1) continue\n\n          const selectorList = stylesheet.selectorText\n            .split(/,/gm)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let j = 0; j < selectorList.length; j++) {\n            // Remove empty rules\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n          }\n        }\n      }\n\n      /**\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n       * From\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n       * To\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n       */\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          // draw a line if either of the radii == 0\n          path.lineTo(end.x, end.y)\n          return\n        }\n\n        x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n        // Ensure radii are positive\n        rx = Math.abs(rx)\n        ry = Math.abs(ry)\n\n        // Compute (x1', y1')\n        const dx2 = (start.x - end.x) / 2.0\n        const dy2 = (start.y - end.y) / 2.0\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n        // Compute (cx', cy')\n        let rxs = rx * rx\n        let rys = ry * ry\n        const x1ps = x1p * x1p\n        const y1ps = y1p * y1p\n\n        // Ensure radii are large enough\n        const cr = x1ps / rxs + y1ps / rys\n\n        if (cr > 1) {\n          // scale up rx,ry equally so cr == 1\n          const s = Math.sqrt(cr)\n          rx = s * rx\n          ry = s * ry\n          rxs = rx * rx\n          rys = ry * ry\n        }\n\n        const dq = rxs * y1ps + rys * x1ps\n        const pq = (rxs * rys - dq) / dq\n        let q = Math.sqrt(Math.max(0, pq))\n        if (large_arc_flag === sweep_flag) q = -q\n        const cxp = (q * rx * y1p) / ry\n        const cyp = (-q * ry * x1p) / rx\n\n        // Step 3: Compute (cx, cy) from (cx', cy')\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n        // Step 4: Compute 1 and \n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n        if (ux * vy - uy * vx < 0) ang = -ang\n        return ang\n      }\n\n      /*\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n       */\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n        const w = parseFloatWithUnits(node.getAttribute('width'))\n        const h = parseFloatWithUnits(node.getAttribute('height'))\n\n        // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n        // https://spencermortensen.com/articles/bezier-circle/\n        const bci = 1 - 0.551915024494\n\n        const path = new ShapePath()\n\n        // top left\n        path.moveTo(x + rx, y)\n\n        // top right\n        path.lineTo(x + w - rx, y)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n        }\n\n        // bottom right\n        path.lineTo(x + w, y + h - ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n        }\n\n        // bottom left\n        path.lineTo(x + rx, y + h)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n        }\n\n        // back to top left\n        path.lineTo(x, y + ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n        }\n\n        return path\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = true\n\n        return path\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n        const subpath = new Path()\n        subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n        const subpath = new Path()\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n        const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n        const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n        const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n        const path = new ShapePath()\n        path.moveTo(x1, y1)\n        path.lineTo(x2, y2)\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      //\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style) // clone style\n\n        let stylesheetStyles = {}\n\n        if (node.hasAttribute('class')) {\n          const classSelectors = node\n            .getAttribute('class')\n            .split(/\\s/)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n          }\n        }\n\n        if (node.hasAttribute('id')) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === undefined)\n            adjustFunction = function copy(v) {\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n              return v\n            }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v))\n        }\n\n        addStyle('fill', 'fill')\n        addStyle('fill-opacity', 'fillOpacity', clamp)\n        addStyle('fill-rule', 'fillRule')\n        addStyle('opacity', 'opacity', clamp)\n        addStyle('stroke', 'stroke')\n        addStyle('stroke-opacity', 'strokeOpacity', clamp)\n        addStyle('stroke-width', 'strokeWidth', positive)\n        addStyle('stroke-linejoin', 'strokeLineJoin')\n        addStyle('stroke-linecap', 'strokeLineCap')\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n        addStyle('visibility', 'visibility')\n\n        return style\n      }\n\n      // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n      function getReflection(a, b) {\n        return a - (b - a)\n      }\n\n      // from https://github.com/ppvg/svg-numbers (MIT License)\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== 'string') {\n          throw new TypeError('Invalid input: ' + typeof input)\n        }\n\n        // Character groups\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/,\n        }\n\n        // States\n        const SEP = 0\n        const INT = 1\n        const FLOAT = 2\n        const EXP = 3\n\n        let state = SEP\n        let seenComma = true\n        let number = '',\n          exponent = ''\n        const result = []\n\n        function throwSyntaxError(current, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n          error.partial = partial\n          throw error\n        }\n\n        function newNumber() {\n          if (number !== '') {\n            if (exponent === '') result.push(Number(number))\n            else result.push(Number(number) * Math.pow(10, Number(exponent)))\n          }\n\n          number = ''\n          exponent = ''\n        }\n\n        let current\n        const length = input.length\n\n        for (let i = 0; i < length; i++) {\n          current = input[i]\n\n          // check for flags\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT\n            number = current\n            newNumber()\n            continue\n          }\n\n          // parse until next number\n          if (state === SEP) {\n            // eat whitespace\n            if (RE.WHITESPACE.test(current)) {\n              continue\n            }\n\n            // start new number\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT\n              number = current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT\n              number = current\n              continue\n            }\n\n            // throw on double commas (e.g. \"1, , 2\")\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result)\n              }\n\n              seenComma = true\n            }\n          }\n\n          // parse integer part\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current\n              state = FLOAT\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse decimal part\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double decimal points (e.g. \"1..2\")\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse exponent part\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current\n              continue\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === '') {\n                exponent += current\n                continue\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result)\n              }\n            }\n          }\n\n          // end of number\n          if (RE.WHITESPACE.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = false\n          } else if (RE.COMMA.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = true\n          } else if (RE.SIGN.test(current)) {\n            newNumber()\n            state = INT\n            number = current\n          } else if (RE.POINT.test(current)) {\n            newNumber()\n            state = FLOAT\n            number = current\n          } else {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // add the last number found (if any)\n        newNumber()\n\n        return result\n      }\n\n      // Units\n\n      const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n      // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1,\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1,\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1,\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1,\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1,\n        },\n        px: {\n          px: 1,\n        },\n      }\n\n      function parseFloatWithUnits(string) {\n        let theUnit = 'px'\n\n        if (typeof string === 'string' || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i]\n\n            if (string.endsWith(u)) {\n              theUnit = u\n              string = string.substring(0, string.length - u.length)\n              break\n            }\n          }\n        }\n\n        let scale = undefined\n\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n          // Conversion scale from  pixels to inches, then to default units\n\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit]\n\n          if (scale < 0) {\n            // Conversion scale to pixels\n\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n          }\n        }\n\n        return scale * parseFloat(string)\n      }\n\n      // Transforms\n\n      function getNodeTransform(node) {\n        if (\n          !(\n            node.hasAttribute('transform') ||\n            (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n          )\n        ) {\n          return null\n        }\n\n        const transform = parseNodeTransform(node)\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1])\n        }\n\n        currentTransform.copy(transform)\n        transformStack.push(transform)\n\n        return transform\n      }\n\n      function parseNodeTransform(node) {\n        const transform = new Matrix3()\n        const currentTransform = tempTransform0\n\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n          const tx = parseFloatWithUnits(node.getAttribute('x'))\n          const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n          transform.translate(tx, ty)\n        }\n\n        if (node.hasAttribute('transform')) {\n          const transformsTexts = node.getAttribute('transform').split(')')\n\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim()\n\n            if (transformText === '') continue\n\n            const openParPos = transformText.indexOf('(')\n            const closeParPos = transformText.length\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos)\n\n              const array = parseFloats(transformText.slice(openParPos + 1))\n\n              currentTransform.identity()\n\n              switch (transformType) {\n                case 'translate':\n                  if (array.length >= 1) {\n                    const tx = array[0]\n                    let ty = 0\n\n                    if (array.length >= 2) {\n                      ty = array[1]\n                    }\n\n                    currentTransform.translate(tx, ty)\n                  }\n\n                  break\n\n                case 'rotate':\n                  if (array.length >= 1) {\n                    let angle = 0\n                    let cx = 0\n                    let cy = 0\n\n                    // Angle\n                    angle = (array[0] * Math.PI) / 180\n\n                    if (array.length >= 3) {\n                      // Center x, y\n                      cx = array[1]\n                      cy = array[2]\n                    }\n\n                    // Rotate around center (cx, cy)\n                    tempTransform1.makeTranslation(-cx, -cy)\n                    tempTransform2.makeRotation(angle)\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                    tempTransform1.makeTranslation(cx, cy)\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                  }\n\n                  break\n\n                case 'scale':\n                  if (array.length >= 1) {\n                    const scaleX = array[0]\n                    let scaleY = scaleX\n\n                    if (array.length >= 2) {\n                      scaleY = array[1]\n                    }\n\n                    currentTransform.scale(scaleX, scaleY)\n                  }\n\n                  break\n\n                case 'skewX':\n                  if (array.length === 1) {\n                    currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'skewY':\n                  if (array.length === 1) {\n                    currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'matrix':\n                  if (array.length === 6) {\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                  }\n\n                  break\n              }\n            }\n\n            transform.premultiply(currentTransform)\n          }\n        }\n\n        return transform\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n          v2.set(tempV3.x, tempV3.y)\n        }\n\n        function transfEllipseGeneric(curve) {\n          // For math description see:\n          // https://math.stackexchange.com/questions/4544164\n\n          const a = curve.xRadius\n          const b = curve.yRadius\n\n          const cosTheta = Math.cos(curve.aRotation)\n          const sinTheta = Math.sin(curve.aRotation)\n\n          const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n          const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n          const f1 = v1.applyMatrix3(m)\n          const f2 = v2.applyMatrix3(m)\n\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n          const mFInv = tempTransform1.copy(mF).invert()\n          const mFInvT = tempTransform2.copy(mFInv).transpose()\n          const mQ = mFInvT.multiply(mFInv)\n          const mQe = mQ.elements\n\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n          const rt1sqrt = Math.sqrt(ed.rt1)\n          const rt2sqrt = Math.sqrt(ed.rt2)\n\n          curve.xRadius = 1 / rt1sqrt\n          curve.yRadius = 1 / rt2sqrt\n          curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n          // Do not touch angles of a full ellipse because after transformation they\n          // would converge to a sinle value effectively removing the whole curve\n\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n            const transformAngle = (phi) => {\n              const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n              return Math.atan2(sinR, cosR)\n            }\n\n            curve.aStartAngle = transformAngle(curve.aStartAngle)\n            curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise\n            }\n          }\n        }\n\n        function transfEllipseNoSkew(curve) {\n          // Faster shortcut if no skew is applied\n          // (e.g, a euclidean transform of a group containing the ellipse)\n\n          const sx = getTransformScaleX(m)\n          const sy = getTransformScaleY(m)\n\n          curve.xRadius *= sx\n          curve.yRadius *= sy\n\n          // Extract rotation angle from the matrix of form:\n          //\n          //  | cos sx   -sin sy |\n          //  | sin sx    cos sy |\n          //\n          // Remembering that tan = sin / cos; and that\n          // `sx`, `sy`, or both might be zero.\n          const theta =\n            sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n          curve.aRotation += theta\n\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1\n            curve.aEndAngle *= -1\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n\n        const subPaths = path.subPaths\n\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i]\n          const curves = subPath.curves\n\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j]\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n              transfVec2(curve.v3)\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isEllipseCurve) {\n              // Transform ellipse center point\n\n              tempV2.set(curve.aX, curve.aY)\n              transfVec2(tempV2)\n              curve.aX = tempV2.x\n              curve.aY = tempV2.y\n\n              // Transform ellipse shape parameters\n\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve)\n              } else {\n                transfEllipseNoSkew(curve)\n              }\n            }\n          }\n        }\n      }\n\n      function isTransformFlipped(m) {\n        const te = m.elements\n        return te[0] * te[4] - te[1] * te[3] < 0\n      }\n\n      function isTransformSkewed(m) {\n        const te = m.elements\n        const basisDot = te[0] * te[3] + te[1] * te[4]\n\n        // Shortcut for trivial rotations and transformations\n        if (basisDot === 0) return false\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n      }\n\n      function getTransformScaleX(m) {\n        const te = m.elements\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n      }\n\n      function getTransformScaleY(m) {\n        const te = m.elements\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n      }\n\n      // Calculates the eigensystem of a real symmetric 2x2 matrix\n      //    [ A  B ]\n      //    [ B  C ]\n      // in the form\n      //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n      //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n      // where rt1 >= rt2.\n      //\n      // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n      // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t\n        const sm = A + C\n        const df = A - C\n        const rt = Math.sqrt(df * df + 4 * B * B)\n\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt)\n          t = 1 / rt1\n          rt2 = A * t * C - B * t * B\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt)\n        } else {\n          // This case needs to be treated separately to avoid div by 0\n\n          rt1 = 0.5 * rt\n          rt2 = -0.5 * rt\n        }\n\n        // Calculate eigenvectors\n\n        if (df > 0) {\n          cs = df + rt\n        } else {\n          cs = df - rt\n        }\n\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = (-2 * B) / cs\n          sn = 1 / Math.sqrt(1 + t * t)\n          cs = t * sn\n        } else if (Math.abs(B) === 0) {\n          cs = 1\n          sn = 0\n        } else {\n          t = (-0.5 * cs) / B\n          cs = 1 / Math.sqrt(1 + t * t)\n          sn = t * cs\n        }\n\n        if (df > 0) {\n          t = cs\n          cs = -sn\n          sn = t\n        }\n\n        return { rt1, rt2, cs, sn }\n      }\n\n      //\n\n      const paths = []\n      const stylesheets = {}\n\n      const transformStack = []\n\n      const tempTransform0 = new Matrix3()\n      const tempTransform1 = new Matrix3()\n      const tempTransform2 = new Matrix3()\n      const tempTransform3 = new Matrix3()\n      const tempV2 = new Vector2()\n      const tempV3 = new Vector3()\n\n      const currentTransform = new Matrix3()\n\n      const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n      parseNode(xml.documentElement, {\n        fill: '#000',\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: 'miter',\n        strokeLineCap: 'butt',\n        strokeMiterLimit: 4,\n      })\n\n      const data = { paths: paths, xml: xml.documentElement }\n\n      // console.log( paths );\n      return data\n    }\n\n    static createShapes(shapePath) {\n      // Param shapePath: a shapepath as returned by the parse function of this class\n      // Returns Shape object\n\n      const BIGNUMBER = 999999999\n\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6,\n      }\n\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0,\n      }\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x\n        const x2 = a1.x\n        const x3 = b0.x\n        const x4 = b1.x\n        const y1 = a0.y\n        const y2 = a1.y\n        const y3 = b0.y\n        const y4 = b1.y\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        const t1 = nom1 / denom\n        const t2 = nom2 / denom\n\n        if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          //1. lines are parallel or edges don't intersect\n\n          return null\n        } else if (nom1 === 0 && denom === 0) {\n          //2. lines are colinear\n\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n            //find position of this endpoints relatively to edge1\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n              return { x: x, y: y, t: classifyResult.t }\n            }\n          }\n\n          return null\n        } else {\n          //3. edges intersect\n\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            }\n          }\n\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n          return { x: x, y: y, t: t1 }\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x\n        const ay = edgeEnd.y - edgeStart.y\n        const bx = p.x - edgeStart.x\n        const by = p.y - edgeStart.y\n        const sa = ax * by - bx * ay\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN\n          classifyResult.t = 0\n          return\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION\n          classifyResult.t = 1\n          return\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT\n          return\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT\n          return\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND\n          return\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND\n          return\n        }\n\n        let t\n\n        if (ax !== 0) {\n          t = bx / ax\n        } else {\n          t = by / ay\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN\n        classifyResult.t = t\n      }\n\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = []\n        const intersections = []\n\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1]\n          const path1EdgeEnd = path1[index]\n\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1]\n            const path2EdgeEnd = path2[index2]\n\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n            if (\n              intersection !== null &&\n              intersectionsRaw.find(\n                (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n              ) === undefined\n            ) {\n              intersectionsRaw.push(intersection)\n              intersections.push(new Vector2(intersection.x, intersection.y))\n            }\n          }\n        }\n\n        return intersections\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new Vector2()\n        boundingBox.getCenter(center)\n\n        const allIntersections = []\n\n        paths.forEach((path) => {\n          // check if the center of the bounding box is in the bounding box of the paths.\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points)\n\n            intersections.forEach((p) => {\n              allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n            })\n          }\n        })\n\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        return allIntersections\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n          _fillRule = 'nonzero'\n        }\n\n        const centerBoundingBox = new Vector2()\n        simplePath.boundingBox.getCenter(centerBoundingBox)\n\n        const scanline = [\n          new Vector2(scanlineMinX, centerBoundingBox.y),\n          new Vector2(scanlineMaxX, centerBoundingBox.y),\n        ]\n\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        const baseIntersections = []\n        const otherIntersections = []\n\n        scanlineIntersections.forEach((i) => {\n          if (i.identifier === simplePath.identifier) {\n            baseIntersections.push(i)\n          } else {\n            otherIntersections.push(i)\n          }\n        })\n\n        const firstXOfPath = baseIntersections[0].point.x\n\n        // build up the path hierarchy\n        const stack = []\n        let i = 0\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop()\n          } else {\n            stack.push(otherIntersections[i].identifier)\n          }\n\n          i++\n        }\n\n        stack.push(simplePath.identifier)\n\n        if (_fillRule === 'evenodd') {\n          const isHole = stack.length % 2 === 0 ? true : false\n          const isHoleFor = stack[stack.length - 2]\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else if (_fillRule === 'nonzero') {\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n          let isHole = true\n          let isHoleFor = null\n          let lastCWValue = null\n\n          for (let i = 0; i < stack.length; i++) {\n            const identifier = stack[i]\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = false\n              isHoleFor = identifier\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = true\n            }\n          }\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n        }\n      }\n\n      // check for self intersecting paths\n      // TODO\n\n      // check intersecting paths\n      // TODO\n\n      // prepare paths for hole detection\n      let scanlineMinX = BIGNUMBER\n      let scanlineMaxX = -BIGNUMBER\n\n      let simplePaths = shapePath.subPaths.map((p) => {\n        const points = p.getPoints()\n        let maxY = -BIGNUMBER\n        let minY = BIGNUMBER\n        let maxX = -BIGNUMBER\n        let minX = BIGNUMBER\n\n        //points.forEach(p => p.y *= -1);\n\n        for (let i = 0; i < points.length; i++) {\n          const p = points[i]\n\n          if (p.y > maxY) {\n            maxY = p.y\n          }\n\n          if (p.y < minY) {\n            minY = p.y\n          }\n\n          if (p.x > maxX) {\n            maxX = p.x\n          }\n\n          if (p.x < minX) {\n            minX = p.x\n          }\n        }\n\n        //\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1\n        }\n\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n        }\n      })\n\n      simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier\n      }\n\n      // check if path is solid or a hole\n      const isAHole = simplePaths.map((p) =>\n        isHoleTo(\n          p,\n          simplePaths,\n          scanlineMinX,\n          scanlineMaxX,\n          shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n        ),\n      )\n\n      const shapesToReturn = []\n      simplePaths.forEach((p) => {\n        const amIAHole = isAHole[p.identifier]\n\n        if (!amIAHole.isHole) {\n          const shape = new Shape()\n          shape.curves = p.curves\n          const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n          holes.forEach((h) => {\n            const hole = simplePaths[h.identifier]\n            const path = new Path()\n            path.curves = hole.curves\n            shape.holes.push(path)\n          })\n          shapesToReturn.push(shape)\n        }\n      })\n\n      return shapesToReturn\n    }\n\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      // Param width: Stroke width\n      // Param color: As returned by THREE.Color.getStyle()\n      // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n      // Param lineCap: One of \"round\", \"square\" or \"butt\"\n      // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n      // Returns style object\n\n      width = width !== undefined ? width : 1\n      color = color !== undefined ? color : '#000'\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n      lineCap = lineCap !== undefined ? lineCap : 'butt'\n      miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit,\n      }\n    }\n\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      // Generates a stroke with some width around the given path.\n      // The path can be open or closed (last point equals to first point)\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n      const vertices = []\n      const normals = []\n      const uvs = []\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null\n      }\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n      return geometry\n    }\n\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      // This function can be called to update existing arrays or buffers.\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n      // Returns number of written vertices / normals / uvs pairs\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n      // 'normals' and 'uvs' buffers are optional\n\n      const tempV2_1 = new Vector2()\n      const tempV2_2 = new Vector2()\n      const tempV2_3 = new Vector2()\n      const tempV2_4 = new Vector2()\n      const tempV2_5 = new Vector2()\n      const tempV2_6 = new Vector2()\n      const tempV2_7 = new Vector2()\n      const lastPointL = new Vector2()\n      const lastPointR = new Vector2()\n      const point0L = new Vector2()\n      const point0R = new Vector2()\n      const currentPointL = new Vector2()\n      const currentPointR = new Vector2()\n      const nextPointL = new Vector2()\n      const nextPointR = new Vector2()\n      const innerPoint = new Vector2()\n      const outerPoint = new Vector2()\n\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n      minDistance = minDistance !== undefined ? minDistance : 0.001\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n      // First ensure there are no duplicated points\n      points = removeDuplicatedPoints(points)\n\n      const numPoints = points.length\n\n      if (numPoints < 2) return 0\n\n      const isClosed = points[0].equals(points[numPoints - 1])\n\n      let currentPoint\n      let previousPoint = points[0]\n      let nextPoint\n\n      const strokeWidth2 = style.strokeWidth / 2\n\n      const deltaU = 1 / (numPoints - 1)\n      let u0 = 0,\n        u1\n\n      let innerSideModified\n      let joinIsOnLeftSide\n      let isMiter\n      let initialJoinIsOnLeftSide = false\n\n      let numVertices = 0\n      let currentCoordinate = vertexOffset * 3\n      let currentCoordinateUV = vertexOffset * 2\n\n      // Get initial left and right stroke points\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n      lastPointL.copy(points[0]).sub(tempV2_1)\n      lastPointR.copy(points[0]).add(tempV2_1)\n      point0L.copy(lastPointL)\n      point0R.copy(lastPointR)\n\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint]\n\n        // Get next point\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            // Skip duplicated initial point\n            nextPoint = points[1]\n          } else nextPoint = undefined\n        } else {\n          nextPoint = points[iPoint + 1]\n        }\n\n        // Normal of previous segment in tempV2_1\n        const normal1 = tempV2_1\n        getNormal(previousPoint, currentPoint, normal1)\n\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n        currentPointL.copy(currentPoint).sub(tempV2_3)\n        currentPointR.copy(currentPoint).add(tempV2_3)\n\n        u1 = u0 + deltaU\n\n        innerSideModified = false\n\n        if (nextPoint !== undefined) {\n          // Normal of next segment in tempV2_2\n          getNormal(currentPoint, nextPoint, tempV2_2)\n\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n          nextPointL.copy(currentPoint).sub(tempV2_3)\n          nextPointR.copy(currentPoint).add(tempV2_3)\n\n          joinIsOnLeftSide = true\n          tempV2_3.subVectors(nextPoint, previousPoint)\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n          tempV2_3.subVectors(nextPoint, currentPoint)\n          tempV2_3.normalize()\n          const dot = Math.abs(normal1.dot(tempV2_3))\n\n          // If path is straight, don't create join\n          if (dot > Number.EPSILON) {\n            // Compute inner and outer segment intersections\n            const miterSide = strokeWidth2 / dot\n            tempV2_3.multiplyScalar(-miterSide)\n            tempV2_4.subVectors(currentPoint, previousPoint)\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n            innerPoint.copy(tempV2_5).negate()\n            const miterLength2 = tempV2_5.length()\n            const segmentLengthPrev = tempV2_4.length()\n            tempV2_4.divideScalar(segmentLengthPrev)\n            tempV2_6.subVectors(nextPoint, currentPoint)\n            const segmentLengthNext = tempV2_6.length()\n            tempV2_6.divideScalar(segmentLengthNext)\n            // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint)\n            innerPoint.add(currentPoint)\n\n            isMiter = false\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint)\n                currentPointR.copy(innerPoint)\n              } else {\n                nextPointL.copy(innerPoint)\n                currentPointL.copy(innerPoint)\n              }\n            } else {\n              // The segment triangles are generated here if there was overlapping\n\n              makeSegmentTriangles()\n            }\n\n            switch (style.strokeLineJoin) {\n              case 'bevel':\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n                break\n\n              case 'round':\n                // Segment triangles\n\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                // Join triangles\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n                }\n\n                break\n\n              case 'miter':\n              case 'miter-clip':\n              default:\n                const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n                if (miterFraction < 1) {\n                  // The join miter length exceeds the miter limit\n\n                  if (style.strokeLineJoin !== 'miter-clip') {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                    break\n                  } else {\n                    // Segment triangles\n\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                    // Miter-clip join triangles\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(tempV2_7, u1, 0)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(tempV2_7, u1, 1)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n                } else {\n                  // Miter join segment triangles\n\n                  if (innerSideModified) {\n                    // Optimized segment + join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 0)\n\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(innerPoint, u1, 1)\n                    } else {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 1)\n\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(innerPoint, u1, 0)\n                      addVertex(outerPoint, u1, 1)\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint)\n                    } else {\n                      nextPointR.copy(outerPoint)\n                    }\n                  } else {\n                    // Add extra miter join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n\n                  isMiter = true\n                }\n\n                break\n            }\n          } else {\n            // The segment triangles are generated here when two consecutive points are collinear\n\n            makeSegmentTriangles()\n          }\n        } else {\n          // The segment triangles are generated here if it is the ending segment\n\n          makeSegmentTriangles()\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          // Start line endcap\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n        }\n\n        // Increment loop variables\n\n        u0 = u1\n\n        previousPoint = currentPoint\n\n        lastPointL.copy(nextPointL)\n        lastPointR.copy(nextPointR)\n      }\n\n      if (!isClosed) {\n        // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n      } else if (innerSideModified && vertices) {\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n        let lastOuter = outerPoint\n        let lastInner = innerPoint\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint\n          lastInner = outerPoint\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3)\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3)\n            }\n          }\n        }\n      }\n\n      return numVertices\n\n      // -- End of algorithm\n\n      // -- Functions\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1)\n        return result.set(-result.y, result.x).normalize()\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x\n          vertices[currentCoordinate + 1] = position.y\n          vertices[currentCoordinate + 2] = 0\n\n          if (normals) {\n            normals[currentCoordinate] = 0\n            normals[currentCoordinate + 1] = 0\n            normals[currentCoordinate + 2] = 1\n          }\n\n          currentCoordinate += 3\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u\n            uvs[currentCoordinateUV + 1] = v\n\n            currentCoordinateUV += 2\n          }\n        }\n\n        numVertices += 3\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        // param p1, p2: Points in the circle arc.\n        // p1 and p2 are in clockwise direction.\n\n        tempV2_1.copy(p1).sub(center).normalize()\n        tempV2_2.copy(p2).sub(center).normalize()\n\n        let angle = Math.PI\n        const dot = tempV2_1.dot(tempV2_2)\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n        angle /= arcDivisions\n\n        tempV2_3.copy(p1)\n\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n          addVertex(tempV2_3, u, v)\n          addVertex(tempV2_4, u, v)\n          addVertex(center, u, 0.5)\n\n          tempV2_3.copy(tempV2_4)\n        }\n\n        addVertex(tempV2_4, u, v)\n        addVertex(p2, u, v)\n        addVertex(center, u, 0.5)\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1)\n        addVertex(lastPointL, u0, 0)\n        addVertex(currentPointL, u1, 0)\n\n        addVertex(lastPointR, u0, 1)\n        addVertex(currentPointL, u1, 0)\n        addVertex(currentPointR, u1, 1)\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n        if (innerSideModified) {\n          // Optimized segment + bevel triangles\n\n          if (joinIsOnLeftSide) {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(innerPoint, u, 0.5)\n          } else {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointR, u, 1)\n            addVertex(innerPoint, u, 0)\n            addVertex(nextPointR, u, 1)\n          }\n        } else {\n          // Bevel join triangle. The segment triangles are done in the main loop\n\n          if (joinIsOnLeftSide) {\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          } else {\n            addVertex(currentPointR, u, 1)\n            addVertex(nextPointR, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n        if (innerSideModified) {\n          if (joinIsOnLeftSide) {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPointL, u0, 0)\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(nextPointL, u0, 0)\n            addVertex(innerPoint, u1, 1)\n          } else {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(currentPointR, u0, 1)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPoint, u1, 0.5)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 0)\n            addVertex(nextPointR, u0, 1)\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n        // param center: End point of the path\n        // param p1, p2: Left and right cap points\n\n        switch (style.strokeLineCap) {\n          case 'round':\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5)\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5)\n            }\n\n            break\n\n          case 'square':\n            if (start) {\n              tempV2_1.subVectors(p1, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, 1 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n                tempV2_4.toArray(vertices, 3 * 3)\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3)\n                // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n              }\n            } else {\n              tempV2_1.subVectors(p2, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              const vl = vertices.length\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              }\n            }\n\n            break\n\n          case 'butt':\n          default:\n            // Nothing to do here\n            break\n        }\n      }\n\n      function removeDuplicatedPoints(points) {\n        // Creates a new array if necessary with duplicated points removed.\n        // This does not remove duplicated initial and ending points of a closed path.\n\n        let dupPoints = false\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\n            dupPoints = true\n            break\n          }\n        }\n\n        if (!dupPoints) return points\n\n        const newPoints = []\n        newPoints.push(points[0])\n\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n            newPoints.push(points[i])\n          }\n        }\n\n        newPoints.push(points[points.length - 1])\n\n        return newPoints\n      }\n    }\n  }\n\n  return SVGLoader\n})()\n\nexport { SVGLoader }\n"],"names":["SVGLoader","node","data","i","current","currentTransform","scanlineMinX","scanlineMaxX","p","joinIsOnLeftSide","innerSideModified","points"],"mappings":"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"}},
    {"offset": {"line": 23874, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/3DMLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/3DMLoader.js"],"sourcesContent":["import {\n  BufferGeometryLoader,\n  FileLoader,\n  Loader,\n  Object3D,\n  MeshStandardMaterial,\n  Mesh,\n  Color,\n  Points,\n  PointsMaterial,\n  Line,\n  LineBasicMaterial,\n  Matrix4,\n  DirectionalLight,\n  PointLight,\n  SpotLight,\n  RectAreaLight,\n  Vector3,\n  Sprite,\n  SpriteMaterial,\n  CanvasTexture,\n  LinearFilter,\n  ClampToEdgeWrapping,\n  TextureLoader,\n} from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass Rhino3dmLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.libraryPath = ''\n    this.libraryPending = null\n    this.libraryBinary = null\n    this.libraryConfig = {}\n\n    this.url = ''\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n    this.workerConfig = {}\n\n    this.materials = []\n  }\n\n  setLibraryPath(path) {\n    this.libraryPath = path\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n\n    this.url = url\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this.decodeObjects(buffer, url).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  decodeObjects(buffer, url) {\n    let worker\n    let taskID\n\n    const taskCost = buffer.byteLength\n\n    const objectPending = this._getWorker(taskCost)\n      .then((_worker) => {\n        worker = _worker\n        taskID = this.workerNextTaskID++ //hmmm\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, buffer }, [buffer])\n\n          //this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.data))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    objectPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          //this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      url: url,\n      promise: objectPending,\n    })\n\n    return objectPending\n  }\n\n  parse(data, onLoad, onError) {\n    this.decodeObjects(data, '').then(onLoad).catch(onError)\n  }\n\n  _compareMaterials(material) {\n    const mat = {}\n    mat.name = material.name\n    mat.color = {}\n    mat.color.r = material.color.r\n    mat.color.g = material.color.g\n    mat.color.b = material.color.b\n    mat.type = material.type\n\n    for (let i = 0; i < this.materials.length; i++) {\n      const m = this.materials[i]\n      const _mat = {}\n      _mat.name = m.name\n      _mat.color = {}\n      _mat.color.r = m.color.r\n      _mat.color.g = m.color.g\n      _mat.color.b = m.color.b\n      _mat.type = m.type\n\n      if (JSON.stringify(mat) === JSON.stringify(_mat)) {\n        return m\n      }\n    }\n\n    this.materials.push(material)\n\n    return material\n  }\n\n  _createMaterial(material) {\n    if (material === undefined) {\n      return new MeshStandardMaterial({\n        color: new Color(1, 1, 1),\n        metalness: 0.8,\n        name: 'default',\n        side: 2,\n      })\n    }\n\n    const _diffuseColor = material.diffuseColor\n\n    const diffusecolor = new Color(_diffuseColor.r / 255.0, _diffuseColor.g / 255.0, _diffuseColor.b / 255.0)\n\n    if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {\n      diffusecolor.r = 1\n      diffusecolor.g = 1\n      diffusecolor.b = 1\n    }\n\n    // console.log( material );\n\n    const mat = new MeshStandardMaterial({\n      color: diffusecolor,\n      name: material.name,\n      side: 2,\n      transparent: material.transparency > 0 ? true : false,\n      opacity: 1.0 - material.transparency,\n    })\n\n    const textureLoader = new TextureLoader()\n\n    for (let i = 0; i < material.textures.length; i++) {\n      const texture = material.textures[i]\n\n      if (texture.image !== null) {\n        const map = textureLoader.load(texture.image)\n\n        switch (texture.type) {\n          case 'Diffuse':\n            mat.map = map\n\n            break\n\n          case 'Bump':\n            mat.bumpMap = map\n\n            break\n\n          case 'Transparency':\n            mat.alphaMap = map\n            mat.transparent = true\n\n            break\n\n          case 'Emap':\n            mat.envMap = map\n\n            break\n        }\n      }\n    }\n\n    return mat\n  }\n\n  _createGeometry(data) {\n    // console.log(data);\n\n    const object = new Object3D()\n    const instanceDefinitionObjects = []\n    const instanceDefinitions = []\n    const instanceReferences = []\n\n    object.userData['layers'] = data.layers\n    object.userData['groups'] = data.groups\n    object.userData['settings'] = data.settings\n    object.userData['objectType'] = 'File3dm'\n    object.userData['materials'] = null\n    object.name = this.url\n\n    let objects = data.objects\n    const materials = data.materials\n\n    for (let i = 0; i < objects.length; i++) {\n      const obj = objects[i]\n      const attributes = obj.attributes\n\n      switch (obj.objectType) {\n        case 'InstanceDefinition':\n          instanceDefinitions.push(obj)\n\n          break\n\n        case 'InstanceReference':\n          instanceReferences.push(obj)\n\n          break\n\n        default:\n          let _object\n\n          if (attributes.materialIndex >= 0) {\n            const rMaterial = materials[attributes.materialIndex]\n            let material = this._createMaterial(rMaterial)\n            material = this._compareMaterials(material)\n            _object = this._createObject(obj, material)\n          } else {\n            const material = this._createMaterial()\n            _object = this._createObject(obj, material)\n          }\n\n          if (_object === undefined) {\n            continue\n          }\n\n          const layer = data.layers[attributes.layerIndex]\n\n          _object.visible = layer ? data.layers[attributes.layerIndex].visible : true\n\n          if (attributes.isInstanceDefinitionObject) {\n            instanceDefinitionObjects.push(_object)\n          } else {\n            object.add(_object)\n          }\n\n          break\n      }\n    }\n\n    for (let i = 0; i < instanceDefinitions.length; i++) {\n      const iDef = instanceDefinitions[i]\n\n      objects = []\n\n      for (let j = 0; j < iDef.attributes.objectIds.length; j++) {\n        const objId = iDef.attributes.objectIds[j]\n\n        for (let p = 0; p < instanceDefinitionObjects.length; p++) {\n          const idoId = instanceDefinitionObjects[p].userData.attributes.id\n\n          if (objId === idoId) {\n            objects.push(instanceDefinitionObjects[p])\n          }\n        }\n      }\n\n      // Currently clones geometry and does not take advantage of instancing\n\n      for (let j = 0; j < instanceReferences.length; j++) {\n        const iRef = instanceReferences[j]\n\n        if (iRef.geometry.parentIdefId === iDef.attributes.id) {\n          const iRefObject = new Object3D()\n          const xf = iRef.geometry.xform.array\n\n          const matrix = new Matrix4()\n          matrix.set(\n            xf[0],\n            xf[1],\n            xf[2],\n            xf[3],\n            xf[4],\n            xf[5],\n            xf[6],\n            xf[7],\n            xf[8],\n            xf[9],\n            xf[10],\n            xf[11],\n            xf[12],\n            xf[13],\n            xf[14],\n            xf[15],\n          )\n\n          iRefObject.applyMatrix4(matrix)\n\n          for (let p = 0; p < objects.length; p++) {\n            iRefObject.add(objects[p].clone(true))\n          }\n\n          object.add(iRefObject)\n        }\n      }\n    }\n\n    object.userData['materials'] = this.materials\n    return object\n  }\n\n  _createObject(obj, mat) {\n    const loader = new BufferGeometryLoader()\n\n    const attributes = obj.attributes\n\n    let geometry, material, _color, color\n\n    switch (obj.objectType) {\n      case 'Point':\n      case 'PointSet':\n        geometry = loader.parse(obj.geometry)\n\n        if (geometry.attributes.hasOwnProperty('color')) {\n          material = new PointsMaterial({ vertexColors: true, sizeAttenuation: false, size: 2 })\n        } else {\n          _color = attributes.drawColor\n          color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0)\n          material = new PointsMaterial({ color: color, sizeAttenuation: false, size: 2 })\n        }\n\n        material = this._compareMaterials(material)\n\n        const points = new Points(geometry, material)\n        points.userData['attributes'] = attributes\n        points.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          points.name = attributes.name\n        }\n\n        return points\n\n      case 'Mesh':\n      case 'Extrusion':\n      case 'SubD':\n      case 'Brep':\n        if (obj.geometry === null) return\n\n        geometry = loader.parse(obj.geometry)\n\n        if (geometry.attributes.hasOwnProperty('color')) {\n          mat.vertexColors = true\n        }\n\n        if (mat === null) {\n          mat = this._createMaterial()\n          mat = this._compareMaterials(mat)\n        }\n\n        const mesh = new Mesh(geometry, mat)\n        mesh.castShadow = attributes.castsShadows\n        mesh.receiveShadow = attributes.receivesShadows\n        mesh.userData['attributes'] = attributes\n        mesh.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          mesh.name = attributes.name\n        }\n\n        return mesh\n\n      case 'Curve':\n        geometry = loader.parse(obj.geometry)\n\n        _color = attributes.drawColor\n        color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0)\n\n        material = new LineBasicMaterial({ color: color })\n        material = this._compareMaterials(material)\n\n        const lines = new Line(geometry, material)\n        lines.userData['attributes'] = attributes\n        lines.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          lines.name = attributes.name\n        }\n\n        return lines\n\n      case 'TextDot':\n        geometry = obj.geometry\n\n        const ctx = document.createElement('canvas').getContext('2d')\n        const font = `${geometry.fontHeight}px ${geometry.fontFace}`\n        ctx.font = font\n        const width = ctx.measureText(geometry.text).width + 10\n        const height = geometry.fontHeight + 10\n\n        const r = window.devicePixelRatio\n\n        ctx.canvas.width = width * r\n        ctx.canvas.height = height * r\n        ctx.canvas.style.width = width + 'px'\n        ctx.canvas.style.height = height + 'px'\n        ctx.setTransform(r, 0, 0, r, 0, 0)\n\n        ctx.font = font\n        ctx.textBaseline = 'middle'\n        ctx.textAlign = 'center'\n        color = attributes.drawColor\n        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`\n        ctx.fillRect(0, 0, width, height)\n        ctx.fillStyle = 'white'\n        ctx.fillText(geometry.text, width / 2, height / 2)\n\n        const texture = new CanvasTexture(ctx.canvas)\n        texture.minFilter = LinearFilter\n        texture.wrapS = ClampToEdgeWrapping\n        texture.wrapT = ClampToEdgeWrapping\n\n        material = new SpriteMaterial({ map: texture, depthTest: false })\n        const sprite = new Sprite(material)\n        sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2])\n        sprite.scale.set(width / 10, height / 10, 1.0)\n\n        sprite.userData['attributes'] = attributes\n        sprite.userData['objectType'] = obj.objectType\n\n        if (attributes.name) {\n          sprite.name = attributes.name\n        }\n\n        return sprite\n\n      case 'Light':\n        geometry = obj.geometry\n\n        let light\n\n        if (geometry.isDirectionalLight) {\n          light = new DirectionalLight()\n          light.castShadow = attributes.castsShadows\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2])\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2])\n          light.shadow.normalBias = 0.1\n        } else if (geometry.isPointLight) {\n          light = new PointLight()\n          light.castShadow = attributes.castsShadows\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2])\n          light.shadow.normalBias = 0.1\n        } else if (geometry.isRectangularLight) {\n          light = new RectAreaLight()\n\n          const width = Math.abs(geometry.width[2])\n          const height = Math.abs(geometry.length[0])\n\n          light.position.set(geometry.location[0] - height / 2, geometry.location[1], geometry.location[2] - width / 2)\n\n          light.height = height\n          light.width = width\n\n          light.lookAt(new Vector3(geometry.direction[0], geometry.direction[1], geometry.direction[2]))\n        } else if (geometry.isSpotLight) {\n          light = new SpotLight()\n          light.castShadow = attributes.castsShadows\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2])\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2])\n          light.angle = geometry.spotAngleRadians\n          light.shadow.normalBias = 0.1\n        } else if (geometry.isLinearLight) {\n          console.warn('THREE.3DMLoader:  No conversion exists for linear lights.')\n\n          return\n        }\n\n        if (light) {\n          light.intensity = geometry.intensity\n          _color = geometry.diffuse\n          color = new Color(_color.r / 255.0, _color.g / 255.0, _color.b / 255.0)\n          light.color = color\n          light.userData['attributes'] = attributes\n          light.userData['objectType'] = obj.objectType\n        }\n\n        return light\n    }\n  }\n\n  _initLibrary() {\n    if (!this.libraryPending) {\n      // Load rhino3dm wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.libraryPath)\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('rhino3dm.js', resolve, undefined, reject)\n      })\n\n      // Load rhino3dm WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.libraryPath)\n      binaryLoader.setResponseType('arraybuffer')\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('rhino3dm.wasm', resolve, undefined, reject)\n      })\n\n      this.libraryPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        //this.libraryBinary = binaryContent;\n        this.libraryConfig.wasmBinary = binaryContent\n\n        const fn = Rhino3dmWorker.toString()\n\n        const body = [\n          '/* rhino3dm.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n      })\n    }\n\n    return this.libraryPending\n  }\n\n  _getWorker(taskCost) {\n    return this._initLibrary().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({\n          type: 'init',\n          libraryConfig: this.libraryConfig,\n        })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.Rhino3dmLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n\n      worker._taskLoad += taskCost\n\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction Rhino3dmWorker() {\n  let libraryPending\n  let libraryConfig\n  let rhino\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        libraryConfig = message.libraryConfig\n        const wasmBinary = libraryConfig.wasmBinary\n        let RhinoModule\n        libraryPending = new Promise(function (resolve) {\n          /* Like Basis Loader */\n          RhinoModule = { wasmBinary, onRuntimeInitialized: resolve }\n\n          rhino3dm(RhinoModule)\n        }).then(() => {\n          rhino = RhinoModule\n        })\n\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        libraryPending.then(() => {\n          const data = decodeObjects(rhino, buffer)\n\n          self.postMessage({ type: 'decode', id: message.id, data })\n        })\n\n        break\n    }\n  }\n\n  function decodeObjects(rhino, buffer) {\n    const arr = new Uint8Array(buffer)\n    const doc = rhino.File3dm.fromByteArray(arr)\n\n    const objects = []\n    const materials = []\n    const layers = []\n    const views = []\n    const namedViews = []\n    const groups = []\n\n    //Handle objects\n\n    const objs = doc.objects()\n    const cnt = objs.count\n\n    for (let i = 0; i < cnt; i++) {\n      const _object = objs.get(i)\n\n      const object = extractObjectData(_object, doc)\n\n      _object.delete()\n\n      if (object) {\n        objects.push(object)\n      }\n    }\n\n    // Handle instance definitions\n    // console.log( `Instance Definitions Count: ${doc.instanceDefinitions().count()}` );\n\n    for (let i = 0; i < doc.instanceDefinitions().count(); i++) {\n      const idef = doc.instanceDefinitions().get(i)\n      const idefAttributes = extractProperties(idef)\n      idefAttributes.objectIds = idef.getObjectIds()\n\n      objects.push({ geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' })\n    }\n\n    // Handle materials\n\n    const textureTypes = [\n      // rhino.TextureType.Bitmap,\n      rhino.TextureType.Diffuse,\n      rhino.TextureType.Bump,\n      rhino.TextureType.Transparency,\n      rhino.TextureType.Opacity,\n      rhino.TextureType.Emap,\n    ]\n\n    const pbrTextureTypes = [\n      rhino.TextureType.PBR_BaseColor,\n      rhino.TextureType.PBR_Subsurface,\n      rhino.TextureType.PBR_SubsurfaceScattering,\n      rhino.TextureType.PBR_SubsurfaceScatteringRadius,\n      rhino.TextureType.PBR_Metallic,\n      rhino.TextureType.PBR_Specular,\n      rhino.TextureType.PBR_SpecularTint,\n      rhino.TextureType.PBR_Roughness,\n      rhino.TextureType.PBR_Anisotropic,\n      rhino.TextureType.PBR_Anisotropic_Rotation,\n      rhino.TextureType.PBR_Sheen,\n      rhino.TextureType.PBR_SheenTint,\n      rhino.TextureType.PBR_Clearcoat,\n      rhino.TextureType.PBR_ClearcoatBump,\n      rhino.TextureType.PBR_ClearcoatRoughness,\n      rhino.TextureType.PBR_OpacityIor,\n      rhino.TextureType.PBR_OpacityRoughness,\n      rhino.TextureType.PBR_Emission,\n      rhino.TextureType.PBR_AmbientOcclusion,\n      rhino.TextureType.PBR_Displacement,\n    ]\n\n    for (let i = 0; i < doc.materials().count(); i++) {\n      const _material = doc.materials().get(i)\n      const _pbrMaterial = _material.physicallyBased()\n\n      let material = extractProperties(_material)\n\n      const textures = []\n\n      for (let j = 0; j < textureTypes.length; j++) {\n        const _texture = _material.getTexture(textureTypes[j])\n        if (_texture) {\n          let textureType = textureTypes[j].constructor.name\n          textureType = textureType.substring(12, textureType.length)\n          const texture = { type: textureType }\n\n          const image = doc.getEmbeddedFileAsBase64(_texture.fileName)\n\n          if (image) {\n            texture.image = 'data:image/png;base64,' + image\n          } else {\n            console.warn(`THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`)\n            texture.image = null\n          }\n\n          textures.push(texture)\n\n          _texture.delete()\n        }\n      }\n\n      material.textures = textures\n\n      if (_pbrMaterial.supported) {\n        console.log('pbr true')\n\n        for (let j = 0; j < pbrTextureTypes.length; j++) {\n          const _texture = _material.getTexture(textureTypes[j])\n          if (_texture) {\n            const image = doc.getEmbeddedFileAsBase64(_texture.fileName)\n            let textureType = textureTypes[j].constructor.name\n            textureType = textureType.substring(12, textureType.length)\n            const texture = { type: textureType, image: 'data:image/png;base64,' + image }\n            textures.push(texture)\n\n            _texture.delete()\n          }\n        }\n\n        const pbMaterialProperties = extractProperties(_material.physicallyBased())\n\n        material = Object.assign(pbMaterialProperties, material)\n      }\n\n      materials.push(material)\n\n      _material.delete()\n      _pbrMaterial.delete()\n    }\n\n    // Handle layers\n\n    for (let i = 0; i < doc.layers().count(); i++) {\n      const _layer = doc.layers().get(i)\n      const layer = extractProperties(_layer)\n\n      layers.push(layer)\n\n      _layer.delete()\n    }\n\n    // Handle views\n\n    for (let i = 0; i < doc.views().count(); i++) {\n      const _view = doc.views().get(i)\n      const view = extractProperties(_view)\n\n      views.push(view)\n\n      _view.delete()\n    }\n\n    // Handle named views\n\n    for (let i = 0; i < doc.namedViews().count(); i++) {\n      const _namedView = doc.namedViews().get(i)\n      const namedView = extractProperties(_namedView)\n\n      namedViews.push(namedView)\n\n      _namedView.delete()\n    }\n\n    // Handle groups\n\n    for (let i = 0; i < doc.groups().count(); i++) {\n      const _group = doc.groups().get(i)\n      const group = extractProperties(_group)\n\n      groups.push(group)\n\n      _group.delete()\n    }\n\n    // Handle settings\n\n    const settings = extractProperties(doc.settings())\n\n    //TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.\n\n    // Handle dimstyles\n    // console.log( `Dimstyle Count: ${doc.dimstyles().count()}` );\n\n    // Handle bitmaps\n    // console.log( `Bitmap Count: ${doc.bitmaps().count()}` );\n\n    // Handle strings -- this seems to be broken at the moment in rhino3dm\n    // console.log( `Document Strings Count: ${doc.strings().count()}` );\n\n    /*\n\t\tfor( var i = 0; i < doc.strings().count(); i++ ){\n\n\t\t\tvar _string= doc.strings().get( i );\n\n\t\t\tconsole.log(_string);\n\t\t\tvar string = extractProperties( _group );\n\n\t\t\tstrings.push( string );\n\n\t\t\t_string.delete();\n\n\t\t}\n\t\t*/\n\n    doc.delete()\n\n    return { objects, materials, layers, views, namedViews, groups, settings }\n  }\n\n  function extractObjectData(object, doc) {\n    const _geometry = object.geometry()\n    const _attributes = object.attributes()\n    let objectType = _geometry.objectType\n    let geometry, attributes, position, data, mesh\n\n    // skip instance definition objects\n    //if( _attributes.isInstanceDefinitionObject ) { continue; }\n\n    // TODO: handle other geometry types\n    switch (objectType) {\n      case rhino.ObjectType.Curve:\n        const pts = curveToPoints(_geometry, 100)\n\n        position = {}\n        attributes = {}\n        data = {}\n\n        position.itemSize = 3\n        position.type = 'Float32Array'\n        position.array = []\n\n        for (let j = 0; j < pts.length; j++) {\n          position.array.push(pts[j][0])\n          position.array.push(pts[j][1])\n          position.array.push(pts[j][2])\n        }\n\n        attributes.position = position\n        data.attributes = attributes\n\n        geometry = { data }\n\n        break\n\n      case rhino.ObjectType.Point:\n        const pt = _geometry.location\n\n        position = {}\n        const color = {}\n        attributes = {}\n        data = {}\n\n        position.itemSize = 3\n        position.type = 'Float32Array'\n        position.array = [pt[0], pt[1], pt[2]]\n\n        const _color = _attributes.drawColor(doc)\n\n        color.itemSize = 3\n        color.type = 'Float32Array'\n        color.array = [_color.r / 255.0, _color.g / 255.0, _color.b / 255.0]\n\n        attributes.position = position\n        attributes.color = color\n        data.attributes = attributes\n\n        geometry = { data }\n\n        break\n\n      case rhino.ObjectType.PointSet:\n      case rhino.ObjectType.Mesh:\n        geometry = _geometry.toThreejsJSON()\n\n        break\n\n      case rhino.ObjectType.Brep:\n        const faces = _geometry.faces()\n        mesh = new rhino.Mesh()\n\n        for (let faceIndex = 0; faceIndex < faces.count; faceIndex++) {\n          const face = faces.get(faceIndex)\n          const _mesh = face.getMesh(rhino.MeshType.Any)\n\n          if (_mesh) {\n            mesh.append(_mesh)\n            _mesh.delete()\n          }\n\n          face.delete()\n        }\n\n        if (mesh.faces().count > 0) {\n          mesh.compact()\n          geometry = mesh.toThreejsJSON()\n          faces.delete()\n        }\n\n        mesh.delete()\n\n        break\n\n      case rhino.ObjectType.Extrusion:\n        mesh = _geometry.getMesh(rhino.MeshType.Any)\n\n        if (mesh) {\n          geometry = mesh.toThreejsJSON()\n          mesh.delete()\n        }\n\n        break\n\n      case rhino.ObjectType.TextDot:\n        geometry = extractProperties(_geometry)\n\n        break\n\n      case rhino.ObjectType.Light:\n        geometry = extractProperties(_geometry)\n\n        break\n\n      case rhino.ObjectType.InstanceReference:\n        geometry = extractProperties(_geometry)\n        geometry.xform = extractProperties(_geometry.xform)\n        geometry.xform.array = _geometry.xform.toFloatArray(true)\n\n        break\n\n      case rhino.ObjectType.SubD:\n        // TODO: precalculate resulting vertices and faces and warn on excessive results\n        _geometry.subdivide(3)\n        mesh = rhino.Mesh.createFromSubDControlNet(_geometry)\n        if (mesh) {\n          geometry = mesh.toThreejsJSON()\n          mesh.delete()\n        }\n\n        break\n\n      /*\n\t\t\t\tcase rhino.ObjectType.Annotation:\n\t\t\t\tcase rhino.ObjectType.Hatch:\n\t\t\t\tcase rhino.ObjectType.ClipPlane:\n\t\t\t\t*/\n\n      default:\n        console.warn(`THREE.3DMLoader: TODO: Implement ${objectType.constructor.name}`)\n        break\n    }\n\n    if (geometry) {\n      attributes = extractProperties(_attributes)\n      attributes.geometry = extractProperties(_geometry)\n\n      if (_attributes.groupCount > 0) {\n        attributes.groupIds = _attributes.getGroupList()\n      }\n\n      if (_attributes.userStringCount > 0) {\n        attributes.userStrings = _attributes.getUserStrings()\n      }\n\n      if (_geometry.userStringCount > 0) {\n        attributes.geometry.userStrings = _geometry.getUserStrings()\n      }\n\n      attributes.drawColor = _attributes.drawColor(doc)\n\n      objectType = objectType.constructor.name\n      objectType = objectType.substring(11, objectType.length)\n\n      return { geometry, attributes, objectType }\n    } else {\n      console.warn(`THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`)\n    }\n  }\n\n  function extractProperties(object) {\n    const result = {}\n\n    for (const property in object) {\n      const value = object[property]\n\n      if (typeof value !== 'function') {\n        if (typeof value === 'object' && value !== null && value.hasOwnProperty('constructor')) {\n          result[property] = { name: value.constructor.name, value: value.value }\n        } else {\n          result[property] = value\n        }\n      } else {\n        // these are functions that could be called to extract more data.\n        //console.log( `${property}: ${object[ property ].constructor.name}` );\n      }\n    }\n\n    return result\n  }\n\n  function curveToPoints(curve, pointLimit) {\n    let pointCount = pointLimit\n    let rc = []\n    const ts = []\n\n    if (curve instanceof rhino.LineCurve) {\n      return [curve.pointAtStart, curve.pointAtEnd]\n    }\n\n    if (curve instanceof rhino.PolylineCurve) {\n      pointCount = curve.pointCount\n      for (let i = 0; i < pointCount; i++) {\n        rc.push(curve.point(i))\n      }\n\n      return rc\n    }\n\n    if (curve instanceof rhino.PolyCurve) {\n      const segmentCount = curve.segmentCount\n\n      for (let i = 0; i < segmentCount; i++) {\n        const segment = curve.segmentCurve(i)\n        const segmentArray = curveToPoints(segment, pointCount)\n        rc = rc.concat(segmentArray)\n        segment.delete()\n      }\n\n      return rc\n    }\n\n    if (curve instanceof rhino.ArcCurve) {\n      pointCount = Math.floor(curve.angleDegrees / 5)\n      pointCount = pointCount < 2 ? 2 : pointCount\n      // alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399\n    }\n\n    if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {\n      const pLine = curve.tryGetPolyline()\n\n      for (let i = 0; i < pLine.count; i++) {\n        rc.push(pLine.get(i))\n      }\n\n      pLine.delete()\n\n      return rc\n    }\n\n    const domain = curve.domain\n    const divisions = pointCount - 1.0\n\n    for (let j = 0; j < pointCount; j++) {\n      const t = domain[0] + (j / divisions) * (domain[1] - domain[0])\n\n      if (t === domain[0] || t === domain[1]) {\n        ts.push(t)\n        continue\n      }\n\n      const tan = curve.tangentAt(t)\n      const prevTan = curve.tangentAt(ts.slice(-1)[0])\n\n      // Duplicated from THREE.Vector3\n      // How to pass imports to worker?\n\n      const tS = tan[0] * tan[0] + tan[1] * tan[1] + tan[2] * tan[2]\n      const ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2]\n\n      const denominator = Math.sqrt(tS * ptS)\n\n      let angle\n\n      if (denominator === 0) {\n        angle = Math.PI / 2\n      } else {\n        const theta = (tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z) / denominator\n        angle = Math.acos(Math.max(-1, Math.min(1, theta)))\n      }\n\n      if (angle < 0.1) continue\n\n      ts.push(t)\n    }\n\n    rc = ts.map((t) => curve.pointAt(t))\n    return rc\n  }\n}\n\nexport { Rhino3dmLoader }\n"],"names":["width","height","jsContent","binaryContent","worker","rhino"],"mappings":";;;;;;AA0BA,MAAM,aAAa,aAAA,GAAA,IAAI,QAAS;AAEhC,MAAM,uBAAuB,yJAAA,CAAO;IAClC,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QAEb,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,cAAA,GAAiB;QACtB,IAAA,CAAK,aAAA,GAAgB;QACrB,IAAA,CAAK,aAAA,GAAgB,CAAE;QAEvB,IAAA,CAAK,GAAA,GAAM;QAEX,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,UAAA,GAAa,CAAE,CAAA;QACpB,IAAA,CAAK,gBAAA,GAAmB;QACxB,IAAA,CAAK,eAAA,GAAkB;QACvB,IAAA,CAAK,YAAA,GAAe,CAAE;QAEtB,IAAA,CAAK,SAAA,GAAY,CAAE,CAAA;IACpB;IAED,eAAe,IAAA,EAAM;QACnB,IAAA,CAAK,WAAA,GAAc;QAEnB,OAAO,IAAA;IACR;IAED,eAAe,WAAA,EAAa;QAC1B,IAAA,CAAK,WAAA,GAAc;QAEnB,OAAO,IAAA;IACR;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,SAAS,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;QAE1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,eAAA,CAAgB,aAAa;QACpC,OAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa;QAE1C,IAAA,CAAK,GAAA,GAAM;QAEX,OAAO,IAAA,CACL,KACA,CAAC,WAAW;YAGV,IAAI,WAAW,GAAA,CAAI,MAAM,GAAG;gBAC1B,MAAM,aAAa,WAAW,GAAA,CAAI,MAAM;gBAExC,OAAO,WAAW,OAAA,CAAQ,IAAA,CAAK,MAAM,EAAE,KAAA,CAAM,OAAO;YACrD;YAED,IAAA,CAAK,aAAA,CAAc,QAAQ,GAAG,EAAE,IAAA,CAAK,MAAM,EAAE,KAAA,CAAM,OAAO;QAC3D,GACD,YACA;IAEH;IAED,QAAQ;QACN,QAAQ,GAAA,CACN,eACA,IAAA,CAAK,UAAA,CAAW,GAAA,CAAI,CAAC,SAAW,OAAO,SAAS;IAEnD;IAED,cAAc,MAAA,EAAQ,GAAA,EAAK;QACzB,IAAI;QACJ,IAAI;QAEJ,MAAM,WAAW,OAAO,UAAA;QAExB,MAAM,gBAAgB,IAAA,CAAK,UAAA,CAAW,QAAQ,EAC3C,IAAA,CAAK,CAAC,YAAY;YACjB,SAAS;YACT,SAAS,IAAA,CAAK,gBAAA;YAEd,OAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;gBACtC,OAAO,UAAA,CAAW,MAAM,CAAA,GAAI;oBAAE;oBAAS;gBAAQ;gBAE/C,OAAO,WAAA,CAAY;oBAAE,MAAM;oBAAU,IAAI;oBAAQ;gBAAM,GAAI;oBAAC,MAAM;iBAAC;YAG7E,CAAS;QACT,CAAO,EACA,IAAA,CAAK,CAAC,UAAY,IAAA,CAAK,eAAA,CAAgB,QAAQ,IAAI,CAAC;QAIvD,cACG,KAAA,CAAM,IAAM,IAAI,EAChB,IAAA,CAAK,MAAM;YACV,IAAI,UAAU,QAAQ;gBACpB,IAAA,CAAK,YAAA,CAAa,QAAQ,MAAM;YAGjC;QACT,CAAO;QAGH,WAAW,GAAA,CAAI,QAAQ;YACrB;YACA,SAAS;QACf,CAAK;QAED,OAAO;IACR;IAED,MAAM,IAAA,EAAM,MAAA,EAAQ,OAAA,EAAS;QAC3B,IAAA,CAAK,aAAA,CAAc,MAAM,EAAE,EAAE,IAAA,CAAK,MAAM,EAAE,KAAA,CAAM,OAAO;IACxD;IAED,kBAAkB,QAAA,EAAU;QAC1B,MAAM,MAAM,CAAE;QACd,IAAI,IAAA,GAAO,SAAS,IAAA;QACpB,IAAI,KAAA,GAAQ,CAAE;QACd,IAAI,KAAA,CAAM,CAAA,GAAI,SAAS,KAAA,CAAM,CAAA;QAC7B,IAAI,KAAA,CAAM,CAAA,GAAI,SAAS,KAAA,CAAM,CAAA;QAC7B,IAAI,KAAA,CAAM,CAAA,GAAI,SAAS,KAAA,CAAM,CAAA;QAC7B,IAAI,IAAA,GAAO,SAAS,IAAA;QAEpB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,SAAA,CAAU,MAAA,EAAQ,IAAK;YAC9C,MAAM,IAAI,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA;YAC1B,MAAM,OAAO,CAAE;YACf,KAAK,IAAA,GAAO,EAAE,IAAA;YACd,KAAK,KAAA,GAAQ,CAAE;YACf,KAAK,KAAA,CAAM,CAAA,GAAI,EAAE,KAAA,CAAM,CAAA;YACvB,KAAK,KAAA,CAAM,CAAA,GAAI,EAAE,KAAA,CAAM,CAAA;YACvB,KAAK,KAAA,CAAM,CAAA,GAAI,EAAE,KAAA,CAAM,CAAA;YACvB,KAAK,IAAA,GAAO,EAAE,IAAA;YAEd,IAAI,KAAK,SAAA,CAAU,GAAG,MAAM,KAAK,SAAA,CAAU,IAAI,GAAG;gBAChD,OAAO;YACR;QACF;QAED,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ;QAE5B,OAAO;IACR;IAED,gBAAgB,QAAA,EAAU;QACxB,IAAI,aAAa,KAAA,GAAW;YAC1B,OAAO,IAAI,uKAAA,CAAqB;gBAC9B,OAAO,IAAI,wJAAA,CAAM,GAAG,GAAG,CAAC;gBACxB,WAAW;gBACX,MAAM;gBACN,MAAM;YACd,CAAO;QACF;QAED,MAAM,gBAAgB,SAAS,YAAA;QAE/B,MAAM,eAAe,IAAI,wJAAA,CAAM,cAAc,CAAA,GAAI,KAAO,cAAc,CAAA,GAAI,KAAO,cAAc,CAAA,GAAI,GAAK;QAExG,IAAI,cAAc,CAAA,KAAM,KAAK,cAAc,CAAA,KAAM,KAAK,cAAc,CAAA,KAAM,GAAG;YAC3E,aAAa,CAAA,GAAI;YACjB,aAAa,CAAA,GAAI;YACjB,aAAa,CAAA,GAAI;QAClB;QAID,MAAM,MAAM,IAAI,uKAAA,CAAqB;YACnC,OAAO;YACP,MAAM,SAAS,IAAA;YACf,MAAM;YACN,aAAa,SAAS,YAAA,GAAe,IAAI,OAAO;YAChD,SAAS,IAAM,SAAS,YAAA;QAC9B,CAAK;QAED,MAAM,gBAAgB,IAAI,gKAAA,CAAe;QAEzC,IAAA,IAAS,IAAI,GAAG,IAAI,SAAS,QAAA,CAAS,MAAA,EAAQ,IAAK;YACjD,MAAM,UAAU,SAAS,QAAA,CAAS,CAAC,CAAA;YAEnC,IAAI,QAAQ,KAAA,KAAU,MAAM;gBAC1B,MAAM,MAAM,cAAc,IAAA,CAAK,QAAQ,KAAK;gBAE5C,OAAQ,QAAQ,IAAA,EAAI;oBAClB,KAAK;wBACH,IAAI,GAAA,GAAM;wBAEV;oBAEF,KAAK;wBACH,IAAI,OAAA,GAAU;wBAEd;oBAEF,KAAK;wBACH,IAAI,QAAA,GAAW;wBACf,IAAI,WAAA,GAAc;wBAElB;oBAEF,KAAK;wBACH,IAAI,MAAA,GAAS;wBAEb;gBACH;YACF;QACF;QAED,OAAO;IACR;IAED,gBAAgB,IAAA,EAAM;QAGpB,MAAM,SAAS,IAAI,2JAAA,CAAU;QAC7B,MAAM,4BAA4B,CAAE,CAAA;QACpC,MAAM,sBAAsB,CAAE,CAAA;QAC9B,MAAM,qBAAqB,CAAE,CAAA;QAE7B,OAAO,QAAA,CAAS,QAAQ,CAAA,GAAI,KAAK,MAAA;QACjC,OAAO,QAAA,CAAS,QAAQ,CAAA,GAAI,KAAK,MAAA;QACjC,OAAO,QAAA,CAAS,UAAU,CAAA,GAAI,KAAK,QAAA;QACnC,OAAO,QAAA,CAAS,YAAY,CAAA,GAAI;QAChC,OAAO,QAAA,CAAS,WAAW,CAAA,GAAI;QAC/B,OAAO,IAAA,GAAO,IAAA,CAAK,GAAA;QAEnB,IAAI,UAAU,KAAK,OAAA;QACnB,MAAM,YAAY,KAAK,SAAA;QAEvB,IAAA,IAAS,IAAI,GAAG,IAAI,QAAQ,MAAA,EAAQ,IAAK;YACvC,MAAM,MAAM,OAAA,CAAQ,CAAC,CAAA;YACrB,MAAM,aAAa,IAAI,UAAA;YAEvB,OAAQ,IAAI,UAAA,EAAU;gBACpB,KAAK;oBACH,oBAAoB,IAAA,CAAK,GAAG;oBAE5B;gBAEF,KAAK;oBACH,mBAAmB,IAAA,CAAK,GAAG;oBAE3B;gBAEF;oBACE,IAAI;oBAEJ,IAAI,WAAW,aAAA,IAAiB,GAAG;wBACjC,MAAM,YAAY,SAAA,CAAU,WAAW,aAAa,CAAA;wBACpD,IAAI,WAAW,IAAA,CAAK,eAAA,CAAgB,SAAS;wBAC7C,WAAW,IAAA,CAAK,iBAAA,CAAkB,QAAQ;wBAC1C,UAAU,IAAA,CAAK,aAAA,CAAc,KAAK,QAAQ;oBACtD,OAAiB;wBACL,MAAM,WAAW,IAAA,CAAK,eAAA,CAAiB;wBACvC,UAAU,IAAA,CAAK,aAAA,CAAc,KAAK,QAAQ;oBAC3C;oBAED,IAAI,YAAY,KAAA,GAAW;wBACzB;oBACD;oBAED,MAAM,QAAQ,KAAK,MAAA,CAAO,WAAW,UAAU,CAAA;oBAE/C,QAAQ,OAAA,GAAU,QAAQ,KAAK,MAAA,CAAO,WAAW,UAAU,CAAA,CAAE,OAAA,GAAU;oBAEvE,IAAI,WAAW,0BAAA,EAA4B;wBACzC,0BAA0B,IAAA,CAAK,OAAO;oBAClD,OAAiB;wBACL,OAAO,GAAA,CAAI,OAAO;oBACnB;oBAED;YACH;QACF;QAED,IAAA,IAAS,IAAI,GAAG,IAAI,oBAAoB,MAAA,EAAQ,IAAK;YACnD,MAAM,OAAO,mBAAA,CAAoB,CAAC,CAAA;YAElC,UAAU,CAAE,CAAA;YAEZ,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,UAAA,CAAW,SAAA,CAAU,MAAA,EAAQ,IAAK;gBACzD,MAAM,QAAQ,KAAK,UAAA,CAAW,SAAA,CAAU,CAAC,CAAA;gBAEzC,IAAA,IAAS,IAAI,GAAG,IAAI,0BAA0B,MAAA,EAAQ,IAAK;oBACzD,MAAM,QAAQ,yBAAA,CAA0B,CAAC,CAAA,CAAE,QAAA,CAAS,UAAA,CAAW,EAAA;oBAE/D,IAAI,UAAU,OAAO;wBACnB,QAAQ,IAAA,CAAK,yBAAA,CAA0B,CAAC,CAAC;oBAC1C;gBACF;YACF;YAID,IAAA,IAAS,IAAI,GAAG,IAAI,mBAAmB,MAAA,EAAQ,IAAK;gBAClD,MAAM,OAAO,kBAAA,CAAmB,CAAC,CAAA;gBAEjC,IAAI,KAAK,QAAA,CAAS,YAAA,KAAiB,KAAK,UAAA,CAAW,EAAA,EAAI;oBACrD,MAAM,aAAa,IAAI,2JAAA,CAAU;oBACjC,MAAM,KAAK,KAAK,QAAA,CAAS,KAAA,CAAM,KAAA;oBAE/B,MAAM,SAAS,IAAI,0JAAA,CAAS;oBAC5B,OAAO,GAAA,CACL,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,CAAC,CAAA,EACJ,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA,EACL,EAAA,CAAG,EAAE,CAAA;oBAGP,WAAW,YAAA,CAAa,MAAM;oBAE9B,IAAA,IAAS,IAAI,GAAG,IAAI,QAAQ,MAAA,EAAQ,IAAK;wBACvC,WAAW,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAA,CAAE,KAAA,CAAM,IAAI,CAAC;oBACtC;oBAED,OAAO,GAAA,CAAI,UAAU;gBACtB;YACF;QACF;QAED,OAAO,QAAA,CAAS,WAAW,CAAA,GAAI,IAAA,CAAK,SAAA;QACpC,OAAO;IACR;IAED,cAAc,GAAA,EAAK,GAAA,EAAK;QACtB,MAAM,SAAS,IAAI,uKAAA,CAAsB;QAEzC,MAAM,aAAa,IAAI,UAAA;QAEvB,IAAI,UAAU,UAAU,QAAQ;QAEhC,OAAQ,IAAI,UAAA,EAAU;YACpB,KAAK;YACL,KAAK;gBACH,WAAW,OAAO,KAAA,CAAM,IAAI,QAAQ;gBAEpC,IAAI,SAAS,UAAA,CAAW,cAAA,CAAe,OAAO,GAAG;oBAC/C,WAAW,IAAI,iKAAA,CAAe;wBAAE,cAAc;wBAAM,iBAAiB;wBAAO,MAAM;oBAAA,CAAG;gBAC/F,OAAe;oBACL,SAAS,WAAW,SAAA;oBACpB,QAAQ,IAAI,wJAAA,CAAM,OAAO,CAAA,GAAI,KAAO,OAAO,CAAA,GAAI,KAAO,OAAO,CAAA,GAAI,GAAK;oBACtE,WAAW,IAAI,iKAAA,CAAe;wBAAE;wBAAc,iBAAiB;wBAAO,MAAM;oBAAA,CAAG;gBAChF;gBAED,WAAW,IAAA,CAAK,iBAAA,CAAkB,QAAQ;gBAE1C,MAAM,SAAS,IAAI,yJAAA,CAAO,UAAU,QAAQ;gBAC5C,OAAO,QAAA,CAAS,YAAY,CAAA,GAAI;gBAChC,OAAO,QAAA,CAAS,YAAY,CAAA,GAAI,IAAI,UAAA;gBAEpC,IAAI,WAAW,IAAA,EAAM;oBACnB,OAAO,IAAA,GAAO,WAAW,IAAA;gBAC1B;gBAED,OAAO;YAET,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAI,IAAI,QAAA,KAAa,MAAM;gBAE3B,WAAW,OAAO,KAAA,CAAM,IAAI,QAAQ;gBAEpC,IAAI,SAAS,UAAA,CAAW,cAAA,CAAe,OAAO,GAAG;oBAC/C,IAAI,YAAA,GAAe;gBACpB;gBAED,IAAI,QAAQ,MAAM;oBAChB,MAAM,IAAA,CAAK,eAAA,CAAiB;oBAC5B,MAAM,IAAA,CAAK,iBAAA,CAAkB,GAAG;gBACjC;gBAED,MAAM,OAAO,IAAI,uJAAA,CAAK,UAAU,GAAG;gBACnC,KAAK,UAAA,GAAa,WAAW,YAAA;gBAC7B,KAAK,aAAA,GAAgB,WAAW,eAAA;gBAChC,KAAK,QAAA,CAAS,YAAY,CAAA,GAAI;gBAC9B,KAAK,QAAA,CAAS,YAAY,CAAA,GAAI,IAAI,UAAA;gBAElC,IAAI,WAAW,IAAA,EAAM;oBACnB,KAAK,IAAA,GAAO,WAAW,IAAA;gBACxB;gBAED,OAAO;YAET,KAAK;gBACH,WAAW,OAAO,KAAA,CAAM,IAAI,QAAQ;gBAEpC,SAAS,WAAW,SAAA;gBACpB,QAAQ,IAAI,wJAAA,CAAM,OAAO,CAAA,GAAI,KAAO,OAAO,CAAA,GAAI,KAAO,OAAO,CAAA,GAAI,GAAK;gBAEtE,WAAW,IAAI,oKAAA,CAAkB;oBAAE;gBAAY,CAAE;gBACjD,WAAW,IAAA,CAAK,iBAAA,CAAkB,QAAQ;gBAE1C,MAAM,QAAQ,IAAI,uJAAA,CAAK,UAAU,QAAQ;gBACzC,MAAM,QAAA,CAAS,YAAY,CAAA,GAAI;gBAC/B,MAAM,QAAA,CAAS,YAAY,CAAA,GAAI,IAAI,UAAA;gBAEnC,IAAI,WAAW,IAAA,EAAM;oBACnB,MAAM,IAAA,GAAO,WAAW,IAAA;gBACzB;gBAED,OAAO;YAET,KAAK;gBACH,WAAW,IAAI,QAAA;gBAEf,MAAM,MAAM,SAAS,aAAA,CAAc,QAAQ,EAAE,UAAA,CAAW,IAAI;gBAC5D,MAAM,OAAO,GAAG,SAAS,UAAA,CAAA,GAAA,EAAgB,SAAS,QAAA,EAAA;gBAClD,IAAI,IAAA,GAAO;gBACX,MAAM,QAAQ,IAAI,WAAA,CAAY,SAAS,IAAI,EAAE,KAAA,GAAQ;gBACrD,MAAM,SAAS,SAAS,UAAA,GAAa;gBAErC,MAAM,IAAI,OAAO,gBAAA;gBAEjB,IAAI,MAAA,CAAO,KAAA,GAAQ,QAAQ;gBAC3B,IAAI,MAAA,CAAO,MAAA,GAAS,SAAS;gBAC7B,IAAI,MAAA,CAAO,KAAA,CAAM,KAAA,GAAQ,QAAQ;gBACjC,IAAI,MAAA,CAAO,KAAA,CAAM,MAAA,GAAS,SAAS;gBACnC,IAAI,YAAA,CAAa,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;gBAEjC,IAAI,IAAA,GAAO;gBACX,IAAI,YAAA,GAAe;gBACnB,IAAI,SAAA,GAAY;gBAChB,QAAQ,WAAW,SAAA;gBACnB,IAAI,SAAA,GAAY,CAAA,KAAA,EAAQ,MAAM,CAAA,CAAA,CAAA,EAAK,MAAM,CAAA,CAAA,CAAA,EAAK,MAAM,CAAA,CAAA,CAAA,EAAK,MAAM,CAAA,CAAA,CAAA,CAAA;gBAC/D,IAAI,QAAA,CAAS,GAAG,GAAG,OAAO,MAAM;gBAChC,IAAI,SAAA,GAAY;gBAChB,IAAI,QAAA,CAAS,SAAS,IAAA,EAAM,QAAQ,GAAG,SAAS,CAAC;gBAEjD,MAAM,UAAU,IAAI,gKAAA,CAAc,IAAI,MAAM;gBAC5C,QAAQ,SAAA,GAAY,+JAAA;gBACpB,QAAQ,KAAA,GAAQ,sKAAA;gBAChB,QAAQ,KAAA,GAAQ,sKAAA;gBAEhB,WAAW,IAAI,iKAAA,CAAe;oBAAE,KAAK;oBAAS,WAAW;gBAAA,CAAO;gBAChE,MAAM,SAAS,IAAI,yJAAA,CAAO,QAAQ;gBAClC,OAAO,QAAA,CAAS,GAAA,CAAI,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,SAAS,KAAA,CAAM,CAAC,CAAC;gBAC3E,OAAO,KAAA,CAAM,GAAA,CAAI,QAAQ,IAAI,SAAS,IAAI,CAAG;gBAE7C,OAAO,QAAA,CAAS,YAAY,CAAA,GAAI;gBAChC,OAAO,QAAA,CAAS,YAAY,CAAA,GAAI,IAAI,UAAA;gBAEpC,IAAI,WAAW,IAAA,EAAM;oBACnB,OAAO,IAAA,GAAO,WAAW,IAAA;gBAC1B;gBAED,OAAO;YAET,KAAK;gBACH,WAAW,IAAI,QAAA;gBAEf,IAAI;gBAEJ,IAAI,SAAS,kBAAA,EAAoB;oBAC/B,QAAQ,IAAI,mKAAA,CAAkB;oBAC9B,MAAM,UAAA,GAAa,WAAW,YAAA;oBAC9B,MAAM,QAAA,CAAS,GAAA,CAAI,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAC;oBACnF,MAAM,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,SAAS,SAAA,CAAU,CAAC,CAAA,EAAG,SAAS,SAAA,CAAU,CAAC,CAAA,EAAG,SAAS,SAAA,CAAU,CAAC,CAAC;oBAC7F,MAAM,MAAA,CAAO,UAAA,GAAa;gBACpC,OAAA,IAAmB,SAAS,YAAA,EAAc;oBAChC,QAAQ,IAAI,6JAAA,CAAY;oBACxB,MAAM,UAAA,GAAa,WAAW,YAAA;oBAC9B,MAAM,QAAA,CAAS,GAAA,CAAI,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAC;oBACnF,MAAM,MAAA,CAAO,UAAA,GAAa;gBACpC,OAAA,IAAmB,SAAS,kBAAA,EAAoB;oBACtC,QAAQ,IAAI,gKAAA,CAAe;oBAE3B,MAAMA,SAAQ,KAAK,GAAA,CAAI,SAAS,KAAA,CAAM,CAAC,CAAC;oBACxC,MAAMC,UAAS,KAAK,GAAA,CAAI,SAAS,MAAA,CAAO,CAAC,CAAC;oBAE1C,MAAM,QAAA,CAAS,GAAA,CAAI,SAAS,QAAA,CAAS,CAAC,CAAA,GAAIA,UAAS,GAAG,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAA,GAAID,SAAQ,CAAC;oBAE5G,MAAM,MAAA,GAASC;oBACf,MAAM,KAAA,GAAQD;oBAEd,MAAM,MAAA,CAAO,IAAI,0JAAA,CAAQ,SAAS,SAAA,CAAU,CAAC,CAAA,EAAG,SAAS,SAAA,CAAU,CAAC,CAAA,EAAG,SAAS,SAAA,CAAU,CAAC,CAAC,CAAC;gBACvG,OAAA,IAAmB,SAAS,WAAA,EAAa;oBAC/B,QAAQ,IAAI,4JAAA,CAAW;oBACvB,MAAM,UAAA,GAAa,WAAW,YAAA;oBAC9B,MAAM,QAAA,CAAS,GAAA,CAAI,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAA,EAAG,SAAS,QAAA,CAAS,CAAC,CAAC;oBACnF,MAAM,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,SAAS,SAAA,CAAU,CAAC,CAAA,EAAG,SAAS,SAAA,CAAU,CAAC,CAAA,EAAG,SAAS,SAAA,CAAU,CAAC,CAAC;oBAC7F,MAAM,KAAA,GAAQ,SAAS,gBAAA;oBACvB,MAAM,MAAA,CAAO,UAAA,GAAa;gBACpC,OAAA,IAAmB,SAAS,aAAA,EAAe;oBACjC,QAAQ,IAAA,CAAK,2DAA2D;oBAExE;gBACD;gBAED,IAAI,OAAO;oBACT,MAAM,SAAA,GAAY,SAAS,SAAA;oBAC3B,SAAS,SAAS,OAAA;oBAClB,QAAQ,IAAI,wJAAA,CAAM,OAAO,CAAA,GAAI,KAAO,OAAO,CAAA,GAAI,KAAO,OAAO,CAAA,GAAI,GAAK;oBACtE,MAAM,KAAA,GAAQ;oBACd,MAAM,QAAA,CAAS,YAAY,CAAA,GAAI;oBAC/B,MAAM,QAAA,CAAS,YAAY,CAAA,GAAI,IAAI,UAAA;gBACpC;gBAED,OAAO;QACV;IACF;IAED,eAAe;QACb,IAAI,CAAC,IAAA,CAAK,cAAA,EAAgB;YAExB,MAAM,WAAW,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;YAC5C,SAAS,OAAA,CAAQ,IAAA,CAAK,WAAW;YACjC,MAAM,YAAY,IAAI,QAAQ,CAAC,SAAS,WAAW;gBACjD,SAAS,IAAA,CAAK,eAAe,SAAS,KAAA,GAAW,MAAM;YAC/D,CAAO;YAGD,MAAM,eAAe,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;YAChD,aAAa,OAAA,CAAQ,IAAA,CAAK,WAAW;YACrC,aAAa,eAAA,CAAgB,aAAa;YAC1C,MAAM,gBAAgB,IAAI,QAAQ,CAAC,SAAS,WAAW;gBACrD,aAAa,IAAA,CAAK,iBAAiB,SAAS,KAAA,GAAW,MAAM;YACrE,CAAO;YAED,IAAA,CAAK,cAAA,GAAiB,QAAQ,GAAA,CAAI;gBAAC;gBAAW,aAAa;aAAC,EAAE,IAAA,CAAK,CAAC,CAACE,YAAWC,cAAa,CAAA,KAAM;gBAEjG,IAAA,CAAK,aAAA,CAAc,UAAA,GAAaA;gBAEhC,MAAM,KAAK,eAAe,QAAA,CAAU;gBAEpC,MAAM,OAAO;oBACX;oBACAD;oBACA;oBACA,GAAG,SAAA,CAAU,GAAG,OAAA,CAAQ,GAAG,IAAI,GAAG,GAAG,WAAA,CAAY,GAAG,CAAC;iBAC/D,CAAU,IAAA,CAAK,IAAI;gBAEX,IAAA,CAAK,eAAA,GAAkB,IAAI,eAAA,CAAgB,IAAI,KAAK;oBAAC,IAAI;iBAAC,CAAC;YACnE,CAAO;QACF;QAED,OAAO,IAAA,CAAK,cAAA;IACb;IAED,WAAW,QAAA,EAAU;QACnB,OAAO,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,MAAM;YACpC,IAAI,IAAA,CAAK,UAAA,CAAW,MAAA,GAAS,IAAA,CAAK,WAAA,EAAa;gBAC7C,MAAME,UAAS,IAAI,OAAO,IAAA,CAAK,eAAe;gBAE9CA,QAAO,UAAA,GAAa,CAAE;gBACtBA,QAAO,UAAA,GAAa,CAAE;gBACtBA,QAAO,SAAA,GAAY;gBAEnBA,QAAO,WAAA,CAAY;oBACjB,MAAM;oBACN,eAAe,IAAA,CAAK,aAAA;gBAC9B,CAAS;gBAEDA,QAAO,SAAA,GAAY,SAAU,CAAA,EAAG;oBAC9B,MAAM,UAAU,EAAE,IAAA;oBAElB,OAAQ,QAAQ,IAAA,EAAI;wBAClB,KAAK;4BACHA,QAAO,UAAA,CAAW,QAAQ,EAAE,CAAA,CAAE,OAAA,CAAQ,OAAO;4BAC7C;wBAEF,KAAK;4BACHA,QAAO,UAAA,CAAW,QAAQ,EAAE,CAAA,CAAE,MAAA,CAAO,OAAO;4BAC5C;wBAEF;4BACE,QAAQ,KAAA,CAAM,gDAAgD,QAAQ,IAAA,GAAO,GAAG;oBACnF;gBACF;gBAED,IAAA,CAAK,UAAA,CAAW,IAAA,CAAKA,OAAM;YACnC,OAAa;gBACL,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,SAAU,CAAA,EAAG,CAAA,EAAG;oBACnC,OAAO,EAAE,SAAA,GAAY,EAAE,SAAA,GAAY,CAAA,IAAK;gBAClD,CAAS;YACF;YAED,MAAM,SAAS,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,UAAA,CAAW,MAAA,GAAS,CAAC,CAAA;YAEzD,OAAO,SAAA,IAAa;YAEpB,OAAO;QACb,CAAK;IACF;IAED,aAAa,MAAA,EAAQ,MAAA,EAAQ;QAC3B,OAAO,SAAA,IAAa,OAAO,UAAA,CAAW,MAAM,CAAA;QAC5C,OAAO,OAAO,UAAA,CAAW,MAAM,CAAA;QAC/B,OAAO,OAAO,UAAA,CAAW,MAAM,CAAA;IAChC;IAED,UAAU;QACR,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,UAAA,CAAW,MAAA,EAAQ,EAAE,EAAG;YAC/C,IAAA,CAAK,UAAA,CAAW,CAAC,CAAA,CAAE,SAAA,CAAW;QAC/B;QAED,IAAA,CAAK,UAAA,CAAW,MAAA,GAAS;QAEzB,OAAO,IAAA;IACR;AACH;AAIA,SAAS,iBAAiB;IACxB,IAAI;IACJ,IAAI;IACJ,IAAI;IAEJ,YAAY,SAAU,CAAA,EAAG;QACvB,MAAM,UAAU,EAAE,IAAA;QAElB,OAAQ,QAAQ,IAAA,EAAI;YAClB,KAAK;gBACH,gBAAgB,QAAQ,aAAA;gBACxB,MAAM,aAAa,cAAc,UAAA;gBACjC,IAAI;gBACJ,iBAAiB,IAAI,QAAQ,SAAU,OAAA,EAAS;oBAE9C,cAAc;wBAAE;wBAAY,sBAAsB;oBAAS;oBAE3D,SAAS,WAAW;gBAC9B,CAAS,EAAE,IAAA,CAAK,MAAM;oBACZ,QAAQ;gBAClB,CAAS;gBAED;YAEF,KAAK;gBACH,MAAM,SAAS,QAAQ,MAAA;gBACvB,eAAe,IAAA,CAAK,MAAM;oBACxB,MAAM,OAAO,cAAc,OAAO,MAAM;oBAExC,KAAK,WAAA,CAAY;wBAAE,MAAM;wBAAU,IAAI,QAAQ,EAAA;wBAAI;oBAAA,CAAM;gBACnE,CAAS;gBAED;QACH;IACF;IAED,SAAS,cAAcC,MAAAA,EAAO,MAAA,EAAQ;QACpC,MAAM,MAAM,IAAI,WAAW,MAAM;QACjC,MAAM,MAAMA,OAAM,OAAA,CAAQ,aAAA,CAAc,GAAG;QAE3C,MAAM,UAAU,CAAE,CAAA;QAClB,MAAM,YAAY,CAAE,CAAA;QACpB,MAAM,SAAS,CAAE,CAAA;QACjB,MAAM,QAAQ,CAAE,CAAA;QAChB,MAAM,aAAa,CAAE,CAAA;QACrB,MAAM,SAAS,CAAE,CAAA;QAIjB,MAAM,OAAO,IAAI,OAAA,CAAS;QAC1B,MAAM,MAAM,KAAK,KAAA;QAEjB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;YAC5B,MAAM,UAAU,KAAK,GAAA,CAAI,CAAC;YAE1B,MAAM,SAAS,kBAAkB,SAAS,GAAG;YAE7C,QAAQ,MAAA,CAAQ;YAEhB,IAAI,QAAQ;gBACV,QAAQ,IAAA,CAAK,MAAM;YACpB;QACF;QAKD,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,mBAAA,GAAsB,KAAA,IAAS,IAAK;YAC1D,MAAM,OAAO,IAAI,mBAAA,CAAmB,EAAG,GAAA,CAAI,CAAC;YAC5C,MAAM,iBAAiB,kBAAkB,IAAI;YAC7C,eAAe,SAAA,GAAY,KAAK,YAAA,CAAc;YAE9C,QAAQ,IAAA,CAAK;gBAAE,UAAU;gBAAM,YAAY;gBAAgB,YAAY;YAAA,CAAsB;QAC9F;QAID,MAAM,eAAe;YAAA,4BAAA;YAEnBA,OAAM,WAAA,CAAY,OAAA;YAClBA,OAAM,WAAA,CAAY,IAAA;YAClBA,OAAM,WAAA,CAAY,YAAA;YAClBA,OAAM,WAAA,CAAY,OAAA;YAClBA,OAAM,WAAA,CAAY,IAAA;SACnB;QAED,MAAM,kBAAkB;YACtBA,OAAM,WAAA,CAAY,aAAA;YAClBA,OAAM,WAAA,CAAY,cAAA;YAClBA,OAAM,WAAA,CAAY,wBAAA;YAClBA,OAAM,WAAA,CAAY,8BAAA;YAClBA,OAAM,WAAA,CAAY,YAAA;YAClBA,OAAM,WAAA,CAAY,YAAA;YAClBA,OAAM,WAAA,CAAY,gBAAA;YAClBA,OAAM,WAAA,CAAY,aAAA;YAClBA,OAAM,WAAA,CAAY,eAAA;YAClBA,OAAM,WAAA,CAAY,wBAAA;YAClBA,OAAM,WAAA,CAAY,SAAA;YAClBA,OAAM,WAAA,CAAY,aAAA;YAClBA,OAAM,WAAA,CAAY,aAAA;YAClBA,OAAM,WAAA,CAAY,iBAAA;YAClBA,OAAM,WAAA,CAAY,sBAAA;YAClBA,OAAM,WAAA,CAAY,cAAA;YAClBA,OAAM,WAAA,CAAY,oBAAA;YAClBA,OAAM,WAAA,CAAY,YAAA;YAClBA,OAAM,WAAA,CAAY,oBAAA;YAClBA,OAAM,WAAA,CAAY,gBAAA;SACnB;QAED,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,SAAA,GAAY,KAAA,IAAS,IAAK;YAChD,MAAM,YAAY,IAAI,SAAA,CAAS,EAAG,GAAA,CAAI,CAAC;YACvC,MAAM,eAAe,UAAU,eAAA,CAAiB;YAEhD,IAAI,WAAW,kBAAkB,SAAS;YAE1C,MAAM,WAAW,CAAE,CAAA;YAEnB,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,IAAK;gBAC5C,MAAM,WAAW,UAAU,UAAA,CAAW,YAAA,CAAa,CAAC,CAAC;gBACrD,IAAI,UAAU;oBACZ,IAAI,cAAc,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,CAAY,IAAA;oBAC9C,cAAc,YAAY,SAAA,CAAU,IAAI,YAAY,MAAM;oBAC1D,MAAM,UAAU;wBAAE,MAAM;oBAAa;oBAErC,MAAM,QAAQ,IAAI,uBAAA,CAAwB,SAAS,QAAQ;oBAE3D,IAAI,OAAO;wBACT,QAAQ,KAAA,GAAQ,2BAA2B;oBACvD,OAAiB;wBACL,QAAQ,IAAA,CAAK,CAAA,2BAAA,EAA8B,YAAA,8BAAA,CAA2C;wBACtF,QAAQ,KAAA,GAAQ;oBACjB;oBAED,SAAS,IAAA,CAAK,OAAO;oBAErB,SAAS,MAAA,CAAQ;gBAClB;YACF;YAED,SAAS,QAAA,GAAW;YAEpB,IAAI,aAAa,SAAA,EAAW;gBAC1B,QAAQ,GAAA,CAAI,UAAU;gBAEtB,IAAA,IAAS,IAAI,GAAG,IAAI,gBAAgB,MAAA,EAAQ,IAAK;oBAC/C,MAAM,WAAW,UAAU,UAAA,CAAW,YAAA,CAAa,CAAC,CAAC;oBACrD,IAAI,UAAU;wBACZ,MAAM,QAAQ,IAAI,uBAAA,CAAwB,SAAS,QAAQ;wBAC3D,IAAI,cAAc,YAAA,CAAa,CAAC,CAAA,CAAE,WAAA,CAAY,IAAA;wBAC9C,cAAc,YAAY,SAAA,CAAU,IAAI,YAAY,MAAM;wBAC1D,MAAM,UAAU;4BAAE,MAAM;4BAAa,OAAO,2BAA2B;wBAAO;wBAC9E,SAAS,IAAA,CAAK,OAAO;wBAErB,SAAS,MAAA,CAAQ;oBAClB;gBACF;gBAED,MAAM,uBAAuB,kBAAkB,UAAU,eAAA,CAAe,CAAE;gBAE1E,WAAW,OAAO,MAAA,CAAO,sBAAsB,QAAQ;YACxD;YAED,UAAU,IAAA,CAAK,QAAQ;YAEvB,UAAU,MAAA,CAAQ;YAClB,aAAa,MAAA,CAAQ;QACtB;QAID,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,GAAS,KAAA,IAAS,IAAK;YAC7C,MAAM,SAAS,IAAI,MAAA,CAAM,EAAG,GAAA,CAAI,CAAC;YACjC,MAAM,QAAQ,kBAAkB,MAAM;YAEtC,OAAO,IAAA,CAAK,KAAK;YAEjB,OAAO,MAAA,CAAQ;QAChB;QAID,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,KAAA,GAAQ,KAAA,IAAS,IAAK;YAC5C,MAAM,QAAQ,IAAI,KAAA,CAAK,EAAG,GAAA,CAAI,CAAC;YAC/B,MAAM,OAAO,kBAAkB,KAAK;YAEpC,MAAM,IAAA,CAAK,IAAI;YAEf,MAAM,MAAA,CAAQ;QACf;QAID,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,UAAA,GAAa,KAAA,IAAS,IAAK;YACjD,MAAM,aAAa,IAAI,UAAA,CAAU,EAAG,GAAA,CAAI,CAAC;YACzC,MAAM,YAAY,kBAAkB,UAAU;YAE9C,WAAW,IAAA,CAAK,SAAS;YAEzB,WAAW,MAAA,CAAQ;QACpB;QAID,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,GAAS,KAAA,IAAS,IAAK;YAC7C,MAAM,SAAS,IAAI,MAAA,CAAM,EAAG,GAAA,CAAI,CAAC;YACjC,MAAM,QAAQ,kBAAkB,MAAM;YAEtC,OAAO,IAAA,CAAK,KAAK;YAEjB,OAAO,MAAA,CAAQ;QAChB;QAID,MAAM,WAAW,kBAAkB,IAAI,QAAA,CAAQ,CAAE;QA4BjD,IAAI,MAAA,CAAQ;QAEZ,OAAO;YAAE;YAAS;YAAW;YAAQ;YAAO;YAAY;YAAQ;QAAU;IAC3E;IAED,SAAS,kBAAkB,MAAA,EAAQ,GAAA,EAAK;QACtC,MAAM,YAAY,OAAO,QAAA,CAAU;QACnC,MAAM,cAAc,OAAO,UAAA,CAAY;QACvC,IAAI,aAAa,UAAU,UAAA;QAC3B,IAAI,UAAU,YAAY,UAAU,MAAM;QAM1C,OAAQ,YAAU;YAChB,KAAK,MAAM,UAAA,CAAW,KAAA;gBACpB,MAAM,MAAM,cAAc,WAAW,GAAG;gBAExC,WAAW,CAAE;gBACb,aAAa,CAAE;gBACf,OAAO,CAAE;gBAET,SAAS,QAAA,GAAW;gBACpB,SAAS,IAAA,GAAO;gBAChB,SAAS,KAAA,GAAQ,CAAE,CAAA;gBAEnB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,EAAQ,IAAK;oBACnC,SAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,CAAE,CAAC,CAAC;oBAC7B,SAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,CAAE,CAAC,CAAC;oBAC7B,SAAS,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA,CAAE,CAAC,CAAC;gBAC9B;gBAED,WAAW,QAAA,GAAW;gBACtB,KAAK,UAAA,GAAa;gBAElB,WAAW;oBAAE;gBAAM;gBAEnB;YAEF,KAAK,MAAM,UAAA,CAAW,KAAA;gBACpB,MAAM,KAAK,UAAU,QAAA;gBAErB,WAAW,CAAE;gBACb,MAAM,QAAQ,CAAE;gBAChB,aAAa,CAAE;gBACf,OAAO,CAAE;gBAET,SAAS,QAAA,GAAW;gBACpB,SAAS,IAAA,GAAO;gBAChB,SAAS,KAAA,GAAQ;oBAAC,EAAA,CAAG,CAAC,CAAA;oBAAG,EAAA,CAAG,CAAC,CAAA;oBAAG,EAAA,CAAG,CAAC,CAAC;iBAAA;gBAErC,MAAM,SAAS,YAAY,SAAA,CAAU,GAAG;gBAExC,MAAM,QAAA,GAAW;gBACjB,MAAM,IAAA,GAAO;gBACb,MAAM,KAAA,GAAQ;oBAAC,OAAO,CAAA,GAAI;oBAAO,OAAO,CAAA,GAAI;oBAAO,OAAO,CAAA,GAAI,GAAK;iBAAA;gBAEnE,WAAW,QAAA,GAAW;gBACtB,WAAW,KAAA,GAAQ;gBACnB,KAAK,UAAA,GAAa;gBAElB,WAAW;oBAAE;gBAAM;gBAEnB;YAEF,KAAK,MAAM,UAAA,CAAW,QAAA;YACtB,KAAK,MAAM,UAAA,CAAW,IAAA;gBACpB,WAAW,UAAU,aAAA,CAAe;gBAEpC;YAEF,KAAK,MAAM,UAAA,CAAW,IAAA;gBACpB,MAAM,QAAQ,UAAU,KAAA,CAAO;gBAC/B,OAAO,IAAI,MAAM,IAAA,CAAM;gBAEvB,IAAA,IAAS,YAAY,GAAG,YAAY,MAAM,KAAA,EAAO,YAAa;oBAC5D,MAAM,OAAO,MAAM,GAAA,CAAI,SAAS;oBAChC,MAAM,QAAQ,KAAK,OAAA,CAAQ,MAAM,QAAA,CAAS,GAAG;oBAE7C,IAAI,OAAO;wBACT,KAAK,MAAA,CAAO,KAAK;wBACjB,MAAM,MAAA,CAAQ;oBACf;oBAED,KAAK,MAAA,CAAQ;gBACd;gBAED,IAAI,KAAK,KAAA,GAAQ,KAAA,GAAQ,GAAG;oBAC1B,KAAK,OAAA,CAAS;oBACd,WAAW,KAAK,aAAA,CAAe;oBAC/B,MAAM,MAAA,CAAQ;gBACf;gBAED,KAAK,MAAA,CAAQ;gBAEb;YAEF,KAAK,MAAM,UAAA,CAAW,SAAA;gBACpB,OAAO,UAAU,OAAA,CAAQ,MAAM,QAAA,CAAS,GAAG;gBAE3C,IAAI,MAAM;oBACR,WAAW,KAAK,aAAA,CAAe;oBAC/B,KAAK,MAAA,CAAQ;gBACd;gBAED;YAEF,KAAK,MAAM,UAAA,CAAW,OAAA;gBACpB,WAAW,kBAAkB,SAAS;gBAEtC;YAEF,KAAK,MAAM,UAAA,CAAW,KAAA;gBACpB,WAAW,kBAAkB,SAAS;gBAEtC;YAEF,KAAK,MAAM,UAAA,CAAW,iBAAA;gBACpB,WAAW,kBAAkB,SAAS;gBACtC,SAAS,KAAA,GAAQ,kBAAkB,UAAU,KAAK;gBAClD,SAAS,KAAA,CAAM,KAAA,GAAQ,UAAU,KAAA,CAAM,YAAA,CAAa,IAAI;gBAExD;YAEF,KAAK,MAAM,UAAA,CAAW,IAAA;gBAEpB,UAAU,SAAA,CAAU,CAAC;gBACrB,OAAO,MAAM,IAAA,CAAK,wBAAA,CAAyB,SAAS;gBACpD,IAAI,MAAM;oBACR,WAAW,KAAK,aAAA,CAAe;oBAC/B,KAAK,MAAA,CAAQ;gBACd;gBAED;YAQF;gBACE,QAAQ,IAAA,CAAK,CAAA,iCAAA,EAAoC,WAAW,WAAA,CAAY,IAAA,EAAM;gBAC9E;QACH;QAED,IAAI,UAAU;YACZ,aAAa,kBAAkB,WAAW;YAC1C,WAAW,QAAA,GAAW,kBAAkB,SAAS;YAEjD,IAAI,YAAY,UAAA,GAAa,GAAG;gBAC9B,WAAW,QAAA,GAAW,YAAY,YAAA,CAAc;YACjD;YAED,IAAI,YAAY,eAAA,GAAkB,GAAG;gBACnC,WAAW,WAAA,GAAc,YAAY,cAAA,CAAgB;YACtD;YAED,IAAI,UAAU,eAAA,GAAkB,GAAG;gBACjC,WAAW,QAAA,CAAS,WAAA,GAAc,UAAU,cAAA,CAAgB;YAC7D;YAED,WAAW,SAAA,GAAY,YAAY,SAAA,CAAU,GAAG;YAEhD,aAAa,WAAW,WAAA,CAAY,IAAA;YACpC,aAAa,WAAW,SAAA,CAAU,IAAI,WAAW,MAAM;YAEvD,OAAO;gBAAE;gBAAU;gBAAY;YAAY;QACjD,OAAW;YACL,QAAQ,IAAA,CAAK,CAAA,iBAAA,EAAoB,WAAW,WAAA,CAAY,IAAA,CAAA,iCAAA,CAAuC;QAChG;IACF;IAED,SAAS,kBAAkB,MAAA,EAAQ;QACjC,MAAM,SAAS,CAAE;QAEjB,IAAA,MAAW,YAAY,OAAQ;YAC7B,MAAM,QAAQ,MAAA,CAAO,QAAQ,CAAA;YAE7B,IAAI,OAAO,UAAU,YAAY;gBAC/B,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,cAAA,CAAe,aAAa,GAAG;oBACtF,MAAA,CAAO,QAAQ,CAAA,GAAI;wBAAE,MAAM,MAAM,WAAA,CAAY,IAAA;wBAAM,OAAO,MAAM,KAAA;oBAAO;gBACjF,OAAe;oBACL,MAAA,CAAO,QAAQ,CAAA,GAAI;gBACpB;YAIF;QACF;QAED,OAAO;IACR;IAED,SAAS,cAAc,KAAA,EAAO,UAAA,EAAY;QACxC,IAAI,aAAa;QACjB,IAAI,KAAK,CAAE,CAAA;QACX,MAAM,KAAK,CAAE,CAAA;QAEb,IAAI,iBAAiB,MAAM,SAAA,EAAW;YACpC,OAAO;gBAAC,MAAM,YAAA;gBAAc,MAAM,UAAU;aAAA;QAC7C;QAED,IAAI,iBAAiB,MAAM,aAAA,EAAe;YACxC,aAAa,MAAM,UAAA;YACnB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;gBACnC,GAAG,IAAA,CAAK,MAAM,KAAA,CAAM,CAAC,CAAC;YACvB;YAED,OAAO;QACR;QAED,IAAI,iBAAiB,MAAM,SAAA,EAAW;YACpC,MAAM,eAAe,MAAM,YAAA;YAE3B,IAAA,IAAS,IAAI,GAAG,IAAI,cAAc,IAAK;gBACrC,MAAM,UAAU,MAAM,YAAA,CAAa,CAAC;gBACpC,MAAM,eAAe,cAAc,SAAS,UAAU;gBACtD,KAAK,GAAG,MAAA,CAAO,YAAY;gBAC3B,QAAQ,MAAA,CAAQ;YACjB;YAED,OAAO;QACR;QAED,IAAI,iBAAiB,MAAM,QAAA,EAAU;YACnC,aAAa,KAAK,KAAA,CAAM,MAAM,YAAA,GAAe,CAAC;YAC9C,aAAa,aAAa,IAAI,IAAI;QAEnC;QAED,IAAI,iBAAiB,MAAM,UAAA,IAAc,MAAM,MAAA,KAAW,GAAG;YAC3D,MAAM,QAAQ,MAAM,cAAA,CAAgB;YAEpC,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,KAAA,EAAO,IAAK;gBACpC,GAAG,IAAA,CAAK,MAAM,GAAA,CAAI,CAAC,CAAC;YACrB;YAED,MAAM,MAAA,CAAQ;YAEd,OAAO;QACR;QAED,MAAM,SAAS,MAAM,MAAA;QACrB,MAAM,YAAY,aAAa;QAE/B,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;YACnC,MAAM,IAAI,MAAA,CAAO,CAAC,CAAA,GAAK,IAAI,YAAA,CAAc,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA;YAE7D,IAAI,MAAM,MAAA,CAAO,CAAC,CAAA,IAAK,MAAM,MAAA,CAAO,CAAC,CAAA,EAAG;gBACtC,GAAG,IAAA,CAAK,CAAC;gBACT;YACD;YAED,MAAM,MAAM,MAAM,SAAA,CAAU,CAAC;YAC7B,MAAM,UAAU,MAAM,SAAA,CAAU,GAAG,KAAA,CAAM,CAAA,CAAE,CAAA,CAAE,CAAC,CAAC;YAK/C,MAAM,KAAK,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA,GAAI,GAAA,CAAI,CAAC,CAAA;YAC7D,MAAM,MAAM,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA;YAEtF,MAAM,cAAc,KAAK,IAAA,CAAK,KAAK,GAAG;YAEtC,IAAI;YAEJ,IAAI,gBAAgB,GAAG;gBACrB,QAAQ,KAAK,EAAA,GAAK;YAC1B,OAAa;gBACL,MAAM,QAAA,CAAS,IAAI,CAAA,GAAI,QAAQ,CAAA,GAAI,IAAI,CAAA,GAAI,QAAQ,CAAA,GAAI,IAAI,CAAA,GAAI,QAAQ,CAAA,IAAK;gBAC5E,QAAQ,KAAK,IAAA,CAAK,KAAK,GAAA,CAAI,CAAA,GAAI,KAAK,GAAA,CAAI,GAAG,KAAK,CAAC,CAAC;YACnD;YAED,IAAI,QAAQ,KAAK;YAEjB,GAAG,IAAA,CAAK,CAAC;QACV;QAED,KAAK,GAAG,GAAA,CAAI,CAAC,IAAM,MAAM,OAAA,CAAQ,CAAC,CAAC;QACnC,OAAO;IACR;AACH"}},
    {"offset": {"line": 24730, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/OBJLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/OBJLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Material,\n  Mesh,\n  MeshPhongMaterial,\n  Points,\n  PointsMaterial,\n  Vector3,\n} from 'three'\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /\n// usemap map_name\nconst _map_use_pattern = /^usemap /\n\nconst _vA = /* @__PURE__ */ new Vector3()\nconst _vB = /* @__PURE__ */ new Vector3()\nconst _vC = /* @__PURE__ */ new Vector3()\n\nconst _ab = /* @__PURE__ */ new Vector3()\nconst _cb = /* @__PURE__ */ new Vector3()\n\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n\n    materials: {},\n    materialLibraries: [],\n\n    startObject: function (name, fromDeclaration) {\n      // If the current object (initial from reset) is not from a g/o declaration in the parsed\n      // file. We need to use it for the first parsed g/o to keep things in sync.\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name\n        this.object.fromDeclaration = fromDeclaration !== false\n        return\n      }\n\n      const previousMaterial =\n        this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined\n\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n\n      this.object = {\n        name: name || '',\n        fromDeclaration: fromDeclaration !== false,\n\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false,\n        },\n        materials: [],\n        smooth: true,\n\n        startMaterial: function (name, libraries) {\n          const previous = this._finalize(false)\n\n          // New usemtl declaration overwrites an inherited material, except if faces were declared\n          // after the material, then it must be preserved for proper MultiMaterial continuation.\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1)\n          }\n\n          const material = {\n            index: this.materials.length,\n            name: name || '',\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\n            groupStart: previous !== undefined ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n\n            clone: function (index) {\n              const cloned = {\n                index: typeof index === 'number' ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false,\n              }\n              cloned.clone = this.clone.bind(cloned)\n              return cloned\n            },\n          }\n\n          this.materials.push(material)\n\n          return material\n        },\n\n        currentMaterial: function () {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1]\n          }\n\n          return undefined\n        },\n\n        _finalize: function (end) {\n          const lastMultiMaterial = this.currentMaterial()\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart\n            lastMultiMaterial.inherited = false\n          }\n\n          // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1)\n              }\n            }\n          }\n\n          // Guarantee at least one empty material, this makes the creation later more straight forward.\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: '',\n              smooth: this.smooth,\n            })\n          }\n\n          return lastMultiMaterial\n        },\n      }\n\n      // Inherit previous objects material.\n      // Spec tells us that a declared material must be set to all objects until a new material is declared.\n      // If a usemtl declaration is encountered while this new object is being parsed, it will\n      // overwrite the inherited material. Exception being that there was already face declarations\n      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n        const declared = previousMaterial.clone(0)\n        declared.inherited = true\n        this.object.materials.push(declared)\n      }\n\n      this.objects.push(this.object)\n    },\n\n    finalize: function () {\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n    },\n\n    parseVertexIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseNormalIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseUVIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 2) * 2\n    },\n\n    addVertex: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addVertexPoint: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addVertexLine: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addNormal: function (a, b, c) {\n      const src = this.normals\n      const dst = this.object.geometry.normals\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addFaceNormal: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.normals\n\n      _vA.fromArray(src, a)\n      _vB.fromArray(src, b)\n      _vC.fromArray(src, c)\n\n      _cb.subVectors(_vC, _vB)\n      _ab.subVectors(_vA, _vB)\n      _cb.cross(_ab)\n\n      _cb.normalize()\n\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n    },\n\n    addColor: function (a, b, c) {\n      const src = this.colors\n      const dst = this.object.geometry.colors\n\n      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2])\n      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2])\n      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addUV: function (a, b, c) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n      dst.push(src[b + 0], src[b + 1])\n      dst.push(src[c + 0], src[c + 1])\n    },\n\n    addDefaultUV: function () {\n      const dst = this.object.geometry.uvs\n\n      dst.push(0, 0)\n      dst.push(0, 0)\n      dst.push(0, 0)\n    },\n\n    addUVLine: function (a) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n    },\n\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length\n\n      let ia = this.parseVertexIndex(a, vLen)\n      let ib = this.parseVertexIndex(b, vLen)\n      let ic = this.parseVertexIndex(c, vLen)\n\n      this.addVertex(ia, ib, ic)\n      this.addColor(ia, ib, ic)\n\n      // normals\n\n      if (na !== undefined && na !== '') {\n        const nLen = this.normals.length\n\n        ia = this.parseNormalIndex(na, nLen)\n        ib = this.parseNormalIndex(nb, nLen)\n        ic = this.parseNormalIndex(nc, nLen)\n\n        this.addNormal(ia, ib, ic)\n      } else {\n        this.addFaceNormal(ia, ib, ic)\n      }\n\n      // uvs\n\n      if (ua !== undefined && ua !== '') {\n        const uvLen = this.uvs.length\n\n        ia = this.parseUVIndex(ua, uvLen)\n        ib = this.parseUVIndex(ub, uvLen)\n        ic = this.parseUVIndex(uc, uvLen)\n\n        this.addUV(ia, ib, ic)\n\n        this.object.geometry.hasUVIndices = true\n      } else {\n        // add placeholder values (for inconsistent face definitions)\n\n        this.addDefaultUV()\n      }\n    },\n\n    addPointGeometry: function (vertices) {\n      this.object.geometry.type = 'Points'\n\n      const vLen = this.vertices.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen)\n\n        this.addVertexPoint(index)\n        this.addColor(index)\n      }\n    },\n\n    addLineGeometry: function (vertices, uvs) {\n      this.object.geometry.type = 'Line'\n\n      const vLen = this.vertices.length\n      const uvLen = this.uvs.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen))\n      }\n\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen))\n      }\n    },\n  }\n\n  state.startObject('', false)\n\n  return state\n}\n\n//\n\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.materials = null\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setMaterials(materials) {\n    this.materials = materials\n\n    return this\n  }\n\n  parse(text) {\n    const state = new ParserState()\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    if (text.indexOf('\\\\\\n') !== -1) {\n      // join lines separated by a line continuation character (\\)\n      text = text.replace(/\\\\\\n/g, '')\n    }\n\n    const lines = text.split('\\n')\n    let line = '',\n      lineFirstChar = ''\n    let lineLength = 0\n    let result = []\n\n    // Faster to just trim left side of the line. Use if available.\n    const trimLeft = typeof ''.trimLeft === 'function'\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i]\n\n      line = trimLeft ? line.trimLeft() : line.trim()\n\n      lineLength = line.length\n\n      if (lineLength === 0) continue\n\n      lineFirstChar = line.charAt(0)\n\n      // @todo invoke passed in handler if any\n      if (lineFirstChar === '#') continue\n\n      if (lineFirstChar === 'v') {\n        const data = line.split(/\\s+/)\n\n        switch (data[0]) {\n          case 'v':\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]))\n            } else {\n              // if no colors are defined, add placeholders so color and vertex indices match\n\n              state.colors.push(undefined, undefined, undefined)\n            }\n\n            break\n          case 'vn':\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            break\n          case 'vt':\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]))\n            break\n        }\n      } else if (lineFirstChar === 'f') {\n        const lineData = line.substr(1).trim()\n        const vertexData = lineData.split(/\\s+/)\n        const faceVertices = []\n\n        // Parse the face vertex data into an easy to work with format\n\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j]\n\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split('/')\n            faceVertices.push(vertexParts)\n          }\n        }\n\n        // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n        const v1 = faceVertices[0]\n\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j]\n          const v3 = faceVertices[j + 1]\n\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2])\n        }\n      } else if (lineFirstChar === 'l') {\n        const lineParts = line.substring(1).trim().split(' ')\n        let lineVertices = []\n        const lineUVs = []\n\n        if (line.indexOf('/') === -1) {\n          lineVertices = lineParts\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split('/')\n\n            if (parts[0] !== '') lineVertices.push(parts[0])\n            if (parts[1] !== '') lineUVs.push(parts[1])\n          }\n        }\n\n        state.addLineGeometry(lineVertices, lineUVs)\n      } else if (lineFirstChar === 'p') {\n        const lineData = line.substr(1).trim()\n        const pointData = lineData.split(' ')\n\n        state.addPointGeometry(pointData)\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        // o object_name\n        // or\n        // g group_name\n\n        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        // let name = result[ 0 ].substr( 1 ).trim();\n        const name = (' ' + result[0].substr(1).trim()).substr(1)\n\n        state.startObject(name)\n      } else if (_material_use_pattern.test(line)) {\n        // material\n\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries)\n      } else if (_material_library_pattern.test(line)) {\n        // mtl file\n\n        state.materialLibraries.push(line.substring(7).trim())\n      } else if (_map_use_pattern.test(line)) {\n        // the line is parsed but ignored since the loader assumes textures are defined MTL files\n        // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n        console.warn(\n          'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.',\n        )\n      } else if (lineFirstChar === 's') {\n        result = line.split(' ')\n\n        // smooth shading\n\n        // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n        // but does not define a usemtl for each face set.\n        // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n        // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n        // where explicit usemtl defines geometry groups.\n        // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n        /*\n         * http://paulbourke.net/dataformats/obj/\n         * or\n         * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n         *\n         * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n         * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n         * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n         * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n         * than 0.\"\n         */\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase()\n          state.object.smooth = value !== '0' && value !== 'off'\n        } else {\n          // ZBrush can produce \"s\" lines #11707\n          state.object.smooth = true\n        }\n\n        const material = state.object.currentMaterial()\n        if (material) material.smooth = state.object.smooth\n      } else {\n        // Handle null terminated files without exception\n        if (line === '\\0') continue\n\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"')\n      }\n    }\n\n    state.finalize()\n\n    const container = new Group()\n    container.materialLibraries = [].concat(state.materialLibraries)\n\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0)\n\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i]\n        const geometry = object.geometry\n        const materials = object.materials\n        const isLine = geometry.type === 'Line'\n        const isPoints = geometry.type === 'Points'\n        let hasVertexColors = false\n\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0) continue\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3))\n\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3))\n        }\n\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3))\n        }\n\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2))\n        }\n\n        // Create materials\n\n        const createdMaterials = []\n\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi]\n          const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors\n          let material = state.materials[materialHash]\n\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name)\n\n            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial()\n              Material.prototype.copy.call(materialLine, material)\n              materialLine.color.copy(material.color)\n              material = materialLine\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false })\n              Material.prototype.copy.call(materialPoints, material)\n              materialPoints.color.copy(material.color)\n              materialPoints.map = material.map\n              material = materialPoints\n            }\n          }\n\n          if (material === undefined) {\n            if (isLine) {\n              material = new LineBasicMaterial()\n            } else if (isPoints) {\n              material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n            } else {\n              material = new MeshPhongMaterial()\n            }\n\n            material.name = sourceMaterial.name\n            material.flatShading = sourceMaterial.smooth ? false : true\n            material.vertexColors = hasVertexColors\n\n            state.materials[materialHash] = material\n          }\n\n          createdMaterials.push(material)\n        }\n\n        // Create mesh\n\n        let mesh\n\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi]\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi)\n          }\n\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials)\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials)\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials)\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0])\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0])\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0])\n          }\n        }\n\n        mesh.name = object.name\n\n        container.add(mesh)\n      }\n    } else {\n      // if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3))\n\n        if (state.colors.length > 0 && state.colors[0] !== undefined) {\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3))\n          material.vertexColors = true\n        }\n\n        const points = new Points(buffergeometry, material)\n        container.add(points)\n      }\n    }\n\n    return container\n  }\n}\n\nexport { OBJLoader }\n"],"names":["name"],"mappings":";;;;;;AAiBA,MAAM,kBAAkB;AAExB,MAAM,4BAA4B;AAElC,MAAM,wBAAwB;AAE9B,MAAM,mBAAmB;AAEzB,MAAM,MAAsB,aAAA,GAAA,IAAI,0JAAA,CAAS;AACzC,MAAM,MAAsB,aAAA,GAAA,IAAI,0JAAA,CAAS;AACzC,MAAM,MAAsB,aAAA,GAAA,IAAI,0JAAA,CAAS;AAEzC,MAAM,MAAsB,aAAA,GAAA,IAAI,0JAAA,CAAS;AACzC,MAAM,MAAsB,aAAA,GAAA,IAAI,0JAAA,CAAS;AAEzC,SAAS,cAAc;IACrB,MAAM,QAAQ;QACZ,SAAS,CAAE,CAAA;QACX,QAAQ,CAAE;QAEV,UAAU,CAAE,CAAA;QACZ,SAAS,CAAE,CAAA;QACX,QAAQ,CAAE,CAAA;QACV,KAAK,CAAE,CAAA;QAEP,WAAW,CAAE;QACb,mBAAmB,CAAE,CAAA;QAErB,aAAa,SAAU,IAAA,EAAM,eAAA,EAAiB;YAG5C,IAAI,IAAA,CAAK,MAAA,IAAU,IAAA,CAAK,MAAA,CAAO,eAAA,KAAoB,OAAO;gBACxD,IAAA,CAAK,MAAA,CAAO,IAAA,GAAO;gBACnB,IAAA,CAAK,MAAA,CAAO,eAAA,GAAkB,oBAAoB;gBAClD;YACD;YAED,MAAM,mBACJ,IAAA,CAAK,MAAA,IAAU,OAAO,IAAA,CAAK,MAAA,CAAO,eAAA,KAAoB,aAAa,IAAA,CAAK,MAAA,CAAO,eAAA,CAAe,IAAK,KAAA;YAErG,IAAI,IAAA,CAAK,MAAA,IAAU,OAAO,IAAA,CAAK,MAAA,CAAO,SAAA,KAAc,YAAY;gBAC9D,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,IAAI;YAC3B;YAED,IAAA,CAAK,MAAA,GAAS;gBACZ,MAAM,QAAQ;gBACd,iBAAiB,oBAAoB;gBAErC,UAAU;oBACR,UAAU,CAAE,CAAA;oBACZ,SAAS,CAAE,CAAA;oBACX,QAAQ,CAAE,CAAA;oBACV,KAAK,CAAE,CAAA;oBACP,cAAc;gBACf;gBACD,WAAW,CAAE,CAAA;gBACb,QAAQ;gBAER,eAAe,SAAUA,KAAAA,EAAM,SAAA,EAAW;oBACxC,MAAM,WAAW,IAAA,CAAK,SAAA,CAAU,KAAK;oBAIrC,IAAI,YAAA,CAAa,SAAS,SAAA,IAAa,SAAS,UAAA,IAAc,CAAA,GAAI;wBAChE,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,SAAS,KAAA,EAAO,CAAC;oBACxC;oBAED,MAAM,WAAW;wBACf,OAAO,IAAA,CAAK,SAAA,CAAU,MAAA;wBACtB,MAAMA,SAAQ;wBACd,QAAQ,MAAM,OAAA,CAAQ,SAAS,KAAK,UAAU,MAAA,GAAS,IAAI,SAAA,CAAU,UAAU,MAAA,GAAS,CAAC,CAAA,GAAI;wBAC7F,QAAQ,aAAa,KAAA,IAAY,SAAS,MAAA,GAAS,IAAA,CAAK,MAAA;wBACxD,YAAY,aAAa,KAAA,IAAY,SAAS,QAAA,GAAW;wBACzD,UAAU,CAAA;wBACV,YAAY,CAAA;wBACZ,WAAW;wBAEX,OAAO,SAAU,KAAA,EAAO;4BACtB,MAAM,SAAS;gCACb,OAAO,OAAO,UAAU,WAAW,QAAQ,IAAA,CAAK,KAAA;gCAChD,MAAM,IAAA,CAAK,IAAA;gCACX,QAAQ,IAAA,CAAK,MAAA;gCACb,QAAQ,IAAA,CAAK,MAAA;gCACb,YAAY;gCACZ,UAAU,CAAA;gCACV,YAAY,CAAA;gCACZ,WAAW;4BACZ;4BACD,OAAO,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAM;4BACrC,OAAO;wBACR;oBACF;oBAED,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ;oBAE5B,OAAO;gBACR;gBAED,iBAAiB,WAAY;oBAC3B,IAAI,IAAA,CAAK,SAAA,CAAU,MAAA,GAAS,GAAG;wBAC7B,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,SAAA,CAAU,MAAA,GAAS,CAAC,CAAA;oBAChD;oBAED,OAAO,KAAA;gBACR;gBAED,WAAW,SAAU,GAAA,EAAK;oBACxB,MAAM,oBAAoB,IAAA,CAAK,eAAA,CAAiB;oBAChD,IAAI,qBAAqB,kBAAkB,QAAA,KAAa,CAAA,GAAI;wBAC1D,kBAAkB,QAAA,GAAW,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS;wBAC7D,kBAAkB,UAAA,GAAa,kBAAkB,QAAA,GAAW,kBAAkB,UAAA;wBAC9E,kBAAkB,SAAA,GAAY;oBAC/B;oBAGD,IAAI,OAAO,IAAA,CAAK,SAAA,CAAU,MAAA,GAAS,GAAG;wBACpC,IAAA,IAAS,KAAK,IAAA,CAAK,SAAA,CAAU,MAAA,GAAS,GAAG,MAAM,GAAG,KAAM;4BACtD,IAAI,IAAA,CAAK,SAAA,CAAU,EAAE,CAAA,CAAE,UAAA,IAAc,GAAG;gCACtC,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,IAAI,CAAC;4BAC5B;wBACF;oBACF;oBAGD,IAAI,OAAO,IAAA,CAAK,SAAA,CAAU,MAAA,KAAW,GAAG;wBACtC,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK;4BAClB,MAAM;4BACN,QAAQ,IAAA,CAAK,MAAA;wBAC3B,CAAa;oBACF;oBAED,OAAO;gBACR;YACF;YAQD,IAAI,oBAAoB,iBAAiB,IAAA,IAAQ,OAAO,iBAAiB,KAAA,KAAU,YAAY;gBAC7F,MAAM,WAAW,iBAAiB,KAAA,CAAM,CAAC;gBACzC,SAAS,SAAA,GAAY;gBACrB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,IAAA,CAAK,QAAQ;YACpC;YAED,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,MAAM;QAC9B;QAED,UAAU,WAAY;YACpB,IAAI,IAAA,CAAK,MAAA,IAAU,OAAO,IAAA,CAAK,MAAA,CAAO,SAAA,KAAc,YAAY;gBAC9D,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,IAAI;YAC3B;QACF;QAED,kBAAkB,SAAU,KAAA,EAAO,GAAA,EAAK;YACtC,MAAM,QAAQ,SAAS,OAAO,EAAE;YAChC,OAAA,CAAQ,SAAS,IAAI,QAAQ,IAAI,QAAQ,MAAM,CAAA,IAAK;QACrD;QAED,kBAAkB,SAAU,KAAA,EAAO,GAAA,EAAK;YACtC,MAAM,QAAQ,SAAS,OAAO,EAAE;YAChC,OAAA,CAAQ,SAAS,IAAI,QAAQ,IAAI,QAAQ,MAAM,CAAA,IAAK;QACrD;QAED,cAAc,SAAU,KAAA,EAAO,GAAA,EAAK;YAClC,MAAM,QAAQ,SAAS,OAAO,EAAE;YAChC,OAAA,CAAQ,SAAS,IAAI,QAAQ,IAAI,QAAQ,MAAM,CAAA,IAAK;QACrD;QAED,WAAW,SAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;YAC5B,MAAM,MAAM,IAAA,CAAK,QAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,QAAA;YAEjC,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YAC3C,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YAC3C,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QAC5C;QAED,gBAAgB,SAAU,CAAA,EAAG;YAC3B,MAAM,MAAM,IAAA,CAAK,QAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,QAAA;YAEjC,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QAC5C;QAED,eAAe,SAAU,CAAA,EAAG;YAC1B,MAAM,MAAM,IAAA,CAAK,QAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,QAAA;YAEjC,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QAC5C;QAED,WAAW,SAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;YAC5B,MAAM,MAAM,IAAA,CAAK,OAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,OAAA;YAEjC,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YAC3C,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YAC3C,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QAC5C;QAED,eAAe,SAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;YAChC,MAAM,MAAM,IAAA,CAAK,QAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,OAAA;YAEjC,IAAI,SAAA,CAAU,KAAK,CAAC;YACpB,IAAI,SAAA,CAAU,KAAK,CAAC;YACpB,IAAI,SAAA,CAAU,KAAK,CAAC;YAEpB,IAAI,UAAA,CAAW,KAAK,GAAG;YACvB,IAAI,UAAA,CAAW,KAAK,GAAG;YACvB,IAAI,KAAA,CAAM,GAAG;YAEb,IAAI,SAAA,CAAW;YAEf,IAAI,IAAA,CAAK,IAAI,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAC;YAC5B,IAAI,IAAA,CAAK,IAAI,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAC;YAC5B,IAAI,IAAA,CAAK,IAAI,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAC;QAC7B;QAED,UAAU,SAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;YAC3B,MAAM,MAAM,IAAA,CAAK,MAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,MAAA;YAEjC,IAAI,GAAA,CAAI,CAAC,CAAA,KAAM,KAAA,GAAW,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YACrE,IAAI,GAAA,CAAI,CAAC,CAAA,KAAM,KAAA,GAAW,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YACrE,IAAI,GAAA,CAAI,CAAC,CAAA,KAAM,KAAA,GAAW,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QACtE;QAED,OAAO,SAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG;YACxB,MAAM,MAAM,IAAA,CAAK,GAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,GAAA;YAEjC,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YAC/B,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;YAC/B,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QAChC;QAED,cAAc,WAAY;YACxB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,GAAA;YAEjC,IAAI,IAAA,CAAK,GAAG,CAAC;YACb,IAAI,IAAA,CAAK,GAAG,CAAC;YACb,IAAI,IAAA,CAAK,GAAG,CAAC;QACd;QAED,WAAW,SAAU,CAAA,EAAG;YACtB,MAAM,MAAM,IAAA,CAAK,GAAA;YACjB,MAAM,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,GAAA;YAEjC,IAAI,IAAA,CAAK,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,GAAA,CAAI,IAAI,CAAC,CAAC;QAChC;QAED,SAAS,SAAU,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI,EAAA,EAAI;YAClD,MAAM,OAAO,IAAA,CAAK,QAAA,CAAS,MAAA;YAE3B,IAAI,KAAK,IAAA,CAAK,gBAAA,CAAiB,GAAG,IAAI;YACtC,IAAI,KAAK,IAAA,CAAK,gBAAA,CAAiB,GAAG,IAAI;YACtC,IAAI,KAAK,IAAA,CAAK,gBAAA,CAAiB,GAAG,IAAI;YAEtC,IAAA,CAAK,SAAA,CAAU,IAAI,IAAI,EAAE;YACzB,IAAA,CAAK,QAAA,CAAS,IAAI,IAAI,EAAE;YAIxB,IAAI,OAAO,KAAA,KAAa,OAAO,IAAI;gBACjC,MAAM,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA;gBAE1B,KAAK,IAAA,CAAK,gBAAA,CAAiB,IAAI,IAAI;gBACnC,KAAK,IAAA,CAAK,gBAAA,CAAiB,IAAI,IAAI;gBACnC,KAAK,IAAA,CAAK,gBAAA,CAAiB,IAAI,IAAI;gBAEnC,IAAA,CAAK,SAAA,CAAU,IAAI,IAAI,EAAE;YACjC,OAAa;gBACL,IAAA,CAAK,aAAA,CAAc,IAAI,IAAI,EAAE;YAC9B;YAID,IAAI,OAAO,KAAA,KAAa,OAAO,IAAI;gBACjC,MAAM,QAAQ,IAAA,CAAK,GAAA,CAAI,MAAA;gBAEvB,KAAK,IAAA,CAAK,YAAA,CAAa,IAAI,KAAK;gBAChC,KAAK,IAAA,CAAK,YAAA,CAAa,IAAI,KAAK;gBAChC,KAAK,IAAA,CAAK,YAAA,CAAa,IAAI,KAAK;gBAEhC,IAAA,CAAK,KAAA,CAAM,IAAI,IAAI,EAAE;gBAErB,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,YAAA,GAAe;YAC5C,OAAa;gBAGL,IAAA,CAAK,YAAA,CAAc;YACpB;QACF;QAED,kBAAkB,SAAU,QAAA,EAAU;YACpC,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,IAAA,GAAO;YAE5B,MAAM,OAAO,IAAA,CAAK,QAAA,CAAS,MAAA;YAE3B,IAAA,IAAS,KAAK,GAAG,IAAI,SAAS,MAAA,EAAQ,KAAK,GAAG,KAAM;gBAClD,MAAM,QAAQ,IAAA,CAAK,gBAAA,CAAiB,QAAA,CAAS,EAAE,CAAA,EAAG,IAAI;gBAEtD,IAAA,CAAK,cAAA,CAAe,KAAK;gBACzB,IAAA,CAAK,QAAA,CAAS,KAAK;YACpB;QACF;QAED,iBAAiB,SAAU,QAAA,EAAU,GAAA,EAAK;YACxC,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,IAAA,GAAO;YAE5B,MAAM,OAAO,IAAA,CAAK,QAAA,CAAS,MAAA;YAC3B,MAAM,QAAQ,IAAA,CAAK,GAAA,CAAI,MAAA;YAEvB,IAAA,IAAS,KAAK,GAAG,IAAI,SAAS,MAAA,EAAQ,KAAK,GAAG,KAAM;gBAClD,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,gBAAA,CAAiB,QAAA,CAAS,EAAE,CAAA,EAAG,IAAI,CAAC;YAC7D;YAED,IAAA,IAAS,MAAM,GAAG,IAAI,IAAI,MAAA,EAAQ,MAAM,GAAG,MAAO;gBAChD,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,GAAG,CAAA,EAAG,KAAK,CAAC;YAClD;QACF;IACF;IAED,MAAM,WAAA,CAAY,IAAI,KAAK;IAE3B,OAAO;AACT;AAIA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QAEb,IAAA,CAAK,SAAA,GAAY;IAClB;IAED,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,MAAM,SAAS,IAAI,6JAAA,CAAW,IAAA,CAAK,OAAO;QAC1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;QACxB,OAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa;QAC1C,OAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe;QAC9C,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;YACd,IAAI;gBACF,OAAO,MAAM,KAAA,CAAM,IAAI,CAAC;YACzB,EAAA,OAAQ,GAAP;gBACA,IAAI,SAAS;oBACX,QAAQ,CAAC;gBACrB,OAAiB;oBACL,QAAQ,KAAA,CAAM,CAAC;gBAChB;gBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC5B;QACF,GACD,YACA;IAEH;IAED,aAAa,SAAA,EAAW;QACtB,IAAA,CAAK,SAAA,GAAY;QAEjB,OAAO,IAAA;IACR;IAED,MAAM,IAAA,EAAM;QACV,MAAM,QAAQ,IAAI,YAAa;QAE/B,IAAI,KAAK,OAAA,CAAQ,MAAM,MAAM,CAAA,GAAI;YAE/B,OAAO,KAAK,OAAA,CAAQ,SAAS,IAAI;QAClC;QAED,IAAI,KAAK,OAAA,CAAQ,MAAM,MAAM,CAAA,GAAI;YAE/B,OAAO,KAAK,OAAA,CAAQ,SAAS,EAAE;QAChC;QAED,MAAM,QAAQ,KAAK,KAAA,CAAM,IAAI;QAC7B,IAAI,OAAO,IACT,gBAAgB;QAClB,IAAI,aAAa;QACjB,IAAI,SAAS,CAAE,CAAA;QAGf,MAAM,WAAW,OAAO,GAAG,QAAA,KAAa;QAExC,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,IAAI,GAAG,IAAK;YAC5C,OAAO,KAAA,CAAM,CAAC,CAAA;YAEd,OAAO,WAAW,KAAK,QAAA,CAAQ,IAAK,KAAK,IAAA,CAAM;YAE/C,aAAa,KAAK,MAAA;YAElB,IAAI,eAAe,GAAG;YAEtB,gBAAgB,KAAK,MAAA,CAAO,CAAC;YAG7B,IAAI,kBAAkB,KAAK;YAE3B,IAAI,kBAAkB,KAAK;gBACzB,MAAM,OAAO,KAAK,KAAA,CAAM,KAAK;gBAE7B,OAAQ,IAAA,CAAK,CAAC,CAAA,EAAC;oBACb,KAAK;wBACH,MAAM,QAAA,CAAS,IAAA,CAAK,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,CAAC;wBACjF,IAAI,KAAK,MAAA,IAAU,GAAG;4BACpB,MAAM,MAAA,CAAO,IAAA,CAAK,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,CAAC;wBAC7F,OAAmB;4BAGL,MAAM,MAAA,CAAO,IAAA,CAAK,KAAA,GAAW,KAAA,GAAW,KAAA,CAAS;wBAClD;wBAED;oBACF,KAAK;wBACH,MAAM,OAAA,CAAQ,IAAA,CAAK,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,CAAC;wBAChF;oBACF,KAAK;wBACH,MAAM,GAAA,CAAI,IAAA,CAAK,WAAW,IAAA,CAAK,CAAC,CAAC,GAAG,WAAW,IAAA,CAAK,CAAC,CAAC,CAAC;wBACvD;gBACH;YACT,OAAA,IAAiB,kBAAkB,KAAK;gBAChC,MAAM,WAAW,KAAK,MAAA,CAAO,CAAC,EAAE,IAAA,CAAM;gBACtC,MAAM,aAAa,SAAS,KAAA,CAAM,KAAK;gBACvC,MAAM,eAAe,CAAE,CAAA;gBAIvB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACnD,MAAM,SAAS,UAAA,CAAW,CAAC,CAAA;oBAE3B,IAAI,OAAO,MAAA,GAAS,GAAG;wBACrB,MAAM,cAAc,OAAO,KAAA,CAAM,GAAG;wBACpC,aAAa,IAAA,CAAK,WAAW;oBAC9B;gBACF;gBAID,MAAM,KAAK,YAAA,CAAa,CAAC,CAAA;gBAEzB,IAAA,IAAS,IAAI,GAAG,KAAK,aAAa,MAAA,GAAS,GAAG,IAAI,IAAI,IAAK;oBACzD,MAAM,KAAK,YAAA,CAAa,CAAC,CAAA;oBACzB,MAAM,KAAK,YAAA,CAAa,IAAI,CAAC,CAAA;oBAE7B,MAAM,OAAA,CAAQ,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAA,EAAG,EAAA,CAAG,CAAC,CAAC;gBAC5E;YACT,OAAA,IAAiB,kBAAkB,KAAK;gBAChC,MAAM,YAAY,KAAK,SAAA,CAAU,CAAC,EAAE,IAAA,CAAM,EAAC,KAAA,CAAM,GAAG;gBACpD,IAAI,eAAe,CAAE,CAAA;gBACrB,MAAM,UAAU,CAAE,CAAA;gBAElB,IAAI,KAAK,OAAA,CAAQ,GAAG,MAAM,CAAA,GAAI;oBAC5B,eAAe;gBACzB,OAAe;oBACL,IAAA,IAAS,KAAK,GAAG,OAAO,UAAU,MAAA,EAAQ,KAAK,MAAM,KAAM;wBACzD,MAAM,QAAQ,SAAA,CAAU,EAAE,CAAA,CAAE,KAAA,CAAM,GAAG;wBAErC,IAAI,KAAA,CAAM,CAAC,CAAA,KAAM,IAAI,aAAa,IAAA,CAAK,KAAA,CAAM,CAAC,CAAC;wBAC/C,IAAI,KAAA,CAAM,CAAC,CAAA,KAAM,IAAI,QAAQ,IAAA,CAAK,KAAA,CAAM,CAAC,CAAC;oBAC3C;gBACF;gBAED,MAAM,eAAA,CAAgB,cAAc,OAAO;YACnD,OAAA,IAAiB,kBAAkB,KAAK;gBAChC,MAAM,WAAW,KAAK,MAAA,CAAO,CAAC,EAAE,IAAA,CAAM;gBACtC,MAAM,YAAY,SAAS,KAAA,CAAM,GAAG;gBAEpC,MAAM,gBAAA,CAAiB,SAAS;YACxC,OAAA,IAAA,CAAkB,SAAS,gBAAgB,IAAA,CAAK,IAAI,CAAA,MAAO,MAAM;gBAOzD,MAAM,OAAA,CAAQ,MAAM,MAAA,CAAO,CAAC,CAAA,CAAE,MAAA,CAAO,CAAC,EAAE,IAAA,EAAA,EAAQ,MAAA,CAAO,CAAC;gBAExD,MAAM,WAAA,CAAY,IAAI;YACvB,OAAA,IAAU,sBAAsB,IAAA,CAAK,IAAI,GAAG;gBAG3C,MAAM,MAAA,CAAO,aAAA,CAAc,KAAK,SAAA,CAAU,CAAC,EAAE,IAAA,CAAI,GAAI,MAAM,iBAAiB;YAC7E,OAAA,IAAU,0BAA0B,IAAA,CAAK,IAAI,GAAG;gBAG/C,MAAM,iBAAA,CAAkB,IAAA,CAAK,KAAK,SAAA,CAAU,CAAC,EAAE,IAAA,EAAM;YACtD,OAAA,IAAU,iBAAiB,IAAA,CAAK,IAAI,GAAG;gBAItC,QAAQ,IAAA,CACN;YAEV,OAAA,IAAiB,kBAAkB,KAAK;gBAChC,SAAS,KAAK,KAAA,CAAM,GAAG;gBAsBvB,IAAI,OAAO,MAAA,GAAS,GAAG;oBACrB,MAAM,QAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,IAAA,CAAI,EAAG,WAAA,CAAa;oBAC5C,MAAM,MAAA,CAAO,MAAA,GAAS,UAAU,OAAO,UAAU;gBAC3D,OAAe;oBAEL,MAAM,MAAA,CAAO,MAAA,GAAS;gBACvB;gBAED,MAAM,WAAW,MAAM,MAAA,CAAO,eAAA,CAAiB;gBAC/C,IAAI,UAAU,SAAS,MAAA,GAAS,MAAM,MAAA,CAAO,MAAA;YACrD,OAAa;gBAEL,IAAI,SAAS,MAAM;gBAEnB,QAAQ,IAAA,CAAK,wCAAwC,OAAO,GAAG;YAChE;QACF;QAED,MAAM,QAAA,CAAU;QAEhB,MAAM,YAAY,IAAI,wJAAA,CAAO;QAC7B,UAAU,iBAAA,GAAoB,CAAA,CAAA,CAAG,MAAA,CAAO,MAAM,iBAAiB;QAE/D,MAAM,gBAAgB,CAAA,CAAE,MAAM,OAAA,CAAQ,MAAA,KAAW,KAAK,MAAM,OAAA,CAAQ,CAAC,CAAA,CAAE,QAAA,CAAS,QAAA,CAAS,MAAA,KAAW,CAAA;QAEpG,IAAI,kBAAkB,MAAM;YAC1B,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;gBACpD,MAAM,SAAS,MAAM,OAAA,CAAQ,CAAC,CAAA;gBAC9B,MAAM,WAAW,OAAO,QAAA;gBACxB,MAAM,YAAY,OAAO,SAAA;gBACzB,MAAM,SAAS,SAAS,IAAA,KAAS;gBACjC,MAAM,WAAW,SAAS,IAAA,KAAS;gBACnC,IAAI,kBAAkB;gBAGtB,IAAI,SAAS,QAAA,CAAS,MAAA,KAAW,GAAG;gBAEpC,MAAM,iBAAiB,IAAI,iKAAA,CAAgB;gBAE3C,eAAe,YAAA,CAAa,YAAY,IAAI,yKAAA,CAAuB,SAAS,QAAA,EAAU,CAAC,CAAC;gBAExF,IAAI,SAAS,OAAA,CAAQ,MAAA,GAAS,GAAG;oBAC/B,eAAe,YAAA,CAAa,UAAU,IAAI,yKAAA,CAAuB,SAAS,OAAA,EAAS,CAAC,CAAC;gBACtF;gBAED,IAAI,SAAS,MAAA,CAAO,MAAA,GAAS,GAAG;oBAC9B,kBAAkB;oBAClB,eAAe,YAAA,CAAa,SAAS,IAAI,yKAAA,CAAuB,SAAS,MAAA,EAAQ,CAAC,CAAC;gBACpF;gBAED,IAAI,SAAS,YAAA,KAAiB,MAAM;oBAClC,eAAe,YAAA,CAAa,MAAM,IAAI,yKAAA,CAAuB,SAAS,GAAA,EAAK,CAAC,CAAC;gBAC9E;gBAID,MAAM,mBAAmB,CAAE,CAAA;gBAE3B,IAAA,IAAS,KAAK,GAAG,QAAQ,UAAU,MAAA,EAAQ,KAAK,OAAO,KAAM;oBAC3D,MAAM,iBAAiB,SAAA,CAAU,EAAE,CAAA;oBACnC,MAAM,eAAe,eAAe,IAAA,GAAO,MAAM,eAAe,MAAA,GAAS,MAAM;oBAC/E,IAAI,WAAW,MAAM,SAAA,CAAU,YAAY,CAAA;oBAE3C,IAAI,IAAA,CAAK,SAAA,KAAc,MAAM;wBAC3B,WAAW,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,eAAe,IAAI;wBAGpD,IAAI,UAAU,YAAY,CAAA,CAAE,oBAAoB,oKAAA,GAAoB;4BAClE,MAAM,eAAe,IAAI,oKAAA,CAAmB;4BAC5C,2JAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,cAAc,QAAQ;4BACnD,aAAa,KAAA,CAAM,IAAA,CAAK,SAAS,KAAK;4BACtC,WAAW;wBACZ,OAAA,IAAU,YAAY,YAAY,CAAA,CAAE,oBAAoB,iKAAA,GAAiB;4BACxE,MAAM,iBAAiB,IAAI,iKAAA,CAAe;gCAAE,MAAM;gCAAI,iBAAiB;4BAAA,CAAO;4BAC9E,2JAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,gBAAgB,QAAQ;4BACrD,eAAe,KAAA,CAAM,IAAA,CAAK,SAAS,KAAK;4BACxC,eAAe,GAAA,GAAM,SAAS,GAAA;4BAC9B,WAAW;wBACZ;oBACF;oBAED,IAAI,aAAa,KAAA,GAAW;wBAC1B,IAAI,QAAQ;4BACV,WAAW,IAAI,oKAAA,CAAmB;wBACnC,OAAA,IAAU,UAAU;4BACnB,WAAW,IAAI,iKAAA,CAAe;gCAAE,MAAM;gCAAG,iBAAiB;4BAAA,CAAO;wBAC/E,OAAmB;4BACL,WAAW,IAAI,oKAAA,CAAmB;wBACnC;wBAED,SAAS,IAAA,GAAO,eAAe,IAAA;wBAC/B,SAAS,WAAA,GAAc,eAAe,MAAA,GAAS,QAAQ;wBACvD,SAAS,YAAA,GAAe;wBAExB,MAAM,SAAA,CAAU,YAAY,CAAA,GAAI;oBACjC;oBAED,iBAAiB,IAAA,CAAK,QAAQ;gBAC/B;gBAID,IAAI;gBAEJ,IAAI,iBAAiB,MAAA,GAAS,GAAG;oBAC/B,IAAA,IAAS,KAAK,GAAG,QAAQ,UAAU,MAAA,EAAQ,KAAK,OAAO,KAAM;wBAC3D,MAAM,iBAAiB,SAAA,CAAU,EAAE,CAAA;wBACnC,eAAe,QAAA,CAAS,eAAe,UAAA,EAAY,eAAe,UAAA,EAAY,EAAE;oBACjF;oBAED,IAAI,QAAQ;wBACV,OAAO,IAAI,+JAAA,CAAa,gBAAgB,gBAAgB;oBACzD,OAAA,IAAU,UAAU;wBACnB,OAAO,IAAI,yJAAA,CAAO,gBAAgB,gBAAgB;oBAC9D,OAAiB;wBACL,OAAO,IAAI,uJAAA,CAAK,gBAAgB,gBAAgB;oBACjD;gBACX,OAAe;oBACL,IAAI,QAAQ;wBACV,OAAO,IAAI,+JAAA,CAAa,gBAAgB,gBAAA,CAAiB,CAAC,CAAC;oBAC5D,OAAA,IAAU,UAAU;wBACnB,OAAO,IAAI,yJAAA,CAAO,gBAAgB,gBAAA,CAAiB,CAAC,CAAC;oBACjE,OAAiB;wBACL,OAAO,IAAI,uJAAA,CAAK,gBAAgB,gBAAA,CAAiB,CAAC,CAAC;oBACpD;gBACF;gBAED,KAAK,IAAA,GAAO,OAAO,IAAA;gBAEnB,UAAU,GAAA,CAAI,IAAI;YACnB;QACP,OAAW;YAGL,IAAI,MAAM,QAAA,CAAS,MAAA,GAAS,GAAG;gBAC7B,MAAM,WAAW,IAAI,iKAAA,CAAe;oBAAE,MAAM;oBAAG,iBAAiB;gBAAA,CAAO;gBAEvE,MAAM,iBAAiB,IAAI,iKAAA,CAAgB;gBAE3C,eAAe,YAAA,CAAa,YAAY,IAAI,yKAAA,CAAuB,MAAM,QAAA,EAAU,CAAC,CAAC;gBAErF,IAAI,MAAM,MAAA,CAAO,MAAA,GAAS,KAAK,MAAM,MAAA,CAAO,CAAC,CAAA,KAAM,KAAA,GAAW;oBAC5D,eAAe,YAAA,CAAa,SAAS,IAAI,yKAAA,CAAuB,MAAM,MAAA,EAAQ,CAAC,CAAC;oBAChF,SAAS,YAAA,GAAe;gBACzB;gBAED,MAAM,SAAS,IAAI,yJAAA,CAAO,gBAAgB,QAAQ;gBAClD,UAAU,GAAA,CAAI,MAAM;YACrB;QACF;QAED,OAAO;IACR;AACH"}},
    {"offset": {"line": 25217, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/AMFLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/AMFLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Loader,\n  LoaderUtils,\n  Mesh,\n  MeshPhongMaterial,\n} from 'three'\nimport { unzipSync } from 'fflate'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: Early release of an AMF Loader following the pattern of the\n * example loaders in the three.js project.\n *\n * Usage:\n *\tconst loader = new AMFLoader();\n *\tloader.load('/path/to/project.amf', function(objecttree) {\n *\t\tscene.add(objecttree);\n *\t});\n *\n * Materials now supported, material colors supported\n * Zip support, requires fflate\n * No constellation support (yet)!\n *\n */\n\nclass AMFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    function loadDocument(data) {\n      let view = new DataView(data)\n      const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1))\n\n      if (magic === 'PK') {\n        let zip = null\n        let file = null\n\n        console.log('THREE.AMFLoader: Loading Zip')\n\n        try {\n          zip = unzipSync(new Uint8Array(data))\n        } catch (e) {\n          if (e instanceof ReferenceError) {\n            console.log('THREE.AMFLoader: fflate missing and file is compressed.')\n            return null\n          }\n        }\n\n        for (file in zip) {\n          if (file.toLowerCase().substr(-4) === '.amf') {\n            break\n          }\n        }\n\n        console.log('THREE.AMFLoader: Trying to load file asset: ' + file)\n        view = new DataView(zip[file].buffer)\n      }\n\n      const fileText = decodeText(view)\n      const xmlData = new DOMParser().parseFromString(fileText, 'application/xml')\n\n      if (xmlData.documentElement.nodeName.toLowerCase() !== 'amf') {\n        console.log('THREE.AMFLoader: Error loading AMF - no AMF document found.')\n        return null\n      }\n\n      return xmlData\n    }\n\n    function loadDocumentScale(node) {\n      let scale = 1.0\n      let unit = 'millimeter'\n\n      if (node.documentElement.attributes.unit !== undefined) {\n        unit = node.documentElement.attributes.unit.value.toLowerCase()\n      }\n\n      const scaleUnits = {\n        millimeter: 1.0,\n        inch: 25.4,\n        feet: 304.8,\n        meter: 1000.0,\n        micron: 0.001,\n      }\n\n      if (scaleUnits[unit] !== undefined) {\n        scale = scaleUnits[unit]\n      }\n\n      console.log('THREE.AMFLoader: Unit scale: ' + scale)\n      return scale\n    }\n\n    function loadMaterials(node) {\n      let matName = 'AMF Material'\n      const matId = node.attributes.id.textContent\n      let color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }\n\n      let loadedMaterial = null\n\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const matChildEl = node.childNodes[i]\n\n        if (matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined) {\n          if (matChildEl.attributes.type.value === 'name') {\n            matName = matChildEl.textContent\n          }\n        } else if (matChildEl.nodeName === 'color') {\n          color = loadColor(matChildEl)\n        }\n      }\n\n      loadedMaterial = new MeshPhongMaterial({\n        flatShading: true,\n        color: new Color(color.r, color.g, color.b),\n        name: matName,\n      })\n\n      if (color.a !== 1.0) {\n        loadedMaterial.transparent = true\n        loadedMaterial.opacity = color.a\n      }\n\n      return { id: matId, material: loadedMaterial }\n    }\n\n    function loadColor(node) {\n      const color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }\n\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const matColor = node.childNodes[i]\n\n        if (matColor.nodeName === 'r') {\n          color.r = matColor.textContent\n        } else if (matColor.nodeName === 'g') {\n          color.g = matColor.textContent\n        } else if (matColor.nodeName === 'b') {\n          color.b = matColor.textContent\n        } else if (matColor.nodeName === 'a') {\n          color.a = matColor.textContent\n        }\n      }\n\n      return color\n    }\n\n    function loadMeshVolume(node) {\n      const volume = { name: '', triangles: [], materialid: null }\n\n      let currVolumeNode = node.firstElementChild\n\n      if (node.attributes.materialid !== undefined) {\n        volume.materialId = node.attributes.materialid.nodeValue\n      }\n\n      while (currVolumeNode) {\n        if (currVolumeNode.nodeName === 'metadata') {\n          if (currVolumeNode.attributes.type !== undefined) {\n            if (currVolumeNode.attributes.type.value === 'name') {\n              volume.name = currVolumeNode.textContent\n            }\n          }\n        } else if (currVolumeNode.nodeName === 'triangle') {\n          const v1 = currVolumeNode.getElementsByTagName('v1')[0].textContent\n          const v2 = currVolumeNode.getElementsByTagName('v2')[0].textContent\n          const v3 = currVolumeNode.getElementsByTagName('v3')[0].textContent\n\n          volume.triangles.push(v1, v2, v3)\n        }\n\n        currVolumeNode = currVolumeNode.nextElementSibling\n      }\n\n      return volume\n    }\n\n    function loadMeshVertices(node) {\n      const vertArray = []\n      const normalArray = []\n      let currVerticesNode = node.firstElementChild\n\n      while (currVerticesNode) {\n        if (currVerticesNode.nodeName === 'vertex') {\n          let vNode = currVerticesNode.firstElementChild\n\n          while (vNode) {\n            if (vNode.nodeName === 'coordinates') {\n              const x = vNode.getElementsByTagName('x')[0].textContent\n              const y = vNode.getElementsByTagName('y')[0].textContent\n              const z = vNode.getElementsByTagName('z')[0].textContent\n\n              vertArray.push(x, y, z)\n            } else if (vNode.nodeName === 'normal') {\n              const nx = vNode.getElementsByTagName('nx')[0].textContent\n              const ny = vNode.getElementsByTagName('ny')[0].textContent\n              const nz = vNode.getElementsByTagName('nz')[0].textContent\n\n              normalArray.push(nx, ny, nz)\n            }\n\n            vNode = vNode.nextElementSibling\n          }\n        }\n\n        currVerticesNode = currVerticesNode.nextElementSibling\n      }\n\n      return { vertices: vertArray, normals: normalArray }\n    }\n\n    function loadObject(node) {\n      const objId = node.attributes.id.textContent\n      const loadedObject = { name: 'amfobject', meshes: [] }\n      let currColor = null\n      let currObjNode = node.firstElementChild\n\n      while (currObjNode) {\n        if (currObjNode.nodeName === 'metadata') {\n          if (currObjNode.attributes.type !== undefined) {\n            if (currObjNode.attributes.type.value === 'name') {\n              loadedObject.name = currObjNode.textContent\n            }\n          }\n        } else if (currObjNode.nodeName === 'color') {\n          currColor = loadColor(currObjNode)\n        } else if (currObjNode.nodeName === 'mesh') {\n          let currMeshNode = currObjNode.firstElementChild\n          const mesh = { vertices: [], normals: [], volumes: [], color: currColor }\n\n          while (currMeshNode) {\n            if (currMeshNode.nodeName === 'vertices') {\n              const loadedVertices = loadMeshVertices(currMeshNode)\n\n              mesh.normals = mesh.normals.concat(loadedVertices.normals)\n              mesh.vertices = mesh.vertices.concat(loadedVertices.vertices)\n            } else if (currMeshNode.nodeName === 'volume') {\n              mesh.volumes.push(loadMeshVolume(currMeshNode))\n            }\n\n            currMeshNode = currMeshNode.nextElementSibling\n          }\n\n          loadedObject.meshes.push(mesh)\n        }\n\n        currObjNode = currObjNode.nextElementSibling\n      }\n\n      return { id: objId, obj: loadedObject }\n    }\n\n    const xmlData = loadDocument(data)\n    let amfName = ''\n    let amfAuthor = ''\n    const amfScale = loadDocumentScale(xmlData)\n    const amfMaterials = {}\n    const amfObjects = {}\n    const childNodes = xmlData.documentElement.childNodes\n\n    let i, j\n\n    for (i = 0; i < childNodes.length; i++) {\n      const child = childNodes[i]\n\n      if (child.nodeName === 'metadata') {\n        if (child.attributes.type !== undefined) {\n          if (child.attributes.type.value === 'name') {\n            amfName = child.textContent\n          } else if (child.attributes.type.value === 'author') {\n            amfAuthor = child.textContent\n          }\n        }\n      } else if (child.nodeName === 'material') {\n        const loadedMaterial = loadMaterials(child)\n\n        amfMaterials[loadedMaterial.id] = loadedMaterial.material\n      } else if (child.nodeName === 'object') {\n        const loadedObject = loadObject(child)\n\n        amfObjects[loadedObject.id] = loadedObject.obj\n      }\n    }\n\n    const sceneObject = new Group()\n    const defaultMaterial = new MeshPhongMaterial({ color: 0xaaaaff, flatShading: true })\n\n    sceneObject.name = amfName\n    sceneObject.userData.author = amfAuthor\n    sceneObject.userData.loader = 'AMF'\n\n    for (const id in amfObjects) {\n      const part = amfObjects[id]\n      const meshes = part.meshes\n      const newObject = new Group()\n      newObject.name = part.name || ''\n\n      for (i = 0; i < meshes.length; i++) {\n        let objDefaultMaterial = defaultMaterial\n        const mesh = meshes[i]\n        const vertices = new Float32BufferAttribute(mesh.vertices, 3)\n        let normals = null\n\n        if (mesh.normals.length) {\n          normals = new Float32BufferAttribute(mesh.normals, 3)\n        }\n\n        if (mesh.color) {\n          const color = mesh.color\n\n          objDefaultMaterial = defaultMaterial.clone()\n          objDefaultMaterial.color = new Color(color.r, color.g, color.b)\n\n          if (color.a !== 1.0) {\n            objDefaultMaterial.transparent = true\n            objDefaultMaterial.opacity = color.a\n          }\n        }\n\n        const volumes = mesh.volumes\n\n        for (j = 0; j < volumes.length; j++) {\n          const volume = volumes[j]\n          const newGeometry = new BufferGeometry()\n          let material = objDefaultMaterial\n\n          newGeometry.setIndex(volume.triangles)\n          newGeometry.setAttribute('position', vertices.clone())\n\n          if (normals) {\n            newGeometry.setAttribute('normal', normals.clone())\n          }\n\n          if (amfMaterials[volume.materialId] !== undefined) {\n            material = amfMaterials[volume.materialId]\n          }\n\n          newGeometry.scale(amfScale, amfScale, amfScale)\n          newObject.add(new Mesh(newGeometry, material.clone()))\n        }\n      }\n\n      sceneObject.add(newObject)\n    }\n\n    return sceneObject\n  }\n}\n\nexport { AMFLoader }\n"],"names":["data","xmlData","i"],"mappings":"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"}},
    {"offset": {"line": 25541, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/MMDLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/MMDLoader.js"],"sourcesContent":["import {\n  AddOperation,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  Color,\n  CustomBlending,\n  DoubleSide,\n  DstAlphaFactor,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Interpolant,\n  Loader,\n  LoaderUtils,\n  MeshToonMaterial,\n  MultiplyOperation,\n  NearestFilter,\n  NumberKeyframeTrack,\n  OneMinusSrcAlphaFactor,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SrcAlphaFactor,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { TGALoader } from '../loaders/TGALoader'\nimport { Parser } from '../libs/mmdparser'\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.loader = new FileLoader(this.manager)\n\n    this.parser = null // lazy generation\n    this.meshBuilder = new MeshBuilder(this.manager)\n    this.animationBuilder = new AnimationBuilder()\n  }\n\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath\n    return this\n  }\n\n  // Load MMD assets as Three.js Object\n\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin)\n\n    // resource path\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      resourcePath = this.path\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    const modelExtension = this._extractExtension(url).toLowerCase()\n\n    // Should I detect by seeing header?\n    if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n      if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'))\n\n      return\n    }\n\n    this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](\n      url,\n      function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder\n\n    this.loadVMD(\n      url,\n      function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this\n\n    this.load(\n      modelUrl,\n      function (mesh) {\n        scope.loadAnimation(\n          vmdUrl,\n          mesh,\n          function (animation) {\n            onLoad({\n              mesh: mesh,\n              animation: animation,\n            })\n          },\n          onProgress,\n          onError,\n        )\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  // Load MMD assets as Object data parsed by MMDParser\n\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.path)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (buffer) {\n          onLoad(parser.parsePmd(buffer, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.path)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (buffer) {\n          onLoad(parser.parsePmx(buffer, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url]\n\n    const vmds = []\n    const vmdNum = urls.length\n\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.animationPath)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(\n        urls[i],\n        function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true))\n\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds))\n        },\n        onProgress,\n        onError,\n      )\n    }\n  }\n\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis')\n      .setPath(this.animationPath)\n      .setResponseType('text')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (text) {\n          onLoad(parser.parseVpd(text, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  // private methods\n\n  _extractExtension(url) {\n    const index = url.lastIndexOf('.')\n    return index < 0 ? '' : url.slice(index + 1)\n  }\n\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser()\n    }\n\n    return this.parser\n  }\n}\n\n// Utilities\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n * We don't need to request external toon image files.\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\nconst DEFAULT_TOON_TEXTURES = [\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n]\n\n// Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = 'anonymous'\n    this.geometryBuilder = new GeometryBuilder()\n    this.materialBuilder = new MaterialBuilder(manager)\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin\n    return this\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data)\n    const material = this.materialBuilder\n      .setCrossOrigin(this.crossOrigin)\n      .setResourcePath(resourcePath)\n      .build(data, geometry, onProgress, onError)\n\n    const mesh = new SkinnedMesh(geometry, material)\n\n    const skeleton = new Skeleton(initBones(mesh))\n    mesh.bind(skeleton)\n\n    // console.log( mesh ); // for console debug\n\n    return mesh\n  }\n}\n\n// TODO: Try to remove this function\n\nfunction initBones(mesh) {\n  const geometry = mesh.geometry\n\n  const bones = []\n\n  if (geometry && geometry.bones !== undefined) {\n    // first, create array of 'Bone' objects from geometry data\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]\n\n      // create new 'Bone' object\n\n      const bone = new Bone()\n      bones.push(bone)\n\n      // apply values\n\n      bone.name = gbone.name\n      bone.position.fromArray(gbone.pos)\n      bone.quaternion.fromArray(gbone.rotq)\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl)\n    }\n\n    // second, create bone hierarchy\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]\n\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n        // subsequent bones in the hierarchy\n\n        bones[gbone.parent].add(bones[i])\n      } else {\n        // topmost bone, immediate child of the skinned mesh\n\n        mesh.add(bones[i])\n      }\n    }\n  }\n\n  // now the bones are part of the scene graph and children of the skinned mesh.\n  // let's update the corresponding matrices\n\n  mesh.updateMatrixWorld(true)\n\n  return bones\n}\n\n//\n\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    // for geometry\n    const positions = []\n    const uvs = []\n    const normals = []\n\n    const indices = []\n\n    const groups = []\n\n    const bones = []\n    const skinIndices = []\n    const skinWeights = []\n\n    const morphTargets = []\n    const morphPositions = []\n\n    const iks = []\n    const grants = []\n\n    const rigidBodies = []\n    const constraints = []\n\n    // for work\n    let offset = 0\n    const boneTypeTable = {}\n\n    // positions, normals, uvs, skinIndices, skinWeights\n\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i]\n\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j])\n      }\n\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j])\n      }\n\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j])\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0)\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0)\n      }\n    }\n\n    // indices\n\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i]\n\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j])\n      }\n    }\n\n    // groups\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i]\n\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3,\n      })\n\n      offset += material.faceCount\n    }\n\n    // bones\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i]\n      let value = boneTypeTable[body.boneIndex]\n\n      // keeps greater number if already value is set without any special reasons\n      value = value === undefined ? body.type : Math.max(body.type, value)\n\n      boneTypeTable[body.boneIndex] = value\n    }\n\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i]\n\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1,\n      }\n\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0]\n        bone.pos[1] -= data.bones[bone.parent].position[1]\n        bone.pos[2] -= data.bones[bone.parent].position[2]\n      }\n\n      bones.push(bone)\n    }\n\n    // iks\n\n    // TODO: remove duplicated codes between PMD and PMX\n    if (data.metadata.format === 'pmd') {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i]\n\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: [],\n        }\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {}\n          link.index = ik.links[j].index\n          link.enabled = true\n\n          if (data.bones[link.index].name.indexOf('') >= 0) {\n            link.limitation = new Vector3(1.0, 0.0, 0.0)\n          }\n\n          param.links.push(link)\n        }\n\n        iks.push(param)\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik\n\n        if (ik === undefined) continue\n\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: [],\n        }\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {}\n          link.index = ik.links[j].index\n          link.enabled = true\n\n          if (ik.links[j].angleLimitation === 1) {\n            // Revert if rotationMin/Max doesn't work well\n            // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n\n            const rotationMin = ik.links[j].lowerLimitationAngle\n            const rotationMax = ik.links[j].upperLimitationAngle\n\n            // Convert Left to Right coordinate by myself because\n            // MMDParser doesn't convert. It's a MMDParser's bug\n\n            const tmp1 = -rotationMax[0]\n            const tmp2 = -rotationMax[1]\n            rotationMax[0] = -rotationMin[0]\n            rotationMax[1] = -rotationMin[1]\n            rotationMin[0] = tmp1\n            rotationMin[1] = tmp2\n\n            link.rotationMin = new Vector3().fromArray(rotationMin)\n            link.rotationMax = new Vector3().fromArray(rotationMax)\n          }\n\n          param.links.push(link)\n        }\n\n        iks.push(param)\n\n        // Save the reference even from bone data for efficiently\n        // simulating PMX animation system\n        bones[i].ik = param\n      }\n    }\n\n    // grants\n\n    if (data.metadata.format === 'pmx') {\n      // bone index -> grant entry map\n      const grantEntryMap = {}\n\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i]\n        const grant = boneData.grant\n\n        if (grant === undefined) continue\n\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass,\n        }\n\n        grantEntryMap[i] = { parent: null, children: [], param: param, visited: false }\n      }\n\n      const rootEntry = { parent: null, children: [], param: null, visited: false }\n\n      // Build a tree representing grant hierarchy\n\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex]\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry\n\n        grantEntry.parent = parentGrantEntry\n        parentGrantEntry.children.push(grantEntry)\n      }\n\n      // Sort grant parameters from parents to children because\n      // grant uses parent's transform that parent's grant is already applied\n      // so grant should be applied in order from parents to children\n\n      function traverse(entry) {\n        if (entry.param) {\n          grants.push(entry.param)\n\n          // Save the reference even from bone data for efficiently\n          // simulating PMX animation system\n          bones[entry.param.index].grant = entry.param\n        }\n\n        entry.visited = true\n\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i]\n\n          // Cut off a loop if exists. (Is a grant loop invalid?)\n          if (!child.visited) traverse(child)\n        }\n      }\n\n      traverse(rootEntry)\n    }\n\n    // morph\n\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i]\n\n        let index\n\n        if (data.metadata.format === 'pmd') {\n          index = data.morphs[0].elements[element.index].index\n        } else {\n          index = element.index\n        }\n\n        attribute.array[index * 3 + 0] += element.position[0] * ratio\n        attribute.array[index * 3 + 1] += element.position[1] * ratio\n        attribute.array[index * 3 + 2] += element.position[2] * ratio\n      }\n    }\n\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i]\n      const params = { name: morph.name }\n\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3)\n      attribute.name = morph.name\n\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j]\n      }\n\n      if (data.metadata.format === 'pmd') {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1.0)\n        }\n      } else {\n        if (morph.type === 0) {\n          // group\n\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index]\n            const ratio = morph.elements[j].ratio\n\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio)\n            } else {\n              // TODO: implement\n            }\n          }\n        } else if (morph.type === 1) {\n          // vertex\n\n          updateAttributes(attribute, morph, 1.0)\n        } else if (morph.type === 2) {\n          // bone\n          // TODO: implement\n        } else if (morph.type === 3) {\n          // uv\n          // TODO: implement\n        } else if (morph.type === 4) {\n          // additional uv1\n          // TODO: implement\n        } else if (morph.type === 5) {\n          // additional uv2\n          // TODO: implement\n        } else if (morph.type === 6) {\n          // additional uv3\n          // TODO: implement\n        } else if (morph.type === 7) {\n          // additional uv4\n          // TODO: implement\n        } else if (morph.type === 8) {\n          // material\n          // TODO: implement\n        }\n      }\n\n      morphTargets.push(params)\n      morphPositions.push(attribute)\n    }\n\n    // rigid bodies from rigidBodies field.\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i]\n      const params = {}\n\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key]\n      }\n\n      /*\n       * RigidBody position parameter in PMX seems global position\n       * while the one in PMD seems offset from corresponding bone.\n       * So unify being offset.\n       */\n      if (data.metadata.format === 'pmx') {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex]\n          params.position[0] -= bone.position[0]\n          params.position[1] -= bone.position[1]\n          params.position[2] -= bone.position[2]\n        }\n      }\n\n      rigidBodies.push(params)\n    }\n\n    // constraints from constraints field.\n\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i]\n      const params = {}\n\n      for (const key in constraint) {\n        params[key] = constraint[key]\n      }\n\n      const bodyA = rigidBodies[params.rigidBodyIndex1]\n      const bodyB = rigidBodies[params.rigidBodyIndex2]\n\n      // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (\n          bodyA.boneIndex !== -1 &&\n          bodyB.boneIndex !== -1 &&\n          data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex\n        ) {\n          bodyB.type = 1\n        }\n      }\n\n      constraints.push(params)\n    }\n\n    // build BufferGeometry.\n\n    const geometry = new BufferGeometry()\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n    geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4))\n    geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4))\n    geometry.setIndex(indices)\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i)\n    }\n\n    geometry.bones = bones\n\n    geometry.morphTargets = morphTargets\n    geometry.morphAttributes.position = morphPositions\n    geometry.morphTargetsRelative = false\n\n    geometry.userData.MMD = {\n      bones: bones,\n      iks: iks,\n      grants: grants,\n      rigidBodies: rigidBodies,\n      constraints: constraints,\n      format: data.metadata.format,\n    }\n\n    geometry.computeBoundingSphere()\n\n    return geometry\n  }\n}\n\n//\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager\n\n    this.textureLoader = new TextureLoader(this.manager)\n    this.tgaLoader = null // lazy generation\n\n    this.crossOrigin = 'anonymous'\n    this.resourcePath = undefined\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin\n    return this\n  }\n\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath\n    return this\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry /*, onProgress, onError */) {\n    const materials = []\n\n    const textures = {}\n\n    this.textureLoader.setCrossOrigin(this.crossOrigin)\n\n    // materials\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i]\n\n      const params = { userData: {} }\n\n      if (material.name !== undefined) params.name = material.name\n\n      /*\n       * Color\n       *\n       * MMD         MeshToonMaterial\n       * diffuse  -  color\n       * ambient  -  emissive * a\n       *               (a = 1.0 without map texture or 0.2 with map texture)\n       *\n       * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n       * It'll be too bright if material has map texture so using coef 0.2.\n       */\n      params.color = new Color().fromArray(material.diffuse)\n      params.opacity = material.diffuse[3]\n      params.emissive = new Color().fromArray(material.ambient)\n      params.transparent = params.opacity !== 1.0\n\n      //\n\n      params.skinning = geometry.bones.length > 0 ? true : false\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false\n      params.fog = true\n\n      // blend\n\n      params.blending = CustomBlending\n      params.blendSrc = SrcAlphaFactor\n      params.blendDst = OneMinusSrcAlphaFactor\n      params.blendSrcAlpha = SrcAlphaFactor\n      params.blendDstAlpha = DstAlphaFactor\n\n      // side\n\n      if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n        params.side = DoubleSide\n      } else {\n        params.side = params.opacity === 1.0 ? FrontSide : DoubleSide\n      }\n\n      if (data.metadata.format === 'pmd') {\n        // map, envMap\n\n        if (material.fileName) {\n          const fileName = material.fileName\n          const fileNames = fileName.split('*')\n\n          // fileNames[ 0 ]: mapFileName\n          // fileNames[ 1 ]: envMapFileName( optional )\n\n          params.map = this._loadTexture(fileNames[0], textures)\n\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase()\n\n            params.envMap = this._loadTexture(fileNames[1], textures)\n\n            params.combine = extension === '.sph' ? MultiplyOperation : AddOperation\n          }\n        }\n\n        // gradientMap\n\n        const toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName),\n        })\n\n        // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n          color: [0, 0, 0],\n          alpha: 1.0,\n          visible: material.edgeFlag === 1,\n        }\n      } else {\n        // map\n\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures)\n        }\n\n        // envMap TODO: support m.envFlag === 3\n\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures)\n\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation\n        }\n\n        // gradientMap\n\n        let toonFileName, isDefaultToon\n\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp'\n          isDefaultToon = true\n        } else {\n          toonFileName = data.textures[material.toonIndex]\n          isDefaultToon = false\n        }\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon,\n        })\n\n        // parameters for OutlineEffect\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300, // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0,\n        }\n      }\n\n      if (params.map !== undefined) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i)\n        }\n\n        params.emissive.multiplyScalar(0.2)\n      }\n\n      materials.push(new MeshToonMaterial(params))\n    }\n\n    if (data.metadata.format === 'pmx') {\n      // set transparent true if alpha morph is defined.\n\n      function checkAlphaMorph(elements, materials) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i]\n\n          if (element.index === -1) continue\n\n          const material = materials[element.index]\n\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true\n          }\n        }\n      }\n\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i]\n        const elements = morph.elements\n\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index]\n\n            if (morph2.type !== 8) continue\n\n            checkAlphaMorph(morph2.elements, materials)\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials)\n        }\n      }\n    }\n\n    return materials\n  }\n\n  // private methods\n\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === undefined) {\n        throw new Error('THREE.MMDLoader: Import TGALoader')\n      }\n\n      this.tgaLoader = new TGALoader(this.manager)\n    }\n\n    return this.tgaLoader\n  }\n\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false\n\n    return /toon(10|0[0-9])\\.bmp/.test(name)\n  }\n\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {}\n\n    const scope = this\n\n    let fullPath\n\n    if (params.isDefaultToonTexture === true) {\n      let index\n\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1])\n      } catch (e) {\n        console.warn(\n          'THREE.MMDLoader: ' +\n            filePath +\n            ' seems like a ' +\n            'not right default texture path. Using toon00.bmp instead.',\n        )\n\n        index = 0\n      }\n\n      fullPath = DEFAULT_TOON_TEXTURES[index]\n    } else {\n      fullPath = this.resourcePath + filePath\n    }\n\n    if (textures[fullPath] !== undefined) return textures[fullPath]\n\n    let loader = this.manager.getHandler(fullPath)\n\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader\n    }\n\n    const texture = loader.load(\n      fullPath,\n      function (t) {\n        // MMD toon texture is Axis-Y oriented\n        // but Three.js gradient map is Axis-X oriented.\n        // So here replaces the toon texture image with the rotated one.\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image)\n\n          t.magFilter = NearestFilter\n          t.minFilter = NearestFilter\n        }\n\n        t.flipY = false\n        t.wrapS = RepeatWrapping\n        t.wrapT = RepeatWrapping\n\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture)\n        }\n\n        delete texture.readyCallbacks\n      },\n      onProgress,\n      onError,\n    )\n\n    texture.readyCallbacks = []\n\n    textures[fullPath] = texture\n\n    return texture\n  }\n\n  _getRotatedImage(image) {\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')\n\n    const width = image.width\n    const height = image.height\n\n    canvas.width = width\n    canvas.height = height\n\n    context.clearRect(0, 0, width, height)\n    context.translate(width / 2.0, height / 2.0)\n    context.rotate(0.5 * Math.PI) // 90.0 * Math.PI / 180.0\n    context.translate(-width / 2.0, -height / 2.0)\n    context.drawImage(image, 0, 0)\n\n    return context.getImageData(0, 0, width, height)\n  }\n\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      // Is there any efficient ways?\n      function createImageData(image) {\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n\n        const context = canvas.getContext('2d')\n        context.drawImage(image, 0, 0)\n\n        return context.getImageData(0, 0, canvas.width, canvas.height)\n      }\n\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width\n        const height = image.height\n        const data = image.data\n        const threshold = 253\n\n        if (data.length / (width * height) !== 4) return false\n\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = { x: 0.0, y: 0.0 }\n\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j]\n            const uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] }\n\n            if (getAlphaByUv(image, uv) < threshold) return true\n\n            centerUV.x += uv.x\n            centerUV.y += uv.y\n          }\n\n          centerUV.x /= 3\n          centerUV.y /= 3\n\n          if (getAlphaByUv(image, centerUV) < threshold) return true\n        }\n\n        return false\n      }\n\n      /*\n       * This method expects\n       *   texture.flipY = false\n       *   texture.wrapS = RepeatWrapping\n       *   texture.wrapT = RepeatWrapping\n       * TODO: more precise\n       */\n      function getAlphaByUv(image, uv) {\n        const width = image.width\n        const height = image.height\n\n        let x = Math.round(uv.x * width) % width\n        let y = Math.round(uv.y * height) % height\n\n        if (x < 0) x += width\n        if (y < 0) y += height\n\n        const index = y * width + x\n\n        return image.data[index * 4 + 3]\n      }\n\n      const imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image)\n\n      const group = geometry.groups[groupIndex]\n\n      if (\n        detectImageTransparency(\n          imageData,\n          geometry.attributes.uv.array,\n          geometry.index.array.slice(group.start, group.start + group.count),\n        )\n      ) {\n        map.transparent = true\n      }\n    })\n  }\n}\n\n//\n\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    // combine skeletal and morph animations\n\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks\n\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i])\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127) // x1\n      array.push(interpolation[index + 8] / 127) // x2\n      array.push(interpolation[index + 4] / 127) // y1\n      array.push(interpolation[index + 12] / 127) // y2\n    }\n\n    const tracks = []\n\n    const motions = {}\n    const bones = mesh.skeleton.bones\n    const boneNameDictionary = {}\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true\n    }\n\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i]\n      const boneName = motion.boneName\n\n      if (boneNameDictionary[boneName] === undefined) continue\n\n      motions[boneName] = motions[boneName] || []\n      motions[boneName].push(motion)\n    }\n\n    for (const key in motions) {\n      const array = motions[key]\n\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum\n      })\n\n      const times = []\n      const positions = []\n      const rotations = []\n      const pInterpolations = []\n      const rInterpolations = []\n\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray()\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30\n        const position = array[i].position\n        const rotation = array[i].rotation\n        const interpolation = array[i].interpolation\n\n        times.push(time)\n\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j])\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j])\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j)\n\n        pushInterpolation(rInterpolations, interpolation, 3)\n      }\n\n      const targetName = '.bones[' + key + ']'\n\n      tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations))\n      tracks.push(\n        this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations),\n      )\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = []\n\n    const morphs = {}\n    const morphTargetDictionary = mesh.morphTargetDictionary\n\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i]\n      const morphName = morph.morphName\n\n      if (morphTargetDictionary[morphName] === undefined) continue\n\n      morphs[morphName] = morphs[morphName] || []\n      morphs[morphName].push(morph)\n    }\n\n    for (const key in morphs) {\n      const array = morphs[key]\n\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum\n      })\n\n      const times = []\n      const values = []\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30)\n        values.push(array[i].weight)\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values))\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x)\n      array.push(vec.y)\n      array.push(vec.z)\n    }\n\n    function pushQuaternion(array, q) {\n      array.push(q.x)\n      array.push(q.y)\n      array.push(q.z)\n      array.push(q.w)\n    }\n\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127) // x1\n      array.push(interpolation[index * 4 + 1] / 127) // x2\n      array.push(interpolation[index * 4 + 2] / 127) // y1\n      array.push(interpolation[index * 4 + 3] / 127) // y2\n    }\n\n    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice()\n\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum\n    })\n\n    const times = []\n    const centers = []\n    const quaternions = []\n    const positions = []\n    const fovs = []\n\n    const cInterpolations = []\n    const qInterpolations = []\n    const pInterpolations = []\n    const fInterpolations = []\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n    const position = new Vector3()\n    const center = new Vector3()\n\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i]\n\n      const time = motion.frameNum / 30\n      const pos = motion.position\n      const rot = motion.rotation\n      const distance = motion.distance\n      const fov = motion.fov\n      const interpolation = motion.interpolation\n\n      times.push(time)\n\n      position.set(0, 0, -distance)\n      center.set(pos[0], pos[1], pos[2])\n\n      euler.set(-rot[0], -rot[1], -rot[2])\n      quaternion.setFromEuler(euler)\n\n      position.add(center)\n      position.applyQuaternion(quaternion)\n\n      pushVector3(centers, center)\n      pushQuaternion(quaternions, quaternion)\n      pushVector3(positions, position)\n\n      fovs.push(fov)\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j)\n      }\n\n      pushInterpolation(qInterpolations, interpolation, 3)\n\n      // use the same parameter for x, y, z axis.\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4)\n      }\n\n      pushInterpolation(fInterpolations, interpolation, 5)\n    }\n\n    const tracks = []\n\n    // I expect an object whose name 'target' exists under THREE.Camera\n    tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations))\n\n    tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations))\n    tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations))\n    tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations))\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  // private method\n\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    /*\n     * optimizes here not to let KeyframeTrackPrototype optimize\n     * because KeyframeTrackPrototype optimizes times and values but\n     * doesn't optimize interpolations.\n     */\n    if (times.length > 2) {\n      times = times.slice()\n      values = values.slice()\n      interpolations = interpolations.slice()\n\n      const stride = values.length / times.length\n      const interpolateStride = interpolations.length / times.length\n\n      let index = 1\n\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (\n            values[index * stride + i] !== values[(index - 1) * stride + i] ||\n            values[index * stride + i] !== values[aheadIndex * stride + i]\n          ) {\n            index++\n            break\n          }\n        }\n\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex]\n\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i]\n          }\n\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i]\n          }\n        }\n      }\n\n      times.length = index + 1\n      values.length = (index + 1) * stride\n      interpolations.length = (index + 1) * interpolateStride\n    }\n\n    const track = new typedKeyframeTrack(node, times, values)\n\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(\n        this.times,\n        this.values,\n        this.getValueSize(),\n        result,\n        new Float32Array(interpolations),\n      )\n    }\n\n    return track\n  }\n}\n\n// interpolation\n\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n\n    this.interpolationParams = params\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n    const params = this.interpolationParams\n\n    const offset1 = i1 * stride\n    const offset0 = offset1 - stride\n\n    // No interpolation if next key frame is in one frame in 30fps.\n    // This is from MMD animation spec.\n    // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n    const weight1 = t1 - t0 < (1 / 30) * 1.5 ? 0.0 : (t - t0) / (t1 - t0)\n\n    if (stride === 4) {\n      // Quaternion\n\n      const x1 = params[i1 * 4 + 0]\n      const x2 = params[i1 * 4 + 1]\n      const y1 = params[i1 * 4 + 2]\n      const y2 = params[i1 * 4 + 3]\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio)\n    } else if (stride === 3) {\n      // Vector3\n\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0]\n        const x2 = params[i1 * 12 + i * 4 + 1]\n        const y1 = params[i1 * 12 + i * 4 + 2]\n        const y2 = params[i1 * 12 + i * 4 + 3]\n\n        const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio\n      }\n    } else {\n      // Number\n\n      const x1 = params[i1 * 4 + 0]\n      const x2 = params[i1 * 4 + 1]\n      const y1 = params[i1 * 4 + 2]\n      const y2 = params[i1 * 4 + 3]\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio\n    }\n\n    return result\n  }\n\n  _calculate(x1, x2, y1, y2, x) {\n    /*\n     * Cubic Bezier curves\n     *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n     *\n     * B(t) = ( 1 - t ) ^ 3 * P0\n     *      + 3 * ( 1 - t ) ^ 2 * t * P1\n     *      + 3 * ( 1 - t ) * t^2 * P2\n     *      + t ^ 3 * P3\n     *      ( 0 <= t <= 1 )\n     *\n     * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n     *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n     *\n     *    x = ( 1 - t ) ^ 3 * x0\n     *      + 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 * x3\n     *    y = ( 1 - t ) ^ 3 * y0\n     *      + 3 * ( 1 - t ) ^ 2 * t * y1\n     *      + 3 * ( 1 - t ) * t^2 * y2\n     *      + t ^ 3 * y3\n     *      ( x0 = 0, y0 = 0 )\n     *      ( x3 = 1, y3 = 1 )\n     *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n     *\n     * Here solves this equation with Bisection method,\n     *   https://en.wikipedia.org/wiki/Bisection_method\n     * gets t, and then calculate y.\n     *\n     * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 - x = 0\n     *\n     * (Another option: Newton's method\n     *    https://en.wikipedia.org/wiki/Newton%27s_method)\n     */\n\n    let c = 0.5\n    let t = c\n    let s = 1.0 - t\n    const loop = 15\n    const eps = 1e-5\n    const math = Math\n\n    let sst3, stt3, ttt\n\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3.0 * s * s * t\n      stt3 = 3.0 * s * t * t\n      ttt = t * t * t\n\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x\n\n      if (math.abs(ft) < eps) break\n\n      c /= 2.0\n\n      t += ft < 0 ? c : -c\n      s = 1.0 - t\n    }\n\n    return sst3 * y1 + stt3 * y2 + ttt\n  }\n}\n\nexport { MMDLoader }\n"],"names":["materials"],"mappings":"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"}},
    {"offset": {"line": 26605, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/KTXLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/KTXLoader.js"],"sourcesContent":["import { CompressedTextureLoader } from 'three'\n\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nclass KTXLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer, loadMipmaps) {\n    const ktx = new KhronosTextureContainer(buffer, 1)\n\n    return {\n      mipmaps: ktx.mipmaps(loadMipmaps),\n      width: ktx.pixelWidth,\n      height: ktx.pixelHeight,\n      format: ktx.glInternalFormat,\n      isCubemap: ktx.numberOfFaces === 6,\n      mipmapCount: ktx.numberOfMipmapLevels,\n    }\n  }\n}\n\nconst HEADER_LEN = 12 + 13 * 4 // identifier + header elements (not including key value meta-data pairs)\n// load types\nconst COMPRESSED_2D = 0 // uses a gl.compressedTexImage2D()\n//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n//const TEX_2D = 2; // uses a gl.texImage2D()\n//const TEX_3D = 3; // uses a gl.texImage3D()\n\nclass KhronosTextureContainer {\n  /**\n   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n   */\n  constructor(arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */) {\n    this.arrayBuffer = arrayBuffer\n\n    // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n    // '', 'K', 'T', 'X', ' ', '1', '1', '', '\\r', '\\n', '\\x1A', '\\n'\n    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n    const identifier = new Uint8Array(this.arrayBuffer, 0, 12)\n    if (\n      identifier[0] !== 0xab ||\n      identifier[1] !== 0x4b ||\n      identifier[2] !== 0x54 ||\n      identifier[3] !== 0x58 ||\n      identifier[4] !== 0x20 ||\n      identifier[5] !== 0x31 ||\n      identifier[6] !== 0x31 ||\n      identifier[7] !== 0xbb ||\n      identifier[8] !== 0x0d ||\n      identifier[9] !== 0x0a ||\n      identifier[10] !== 0x1a ||\n      identifier[11] !== 0x0a\n    ) {\n      console.error('texture missing KTX identifier')\n      return\n    }\n\n    // load the reset of the header in native 32 bit uint\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT\n    const headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize)\n    const endianness = headerDataView.getUint32(0, true)\n    const littleEndian = endianness === 0x04030201\n\n    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian) // must be 0 for compressed textures\n    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian) // must be 1 for compressed textures\n    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian) // must be 0 for compressed textures\n    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian) // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian) // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian) // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian) // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian) // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian) // used for texture arrays\n    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian) // used for cubemap textures, should either be 1 or 6\n    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian) // number of levels; disregard possibility of 0 for compressed textures\n    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian) // the amount of space after the header for meta-data\n\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n    if (this.glType !== 0) {\n      console.warn('only compressed formats currently supported')\n      return\n    } else {\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels)\n    }\n\n    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n      console.warn('only 2D textures currently supported')\n      return\n    }\n\n    if (this.numberOfArrayElements !== 0) {\n      console.warn('texture arrays not currently supported')\n      return\n    }\n\n    if (this.numberOfFaces !== facesExpected) {\n      console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces)\n      return\n    }\n\n    // we now have a completely validated file, so could use existence of loadType as success\n    // would need to make this more elaborate & adjust checks above to support more than one load type\n    this.loadType = COMPRESSED_2D\n  }\n\n  mipmaps(loadMipmaps) {\n    const mipmaps = []\n\n    // initialize width & height for level 1\n    let dataOffset = HEADER_LEN + this.bytesOfKeyValueData\n    let width = this.pixelWidth\n    let height = this.pixelHeight\n    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1\n\n    for (let level = 0; level < mipmapCount; level++) {\n      const imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0] // size per face, since not supporting array cubemaps\n      dataOffset += 4 // size of the image + 4 for the imageSize field\n\n      for (let face = 0; face < this.numberOfFaces; face++) {\n        const byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize)\n\n        mipmaps.push({ data: byteArray, width: width, height: height })\n\n        dataOffset += imageSize\n        dataOffset += 3 - ((imageSize + 3) % 4) // add padding for odd sized image\n      }\n\n      width = Math.max(1.0, width * 0.5)\n      height = Math.max(1.0, height * 0.5)\n    }\n\n    return mipmaps\n  }\n}\n\nexport { KTXLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 26709, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/TiltLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/TiltLoader.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  DoubleSide,\n  FileLoader,\n  Group,\n  Loader,\n  Mesh,\n  MeshBasicMaterial,\n  RawShaderMaterial,\n  TextureLoader,\n  Quaternion,\n  Vector3,\n} from 'three'\nimport { unzipSync, strFromU8 } from 'fflate'\n\nclass TiltLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(buffer) {\n    const group = new Group()\n    // https://docs.google.com/document/d/11ZsHozYn9FnWG7y3s3WAyKIACfbfwb4PbaS8cZ_xjvo/edit#\n\n    const zip = unzipSync(new Uint8Array(buffer.slice(16)))\n\n    /*\n\t\tconst thumbnail = zip[ 'thumbnail.png' ].buffer;\n\t\tconst img = document.createElement( 'img' );\n\t\timg.src = URL.createObjectURL( new Blob( [ thumbnail ] ) );\n\t\tdocument.body.appendChild( img );\n\t\t*/\n\n    const metadata = JSON.parse(strFromU8(zip['metadata.json']))\n\n    /*\n\t\tconst blob = new Blob( [ zip[ 'data.sketch' ].buffer ], { type: 'application/octet-stream' } );\n\t\twindow.open( URL.createObjectURL( blob ) );\n\t\t*/\n\n    const data = new DataView(zip['data.sketch'].buffer)\n\n    const num_strokes = data.getInt32(16, true)\n\n    const brushes = {}\n\n    let offset = 20\n\n    for (let i = 0; i < num_strokes; i++) {\n      const brush_index = data.getInt32(offset, true)\n\n      const brush_color = [\n        data.getFloat32(offset + 4, true),\n        data.getFloat32(offset + 8, true),\n        data.getFloat32(offset + 12, true),\n        data.getFloat32(offset + 16, true),\n      ]\n      const brush_size = data.getFloat32(offset + 20, true)\n      const stroke_mask = data.getUint32(offset + 24, true)\n      const controlpoint_mask = data.getUint32(offset + 28, true)\n\n      let offset_stroke_mask = 0\n      let offset_controlpoint_mask = 0\n\n      for (let j = 0; j < 4; j++) {\n        // TOFIX: I don't understand these masks yet\n\n        const byte = 1 << j\n        if ((stroke_mask & byte) > 0) offset_stroke_mask += 4\n        if ((controlpoint_mask & byte) > 0) offset_controlpoint_mask += 4\n      }\n\n      // console.log( { brush_index, brush_color, brush_size, stroke_mask, controlpoint_mask } );\n      // console.log( offset_stroke_mask, offset_controlpoint_mask );\n\n      offset = offset + 28 + offset_stroke_mask + 4 // TOFIX: This is wrong\n\n      const num_control_points = data.getInt32(offset, true)\n\n      // console.log( { num_control_points } );\n\n      const positions = new Float32Array(num_control_points * 3)\n      const quaternions = new Float32Array(num_control_points * 4)\n\n      offset = offset + 4\n\n      for (let j = 0, k = 0; j < positions.length; j += 3, k += 4) {\n        positions[j + 0] = data.getFloat32(offset + 0, true)\n        positions[j + 1] = data.getFloat32(offset + 4, true)\n        positions[j + 2] = data.getFloat32(offset + 8, true)\n\n        quaternions[k + 0] = data.getFloat32(offset + 12, true)\n        quaternions[k + 1] = data.getFloat32(offset + 16, true)\n        quaternions[k + 2] = data.getFloat32(offset + 20, true)\n        quaternions[k + 3] = data.getFloat32(offset + 24, true)\n\n        offset = offset + 28 + offset_controlpoint_mask // TOFIX: This is wrong\n      }\n\n      if (brush_index in brushes === false) {\n        brushes[brush_index] = []\n      }\n\n      brushes[brush_index].push([positions, quaternions, brush_size, brush_color])\n    }\n\n    for (const brush_index in brushes) {\n      const geometry = new StrokeGeometry(brushes[brush_index])\n      const material = getMaterial(metadata.BrushIndex[brush_index])\n\n      group.add(new Mesh(geometry, material))\n    }\n\n    return group\n  }\n}\n\nclass StrokeGeometry extends BufferGeometry {\n  constructor(strokes) {\n    super()\n\n    const vertices = []\n    const colors = []\n    const uvs = []\n\n    const position = new Vector3()\n    const prevPosition = new Vector3()\n\n    const quaternion = new Quaternion()\n    const prevQuaternion = new Quaternion()\n\n    const vector1 = new Vector3()\n    const vector2 = new Vector3()\n    const vector3 = new Vector3()\n    const vector4 = new Vector3()\n\n    // size = size / 2;\n\n    for (const k in strokes) {\n      const stroke = strokes[k]\n      const positions = stroke[0]\n      const quaternions = stroke[1]\n      const size = stroke[2]\n      const color = stroke[3]\n\n      prevPosition.fromArray(positions, 0)\n      prevQuaternion.fromArray(quaternions, 0)\n\n      for (let i = 3, j = 4, l = positions.length; i < l; i += 3, j += 4) {\n        position.fromArray(positions, i)\n        quaternion.fromArray(quaternions, j)\n\n        vector1.set(-size, 0, 0)\n        vector1.applyQuaternion(quaternion)\n        vector1.add(position)\n\n        vector2.set(size, 0, 0)\n        vector2.applyQuaternion(quaternion)\n        vector2.add(position)\n\n        vector3.set(size, 0, 0)\n        vector3.applyQuaternion(prevQuaternion)\n        vector3.add(prevPosition)\n\n        vector4.set(-size, 0, 0)\n        vector4.applyQuaternion(prevQuaternion)\n        vector4.add(prevPosition)\n\n        vertices.push(vector1.x, vector1.y, -vector1.z)\n        vertices.push(vector2.x, vector2.y, -vector2.z)\n        vertices.push(vector4.x, vector4.y, -vector4.z)\n\n        vertices.push(vector2.x, vector2.y, -vector2.z)\n        vertices.push(vector3.x, vector3.y, -vector3.z)\n        vertices.push(vector4.x, vector4.y, -vector4.z)\n\n        prevPosition.copy(position)\n        prevQuaternion.copy(quaternion)\n\n        colors.push(...color)\n        colors.push(...color)\n        colors.push(...color)\n\n        colors.push(...color)\n        colors.push(...color)\n        colors.push(...color)\n\n        const p1 = i / l\n        const p2 = (i - 3) / l\n\n        uvs.push(p1, 0)\n        uvs.push(p1, 1)\n        uvs.push(p2, 0)\n\n        uvs.push(p1, 1)\n        uvs.push(p2, 1)\n        uvs.push(p2, 0)\n      }\n    }\n\n    this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3))\n    this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 4))\n    this.setAttribute('uv', new BufferAttribute(new Float32Array(uvs), 2))\n  }\n}\n\nconst BRUSH_LIST_ARRAY = {\n  '89d104cd-d012-426b-b5b3-bbaee63ac43c': 'Bubbles',\n  '700f3aa8-9a7c-2384-8b8a-ea028905dd8c': 'CelVinyl',\n  '0f0ff7b2-a677-45eb-a7d6-0cd7206f4816': 'ChromaticWave',\n  '1161af82-50cf-47db-9706-0c3576d43c43': 'CoarseBristles',\n  '79168f10-6961-464a-8be1-57ed364c5600': 'CoarseBristlesSingleSided',\n  '1caa6d7d-f015-3f54-3a4b-8b5354d39f81': 'Comet',\n  'c8313697-2563-47fc-832e-290f4c04b901': 'DiamondHull',\n  '4391aaaa-df73-4396-9e33-31e4e4930b27': 'Disco',\n  'd1d991f2-e7a0-4cf1-b328-f57e915e6260': 'DotMarker',\n  '6a1cf9f9-032c-45ec-9b1d-a6680bee30f7': 'Dots',\n  '0d3889f3-3ede-470c-8af4-f44813306126': 'DoubleTaperedFlat',\n  '0d3889f3-3ede-470c-8af4-de4813306126': 'DoubleTaperedMarker',\n  'd0262945-853c-4481-9cbd-88586bed93cb': 'DuctTape',\n  '3ca16e2f-bdcd-4da2-8631-dcef342f40f1': 'DuctTapeSingleSided',\n  'f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51': 'Electricity',\n  '02ffb866-7fb2-4d15-b761-1012cefb1360': 'Embers',\n  'cb92b597-94ca-4255-b017-0e3f42f12f9e': 'Fire',\n  '2d35bcf0-e4d8-452c-97b1-3311be063130': 'Flat',\n  '55303bc4-c749-4a72-98d9-d23e68e76e18': 'FlatDeprecated',\n  '280c0a7a-aad8-416c-a7d2-df63d129ca70': 'FlatSingleSided',\n  'cf019139-d41c-4eb0-a1d0-5cf54b0a42f3': 'Highlighter',\n  '6a1cf9f9-032c-45ec-9b6e-a6680bee32e9': 'HyperGrid',\n  'dce872c2-7b49-4684-b59b-c45387949c5c': 'Hypercolor',\n  'e8ef32b1-baa8-460a-9c2c-9cf8506794f5': 'HypercolorSingleSided',\n  '2f212815-f4d3-c1a4-681a-feeaf9c6dc37': 'Icing',\n  'f5c336cf-5108-4b40-ade9-c687504385ab': 'Ink',\n  'c0012095-3ffd-4040-8ee1-fc180d346eaa': 'InkSingleSided',\n  '4a76a27a-44d8-4bfe-9a8c-713749a499b0': 'Leaves',\n  'ea19de07-d0c0-4484-9198-18489a3c1487': 'LeavesSingleSided',\n  '2241cd32-8ba2-48a5-9ee7-2caef7e9ed62': 'Light',\n  '4391aaaa-df81-4396-9e33-31e4e4930b27': 'LightWire',\n  'd381e0f5-3def-4a0d-8853-31e9200bcbda': 'Lofted',\n  '429ed64a-4e97-4466-84d3-145a861ef684': 'Marker',\n  '79348357-432d-4746-8e29-0e25c112e3aa': 'MatteHull',\n  'b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6': 'NeonPulse',\n  'f72ec0e7-a844-4e38-82e3-140c44772699': 'OilPaint',\n  'c515dad7-4393-4681-81ad-162ef052241b': 'OilPaintSingleSided',\n  'f1114e2e-eb8d-4fde-915a-6e653b54e9f5': 'Paper',\n  '759f1ebd-20cd-4720-8d41-234e0da63716': 'PaperSingleSided',\n  'e0abbc80-0f80-e854-4970-8924a0863dcc': 'Petal',\n  'c33714d1-b2f9-412e-bd50-1884c9d46336': 'Plasma',\n  'ad1ad437-76e2-450d-a23a-e17f8310b960': 'Rainbow',\n  'faaa4d44-fcfb-4177-96be-753ac0421ba3': 'ShinyHull',\n  '70d79cca-b159-4f35-990c-f02193947fe8': 'Smoke',\n  'd902ed8b-d0d1-476c-a8de-878a79e3a34c': 'Snow',\n  'accb32f5-4509-454f-93f8-1df3fd31df1b': 'SoftHighlighter',\n  'cf7f0059-7aeb-53a4-2b67-c83d863a9ffa': 'Spikes',\n  '8dc4a70c-d558-4efd-a5ed-d4e860f40dc3': 'Splatter',\n  '7a1c8107-50c5-4b70-9a39-421576d6617e': 'SplatterSingleSided',\n  '0eb4db27-3f82-408d-b5a1-19ebd7d5b711': 'Stars',\n  '44bb800a-fbc3-4592-8426-94ecb05ddec3': 'Streamers',\n  '0077f88c-d93a-42f3-b59b-b31c50cdb414': 'Taffy',\n  'b468c1fb-f254-41ed-8ec9-57030bc5660c': 'TaperedFlat',\n  'c8ccb53d-ae13-45ef-8afb-b730d81394eb': 'TaperedFlatSingleSided',\n  'd90c6ad8-af0f-4b54-b422-e0f92abe1b3c': 'TaperedMarker',\n  '1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0': 'TaperedMarker_Flat',\n  '75b32cf0-fdd6-4d89-a64b-e2a00b247b0f': 'ThickPaint',\n  'fdf0326a-c0d1-4fed-b101-9db0ff6d071f': 'ThickPaintSingleSided',\n  '4391385a-df73-4396-9e33-31e4e4930b27': 'Toon',\n  'a8fea537-da7c-4d4b-817f-24f074725d6d': 'UnlitHull',\n  'd229d335-c334-495a-a801-660ac8a87360': 'VelvetInk',\n  '10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab': 'Waveform',\n  'b67c0e81-ce6d-40a8-aeb0-ef036b081aa3': 'WetPaint',\n  'dea67637-cd1a-27e4-c9b1-52f4bbcb84e5': 'WetPaintSingleSided',\n  '5347acf0-a8e2-47b6-8346-30c70719d763': 'WigglyGraphite',\n  'e814fef1-97fd-7194-4a2f-50c2bb918be2': 'WigglyGraphiteSingleSided',\n  '4391385a-cf83-4396-9e33-31e4e4930b27': 'Wire',\n}\n\nconst common = {\n  colors: {\n    BloomColor: `\n\t\t\tvec3 BloomColor(vec3 color, float gain) {\n\t\t\t\t// Guarantee that there's at least a little bit of all 3 channels.\n\t\t\t\t// This makes fully-saturated strokes (which only have 2 non-zero\n\t\t\t\t// color channels) eventually clip to white rather than to a secondary.\n\t\t\t\tfloat cmin = length(color.rgb) * .05;\n\t\t\t\tcolor.rgb = max(color.rgb, vec3(cmin, cmin, cmin));\n\t\t\t\t// If we try to remove this pow() from .a, it brightens up\n\t\t\t\t// pressure-sensitive strokes; looks better as-is.\n\t\t\t\tcolor = pow(color, vec3(2.2));\n\t\t\t\tcolor.rgb *= 2. * exp(gain * 10.);\n\t\t\t\treturn color;\n\t\t\t}\n\t\t`,\n\n    LinearToSrgb: `\n\t\t\tvec3 LinearToSrgb(vec3 color) {\n\t\t\t\t// Approximation http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\n\t\t\t\tvec3 linearColor = color.rgb;\n\t\t\t\tvec3 S1 = sqrt(linearColor);\n\t\t\t\tvec3 S2 = sqrt(S1);\n\t\t\t\tvec3 S3 = sqrt(S2);\n\t\t\t\tcolor.rgb = 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * linearColor;\n\t\t\t\treturn color;\n\t\t\t}\n\t\t`,\n\n    hsv: `\n\t\t\t// uniform sampler2D lookupTex;\n\t\t\tvec4 lookup(vec4 textureColor) {\n\t\t\t\treturn textureColor;\n\t\t\t}\n\n\t\t\tvec3 lookup(vec3 textureColor) {\n\t\t\t\treturn textureColor;\n\t\t\t}\n\n\t\t\tvec3 hsv2rgb( vec3 hsv ) {\n\t\t\t\tvec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\t\t\t\treturn hsv.z * mix( vec3(1.0), rgb, hsv.y);\n\t\t\t}\n\n\t\t\tvec3 rgb2hsv( vec3 rgb ) {\n\t\t\t\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\t\t\t\tvec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n\t\t\t\tvec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n\t\t\t\tfloat d = q.x - min(q.w, q.y);\n\t\t\t\tfloat e = 1.0e-10;\n\n\t\t\t\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n\t\t\t}\n\t\t`,\n\n    SrgbToLinear: `\n\t\t\tvec3 SrgbToLinear(vec3 color) {\n\t\t\t\t// Approximation http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\n\t\t\t\tvec3 sRGB = color.rgb;\n\t\t\t\tcolor.rgb = sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n\t\t\t\treturn color;\n\t\t\t}\n\t\t`,\n  },\n}\n\nconst shaders = () => ({\n  Light: {\n    uniforms: {\n      mainTex: {\n        value: new TextureLoader().setPath('./textures/tiltbrush/').loader.load('Light.webp'),\n      },\n      alphaTest: { value: 0.067 },\n      emission_gain: { value: 0.45 },\n      alpha: { value: 1 },\n    },\n    vertexShader: `\n\t\t\tprecision highp float;\n\t\t\tprecision highp int;\n\n\t\t\tattribute vec2 uv;\n\t\t\tattribute vec4 color;\n\t\t\tattribute vec3 position;\n\n\t\t\tuniform mat4 modelMatrix;\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\t\t\tuniform mat4 viewMatrix;\n\t\t\tuniform mat3 normalMatrix;\n\t\t\tuniform vec3 cameraPosition;\n\n\t\t\tvarying vec2 vUv;\n\t\t\tvarying vec3 vColor;\n\n\t\t\t${common.colors.LinearToSrgb}\n\t\t\t${common.colors.hsv}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tvColor = lookup(color.rgb);\n\n\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t}\n\t\t`,\n    fragmentShader: `\n\t\t\tprecision highp float;\n\t\t\tprecision highp int;\n\n\t\t\tuniform float emission_gain;\n\n\t\t\tuniform sampler2D mainTex;\n\t\t\tuniform float alphaTest;\n\n\t\t\tvarying vec2 vUv;\n\t\t\tvarying vec3 vColor;\n\n\t\t\t${common.colors.BloomColor}\n\t\t\t${common.colors.SrgbToLinear}\n\n\t\t\tvoid main(){\n\t\t\t\tvec4 col = texture2D(mainTex, vUv);\n\t\t\t\tvec3 color = vColor;\n\t\t\t\tcolor = BloomColor(color, emission_gain);\n\t\t\t\tcolor = color * col.rgb;\n\t\t\t\tcolor = color * col.a;\n\t\t\t\tcolor = SrgbToLinear(color);\n\t\t\t\tgl_FragColor = vec4(color, 1.0);\n\t\t\t}\n\t\t`,\n    side: 2,\n    transparent: true,\n    depthFunc: 2,\n    depthWrite: true,\n    depthTest: false,\n    blending: 5,\n    blendDst: 201,\n    blendDstAlpha: 201,\n    blendEquation: 100,\n    blendEquationAlpha: 100,\n    blendSrc: 201,\n    blendSrcAlpha: 201,\n  },\n})\n\nfunction getMaterial(GUID) {\n  const name = BRUSH_LIST_ARRAY[GUID]\n\n  switch (name) {\n    case 'Light':\n      return new RawShaderMaterial(shaders().Light)\n\n    default:\n      return new MeshBasicMaterial({ vertexColors: true, side: DoubleSide })\n  }\n}\n\nexport { TiltLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 27100, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/DRACOLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/DRACOLoader.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n"],"names":["worker"],"mappings":"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"}},
    {"offset": {"line": 27466, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/HDRCubeTextureLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/HDRCubeTextureLoader.js"],"sourcesContent":["import { CubeTexture, DataTexture, FileLoader, FloatType, HalfFloatType, LinearFilter, Loader } from 'three'\nimport { RGBELoader } from '../loaders/RGBELoader.js'\n\nclass HDRCubeTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.hdrLoader = new RGBELoader()\n    this.type = HalfFloatType\n  }\n\n  load(urls, onLoad, onProgress, onError) {\n    if (typeof urls === 'string') {\n      urls = [urls]\n    } else if (!Array.isArray(urls)) {\n      console.warn('THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead.')\n\n      this.setDataType(urls)\n\n      urls = onLoad\n      onLoad = onProgress\n      onProgress = onError\n      onError = arguments[4]\n    }\n\n    const texture = new CubeTexture()\n\n    texture.type = this.type\n\n    switch (texture.type) {\n      case FloatType:\n      case HalfFloatType:\n        if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n        else texture.encoding = 3000 // LinearEncoding\n        texture.minFilter = LinearFilter\n        texture.magFilter = LinearFilter\n        texture.generateMipmaps = false\n        break\n    }\n\n    const scope = this\n\n    let loaded = 0\n\n    function loadHDRData(i, onLoad, onProgress, onError) {\n      new FileLoader(scope.manager)\n        .setPath(scope.path)\n        .setResponseType('arraybuffer')\n        .setWithCredentials(scope.withCredentials)\n        .load(\n          urls[i],\n          function (buffer) {\n            loaded++\n\n            const texData = scope.hdrLoader.parse(buffer)\n\n            if (!texData) return\n\n            if (texData.data !== undefined) {\n              const dataTexture = new DataTexture(texData.data, texData.width, texData.height)\n\n              dataTexture.type = texture.type\n              if ('colorSpace' in dataTexture) dataTexture.colorSpace = texture.SRGBColorSpace\n              else dataTexture.encoding = texture.encoding\n              dataTexture.format = texture.format\n              dataTexture.minFilter = texture.minFilter\n              dataTexture.magFilter = texture.magFilter\n              dataTexture.generateMipmaps = texture.generateMipmaps\n\n              texture.images[i] = dataTexture\n            }\n\n            if (loaded === 6) {\n              texture.needsUpdate = true\n              if (onLoad) onLoad(texture)\n            }\n          },\n          onProgress,\n          onError,\n        )\n    }\n\n    for (let i = 0; i < urls.length; i++) {\n      loadHDRData(i, onLoad, onProgress, onError)\n    }\n\n    return texture\n  }\n\n  setDataType(value) {\n    this.type = value\n    this.hdrLoader.setDataType(value)\n\n    return this\n  }\n}\n\nexport { HDRCubeTextureLoader }\n"],"names":["onLoad","onProgress","onError"],"mappings":";;;;;;;;AAGA,MAAM,6BAA6B,yJAAA,CAAO;IACxC,YAAY,OAAA,CAAS;QACnB,KAAA,CAAM,OAAO;QAEb,IAAA,CAAK,SAAA,GAAY,IAAI,sKAAA,CAAY;QACjC,IAAA,CAAK,IAAA,GAAO,gKAAA;IACb;IAED,KAAK,IAAA,EAAM,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACtC,IAAI,OAAO,SAAS,UAAU;YAC5B,OAAO;gBAAC,IAAI;aAAA;QACb,OAAA,IAAU,CAAC,MAAM,OAAA,CAAQ,IAAI,GAAG;YAC/B,QAAQ,IAAA,CAAK,+EAA+E;YAE5F,IAAA,CAAK,WAAA,CAAY,IAAI;YAErB,OAAO;YACP,SAAS;YACT,aAAa;YACb,UAAU,SAAA,CAAU,CAAC,CAAA;QACtB;QAED,MAAM,UAAU,IAAI,8JAAA,CAAa;QAEjC,QAAQ,IAAA,GAAO,IAAA,CAAK,IAAA;QAEpB,OAAQ,QAAQ,IAAA,EAAI;YAClB,KAAK,4JAAA;YACL,KAAK,gKAAA;gBACH,IAAI,gBAAgB,SAAS,QAAQ,UAAA,GAAa;qBAC7C,QAAQ,QAAA,GAAW;gBACxB,QAAQ,SAAA,GAAY,+JAAA;gBACpB,QAAQ,SAAA,GAAY,+JAAA;gBACpB,QAAQ,eAAA,GAAkB;gBAC1B;QACH;QAED,MAAM,QAAQ,IAAA;QAEd,IAAI,SAAS;QAEb,SAAS,YAAY,CAAA,EAAGA,OAAAA,EAAQC,WAAAA,EAAYC,QAAAA,EAAS;YACnD,IAAI,6JAAA,CAAW,MAAM,OAAO,EACzB,OAAA,CAAQ,MAAM,IAAI,EAClB,eAAA,CAAgB,aAAa,EAC7B,kBAAA,CAAmB,MAAM,eAAe,EACxC,IAAA,CACC,IAAA,CAAK,CAAC,CAAA,EACN,SAAU,MAAA,EAAQ;gBAChB;gBAEA,MAAM,UAAU,MAAM,SAAA,CAAU,KAAA,CAAM,MAAM;gBAE5C,IAAI,CAAC,SAAS;gBAEd,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW;oBAC9B,MAAM,cAAc,IAAI,8JAAA,CAAY,QAAQ,IAAA,EAAM,QAAQ,KAAA,EAAO,QAAQ,MAAM;oBAE/E,YAAY,IAAA,GAAO,QAAQ,IAAA;oBAC3B,IAAI,gBAAgB,aAAa,YAAY,UAAA,GAAa,QAAQ,cAAA;yBAC7D,YAAY,QAAA,GAAW,QAAQ,QAAA;oBACpC,YAAY,MAAA,GAAS,QAAQ,MAAA;oBAC7B,YAAY,SAAA,GAAY,QAAQ,SAAA;oBAChC,YAAY,SAAA,GAAY,QAAQ,SAAA;oBAChC,YAAY,eAAA,GAAkB,QAAQ,eAAA;oBAEtC,QAAQ,MAAA,CAAO,CAAC,CAAA,GAAI;gBACrB;gBAED,IAAI,WAAW,GAAG;oBAChB,QAAQ,WAAA,GAAc;oBACtB,IAAIF,SAAQA,QAAO,OAAO;gBAC3B;YACF,GACDC,aACAC;QAEL;QAED,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,MAAA,EAAQ,IAAK;YACpC,YAAY,GAAG,QAAQ,YAAY,OAAO;QAC3C;QAED,OAAO;IACR;IAED,YAAY,KAAA,EAAO;QACjB,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,SAAA,CAAU,WAAA,CAAY,KAAK;QAEhC,OAAO,IAAA;IACR;AACH"}},
    {"offset": {"line": 27546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/PDBLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/PDBLoader.js"],"sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader } from 'three'\n\nclass PDBLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  // Based on CanvasMol PDB parser\n\n  parse(text) {\n    function trim(text) {\n      return text.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '')\n    }\n\n    function capitalize(text) {\n      return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase()\n    }\n\n    function hash(s, e) {\n      return 's' + Math.min(s, e) + 'e' + Math.max(s, e)\n    }\n\n    function parseBond(start, length, satom, i) {\n      const eatom = parseInt(lines[i].substr(start, length))\n\n      if (eatom) {\n        const h = hash(satom, eatom)\n\n        if (_bhash[h] === undefined) {\n          _bonds.push([satom - 1, eatom - 1, 1])\n          _bhash[h] = _bonds.length - 1\n        } else {\n          // doesn't really work as almost all PDBs\n          // have just normal bonds appearing multiple\n          // times instead of being double/triple bonds\n          // bonds[bhash[h]][2] += 1;\n        }\n      }\n    }\n\n    function buildGeometry() {\n      const build = {\n        geometryAtoms: new BufferGeometry(),\n        geometryBonds: new BufferGeometry(),\n        json: {\n          atoms: atoms,\n        },\n      }\n\n      const geometryAtoms = build.geometryAtoms\n      const geometryBonds = build.geometryBonds\n\n      const verticesAtoms = []\n      const colorsAtoms = []\n      const verticesBonds = []\n\n      // atoms\n\n      for (let i = 0, l = atoms.length; i < l; i++) {\n        const atom = atoms[i]\n\n        const x = atom[0]\n        const y = atom[1]\n        const z = atom[2]\n\n        verticesAtoms.push(x, y, z)\n\n        const r = atom[3][0] / 255\n        const g = atom[3][1] / 255\n        const b = atom[3][2] / 255\n\n        colorsAtoms.push(r, g, b)\n      }\n\n      // bonds\n\n      for (let i = 0, l = _bonds.length; i < l; i++) {\n        const bond = _bonds[i]\n\n        const start = bond[0]\n        const end = bond[1]\n\n        const startAtom = _atomMap[start]\n        const endAtom = _atomMap[end]\n\n        let x = startAtom[0]\n        let y = startAtom[1]\n        let z = startAtom[2]\n\n        verticesBonds.push(x, y, z)\n\n        x = endAtom[0]\n        y = endAtom[1]\n        z = endAtom[2]\n\n        verticesBonds.push(x, y, z)\n      }\n\n      // build geometry\n\n      geometryAtoms.setAttribute('position', new Float32BufferAttribute(verticesAtoms, 3))\n      geometryAtoms.setAttribute('color', new Float32BufferAttribute(colorsAtoms, 3))\n\n      geometryBonds.setAttribute('position', new Float32BufferAttribute(verticesBonds, 3))\n\n      return build\n    }\n\n    const CPK = {\n      h: [255, 255, 255],\n      he: [217, 255, 255],\n      li: [204, 128, 255],\n      be: [194, 255, 0],\n      b: [255, 181, 181],\n      c: [144, 144, 144],\n      n: [48, 80, 248],\n      o: [255, 13, 13],\n      f: [144, 224, 80],\n      ne: [179, 227, 245],\n      na: [171, 92, 242],\n      mg: [138, 255, 0],\n      al: [191, 166, 166],\n      si: [240, 200, 160],\n      p: [255, 128, 0],\n      s: [255, 255, 48],\n      cl: [31, 240, 31],\n      ar: [128, 209, 227],\n      k: [143, 64, 212],\n      ca: [61, 255, 0],\n      sc: [230, 230, 230],\n      ti: [191, 194, 199],\n      v: [166, 166, 171],\n      cr: [138, 153, 199],\n      mn: [156, 122, 199],\n      fe: [224, 102, 51],\n      co: [240, 144, 160],\n      ni: [80, 208, 80],\n      cu: [200, 128, 51],\n      zn: [125, 128, 176],\n      ga: [194, 143, 143],\n      ge: [102, 143, 143],\n      as: [189, 128, 227],\n      se: [255, 161, 0],\n      br: [166, 41, 41],\n      kr: [92, 184, 209],\n      rb: [112, 46, 176],\n      sr: [0, 255, 0],\n      y: [148, 255, 255],\n      zr: [148, 224, 224],\n      nb: [115, 194, 201],\n      mo: [84, 181, 181],\n      tc: [59, 158, 158],\n      ru: [36, 143, 143],\n      rh: [10, 125, 140],\n      pd: [0, 105, 133],\n      ag: [192, 192, 192],\n      cd: [255, 217, 143],\n      in: [166, 117, 115],\n      sn: [102, 128, 128],\n      sb: [158, 99, 181],\n      te: [212, 122, 0],\n      i: [148, 0, 148],\n      xe: [66, 158, 176],\n      cs: [87, 23, 143],\n      ba: [0, 201, 0],\n      la: [112, 212, 255],\n      ce: [255, 255, 199],\n      pr: [217, 255, 199],\n      nd: [199, 255, 199],\n      pm: [163, 255, 199],\n      sm: [143, 255, 199],\n      eu: [97, 255, 199],\n      gd: [69, 255, 199],\n      tb: [48, 255, 199],\n      dy: [31, 255, 199],\n      ho: [0, 255, 156],\n      er: [0, 230, 117],\n      tm: [0, 212, 82],\n      yb: [0, 191, 56],\n      lu: [0, 171, 36],\n      hf: [77, 194, 255],\n      ta: [77, 166, 255],\n      w: [33, 148, 214],\n      re: [38, 125, 171],\n      os: [38, 102, 150],\n      ir: [23, 84, 135],\n      pt: [208, 208, 224],\n      au: [255, 209, 35],\n      hg: [184, 184, 208],\n      tl: [166, 84, 77],\n      pb: [87, 89, 97],\n      bi: [158, 79, 181],\n      po: [171, 92, 0],\n      at: [117, 79, 69],\n      rn: [66, 130, 150],\n      fr: [66, 0, 102],\n      ra: [0, 125, 0],\n      ac: [112, 171, 250],\n      th: [0, 186, 255],\n      pa: [0, 161, 255],\n      u: [0, 143, 255],\n      np: [0, 128, 255],\n      pu: [0, 107, 255],\n      am: [84, 92, 242],\n      cm: [120, 92, 227],\n      bk: [138, 79, 227],\n      cf: [161, 54, 212],\n      es: [179, 31, 212],\n      fm: [179, 31, 186],\n      md: [179, 13, 166],\n      no: [189, 13, 135],\n      lr: [199, 0, 102],\n      rf: [204, 0, 89],\n      db: [209, 0, 79],\n      sg: [217, 0, 69],\n      bh: [224, 0, 56],\n      hs: [230, 0, 46],\n      mt: [235, 0, 38],\n      ds: [235, 0, 38],\n      rg: [235, 0, 38],\n      cn: [235, 0, 38],\n      uut: [235, 0, 38],\n      uuq: [235, 0, 38],\n      uup: [235, 0, 38],\n      uuh: [235, 0, 38],\n      uus: [235, 0, 38],\n      uuo: [235, 0, 38],\n    }\n\n    const atoms = []\n\n    const _bonds = []\n    const _bhash = {}\n    const _atomMap = {}\n\n    // parse\n\n    const lines = text.split('\\n')\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      if (lines[i].substr(0, 4) === 'ATOM' || lines[i].substr(0, 6) === 'HETATM') {\n        const x = parseFloat(lines[i].substr(30, 7))\n        const y = parseFloat(lines[i].substr(38, 7))\n        const z = parseFloat(lines[i].substr(46, 7))\n        const index = parseInt(lines[i].substr(6, 5)) - 1\n\n        let e = trim(lines[i].substr(76, 2)).toLowerCase()\n\n        if (e === '') {\n          e = trim(lines[i].substr(12, 2)).toLowerCase()\n        }\n\n        const atomData = [x, y, z, CPK[e], capitalize(e)]\n\n        atoms.push(atomData)\n        _atomMap[index] = atomData\n      } else if (lines[i].substr(0, 6) === 'CONECT') {\n        const satom = parseInt(lines[i].substr(6, 5))\n\n        parseBond(11, 5, satom, i)\n        parseBond(16, 5, satom, i)\n        parseBond(21, 5, satom, i)\n        parseBond(26, 5, satom, i)\n      }\n    }\n\n    // build and return geometry\n\n    return buildGeometry()\n  }\n}\n\nexport { PDBLoader }\n"],"names":["text"],"mappings":"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"}},
    {"offset": {"line": 28277, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/PRWMLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/PRWMLoader.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\n/**\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nlet bigEndianPlatform = null\n\n/**\n * Check if the endianness of the platform is big-endian (most significant bit first)\n * @returns {boolean} True if big-endian, false if little-endian\n */\nfunction isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    const buffer = new ArrayBuffer(2),\n      uint8Array = new Uint8Array(buffer),\n      uint16Array = new Uint16Array(buffer)\n\n    uint8Array[0] = 0xaa // set first byte\n    uint8Array[1] = 0xbb // set second byte\n    bigEndianPlatform = uint16Array[0] === 0xaabb\n  }\n\n  return bigEndianPlatform\n}\n\n// match the values defined in the spec to the TypedArray types\nconst InvertedEncodingTypes = [\n  null,\n  Float32Array,\n  null,\n  Int8Array,\n  Int16Array,\n  null,\n  Int32Array,\n  Uint8Array,\n  Uint16Array,\n  null,\n  Uint32Array,\n]\n\n// define the method to use on a DataView, corresponding the TypedArray type\nconst getMethods = {\n  Uint16Array: 'getUint16',\n  Uint32Array: 'getUint32',\n  Int16Array: 'getInt16',\n  Int32Array: 'getInt32',\n  Float32Array: 'getFloat32',\n  Float64Array: 'getFloat64',\n}\n\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT\n  let result\n\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length)\n  } else {\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n      getMethod = getMethods[viewType.name],\n      littleEndian = !fromBigEndian\n\n    result = new viewType(length)\n\n    for (let i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian)\n    }\n  }\n\n  return result\n}\n\nfunction decodePrwm(buffer) {\n  const array = new Uint8Array(buffer),\n    version = array[0]\n\n  let flags = array[1]\n\n  const indexedGeometry = !!((flags >> 7) & 0x01),\n    indicesType = (flags >> 6) & 0x01,\n    bigEndian = ((flags >> 5) & 0x01) === 1,\n    attributesNumber = flags & 0x1f\n\n  let valuesNumber = 0,\n    indicesNumber = 0\n\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4]\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7]\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16)\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16)\n  }\n\n  /** PRELIMINARY CHECKS **/\n\n  if (version === 0) {\n    throw new Error('PRWM decoder: Invalid format version: 0')\n  } else if (version !== 1) {\n    throw new Error('PRWM decoder: Unsupported format version: ' + version)\n  }\n\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries')\n    } else if (indicesNumber !== 0) {\n      throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries')\n    }\n  }\n\n  /** PARSING **/\n\n  let pos = 8\n\n  const attributes = {}\n\n  for (let i = 0; i < attributesNumber; i++) {\n    let attributeName = ''\n\n    while (pos < array.length) {\n      const char = array[pos]\n      pos++\n\n      if (char === 0) {\n        break\n      } else {\n        attributeName += String.fromCharCode(char)\n      }\n    }\n\n    flags = array[pos]\n\n    const attributeType = (flags >> 7) & 0x01\n    const cardinality = ((flags >> 4) & 0x03) + 1\n    const encodingType = flags & 0x0f\n    const arrayType = InvertedEncodingTypes[encodingType]\n\n    pos++\n\n    // padding to next multiple of 4\n    pos = Math.ceil(pos / 4) * 4\n\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian)\n\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber\n\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality: cardinality,\n      values: values,\n    }\n  }\n\n  pos = Math.ceil(pos / 4) * 4\n\n  let indices = null\n\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian)\n  }\n\n  return {\n    version: version,\n    attributes: attributes,\n    indices: indices,\n  }\n}\n\n// Define the public interface\n\nconst PRWMLoader = /* @__PURE__ */ (() => {\n  class PRWMLoader extends Loader {\n    constructor(manager) {\n      super(manager)\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      const scope = this\n\n      const loader = new FileLoader(scope.manager)\n      loader.setPath(scope.path)\n      loader.setResponseType('arraybuffer')\n      loader.setRequestHeader(scope.requestHeader)\n      loader.setWithCredentials(scope.withCredentials)\n\n      url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le')\n\n      loader.load(\n        url,\n        function (arrayBuffer) {\n          try {\n            onLoad(scope.parse(arrayBuffer))\n          } catch (e) {\n            if (onError) {\n              onError(e)\n            } else {\n              console.error(e)\n            }\n\n            scope.manager.itemError(url)\n          }\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    parse(arrayBuffer) {\n      const data = decodePrwm(arrayBuffer),\n        attributesKey = Object.keys(data.attributes),\n        bufferGeometry = new BufferGeometry()\n\n      for (let i = 0; i < attributesKey.length; i++) {\n        const attribute = data.attributes[attributesKey[i]]\n        bufferGeometry.setAttribute(\n          attributesKey[i],\n          new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized),\n        )\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1))\n      }\n\n      return bufferGeometry\n    }\n\n    static isBigEndianPlatform() {\n      return isBigEndianPlatform()\n    }\n  }\n\n  return PRWMLoader\n})()\n\nexport { PRWMLoader }\n"],"names":["PRWMLoader"],"mappings":"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"}},
    {"offset": {"line": 28440, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/RGBMLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/RGBMLoader.js"],"sourcesContent":["import { DataTextureLoader, RGBAFormat, LinearFilter, CubeTexture, HalfFloatType, DataUtils } from 'three'\n\nlet UPNG\n\nfunction init() {\n  if (UPNG) return UPNG\n  // from https://github.com/photopea/UPNG.js (MIT License)\n\n  UPNG = {}\n\n  UPNG.toRGBA8 = function (out) {\n    var w = out.width,\n      h = out.height\n    if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer]\n\n    var frms = []\n    if (out.frames[0].data == null) out.frames[0].data = out.data\n\n    var len = w * h * 4,\n      img = new Uint8Array(len),\n      empty = new Uint8Array(len),\n      prev = new Uint8Array(len)\n    for (var i = 0; i < out.frames.length; i++) {\n      var frm = out.frames[i]\n      var fx = frm.rect.x,\n        fy = frm.rect.y,\n        fw = frm.rect.width,\n        fh = frm.rect.height\n      var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out)\n\n      if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j]\n\n      if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0)\n      else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1)\n\n      frms.push(img.buffer.slice(0))\n\n      if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0)\n      else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j]\n    }\n\n    return frms\n  }\n\n  UPNG.toRGBA8.decodeImage = function (data, w, h, out) {\n    var area = w * h,\n      bpp = UPNG.decode._getBPP(out)\n    var bpl = Math.ceil((w * bpp) / 8) // bytes per line\n\n    var bf = new Uint8Array(area * 4),\n      bf32 = new Uint32Array(bf.buffer)\n    var ctype = out.ctype,\n      depth = out.depth\n    var rs = UPNG._bin.readUshort\n\n    if (ctype == 6) {\n      // RGB + alpha\n\n      var qarea = area << 2\n      if (depth == 8) {\n        for (var i = 0; i < qarea; i += 4) {\n          bf[i] = data[i]\n          bf[i + 1] = data[i + 1]\n          bf[i + 2] = data[i + 2]\n          bf[i + 3] = data[i + 3]\n        }\n      }\n\n      if (depth == 16) {\n        for (var i = 0; i < qarea; i++) {\n          bf[i] = data[i << 1]\n        }\n      }\n    } else if (ctype == 2) {\n      // RGB\n\n      var ts = out.tabs['tRNS']\n      if (ts == null) {\n        if (depth == 8) {\n          for (var i = 0; i < area; i++) {\n            var ti = i * 3\n            bf32[i] = (255 << 24) | (data[ti + 2] << 16) | (data[ti + 1] << 8) | data[ti]\n          }\n        }\n\n        if (depth == 16) {\n          for (var i = 0; i < area; i++) {\n            var ti = i * 6\n            bf32[i] = (255 << 24) | (data[ti + 4] << 16) | (data[ti + 2] << 8) | data[ti]\n          }\n        }\n      } else {\n        var tr = ts[0],\n          tg = ts[1],\n          tb = ts[2]\n        if (depth == 8) {\n          for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 3\n            bf32[i] = (255 << 24) | (data[ti + 2] << 16) | (data[ti + 1] << 8) | data[ti]\n            if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0\n          }\n        }\n\n        if (depth == 16) {\n          for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 6\n            bf32[i] = (255 << 24) | (data[ti + 4] << 16) | (data[ti + 2] << 8) | data[ti]\n            if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0\n          }\n        }\n      }\n    } else if (ctype == 3) {\n      // palette\n\n      var p = out.tabs['PLTE'],\n        ap = out.tabs['tRNS'],\n        tl = ap ? ap.length : 0\n      //console.log(p, ap);\n      if (depth == 1) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl,\n            t0 = y * w\n          for (var i = 0; i < w; i++) {\n            var qi = (t0 + i) << 2,\n              j = (data[s0 + (i >> 3)] >> (7 - ((i & 7) << 0))) & 1,\n              cj = 3 * j\n            bf[qi] = p[cj]\n            bf[qi + 1] = p[cj + 1]\n            bf[qi + 2] = p[cj + 2]\n            bf[qi + 3] = j < tl ? ap[j] : 255\n          }\n        }\n      }\n\n      if (depth == 2) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl,\n            t0 = y * w\n          for (var i = 0; i < w; i++) {\n            var qi = (t0 + i) << 2,\n              j = (data[s0 + (i >> 2)] >> (6 - ((i & 3) << 1))) & 3,\n              cj = 3 * j\n            bf[qi] = p[cj]\n            bf[qi + 1] = p[cj + 1]\n            bf[qi + 2] = p[cj + 2]\n            bf[qi + 3] = j < tl ? ap[j] : 255\n          }\n        }\n      }\n\n      if (depth == 4) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl,\n            t0 = y * w\n          for (var i = 0; i < w; i++) {\n            var qi = (t0 + i) << 2,\n              j = (data[s0 + (i >> 1)] >> (4 - ((i & 1) << 2))) & 15,\n              cj = 3 * j\n            bf[qi] = p[cj]\n            bf[qi + 1] = p[cj + 1]\n            bf[qi + 2] = p[cj + 2]\n            bf[qi + 3] = j < tl ? ap[j] : 255\n          }\n        }\n      }\n\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            j = data[i],\n            cj = 3 * j\n          bf[qi] = p[cj]\n          bf[qi + 1] = p[cj + 1]\n          bf[qi + 2] = p[cj + 2]\n          bf[qi + 3] = j < tl ? ap[j] : 255\n        }\n      }\n    } else if (ctype == 4) {\n      // gray + alpha\n\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            di = i << 1,\n            gr = data[di]\n          bf[qi] = gr\n          bf[qi + 1] = gr\n          bf[qi + 2] = gr\n          bf[qi + 3] = data[di + 1]\n        }\n      }\n\n      if (depth == 16) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            di = i << 2,\n            gr = data[di]\n          bf[qi] = gr\n          bf[qi + 1] = gr\n          bf[qi + 2] = gr\n          bf[qi + 3] = data[di + 2]\n        }\n      }\n    } else if (ctype == 0) {\n      // gray\n\n      var tr = out.tabs['tRNS'] ? out.tabs['tRNS'] : -1\n      for (var y = 0; y < h; y++) {\n        var off = y * bpl,\n          to = y * w\n        if (depth == 1) {\n          for (var x = 0; x < w; x++) {\n            var gr = 255 * ((data[off + (x >>> 3)] >>> (7 - (x & 7))) & 1),\n              al = gr == tr * 255 ? 0 : 255\n            bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr\n          }\n        } else if (depth == 2) {\n          for (var x = 0; x < w; x++) {\n            var gr = 85 * ((data[off + (x >>> 2)] >>> (6 - ((x & 3) << 1))) & 3),\n              al = gr == tr * 85 ? 0 : 255\n            bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr\n          }\n        } else if (depth == 4) {\n          for (var x = 0; x < w; x++) {\n            var gr = 17 * ((data[off + (x >>> 1)] >>> (4 - ((x & 1) << 2))) & 15),\n              al = gr == tr * 17 ? 0 : 255\n            bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr\n          }\n        } else if (depth == 8) {\n          for (var x = 0; x < w; x++) {\n            var gr = data[off + x],\n              al = gr == tr ? 0 : 255\n            bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr\n          }\n        } else if (depth == 16) {\n          for (var x = 0; x < w; x++) {\n            var gr = data[off + (x << 1)],\n              al = rs(data, off + (x << 1)) == tr ? 0 : 255\n            bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr\n          }\n        }\n      }\n    }\n\n    //console.log(Date.now()-time);\n    return bf\n  }\n\n  UPNG.decode = function (buff) {\n    var data = new Uint8Array(buff),\n      offset = 8,\n      bin = UPNG._bin,\n      rUs = bin.readUshort,\n      rUi = bin.readUint\n    var out = { tabs: {}, frames: [] }\n    var dd = new Uint8Array(data.length),\n      doff = 0 // put all IDAT data into it\n    var fd,\n      foff = 0 // frames\n    var text, keyw, bfr\n\n    var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]\n    for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw new Error('The input is not a PNG file!')\n\n    while (offset < data.length) {\n      var len = bin.readUint(data, offset)\n      offset += 4\n      var type = bin.readASCII(data, offset, 4)\n      offset += 4\n      //console.log(type,len);\n\n      if (type == 'IHDR') {\n        UPNG.decode._IHDR(data, offset, out)\n      } else if (type == 'CgBI') {\n        out.tabs[type] = data.slice(offset, offset + 4)\n      } else if (type == 'IDAT') {\n        for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i]\n        doff += len\n      } else if (type == 'acTL') {\n        out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) }\n        fd = new Uint8Array(data.length)\n      } else if (type == 'fcTL') {\n        if (foff != 0) {\n          var fr = out.frames[out.frames.length - 1]\n          fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height)\n          foff = 0\n        }\n\n        var rct = {\n          x: rUi(data, offset + 12),\n          y: rUi(data, offset + 16),\n          width: rUi(data, offset + 4),\n          height: rUi(data, offset + 8),\n        }\n        var del = rUs(data, offset + 22)\n        del = rUs(data, offset + 20) / (del == 0 ? 100 : del)\n        var frm = { rect: rct, delay: Math.round(del * 1000), dispose: data[offset + 24], blend: data[offset + 25] }\n        //console.log(frm);\n        out.frames.push(frm)\n      } else if (type == 'fdAT') {\n        for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4]\n        foff += len - 4\n      } else if (type == 'pHYs') {\n        out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]]\n      } else if (type == 'cHRM') {\n        out.tabs[type] = []\n        for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4))\n      } else if (type == 'tEXt' || type == 'zTXt') {\n        if (out.tabs[type] == null) out.tabs[type] = {}\n        var nz = bin.nextZero(data, offset)\n        keyw = bin.readASCII(data, offset, nz - offset)\n        var tl = offset + len - nz - 1\n        if (type == 'tEXt') {\n          text = bin.readASCII(data, nz + 1, tl)\n        } else {\n          bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl))\n          text = bin.readUTF8(bfr, 0, bfr.length)\n        }\n\n        out.tabs[type][keyw] = text\n      } else if (type == 'iTXt') {\n        if (out.tabs[type] == null) out.tabs[type] = {}\n        var nz = 0,\n          off = offset\n        nz = bin.nextZero(data, off)\n        keyw = bin.readASCII(data, off, nz - off)\n        off = nz + 1\n        var cflag = data[off]\n        off += 2\n        nz = bin.nextZero(data, off)\n        bin.readASCII(data, off, nz - off)\n        off = nz + 1\n        nz = bin.nextZero(data, off)\n        bin.readUTF8(data, off, nz - off)\n        off = nz + 1\n        var tl = len - (off - offset)\n        if (cflag == 0) {\n          text = bin.readUTF8(data, off, tl)\n        } else {\n          bfr = UPNG.decode._inflate(data.slice(off, off + tl))\n          text = bin.readUTF8(bfr, 0, bfr.length)\n        }\n\n        out.tabs[type][keyw] = text\n      } else if (type == 'PLTE') {\n        out.tabs[type] = bin.readBytes(data, offset, len)\n      } else if (type == 'hIST') {\n        var pl = out.tabs['PLTE'].length / 3\n        out.tabs[type] = []\n        for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2))\n      } else if (type == 'tRNS') {\n        if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len)\n        else if (out.ctype == 0) out.tabs[type] = rUs(data, offset)\n        else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)]\n        //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n      } else if (type == 'gAMA') {\n        out.tabs[type] = bin.readUint(data, offset) / 100000\n      } else if (type == 'sRGB') {\n        out.tabs[type] = data[offset]\n      } else if (type == 'bKGD') {\n        if (out.ctype == 0 || out.ctype == 4) {\n          out.tabs[type] = [rUs(data, offset)]\n        } else if (out.ctype == 2 || out.ctype == 6) {\n          out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)]\n        } else if (out.ctype == 3) {\n          out.tabs[type] = data[offset]\n        }\n      } else if (type == 'IEND') {\n        break\n      }\n\n      //else {  console.log(\"unknown chunk type\", type, len);  out.tabs[type]=data.slice(offset,offset+len);  }\n      offset += len\n      bin.readUint(data, offset)\n      offset += 4\n    }\n\n    if (foff != 0) {\n      var fr = out.frames[out.frames.length - 1]\n      fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height)\n    }\n\n    out.data = UPNG.decode._decompress(out, dd, out.width, out.height)\n\n    delete out.compress\n    delete out.interlace\n    delete out.filter\n    return out\n  }\n\n  UPNG.decode._decompress = function (out, dd, w, h) {\n    var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil((w * bpp) / 8),\n      buff = new Uint8Array((bpl + 1 + out.interlace) * h)\n    if (out.tabs['CgBI']) dd = UPNG.inflateRaw(dd, buff)\n    else dd = UPNG.decode._inflate(dd, buff)\n\n    if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h)\n    else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out)\n\n    return dd\n  }\n\n  UPNG.decode._inflate = function (data, buff) {\n    var out = UPNG['inflateRaw'](new Uint8Array(data.buffer, 2, data.length - 6), buff)\n    return out\n  }\n\n  UPNG.inflateRaw = (function () {\n    var H = {}\n    H.H = {}\n    H.H.N = function (N, W) {\n      var R = Uint8Array,\n        i = 0,\n        m = 0,\n        J = 0,\n        h = 0,\n        Q = 0,\n        X = 0,\n        u = 0,\n        w = 0,\n        d = 0,\n        v,\n        C\n      if (N[0] == 3 && N[1] == 0) return W ? W : new R(0)\n      var V = H.H,\n        n = V.b,\n        A = V.e,\n        l = V.R,\n        M = V.n,\n        I = V.A,\n        e = V.Z,\n        b = V.m,\n        Z = W == null\n      if (Z) W = new R((N.length >>> 2) << 5)\n      while (i == 0) {\n        i = n(N, d, 1)\n        m = n(N, d + 1, 2)\n        d += 3\n        if (m == 0) {\n          if ((d & 7) != 0) d += 8 - (d & 7)\n          var D = (d >>> 3) + 4,\n            q = N[D - 4] | (N[D - 3] << 8)\n          if (Z) W = H.H.W(W, w + q)\n          W.set(new R(N.buffer, N.byteOffset + D, q), w)\n          d = (D + q) << 3\n          w += q\n          continue\n        }\n\n        if (Z) W = H.H.W(W, w + (1 << 17))\n        if (m == 1) {\n          v = b.J\n          C = b.h\n          X = (1 << 9) - 1\n          u = (1 << 5) - 1\n        }\n\n        if (m == 2) {\n          J = A(N, d, 5) + 257\n          h = A(N, d + 5, 5) + 1\n          Q = A(N, d + 10, 4) + 4\n          d += 14\n          var j = 1\n          for (var c = 0; c < 38; c += 2) {\n            b.Q[c] = 0\n            b.Q[c + 1] = 0\n          }\n\n          for (var c = 0; c < Q; c++) {\n            var K = A(N, d + c * 3, 3)\n            b.Q[(b.X[c] << 1) + 1] = K\n            if (K > j) j = K\n          }\n\n          d += 3 * Q\n          M(b.Q, j)\n          I(b.Q, j, b.u)\n          v = b.w\n          C = b.d\n          d = l(b.u, (1 << j) - 1, J + h, N, d, b.v)\n          var r = V.V(b.v, 0, J, b.C)\n          X = (1 << r) - 1\n          var S = V.V(b.v, J, h, b.D)\n          u = (1 << S) - 1\n          M(b.C, r)\n          I(b.C, r, v)\n          M(b.D, S)\n          I(b.D, S, C)\n        }\n\n        while (!0) {\n          var T = v[e(N, d) & X]\n          d += T & 15\n          var p = T >>> 4\n          if (p >>> 8 == 0) {\n            W[w++] = p\n          } else if (p == 256) {\n            break\n          } else {\n            var z = w + p - 254\n            if (p > 264) {\n              var _ = b.q[p - 257]\n              z = w + (_ >>> 3) + A(N, d, _ & 7)\n              d += _ & 7\n            }\n\n            var $ = C[e(N, d) & u]\n            d += $ & 15\n            var s = $ >>> 4,\n              Y = b.c[s],\n              a = (Y >>> 4) + n(N, d, Y & 15)\n            d += Y & 15\n            while (w < z) {\n              W[w] = W[w++ - a]\n              W[w] = W[w++ - a]\n              W[w] = W[w++ - a]\n              W[w] = W[w++ - a]\n            }\n\n            w = z\n          }\n        }\n      }\n\n      return W.length == w ? W : W.slice(0, w)\n    }\n\n    H.H.W = function (N, W) {\n      var R = N.length\n      if (W <= R) return N\n      var V = new Uint8Array(R << 1)\n      V.set(N, 0)\n      return V\n    }\n\n    H.H.R = function (N, W, R, V, n, A) {\n      var l = H.H.e,\n        M = H.H.Z,\n        I = 0\n      while (I < R) {\n        var e = N[M(V, n) & W]\n        n += e & 15\n        var b = e >>> 4\n        if (b <= 15) {\n          A[I] = b\n          I++\n        } else {\n          var Z = 0,\n            m = 0\n          if (b == 16) {\n            m = 3 + l(V, n, 2)\n            n += 2\n            Z = A[I - 1]\n          } else if (b == 17) {\n            m = 3 + l(V, n, 3)\n            n += 3\n          } else if (b == 18) {\n            m = 11 + l(V, n, 7)\n            n += 7\n          }\n\n          var J = I + m\n          while (I < J) {\n            A[I] = Z\n            I++\n          }\n        }\n      }\n\n      return n\n    }\n\n    H.H.V = function (N, W, R, V) {\n      var n = 0,\n        A = 0,\n        l = V.length >>> 1\n      while (A < R) {\n        var M = N[A + W]\n        V[A << 1] = 0\n        V[(A << 1) + 1] = M\n        if (M > n) n = M\n        A++\n      }\n\n      while (A < l) {\n        V[A << 1] = 0\n        V[(A << 1) + 1] = 0\n        A++\n      }\n\n      return n\n    }\n\n    H.H.n = function (N, W) {\n      var R = H.H.m,\n        V = N.length,\n        n,\n        A,\n        l,\n        M,\n        I,\n        e = R.j\n      for (var M = 0; M <= W; M++) e[M] = 0\n      for (M = 1; M < V; M += 2) e[N[M]]++\n      var b = R.K\n      n = 0\n      e[0] = 0\n      for (A = 1; A <= W; A++) {\n        n = (n + e[A - 1]) << 1\n        b[A] = n\n      }\n\n      for (l = 0; l < V; l += 2) {\n        I = N[l + 1]\n        if (I != 0) {\n          N[l] = b[I]\n          b[I]++\n        }\n      }\n    }\n\n    H.H.A = function (N, W, R) {\n      var V = N.length,\n        n = H.H.m,\n        A = n.r\n      for (var l = 0; l < V; l += 2) {\n        if (N[l + 1] != 0) {\n          var M = l >> 1,\n            I = N[l + 1],\n            e = (M << 4) | I,\n            b = W - I,\n            Z = N[l] << b,\n            m = Z + (1 << b)\n          while (Z != m) {\n            var J = A[Z] >>> (15 - W)\n            R[J] = e\n            Z++\n          }\n        }\n      }\n    }\n\n    H.H.l = function (N, W) {\n      var R = H.H.m.r,\n        V = 15 - W\n      for (var n = 0; n < N.length; n += 2) {\n        var A = N[n] << (W - N[n + 1])\n        N[n] = R[A] >>> V\n      }\n    }\n\n    H.H.M = function (N, W, R) {\n      R = R << (W & 7)\n      var V = W >>> 3\n      N[V] |= R\n      N[V + 1] |= R >>> 8\n    }\n\n    H.H.I = function (N, W, R) {\n      R = R << (W & 7)\n      var V = W >>> 3\n      N[V] |= R\n      N[V + 1] |= R >>> 8\n      N[V + 2] |= R >>> 16\n    }\n\n    H.H.e = function (N, W, R) {\n      return ((N[W >>> 3] | (N[(W >>> 3) + 1] << 8)) >>> (W & 7)) & ((1 << R) - 1)\n    }\n\n    H.H.b = function (N, W, R) {\n      return ((N[W >>> 3] | (N[(W >>> 3) + 1] << 8) | (N[(W >>> 3) + 2] << 16)) >>> (W & 7)) & ((1 << R) - 1)\n    }\n\n    H.H.Z = function (N, W) {\n      return (N[W >>> 3] | (N[(W >>> 3) + 1] << 8) | (N[(W >>> 3) + 2] << 16)) >>> (W & 7)\n    }\n\n    H.H.i = function (N, W) {\n      return (N[W >>> 3] | (N[(W >>> 3) + 1] << 8) | (N[(W >>> 3) + 2] << 16) | (N[(W >>> 3) + 3] << 24)) >>> (W & 7)\n    }\n\n    H.H.m = (function () {\n      var N = Uint16Array,\n        W = Uint32Array\n      return {\n        K: new N(16),\n        j: new N(16),\n        X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n        S: [\n          3,\n          4,\n          5,\n          6,\n          7,\n          8,\n          9,\n          10,\n          11,\n          13,\n          15,\n          17,\n          19,\n          23,\n          27,\n          31,\n          35,\n          43,\n          51,\n          59,\n          67,\n          83,\n          99,\n          115,\n          131,\n          163,\n          195,\n          227,\n          258,\n          999,\n          999,\n          999,\n        ],\n        T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n        q: new N(32),\n        p: [\n          1,\n          2,\n          3,\n          4,\n          5,\n          7,\n          9,\n          13,\n          17,\n          25,\n          33,\n          49,\n          65,\n          97,\n          129,\n          193,\n          257,\n          385,\n          513,\n          769,\n          1025,\n          1537,\n          2049,\n          3073,\n          4097,\n          6145,\n          8193,\n          12289,\n          16385,\n          24577,\n          65535,\n          65535,\n        ],\n        z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n        c: new W(32),\n        J: new N(512),\n        _: [],\n        h: new N(32),\n        $: [],\n        w: new N(32768),\n        C: [],\n        v: [],\n        d: new N(32768),\n        D: [],\n        u: new N(512),\n        Q: [],\n        r: new N(1 << 15),\n        s: new W(286),\n        Y: new W(30),\n        a: new W(19),\n        t: new W(15e3),\n        k: new N(1 << 16),\n        g: new N(1 << 15),\n      }\n    })()\n    ;(function () {\n      var N = H.H.m,\n        W = 1 << 15\n      for (var R = 0; R < W; R++) {\n        var V = R\n        V = ((V & 2863311530) >>> 1) | ((V & 1431655765) << 1)\n        V = ((V & 3435973836) >>> 2) | ((V & 858993459) << 2)\n        V = ((V & 4042322160) >>> 4) | ((V & 252645135) << 4)\n        V = ((V & 4278255360) >>> 8) | ((V & 16711935) << 8)\n        N.r[R] = ((V >>> 16) | (V << 16)) >>> 17\n      }\n\n      function n(A, l, M) {\n        while (l-- != 0) A.push(0, M)\n      }\n\n      for (var R = 0; R < 32; R++) {\n        N.q[R] = (N.S[R] << 3) | N.T[R]\n        N.c[R] = (N.p[R] << 4) | N.z[R]\n      }\n\n      n(N._, 144, 8)\n      n(N._, 255 - 143, 9)\n      n(N._, 279 - 255, 7)\n      n(N._, 287 - 279, 8)\n      H.H.n(N._, 9)\n      H.H.A(N._, 9, N.J)\n      H.H.l(N._, 9)\n      n(N.$, 32, 5)\n      H.H.n(N.$, 5)\n      H.H.A(N.$, 5, N.h)\n      H.H.l(N.$, 5)\n      n(N.Q, 19, 0)\n      n(N.C, 286, 0)\n      n(N.D, 30, 0)\n      n(N.v, 320, 0)\n    })()\n\n    return H.H.N\n  })()\n\n  UPNG.decode._readInterlace = function (data, out) {\n    var w = out.width,\n      h = out.height\n    var bpp = UPNG.decode._getBPP(out),\n      cbpp = bpp >> 3,\n      bpl = Math.ceil((w * bpp) / 8)\n    var img = new Uint8Array(h * bpl)\n    var di = 0\n\n    var starting_row = [0, 0, 4, 0, 2, 0, 1]\n    var starting_col = [0, 4, 0, 2, 0, 1, 0]\n    var row_increment = [8, 8, 8, 4, 4, 2, 2]\n    var col_increment = [8, 8, 4, 4, 2, 2, 1]\n\n    var pass = 0\n    while (pass < 7) {\n      var ri = row_increment[pass],\n        ci = col_increment[pass]\n      var sw = 0,\n        sh = 0\n      var cr = starting_row[pass]\n      while (cr < h) {\n        cr += ri\n        sh++\n      }\n\n      var cc = starting_col[pass]\n      while (cc < w) {\n        cc += ci\n        sw++\n      }\n\n      var bpll = Math.ceil((sw * bpp) / 8)\n      UPNG.decode._filterZero(data, out, di, sw, sh)\n\n      var y = 0,\n        row = starting_row[pass]\n      var val\n\n      while (row < h) {\n        var col = starting_col[pass]\n        var cdi = (di + y * bpll) << 3\n\n        while (col < w) {\n          if (bpp == 1) {\n            val = data[cdi >> 3]\n            val = (val >> (7 - (cdi & 7))) & 1\n            img[row * bpl + (col >> 3)] |= val << (7 - ((col & 7) << 0))\n          }\n\n          if (bpp == 2) {\n            val = data[cdi >> 3]\n            val = (val >> (6 - (cdi & 7))) & 3\n            img[row * bpl + (col >> 2)] |= val << (6 - ((col & 3) << 1))\n          }\n\n          if (bpp == 4) {\n            val = data[cdi >> 3]\n            val = (val >> (4 - (cdi & 7))) & 15\n            img[row * bpl + (col >> 1)] |= val << (4 - ((col & 1) << 2))\n          }\n\n          if (bpp >= 8) {\n            var ii = row * bpl + col * cbpp\n            for (var j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j]\n          }\n\n          cdi += bpp\n          col += ci\n        }\n\n        y++\n        row += ri\n      }\n\n      if (sw * sh != 0) di += sh * (1 + bpll)\n      pass = pass + 1\n    }\n\n    return img\n  }\n\n  UPNG.decode._getBPP = function (out) {\n    var noc = [1, null, 3, 1, 2, null, 4][out.ctype]\n    return noc * out.depth\n  }\n\n  UPNG.decode._filterZero = function (data, out, off, w, h) {\n    var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil((w * bpp) / 8),\n      paeth = UPNG.decode._paeth\n    bpp = Math.ceil(bpp / 8)\n\n    var i,\n      di,\n      type = data[off],\n      x = 0\n\n    if (type > 1) data[off] = [0, 0, 1][type - 2]\n    if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = (data[x + 1] + (data[x + 1 - bpp] >>> 1)) & 255\n\n    for (var y = 0; y < h; y++) {\n      i = off + y * bpl\n      di = i + y + 1\n      type = data[di - 1]\n      x = 0\n\n      if (type == 0) {\n        for (; x < bpl; x++) data[i + x] = data[di + x]\n      } else if (type == 1) {\n        for (; x < bpp; x++) data[i + x] = data[di + x]\n        for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpp]\n      } else if (type == 2) {\n        for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpl]\n      } else if (type == 3) {\n        for (; x < bpp; x++) data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1)\n        for (; x < bpl; x++) data[i + x] = data[di + x] + ((data[i + x - bpl] + data[i + x - bpp]) >>> 1)\n      } else {\n        for (; x < bpp; x++) data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0)\n        for (; x < bpl; x++) {\n          data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl])\n        }\n      }\n    }\n\n    return data\n  }\n\n  UPNG.decode._paeth = function (a, b, c) {\n    var p = a + b - c,\n      pa = p - a,\n      pb = p - b,\n      pc = p - c\n    if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a\n    else if (pb * pb <= pc * pc) return b\n    return c\n  }\n\n  UPNG.decode._IHDR = function (data, offset, out) {\n    var bin = UPNG._bin\n    out.width = bin.readUint(data, offset)\n    offset += 4\n    out.height = bin.readUint(data, offset)\n    offset += 4\n    out.depth = data[offset]\n    offset++\n    out.ctype = data[offset]\n    offset++\n    out.compress = data[offset]\n    offset++\n    out.filter = data[offset]\n    offset++\n    out.interlace = data[offset]\n    offset++\n  }\n\n  UPNG._bin = {\n    nextZero: function (data, p) {\n      while (data[p] != 0) p++\n      return p\n    },\n    readUshort: function (buff, p) {\n      return (buff[p] << 8) | buff[p + 1]\n    },\n    writeUshort: function (buff, p, n) {\n      buff[p] = (n >> 8) & 255\n      buff[p + 1] = n & 255\n    },\n    readUint: function (buff, p) {\n      return buff[p] * (256 * 256 * 256) + ((buff[p + 1] << 16) | (buff[p + 2] << 8) | buff[p + 3])\n    },\n    writeUint: function (buff, p, n) {\n      buff[p] = (n >> 24) & 255\n      buff[p + 1] = (n >> 16) & 255\n      buff[p + 2] = (n >> 8) & 255\n      buff[p + 3] = n & 255\n    },\n    readASCII: function (buff, p, l) {\n      var s = ''\n      for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i])\n      return s\n    },\n    writeASCII: function (data, p, s) {\n      for (var i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i)\n    },\n    readBytes: function (buff, p, l) {\n      var arr = []\n      for (var i = 0; i < l; i++) arr.push(buff[p + i])\n      return arr\n    },\n    pad: function (n) {\n      return n.length < 2 ? '0' + n : n\n    },\n    readUTF8: function (buff, p, l) {\n      var s = '',\n        ns\n      for (var i = 0; i < l; i++) s += '%' + UPNG._bin.pad(buff[p + i].toString(16))\n      try {\n        ns = decodeURIComponent(s)\n      } catch (e) {\n        return UPNG._bin.readASCII(buff, p, l)\n      }\n\n      return ns\n    },\n  }\n  UPNG._copyTile = function (sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n    var w = Math.min(sw, tw),\n      h = Math.min(sh, th)\n    var si = 0,\n      ti = 0\n    for (var y = 0; y < h; y++) {\n      for (var x = 0; x < w; x++) {\n        if (xoff >= 0 && yoff >= 0) {\n          si = (y * sw + x) << 2\n          ti = ((yoff + y) * tw + xoff + x) << 2\n        } else {\n          si = ((-yoff + y) * sw - xoff + x) << 2\n          ti = (y * tw + x) << 2\n        }\n\n        if (mode == 0) {\n          tb[ti] = sb[si]\n          tb[ti + 1] = sb[si + 1]\n          tb[ti + 2] = sb[si + 2]\n          tb[ti + 3] = sb[si + 3]\n        } else if (mode == 1) {\n          var fa = sb[si + 3] * (1 / 255),\n            fr = sb[si] * fa,\n            fg = sb[si + 1] * fa,\n            fb = sb[si + 2] * fa\n          var ba = tb[ti + 3] * (1 / 255),\n            br = tb[ti] * ba,\n            bg = tb[ti + 1] * ba,\n            bb = tb[ti + 2] * ba\n\n          var ifa = 1 - fa,\n            oa = fa + ba * ifa,\n            ioa = oa == 0 ? 0 : 1 / oa\n          tb[ti + 3] = 255 * oa\n          tb[ti + 0] = (fr + br * ifa) * ioa\n          tb[ti + 1] = (fg + bg * ifa) * ioa\n          tb[ti + 2] = (fb + bb * ifa) * ioa\n        } else if (mode == 2) {\n          // copy only differences, otherwise zero\n\n          var fa = sb[si + 3],\n            fr = sb[si],\n            fg = sb[si + 1],\n            fb = sb[si + 2]\n          var ba = tb[ti + 3],\n            br = tb[ti],\n            bg = tb[ti + 1],\n            bb = tb[ti + 2]\n          if (fa == ba && fr == br && fg == bg && fb == bb) {\n            tb[ti] = 0\n            tb[ti + 1] = 0\n            tb[ti + 2] = 0\n            tb[ti + 3] = 0\n          } else {\n            tb[ti] = fr\n            tb[ti + 1] = fg\n            tb[ti + 2] = fb\n            tb[ti + 3] = fa\n          }\n        } else if (mode == 3) {\n          // check if can be blended\n\n          var fa = sb[si + 3],\n            fr = sb[si],\n            fg = sb[si + 1],\n            fb = sb[si + 2]\n          var ba = tb[ti + 3],\n            br = tb[ti],\n            bg = tb[ti + 1],\n            bb = tb[ti + 2]\n          if (fa == ba && fr == br && fg == bg && fb == bb) continue\n          //if(fa!=255 && ba!=0) return false;\n          if (fa < 220 && ba > 20) return false\n        }\n      }\n    }\n\n    return true\n  }\n}\n\nclass RGBMLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n    this.maxRange = 7 // more information about this property at https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  setMaxRange(value) {\n    this.maxRange = value\n    return this\n  }\n\n  loadCubemap(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture()\n\n    let loaded = 0\n\n    const scope = this\n\n    function loadTexture(i) {\n      scope.load(\n        urls[i],\n        function (image) {\n          texture.images[i] = image\n\n          loaded++\n\n          if (loaded === 6) {\n            texture.needsUpdate = true\n\n            if (onLoad) onLoad(texture)\n          }\n        },\n        undefined,\n        onError,\n      )\n    }\n\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i)\n    }\n\n    texture.type = this.type\n    texture.format = RGBAFormat\n    texture.minFilter = LinearFilter\n    texture.generateMipmaps = false\n\n    return texture\n  }\n\n  parse(buffer) {\n    init()\n    const img = UPNG.decode(buffer)\n    const rgba = UPNG.toRGBA8(img)[0]\n\n    const data = new Uint8Array(rgba)\n    const size = img.width * img.height * 4\n\n    const output = this.type === HalfFloatType ? new Uint16Array(size) : new Float32Array(size)\n\n    // decode RGBM\n\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i + 0] / 255\n      const g = data[i + 1] / 255\n      const b = data[i + 2] / 255\n      const a = data[i + 3] / 255\n\n      if (this.type === HalfFloatType) {\n        output[i + 0] = DataUtils.toHalfFloat(Math.min(r * a * this.maxRange, 65504))\n        output[i + 1] = DataUtils.toHalfFloat(Math.min(g * a * this.maxRange, 65504))\n        output[i + 2] = DataUtils.toHalfFloat(Math.min(b * a * this.maxRange, 65504))\n        output[i + 3] = DataUtils.toHalfFloat(1)\n      } else {\n        output[i + 0] = r * a * this.maxRange\n        output[i + 1] = g * a * this.maxRange\n        output[i + 2] = b * a * this.maxRange\n        output[i + 3] = 1\n      }\n    }\n\n    return {\n      width: img.width,\n      height: img.height,\n      data: output,\n      format: RGBAFormat,\n      type: this.type,\n      flipY: true,\n    }\n  }\n}\n\nexport { RGBMLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 29553, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/VOXLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/VOXLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  LinearFilter,\n  Mesh,\n  MeshStandardMaterial,\n  NearestFilter,\n  RedFormat,\n} from 'three'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nclass VOXLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(buffer) {\n    const data = new DataView(buffer)\n\n    const id = data.getUint32(0, true)\n    const version = data.getUint32(4, true)\n\n    if (id !== 542658390 || version !== 150) {\n      console.error('Not a valid VOX file')\n      return\n    }\n\n    const DEFAULT_PALETTE = [\n      0x00000000,\n      0xffffffff,\n      0xffccffff,\n      0xff99ffff,\n      0xff66ffff,\n      0xff33ffff,\n      0xff00ffff,\n      0xffffccff,\n      0xffccccff,\n      0xff99ccff,\n      0xff66ccff,\n      0xff33ccff,\n      0xff00ccff,\n      0xffff99ff,\n      0xffcc99ff,\n      0xff9999ff,\n      0xff6699ff,\n      0xff3399ff,\n      0xff0099ff,\n      0xffff66ff,\n      0xffcc66ff,\n      0xff9966ff,\n      0xff6666ff,\n      0xff3366ff,\n      0xff0066ff,\n      0xffff33ff,\n      0xffcc33ff,\n      0xff9933ff,\n      0xff6633ff,\n      0xff3333ff,\n      0xff0033ff,\n      0xffff00ff,\n      0xffcc00ff,\n      0xff9900ff,\n      0xff6600ff,\n      0xff3300ff,\n      0xff0000ff,\n      0xffffffcc,\n      0xffccffcc,\n      0xff99ffcc,\n      0xff66ffcc,\n      0xff33ffcc,\n      0xff00ffcc,\n      0xffffcccc,\n      0xffcccccc,\n      0xff99cccc,\n      0xff66cccc,\n      0xff33cccc,\n      0xff00cccc,\n      0xffff99cc,\n      0xffcc99cc,\n      0xff9999cc,\n      0xff6699cc,\n      0xff3399cc,\n      0xff0099cc,\n      0xffff66cc,\n      0xffcc66cc,\n      0xff9966cc,\n      0xff6666cc,\n      0xff3366cc,\n      0xff0066cc,\n      0xffff33cc,\n      0xffcc33cc,\n      0xff9933cc,\n      0xff6633cc,\n      0xff3333cc,\n      0xff0033cc,\n      0xffff00cc,\n      0xffcc00cc,\n      0xff9900cc,\n      0xff6600cc,\n      0xff3300cc,\n      0xff0000cc,\n      0xffffff99,\n      0xffccff99,\n      0xff99ff99,\n      0xff66ff99,\n      0xff33ff99,\n      0xff00ff99,\n      0xffffcc99,\n      0xffcccc99,\n      0xff99cc99,\n      0xff66cc99,\n      0xff33cc99,\n      0xff00cc99,\n      0xffff9999,\n      0xffcc9999,\n      0xff999999,\n      0xff669999,\n      0xff339999,\n      0xff009999,\n      0xffff6699,\n      0xffcc6699,\n      0xff996699,\n      0xff666699,\n      0xff336699,\n      0xff006699,\n      0xffff3399,\n      0xffcc3399,\n      0xff993399,\n      0xff663399,\n      0xff333399,\n      0xff003399,\n      0xffff0099,\n      0xffcc0099,\n      0xff990099,\n      0xff660099,\n      0xff330099,\n      0xff000099,\n      0xffffff66,\n      0xffccff66,\n      0xff99ff66,\n      0xff66ff66,\n      0xff33ff66,\n      0xff00ff66,\n      0xffffcc66,\n      0xffcccc66,\n      0xff99cc66,\n      0xff66cc66,\n      0xff33cc66,\n      0xff00cc66,\n      0xffff9966,\n      0xffcc9966,\n      0xff999966,\n      0xff669966,\n      0xff339966,\n      0xff009966,\n      0xffff6666,\n      0xffcc6666,\n      0xff996666,\n      0xff666666,\n      0xff336666,\n      0xff006666,\n      0xffff3366,\n      0xffcc3366,\n      0xff993366,\n      0xff663366,\n      0xff333366,\n      0xff003366,\n      0xffff0066,\n      0xffcc0066,\n      0xff990066,\n      0xff660066,\n      0xff330066,\n      0xff000066,\n      0xffffff33,\n      0xffccff33,\n      0xff99ff33,\n      0xff66ff33,\n      0xff33ff33,\n      0xff00ff33,\n      0xffffcc33,\n      0xffcccc33,\n      0xff99cc33,\n      0xff66cc33,\n      0xff33cc33,\n      0xff00cc33,\n      0xffff9933,\n      0xffcc9933,\n      0xff999933,\n      0xff669933,\n      0xff339933,\n      0xff009933,\n      0xffff6633,\n      0xffcc6633,\n      0xff996633,\n      0xff666633,\n      0xff336633,\n      0xff006633,\n      0xffff3333,\n      0xffcc3333,\n      0xff993333,\n      0xff663333,\n      0xff333333,\n      0xff003333,\n      0xffff0033,\n      0xffcc0033,\n      0xff990033,\n      0xff660033,\n      0xff330033,\n      0xff000033,\n      0xffffff00,\n      0xffccff00,\n      0xff99ff00,\n      0xff66ff00,\n      0xff33ff00,\n      0xff00ff00,\n      0xffffcc00,\n      0xffcccc00,\n      0xff99cc00,\n      0xff66cc00,\n      0xff33cc00,\n      0xff00cc00,\n      0xffff9900,\n      0xffcc9900,\n      0xff999900,\n      0xff669900,\n      0xff339900,\n      0xff009900,\n      0xffff6600,\n      0xffcc6600,\n      0xff996600,\n      0xff666600,\n      0xff336600,\n      0xff006600,\n      0xffff3300,\n      0xffcc3300,\n      0xff993300,\n      0xff663300,\n      0xff333300,\n      0xff003300,\n      0xffff0000,\n      0xffcc0000,\n      0xff990000,\n      0xff660000,\n      0xff330000,\n      0xff0000ee,\n      0xff0000dd,\n      0xff0000bb,\n      0xff0000aa,\n      0xff000088,\n      0xff000077,\n      0xff000055,\n      0xff000044,\n      0xff000022,\n      0xff000011,\n      0xff00ee00,\n      0xff00dd00,\n      0xff00bb00,\n      0xff00aa00,\n      0xff008800,\n      0xff007700,\n      0xff005500,\n      0xff004400,\n      0xff002200,\n      0xff001100,\n      0xffee0000,\n      0xffdd0000,\n      0xffbb0000,\n      0xffaa0000,\n      0xff880000,\n      0xff770000,\n      0xff550000,\n      0xff440000,\n      0xff220000,\n      0xff110000,\n      0xffeeeeee,\n      0xffdddddd,\n      0xffbbbbbb,\n      0xffaaaaaa,\n      0xff888888,\n      0xff777777,\n      0xff555555,\n      0xff444444,\n      0xff222222,\n      0xff111111,\n    ]\n\n    let i = 8\n\n    let chunk\n    const chunks = []\n\n    while (i < data.byteLength) {\n      let id = ''\n\n      for (let j = 0; j < 4; j++) {\n        id += String.fromCharCode(data.getUint8(i++))\n      }\n\n      const chunkSize = data.getUint32(i, true)\n      i += 4\n      i += 4 // childChunks\n\n      if (id === 'SIZE') {\n        const x = data.getUint32(i, true)\n        i += 4\n        const y = data.getUint32(i, true)\n        i += 4\n        const z = data.getUint32(i, true)\n        i += 4\n\n        chunk = {\n          palette: DEFAULT_PALETTE,\n          size: { x: x, y: y, z: z },\n        }\n\n        chunks.push(chunk)\n\n        i += chunkSize - 3 * 4\n      } else if (id === 'XYZI') {\n        const numVoxels = data.getUint32(i, true)\n        i += 4\n        chunk.data = new Uint8Array(buffer, i, numVoxels * 4)\n\n        i += numVoxels * 4\n      } else if (id === 'RGBA') {\n        const palette = [0]\n\n        for (let j = 0; j < 256; j++) {\n          palette[j + 1] = data.getUint32(i, true)\n          i += 4\n        }\n\n        chunk.palette = palette\n      } else {\n        // console.log( id, chunkSize, childChunks );\n\n        i += chunkSize\n      }\n    }\n\n    return chunks\n  }\n}\n\nclass VOXMesh extends Mesh {\n  constructor(chunk) {\n    const data = chunk.data\n    const size = chunk.size\n    const palette = chunk.palette\n\n    //\n\n    const vertices = []\n    const colors = []\n\n    const nx = [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1]\n    const px = [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]\n    const py = [0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1]\n    const ny = [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0]\n    const nz = [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0]\n    const pz = [0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1]\n\n    function add(tile, x, y, z, r, g, b) {\n      x -= size.x / 2\n      y -= size.z / 2\n      z += size.y / 2\n\n      for (let i = 0; i < 18; i += 3) {\n        vertices.push(tile[i + 0] + x, tile[i + 1] + y, tile[i + 2] + z)\n        colors.push(r, g, b)\n      }\n    }\n\n    // Store data in a volume for sampling\n\n    const offsety = size.x\n    const offsetz = size.x * size.y\n\n    const array = new Uint8Array(size.x * size.y * size.z)\n\n    for (let j = 0; j < data.length; j += 4) {\n      const x = data[j + 0]\n      const y = data[j + 1]\n      const z = data[j + 2]\n\n      const index = x + y * offsety + z * offsetz\n\n      array[index] = 255\n    }\n\n    // Construct geometry\n\n    let hasColors = false\n\n    for (let j = 0; j < data.length; j += 4) {\n      const x = data[j + 0]\n      const y = data[j + 1]\n      const z = data[j + 2]\n      const c = data[j + 3]\n\n      const hex = palette[c]\n      const r = ((hex >> 0) & 0xff) / 0xff\n      const g = ((hex >> 8) & 0xff) / 0xff\n      const b = ((hex >> 16) & 0xff) / 0xff\n\n      if (r > 0 || g > 0 || b > 0) hasColors = true\n\n      const index = x + y * offsety + z * offsetz\n\n      if (array[index + 1] === 0 || x === size.x - 1) add(px, x, z, -y, r, g, b)\n      if (array[index - 1] === 0 || x === 0) add(nx, x, z, -y, r, g, b)\n      if (array[index + offsety] === 0 || y === size.y - 1) add(ny, x, z, -y, r, g, b)\n      if (array[index - offsety] === 0 || y === 0) add(py, x, z, -y, r, g, b)\n      if (array[index + offsetz] === 0 || z === size.z - 1) add(pz, x, z, -y, r, g, b)\n      if (array[index - offsetz] === 0 || z === 0) add(nz, x, z, -y, r, g, b)\n    }\n\n    const geometry = new BufferGeometry()\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n    geometry.computeVertexNormals()\n\n    const material = new MeshStandardMaterial()\n\n    if (hasColors) {\n      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))\n      material.vertexColors = true\n    }\n\n    super(geometry, material)\n  }\n}\n\nclass VOXData3DTexture extends Data3DTexture {\n  constructor(chunk) {\n    const data = chunk.data\n    const size = chunk.size\n\n    const offsety = size.x\n    const offsetz = size.x * size.y\n\n    const array = new Uint8Array(size.x * size.y * size.z)\n\n    for (let j = 0; j < data.length; j += 4) {\n      const x = data[j + 0]\n      const y = data[j + 1]\n      const z = data[j + 2]\n\n      const index = x + y * offsety + z * offsetz\n\n      array[index] = 255\n    }\n\n    super(array, size.x, size.y, size.z)\n\n    this.format = RedFormat\n    this.minFilter = NearestFilter\n    this.magFilter = LinearFilter\n    this.unpackAlignment = 1\n    this.needsUpdate = true\n  }\n}\n\nexport { VOXLoader, VOXMesh, VOXData3DTexture }\n"],"names":["id"],"mappings":";;;;;;;;;;;;AAaA,MAAM,kBAAkB,yJAAA,CAAO;IAC7B,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;QACrC,MAAM,QAAQ,IAAA;QAEd,MAAM,SAAS,IAAI,6JAAA,CAAW,MAAM,OAAO;QAC3C,OAAO,OAAA,CAAQ,MAAM,IAAI;QACzB,OAAO,eAAA,CAAgB,aAAa;QACpC,OAAO,gBAAA,CAAiB,MAAM,aAAa;QAC3C,OAAO,IAAA,CACL,KACA,SAAU,MAAA,EAAQ;YAChB,IAAI;gBACF,OAAO,MAAM,KAAA,CAAM,MAAM,CAAC;YAC3B,EAAA,OAAQ,GAAP;gBACA,IAAI,SAAS;oBACX,QAAQ,CAAC;gBACrB,OAAiB;oBACL,QAAQ,KAAA,CAAM,CAAC;gBAChB;gBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;YAC5B;QACF,GACD,YACA;IAEH;IAED,MAAM,MAAA,EAAQ;QACZ,MAAM,OAAO,IAAI,SAAS,MAAM;QAEhC,MAAM,KAAK,KAAK,SAAA,CAAU,GAAG,IAAI;QACjC,MAAM,UAAU,KAAK,SAAA,CAAU,GAAG,IAAI;QAEtC,IAAI,OAAO,aAAa,YAAY,KAAK;YACvC,QAAQ,KAAA,CAAM,sBAAsB;YACpC;QACD;QAED,MAAM,kBAAkB;YACtB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QAED,IAAI,IAAI;QAER,IAAI;QACJ,MAAM,SAAS,CAAE,CAAA;QAEjB,MAAO,IAAI,KAAK,UAAA,CAAY;YAC1B,IAAIA,MAAK;YAET,IAAA,IAAS,IAAI,GAAG,IAAI,GAAG,IAAK;gBAC1BA,OAAM,OAAO,YAAA,CAAa,KAAK,QAAA,CAAS,GAAG,CAAC;YAC7C;YAED,MAAM,YAAY,KAAK,SAAA,CAAU,GAAG,IAAI;YACxC,KAAK;YACL,KAAK;YAEL,IAAIA,QAAO,QAAQ;gBACjB,MAAM,IAAI,KAAK,SAAA,CAAU,GAAG,IAAI;gBAChC,KAAK;gBACL,MAAM,IAAI,KAAK,SAAA,CAAU,GAAG,IAAI;gBAChC,KAAK;gBACL,MAAM,IAAI,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"}},
    {"offset": {"line": 30104, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/PCDLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/PCDLoader.js"],"sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils, Points, PointsMaterial } from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.littleEndian = true\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data, url))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length\n      const outData = new Uint8Array(outLength)\n      let inPtr = 0\n      let outPtr = 0\n      let ctrl\n      let len\n      let ref\n      do {\n        ctrl = inData[inPtr++]\n        if (ctrl < 1 << 5) {\n          ctrl++\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough')\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data')\n          do {\n            outData[outPtr++] = inData[inPtr++]\n          } while (--ctrl)\n        } else {\n          len = ctrl >> 5\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1\n          if (inPtr >= inLength) throw new Error('Invalid compressed data')\n          if (len === 7) {\n            len += inData[inPtr++]\n            if (inPtr >= inLength) throw new Error('Invalid compressed data')\n          }\n\n          ref -= inData[inPtr++]\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough')\n          if (ref < 0) throw new Error('Invalid compressed data')\n          if (ref >= outPtr) throw new Error('Invalid compressed data')\n          do {\n            outData[outPtr++] = outData[ref++]\n          } while (--len + 2)\n        }\n      } while (inPtr < inLength)\n\n      return outData\n    }\n\n    function parseHeader(data) {\n      const PCDheader = {}\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i)\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1))\n\n      PCDheader.data = result2[1]\n      PCDheader.headerLen = result2[0].length + result1\n      PCDheader.str = data.substr(0, PCDheader.headerLen)\n\n      // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, '')\n\n      // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str)\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str)\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str)\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str)\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str)\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str)\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str)\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str)\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str)\n\n      // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1])\n\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ')\n\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ')\n\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1])\n\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1])\n\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1]\n\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10)\n\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10)\n        })\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10)\n        })\n      } else {\n        PCDheader.count = []\n\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1)\n        }\n      }\n\n      PCDheader.offset = {}\n\n      let sizeSum = 0\n\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum\n          sizeSum += PCDheader.size[i] * PCDheader.count[i]\n        }\n      }\n\n      // for binary only\n\n      PCDheader.rowSize = sizeSum\n\n      return PCDheader\n    }\n\n    const textData = decodeText(new Uint8Array(data))\n\n    // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData)\n\n    // parse data\n\n    const position = []\n    const normal = []\n    const color = []\n\n    // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset\n      const pcdData = textData.substr(PCDheader.headerLen)\n      const lines = pcdData.split('\\n')\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue\n\n        const line = lines[i].split(' ')\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]))\n          position.push(parseFloat(line[offset.y]))\n          position.push(parseFloat(line[offset.z]))\n        }\n\n        if (offset.rgb !== undefined) {\n          const rgb = parseFloat(line[offset.rgb])\n          const r = (rgb >> 16) & 0x0000ff\n          const g = (rgb >> 8) & 0x0000ff\n          const b = (rgb >> 0) & 0x0000ff\n          color.push(r / 255, g / 255, b / 255)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]))\n          normal.push(parseFloat(line[offset.normal_y]))\n          normal.push(parseFloat(line[offset.normal_z]))\n        }\n      }\n    }\n\n    // binary-compressed\n\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8))\n      const compressedSize = sizes[0]\n      const decompressedSize = sizes[1]\n      const decompressed = decompressLZF(\n        new Uint8Array(data, PCDheader.headerLen + 8, compressedSize),\n        decompressedSize,\n      )\n      const dataview = new DataView(decompressed.buffer)\n\n      const offset = PCDheader.offset\n\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian))\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian))\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian))\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0)\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0)\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian),\n          )\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian),\n          )\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian),\n          )\n        }\n      }\n    }\n\n    // binary\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen)\n      const offset = PCDheader.offset\n\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian))\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian))\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian))\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0)\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0)\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian))\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian))\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian))\n        }\n      }\n    }\n\n    // build geometry\n\n    const geometry = new BufferGeometry()\n\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3))\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3))\n\n    geometry.computeBoundingSphere()\n\n    // build material\n\n    const material = new PointsMaterial({ size: 0.005 })\n\n    if (color.length > 0) {\n      material.vertexColors = true\n    } else {\n      material.color.setHex(Math.random() * 0xffffff)\n    }\n\n    // build point cloud\n\n    const mesh = new Points(geometry, material)\n    let name = url.split('').reverse().join('')\n    name = /([^\\/]*)/.exec(name)\n    name = name[1].split('').reverse().join('')\n    mesh.name = name\n\n    return mesh\n  }\n}\n\nexport { PCDLoader }\n"],"names":["data","PCDheader"],"mappings":"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"}},
    {"offset": {"line": 30331, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/lwo/LWO2Parser.js"],"sourcesContent":["class LWO2Parser {\n  constructor(IFFParser) {\n    this.IFF = IFFParser\n  }\n\n  parseBlock() {\n    this.IFF.debugger.offset = this.IFF.reader.offset\n    this.IFF.debugger.closeForms()\n\n    const blockID = this.IFF.reader.getIDTag()\n    let length = this.IFF.reader.getUint32() // size of data in bytes\n    if (length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {\n      this.IFF.reader.offset -= 4\n      length = this.IFF.reader.getUint16()\n    }\n\n    this.IFF.debugger.dataOffset = this.IFF.reader.offset\n    this.IFF.debugger.length = length\n\n    // Data types may be found in either LWO2 OR LWO3 spec\n    switch (blockID) {\n      case 'FORM': // form blocks may consist of sub -chunks or sub-forms\n        this.IFF.parseForm(length)\n        break\n\n      // SKIPPED CHUNKS\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n      // MISC skipped\n      case 'ICON': // Thumbnail Icon Image\n      case 'VMPA': // Vertex Map Parameter\n      case 'BBOX': // bounding box\n      // case 'VMMD':\n      // case 'VTYP':\n\n      // normal maps can be specified, normally on models imported from other applications. Currently ignored\n      case 'NORM':\n\n      // ENVL FORM skipped\n      case 'PRE ':\n      case 'POST':\n      case 'KEY ':\n      case 'SPAN':\n\n      // CLIP FORM skipped\n      case 'TIME':\n      case 'CLRS':\n      case 'CLRA':\n      case 'FILT':\n      case 'DITH':\n      case 'CONT':\n      case 'BRIT':\n      case 'SATR':\n      case 'HUE ':\n      case 'GAMM':\n      case 'NEGA':\n      case 'IFLT':\n      case 'PFLT':\n\n      // Image Map Layer skipped\n      case 'PROJ':\n      case 'AXIS':\n      case 'AAST':\n      case 'PIXB':\n      case 'AUVO':\n      case 'STCK':\n\n      // Procedural Textures skipped\n      case 'PROC':\n      case 'VALU':\n      case 'FUNC':\n\n      // Gradient Textures skipped\n      case 'PNAM':\n      case 'INAM':\n      case 'GRST':\n      case 'GREN':\n      case 'GRPT':\n      case 'FKEY':\n      case 'IKEY':\n\n      // Texture Mapping Form skipped\n      case 'CSYS':\n\n      // Surface CHUNKs skipped\n      case 'OPAQ': // top level 'opacity' checkbox\n      case 'CMAP': // clip map\n\n      // Surface node CHUNKS skipped\n      // These mainly specify the node editor setup in LW\n      case 'NLOC':\n      case 'NZOM':\n      case 'NVER':\n      case 'NSRV':\n      case 'NVSK': // unknown\n      case 'NCRD':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n      case 'WRPH': // image wrap h\n      case 'NMOD':\n      case 'NSEL':\n      case 'NPRW':\n      case 'NPLA':\n      case 'NODS':\n      case 'VERS':\n      case 'ENUM':\n      case 'TAG ':\n      case 'OPAC':\n\n      // Car Material CHUNKS\n      case 'CGMD':\n      case 'CGTY':\n      case 'CGST':\n      case 'CGEN':\n      case 'CGTS':\n      case 'CGTE':\n      case 'OSMP':\n      case 'OMDE':\n      case 'OUTR':\n      case 'FLAG':\n\n      case 'TRNL':\n      case 'GLOW':\n      case 'GVAL': // glow intensity\n      case 'SHRP':\n      case 'RFOP':\n      case 'RSAN':\n      case 'TROP':\n      case 'RBLR':\n      case 'TBLR':\n      case 'CLRH':\n      case 'CLRF':\n      case 'ADTR':\n      case 'LINE':\n      case 'ALPH':\n      case 'VCOL':\n      case 'ENAB':\n        this.IFF.debugger.skipped = true\n        this.IFF.reader.skip(length)\n        break\n\n      case 'SURF':\n        this.IFF.parseSurfaceLwo2(length)\n        break\n\n      case 'CLIP':\n        this.IFF.parseClipLwo2(length)\n        break\n\n      // Texture node chunks (not in spec)\n      case 'IPIX': // usePixelBlending\n      case 'IMIP': // useMipMaps\n      case 'IMOD': // imageBlendingMode\n      case 'AMOD': // unknown\n      case 'IINV': // imageInvertAlpha\n      case 'INCR': // imageInvertColor\n      case 'IAXS': // imageAxis ( for non-UV maps)\n      case 'IFOT': // imageFallofType\n      case 'ITIM': // timing for animated textures\n      case 'IWRL':\n      case 'IUTI':\n      case 'IINX':\n      case 'IINY':\n      case 'IINZ':\n      case 'IREF': // possibly a VX for reused texture nodes\n        if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32()\n        else this.IFF.reader.skip(length)\n        break\n\n      case 'OTAG':\n        this.IFF.parseObjectTag()\n        break\n\n      case 'LAYR':\n        this.IFF.parseLayer(length)\n        break\n\n      case 'PNTS':\n        this.IFF.parsePoints(length)\n        break\n\n      case 'VMAP':\n        this.IFF.parseVertexMapping(length)\n        break\n\n      case 'AUVU':\n      case 'AUVN':\n        this.IFF.reader.skip(length - 1)\n        this.IFF.reader.getVariableLengthIndex() // VX\n        break\n\n      case 'POLS':\n        this.IFF.parsePolygonList(length)\n        break\n\n      case 'TAGS':\n        this.IFF.parseTagStrings(length)\n        break\n\n      case 'PTAG':\n        this.IFF.parsePolygonTagMapping(length)\n        break\n\n      case 'VMAD':\n        this.IFF.parseVertexMapping(length, true)\n        break\n\n      // Misc CHUNKS\n      case 'DESC': // Description Line\n        this.IFF.currentForm.description = this.IFF.reader.getString()\n        break\n\n      case 'TEXT':\n      case 'CMNT':\n      case 'NCOM':\n        this.IFF.currentForm.comment = this.IFF.reader.getString()\n        break\n\n      // Envelope Form\n      case 'NAME':\n        this.IFF.currentForm.channelName = this.IFF.reader.getString()\n        break\n\n      // Image Map Layer\n      case 'WRAP':\n        this.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() }\n        break\n\n      case 'IMAG':\n        const index = this.IFF.reader.getVariableLengthIndex()\n        this.IFF.currentForm.imageIndex = index\n        break\n\n      // Texture Mapping Form\n      case 'OREF':\n        this.IFF.currentForm.referenceObject = this.IFF.reader.getString()\n        break\n\n      case 'ROID':\n        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32()\n        break\n\n      // Surface Blocks\n      case 'SSHN':\n        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString()\n        break\n\n      case 'AOVN':\n        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString()\n        break\n\n      // Nodal Blocks\n      case 'NSTA':\n        this.IFF.currentForm.disabled = this.IFF.reader.getUint16()\n        break\n\n      case 'NRNM':\n        this.IFF.currentForm.realName = this.IFF.reader.getString()\n        break\n\n      case 'NNME':\n        this.IFF.currentForm.refName = this.IFF.reader.getString()\n        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm\n        break\n\n      // Nodal Blocks : connections\n      case 'INME':\n        if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = []\n        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString())\n        break\n\n      case 'IINN':\n        if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = []\n        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString())\n        break\n\n      case 'IINM':\n        if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = []\n        this.IFF.currentForm.inputName.push(this.IFF.reader.getString())\n        break\n\n      case 'IONM':\n        if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = []\n        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString())\n        break\n\n      case 'FNAM':\n        this.IFF.currentForm.fileName = this.IFF.reader.getString()\n        break\n\n      case 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\n        if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag()\n        else this.IFF.reader.skip(length)\n        break\n\n      // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\n      case 'SMAN':\n        const maxSmoothingAngle = this.IFF.reader.getFloat32()\n        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true\n        break\n\n      // LWO2: Basic Surface Parameters\n      case 'COLR':\n        this.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array(3) }\n        this.IFF.reader.skip(2) // VX: envelope\n        break\n\n      case 'LUMI':\n        this.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'SPEC':\n        this.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'DIFF':\n        this.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'REFL':\n        this.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'GLOS':\n        this.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'TRAN':\n        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32()\n        this.IFF.reader.skip(2)\n        break\n\n      case 'BUMP':\n        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32()\n        this.IFF.reader.skip(2)\n        break\n\n      case 'SIDE':\n        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16()\n        break\n\n      case 'RIMG':\n        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex()\n        break\n\n      case 'RIND':\n        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32()\n        this.IFF.reader.skip(2)\n        break\n\n      case 'TIMG':\n        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex()\n        break\n\n      case 'IMAP':\n        this.IFF.reader.skip(2)\n        break\n\n      case 'TMAP':\n        this.IFF.debugger.skipped = true\n        this.IFF.reader.skip(length) // needs implementing\n        break\n\n      case 'IUVI': // uv channel name\n        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length)\n        break\n\n      case 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32()\n        break\n      case 'IVTL': // heightWrappingMode\n        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32()\n        break\n\n      // LWO2 USE\n      case 'BLOK':\n        // skip\n        break\n\n      default:\n        this.IFF.parseUnknownCHUNK(blockID, length)\n    }\n\n    if (blockID != 'FORM') {\n      this.IFF.debugger.node = 1\n      this.IFF.debugger.nodeID = blockID\n      this.IFF.debugger.log()\n    }\n\n    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {\n      this.IFF.currentForm = this.IFF.parentForm\n    }\n  }\n}\n\nexport { LWO2Parser }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 30657, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/lwo/LWO3Parser.js"],"sourcesContent":["class LWO3Parser {\n  constructor(IFFParser) {\n    this.IFF = IFFParser\n  }\n\n  parseBlock() {\n    this.IFF.debugger.offset = this.IFF.reader.offset\n    this.IFF.debugger.closeForms()\n\n    const blockID = this.IFF.reader.getIDTag()\n    const length = this.IFF.reader.getUint32() // size of data in bytes\n\n    this.IFF.debugger.dataOffset = this.IFF.reader.offset\n    this.IFF.debugger.length = length\n\n    // Data types may be found in either LWO2 OR LWO3 spec\n    switch (blockID) {\n      case 'FORM': // form blocks may consist of sub -chunks or sub-forms\n        this.IFF.parseForm(length)\n        break\n\n      // SKIPPED CHUNKS\n      // MISC skipped\n      case 'ICON': // Thumbnail Icon Image\n      case 'VMPA': // Vertex Map Parameter\n      case 'BBOX': // bounding box\n      // case 'VMMD':\n      // case 'VTYP':\n\n      // normal maps can be specified, normally on models imported from other applications. Currently ignored\n      case 'NORM':\n\n      // ENVL FORM skipped\n      case 'PRE ': // Pre-loop behavior for the keyframe\n      case 'POST': // Post-loop behavior for the keyframe\n      case 'KEY ':\n      case 'SPAN':\n\n      // CLIP FORM skipped\n      case 'TIME':\n      case 'CLRS':\n      case 'CLRA':\n      case 'FILT':\n      case 'DITH':\n      case 'CONT':\n      case 'BRIT':\n      case 'SATR':\n      case 'HUE ':\n      case 'GAMM':\n      case 'NEGA':\n      case 'IFLT':\n      case 'PFLT':\n\n      // Image Map Layer skipped\n      case 'PROJ':\n      case 'AXIS':\n      case 'AAST':\n      case 'PIXB':\n      case 'STCK':\n\n      // Procedural Textures skipped\n      case 'VALU':\n\n      // Gradient Textures skipped\n      case 'PNAM':\n      case 'INAM':\n      case 'GRST':\n      case 'GREN':\n      case 'GRPT':\n      case 'FKEY':\n      case 'IKEY':\n\n      // Texture Mapping Form skipped\n      case 'CSYS':\n\n      // Surface CHUNKs skipped\n      case 'OPAQ': // top level 'opacity' checkbox\n      case 'CMAP': // clip map\n\n      // Surface node CHUNKS skipped\n      // These mainly specify the node editor setup in LW\n      case 'NLOC':\n      case 'NZOM':\n      case 'NVER':\n      case 'NSRV':\n      case 'NCRD':\n      case 'NMOD':\n      case 'NSEL':\n      case 'NPRW':\n      case 'NPLA':\n      case 'VERS':\n      case 'ENUM':\n      case 'TAG ':\n\n      // Car Material CHUNKS\n      case 'CGMD':\n      case 'CGTY':\n      case 'CGST':\n      case 'CGEN':\n      case 'CGTS':\n      case 'CGTE':\n      case 'OSMP':\n      case 'OMDE':\n      case 'OUTR':\n      case 'FLAG':\n\n      case 'TRNL':\n      case 'SHRP':\n      case 'RFOP':\n      case 'RSAN':\n      case 'TROP':\n      case 'RBLR':\n      case 'TBLR':\n      case 'CLRH':\n      case 'CLRF':\n      case 'ADTR':\n      case 'GLOW':\n      case 'LINE':\n      case 'ALPH':\n      case 'VCOL':\n      case 'ENAB':\n        this.IFF.debugger.skipped = true\n        this.IFF.reader.skip(length)\n        break\n\n      // Texture node chunks (not in spec)\n      case 'IPIX': // usePixelBlending\n      case 'IMIP': // useMipMaps\n      case 'IMOD': // imageBlendingMode\n      case 'AMOD': // unknown\n      case 'IINV': // imageInvertAlpha\n      case 'INCR': // imageInvertColor\n      case 'IAXS': // imageAxis ( for non-UV maps)\n      case 'IFOT': // imageFallofType\n      case 'ITIM': // timing for animated textures\n      case 'IWRL':\n      case 'IUTI':\n      case 'IINX':\n      case 'IINY':\n      case 'IINZ':\n      case 'IREF': // possibly a VX for reused texture nodes\n        if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32()\n        else this.IFF.reader.skip(length)\n        break\n\n      case 'OTAG':\n        this.IFF.parseObjectTag()\n        break\n\n      case 'LAYR':\n        this.IFF.parseLayer(length)\n        break\n\n      case 'PNTS':\n        this.IFF.parsePoints(length)\n        break\n\n      case 'VMAP':\n        this.IFF.parseVertexMapping(length)\n        break\n\n      case 'POLS':\n        this.IFF.parsePolygonList(length)\n        break\n\n      case 'TAGS':\n        this.IFF.parseTagStrings(length)\n        break\n\n      case 'PTAG':\n        this.IFF.parsePolygonTagMapping(length)\n        break\n\n      case 'VMAD':\n        this.IFF.parseVertexMapping(length, true)\n        break\n\n      // Misc CHUNKS\n      case 'DESC': // Description Line\n        this.IFF.currentForm.description = this.IFF.reader.getString()\n        break\n\n      case 'TEXT':\n      case 'CMNT':\n      case 'NCOM':\n        this.IFF.currentForm.comment = this.IFF.reader.getString()\n        break\n\n      // Envelope Form\n      case 'NAME':\n        this.IFF.currentForm.channelName = this.IFF.reader.getString()\n        break\n\n      // Image Map Layer\n      case 'WRAP':\n        this.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() }\n        break\n\n      case 'IMAG':\n        const index = this.IFF.reader.getVariableLengthIndex()\n        this.IFF.currentForm.imageIndex = index\n        break\n\n      // Texture Mapping Form\n      case 'OREF':\n        this.IFF.currentForm.referenceObject = this.IFF.reader.getString()\n        break\n\n      case 'ROID':\n        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32()\n        break\n\n      // Surface Blocks\n      case 'SSHN':\n        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString()\n        break\n\n      case 'AOVN':\n        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString()\n        break\n\n      // Nodal Blocks\n      case 'NSTA':\n        this.IFF.currentForm.disabled = this.IFF.reader.getUint16()\n        break\n\n      case 'NRNM':\n        this.IFF.currentForm.realName = this.IFF.reader.getString()\n        break\n\n      case 'NNME':\n        this.IFF.currentForm.refName = this.IFF.reader.getString()\n        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm\n        break\n\n      // Nodal Blocks : connections\n      case 'INME':\n        if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = []\n        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString())\n        break\n\n      case 'IINN':\n        if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = []\n        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString())\n        break\n\n      case 'IINM':\n        if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = []\n        this.IFF.currentForm.inputName.push(this.IFF.reader.getString())\n        break\n\n      case 'IONM':\n        if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = []\n        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString())\n        break\n\n      case 'FNAM':\n        this.IFF.currentForm.fileName = this.IFF.reader.getString()\n        break\n\n      case 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\n        if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag()\n        else this.IFF.reader.skip(length)\n        break\n\n      // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\n      case 'SMAN':\n        const maxSmoothingAngle = this.IFF.reader.getFloat32()\n        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true\n        break\n\n      // LWO2: Basic Surface Parameters\n      case 'COLR':\n        this.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array(3) }\n        this.IFF.reader.skip(2) // VX: envelope\n        break\n\n      case 'LUMI':\n        this.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'SPEC':\n        this.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'DIFF':\n        this.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'REFL':\n        this.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'GLOS':\n        this.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() }\n        this.IFF.reader.skip(2)\n        break\n\n      case 'TRAN':\n        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32()\n        this.IFF.reader.skip(2)\n        break\n\n      case 'BUMP':\n        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32()\n        this.IFF.reader.skip(2)\n        break\n\n      case 'SIDE':\n        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16()\n        break\n\n      case 'RIMG':\n        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex()\n        break\n\n      case 'RIND':\n        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32()\n        this.IFF.reader.skip(2)\n        break\n\n      case 'TIMG':\n        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex()\n        break\n\n      case 'IMAP':\n        this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32()\n        break\n\n      case 'IUVI': // uv channel name\n        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length)\n        break\n\n      case 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32()\n        break\n      case 'IVTL': // heightWrappingMode\n        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32()\n        break\n\n      default:\n        this.IFF.parseUnknownCHUNK(blockID, length)\n    }\n\n    if (blockID != 'FORM') {\n      this.IFF.debugger.node = 1\n      this.IFF.debugger.nodeID = blockID\n      this.IFF.debugger.log()\n    }\n\n    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {\n      this.IFF.currentForm = this.IFF.parentForm\n    }\n  }\n}\n\nexport { LWO3Parser }\n"],"names":[],"mappings":";;;;AAAA,MAAM,WAAW;IACf,YAAY,SAAA,CAAW;QACrB,IAAA,CAAK,GAAA,GAAM;IACZ;IAED,aAAa;QACX,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,MAAA;QAC3C,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,UAAA,CAAY;QAE9B,MAAM,UAAU,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,QAAA,CAAU;QAC1C,MAAM,SAAS,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;QAE1C,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,MAAA;QAC/C,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,MAAA,GAAS;QAG3B,OAAQ,SAAO;YACb,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,SAAA,CAAU,MAAM;gBACzB;YAIF,KAAK;YACL,KAAK;YACL,KAAK;YAKL,KAAK;YAGL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YAGL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YAGL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YAGL,KAAK;YAGL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YAGL,KAAK;YAGL,KAAK;YACL,KAAK;YAIL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YAGL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YAEL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,OAAA,GAAU;gBAC5B,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,MAAM;gBAC3B;YAGF,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAI,WAAW,GAAG,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,OAAO,CAAA,GAAI,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,QAAA,CAAU;qBACvE,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,MAAM;gBAChC;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAgB;gBACzB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,UAAA,CAAW,MAAM;gBAC1B;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,MAAM;gBAC3B;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,kBAAA,CAAmB,MAAM;gBAClC;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,gBAAA,CAAiB,MAAM;gBAChC;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,eAAA,CAAgB,MAAM;gBAC/B;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,sBAAA,CAAuB,MAAM;gBACtC;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,kBAAA,CAAmB,QAAQ,IAAI;gBACxC;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,WAAA,GAAc,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC9D;YAEF,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC1D;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,WAAA,GAAc,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC9D;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,IAAA,GAAO;oBAAE,GAAG,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAS;oBAAI,GAAG,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA;gBAAa;gBAC9F;YAEF,KAAK;gBACH,MAAM,QAAQ,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,sBAAA,CAAwB;gBACtD,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,UAAA,GAAa;gBAClC;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,eAAA,GAAkB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAClE;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,iBAAA,GAAoB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBACpE;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,iBAAA,GAAoB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBACvE;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,oBAAA,GAAuB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC1E;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,QAAA,GAAW,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC3D;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,QAAA,GAAW,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC3D;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC1D,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,OAAO,CAAA,GAAI,IAAA,CAAK,GAAA,CAAI,WAAA;gBACvE;YAGF,KAAK;gBACH,IAAI,CAAC,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,QAAA,EAAU,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,QAAA,GAAW,CAAE,CAAA;gBACtE,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,QAAA,CAAS,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,EAAW;gBAC9D;YAEF,KAAK;gBACH,IAAI,CAAC,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,aAAA,EAAe,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,aAAA,GAAgB,CAAE,CAAA;gBAChF,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,aAAA,CAAc,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,EAAW;gBACnE;YAEF,KAAK;gBACH,IAAI,CAAC,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,SAAA,EAAW,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,SAAA,GAAY,CAAE,CAAA;gBACxE,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,EAAW;gBAC/D;YAEF,KAAK;gBACH,IAAI,CAAC,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,eAAA,EAAiB,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,eAAA,GAAkB,CAAE,CAAA;gBACpF,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,eAAA,CAAgB,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,EAAW;gBACrE;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,QAAA,GAAW,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC3D;YAEF,KAAK;gBACH,IAAI,WAAW,GAAG,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,cAAA,GAAiB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,QAAA,CAAU;qBAC7E,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,MAAM;gBAChC;YAGF,KAAK;gBACH,MAAM,oBAAoB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAY;gBACtD,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,MAAA,GAAS,oBAAoB,IAAI,QAAQ;gBAC5E;YAGF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,KAAA,GAAQ;oBAAE,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,eAAA,CAAgB,CAAC;gBAAG;gBACxF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,UAAA,GAAa;oBAAE,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAU;gBAAI;gBACvF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,QAAA,GAAW;oBAAE,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAU;gBAAI;gBACrF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,OAAA,GAAU;oBAAE,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAU;gBAAI;gBACpF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,UAAA,GAAa;oBAAE,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAU;gBAAI;gBACvF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,UAAA,GAAa;oBAAE,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAU;gBAAI;gBACvF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,OAAA,GAAU,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAY;gBACzE,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,YAAA,GAAe,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAY;gBAC9E,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBACrE;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,aAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,sBAAA,CAAwB;gBAC3F;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,eAAA,GAAkB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,UAAA,CAAY;gBACjF,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,CAAC;gBACtB;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,aAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,sBAAA,CAAwB;gBAC3F;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,cAAA,CAAe,UAAA,CAAW,aAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBAC9E;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,SAAA,GAAY,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAU,MAAM;gBACjE;YAEF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,iBAAA,GAAoB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBACpE;YACF,KAAK;gBACH,IAAA,CAAK,GAAA,CAAI,WAAA,CAAY,kBAAA,GAAqB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,SAAA,CAAW;gBACrE;YAEF;gBACE,IAAA,CAAK,GAAA,CAAI,iBAAA,CAAkB,SAAS,MAAM;QAC7C;QAED,IAAI,WAAW,QAAQ;YACrB,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,IAAA,GAAO;YACzB,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,MAAA,GAAS;YAC3B,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,GAAA,CAAK;QACxB;QAED,IAAI,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,MAAA,IAAU,IAAA,CAAK,GAAA,CAAI,cAAA,EAAgB;YACrD,IAAA,CAAK,GAAA,CAAI,WAAA,GAAc,IAAA,CAAK,GAAA,CAAI,UAAA;QACjC;IACF;AACH"}},
    {"offset": {"line": 30953, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/lwo/IFFParser.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/lwo/IFFParser.js"],"sourcesContent":["/**\n * === IFFParser ===\n * - Parses data from the IFF buffer.\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n *\n * ATOMIC DATA TYPES\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n *  float, 4 byte length: F4\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n *\n * COMPOUND DATA TYPES\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n *  Color (RGB): F4 + F4 + F4: COL12\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n *  Angle in radian F4: ANG4\n *  Filename (string) S0: FNAM0\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n *\n *  The IFF file is arranged in chunks:\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n *\n * COMPOUND DATA TYPES\n * - Chunks are combined in Forms (collections of chunks)\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n * - CHUNKS and FORMS are collectively referred to as blocks\n * - The entire file is contained in one top level FORM\n *\n **/\n\nimport { LWO2Parser } from './LWO2Parser'\nimport { LWO3Parser } from './LWO3Parser'\n\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger()\n    // this.debugger.enable(); // un-comment to log IFF hierarchy.\n  }\n\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer)\n\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: [],\n    }\n\n    // start out at the top level to add any data before first layer is encountered\n    this.currentLayer = this.tree\n    this.currentForm = this.tree\n\n    this.parseTopForm()\n\n    if (this.tree.format === undefined) return\n\n    if (this.tree.format === 'LWO2') {\n      this.parser = new LWO2Parser(this)\n      while (!this.reader.endOfFile()) this.parser.parseBlock()\n    } else if (this.tree.format === 'LWO3') {\n      this.parser = new LWO3Parser(this)\n      while (!this.reader.endOfFile()) this.parser.parseBlock()\n    }\n\n    this.debugger.offset = this.reader.offset\n    this.debugger.closeForms()\n\n    return this.tree\n  }\n\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset\n\n    var topForm = this.reader.getIDTag()\n\n    if (topForm !== 'FORM') {\n      console.warn('LWOLoader: Top-level FORM missing.')\n      return\n    }\n\n    var length = this.reader.getUint32()\n\n    this.debugger.dataOffset = this.reader.offset\n    this.debugger.length = length\n\n    var type = this.reader.getIDTag()\n\n    if (type === 'LWO2') {\n      this.tree.format = type\n    } else if (type === 'LWO3') {\n      this.tree.format = type\n    }\n\n    this.debugger.node = 0\n    this.debugger.nodeID = type\n    this.debugger.log()\n\n    return\n  }\n\n  ///\n  // FORM PARSING METHODS\n  ///\n\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag()\n\n    switch (type) {\n      // SKIPPED FORMS\n      // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n\n      case 'ISEQ': // Image sequence\n      case 'ANIM': // plug in animation\n      case 'STCC': // Color-cycling Still\n      case 'VPVL':\n      case 'VPRM':\n      case 'NROT':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n      case 'WRPH': // image wrap h\n      case 'FUNC':\n      case 'FALL':\n      case 'OPAC':\n      case 'GRAD': // gradient texture\n      case 'ENVS':\n      case 'VMOP':\n      case 'VMBG':\n\n      // Car Material FORMS\n      case 'OMAX':\n      case 'STEX':\n      case 'CKBG':\n      case 'CKEY':\n      case 'VMLA':\n      case 'VMLB':\n        this.debugger.skipped = true\n        this.skipForm(length) // not currently supported\n        break\n\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n      case 'META':\n      case 'NNDS':\n      case 'NODS':\n      case 'NDTA':\n      case 'ADAT':\n      case 'AOVS':\n      case 'BLOK':\n\n      // used by texture nodes\n      case 'IBGC': // imageBackgroundColor\n      case 'IOPC': // imageOpacity\n      case 'IIMG': // hold reference to image path\n      case 'TXTR':\n        // this.setupForm( type, length );\n        this.debugger.length = 4\n        this.debugger.skipped = true\n        break\n\n      case 'IFAL': // imageFallof\n      case 'ISCL': // imageScale\n      case 'IPOS': // imagePosition\n      case 'IROT': // imageRotation\n      case 'IBMP':\n      case 'IUTD':\n      case 'IVTD':\n        this.parseTextureNodeAttribute(type)\n        break\n\n      case 'ENVL':\n        this.parseEnvelope(length)\n        break\n\n      // CLIP FORM AND SUB FORMS\n\n      case 'CLIP':\n        if (this.tree.format === 'LWO2') {\n          this.parseForm(length)\n        } else {\n          this.parseClip(length)\n        }\n\n        break\n\n      case 'STIL':\n        this.parseImage()\n        break\n\n      case 'XREF': // clone of another STIL\n        this.reader.skip(8) // unknown\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString(), // internal unique ref\n        }\n        break\n\n      // Not in spec, used by texture nodes\n\n      case 'IMST':\n        this.parseImageStateForm(length)\n        break\n\n      // SURF FORM AND SUB FORMS\n\n      case 'SURF':\n        this.parseSurfaceForm(length)\n        break\n\n      case 'VALU': // Not in spec\n        this.parseValueForm(length)\n        break\n\n      case 'NTAG':\n        this.parseSubNode(length)\n        break\n\n      case 'ATTR': // BSDF Node Attributes\n      case 'SATR': // Standard Node Attributes\n        this.setupForm('attributes', length)\n        break\n\n      case 'NCON':\n        this.parseConnections(length)\n        break\n\n      case 'SSHA':\n        this.parentForm = this.currentForm\n        this.currentForm = this.currentSurface\n        this.setupForm('surfaceShader', length)\n        break\n\n      case 'SSHD':\n        this.setupForm('surfaceShaderData', length)\n        break\n\n      case 'ENTR': // Not in spec\n        this.parseEntryForm(length)\n        break\n\n      // Image Map Layer\n\n      case 'IMAP':\n        this.parseImageMap(length)\n        break\n\n      case 'TAMP':\n        this.parseXVAL('amplitude', length)\n        break\n\n      //Texture Mapping Form\n\n      case 'TMAP':\n        this.setupForm('textureMap', length)\n        break\n\n      case 'CNTR':\n        this.parseXVAL3('center', length)\n        break\n\n      case 'SIZE':\n        this.parseXVAL3('scale', length)\n        break\n\n      case 'ROTA':\n        this.parseXVAL3('rotation', length)\n        break\n\n      default:\n        this.parseUnknownForm(type, length)\n    }\n\n    this.debugger.node = 0\n    this.debugger.nodeID = type\n    this.debugger.log()\n  }\n\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode\n\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {}\n      this.currentForm = this.currentForm[type]\n    } else {\n      // should never see this unless there's a bug in the reader\n      console.warn('LWOLoader: form already exists on parent: ', type, this.currentForm)\n\n      this.currentForm = this.currentForm[type]\n    }\n  }\n\n  skipForm(length) {\n    this.reader.skip(length - 4)\n  }\n\n  parseUnknownForm(type, length) {\n    console.warn('LWOLoader: unknown FORM encountered: ' + type, length)\n\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4)\n    this.reader.skip(length - 4)\n  }\n\n  parseSurfaceForm(length) {\n    this.reader.skip(8) // unknown Uint32 x2\n\n    var name = this.reader.getString()\n\n    var surface = {\n      attributes: {}, // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString(),\n    }\n\n    this.tree.materials[name] = surface\n    this.currentSurface = surface\n\n    this.parentForm = this.tree.materials\n    this.currentForm = surface\n    this.currentFormEnd = this.reader.offset + length\n  }\n\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString()\n\n    var surface = {\n      attributes: {}, // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      nodes: {},\n      source: this.reader.getString(),\n    }\n\n    this.tree.materials[name] = surface\n    this.currentSurface = surface\n\n    this.parentForm = this.tree.materials\n    this.currentForm = surface\n    this.currentFormEnd = this.reader.offset + length\n  }\n\n  parseSubNode(length) {\n    // parse the NRNM CHUNK of the subnode FORM to get\n    // a meaningful name for the subNode\n    // some subnodes can be renamed, but Input and Surface cannot\n\n    this.reader.skip(8) // NRNM + length\n    var name = this.reader.getString()\n\n    var node = {\n      name: name,\n    }\n    this.currentForm = node\n    this.currentNode = node\n\n    this.currentFormEnd = this.reader.offset + length\n  }\n\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    this.currentForm = this.currentSurface.connections\n  }\n\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8) // NAME + length\n    var name = this.reader.getString()\n    this.currentForm = this.currentNode.attributes\n\n    this.setupForm(name, length)\n  }\n\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8) // unknown + length\n\n    var valueType = this.reader.getString()\n\n    if (valueType === 'double') {\n      this.currentForm.value = this.reader.getUint64()\n    } else if (valueType === 'int') {\n      this.currentForm.value = this.reader.getUint32()\n    } else if (valueType === 'vparam') {\n      this.reader.skip(24)\n      this.currentForm.value = this.reader.getFloat64()\n    } else if (valueType === 'vparam3') {\n      this.reader.skip(24)\n      this.currentForm.value = this.reader.getFloat64Array(3)\n    }\n  }\n\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8) // unknown\n\n    this.currentForm.mipMapLevel = this.reader.getFloat32()\n  }\n\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    if (!this.currentForm.maps) this.currentForm.maps = []\n\n    var map = {}\n    this.currentForm.maps.push(map)\n    this.currentForm = map\n\n    this.reader.skip(10) // unknown, could be an issue if it contains a VX\n  }\n\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28) // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n    this.reader.skip(20) // FORM + length + VPVL + float32 + Uint32\n\n    switch (type) {\n      case 'ISCL':\n        this.currentNode.scale = this.reader.getFloat32Array(3)\n        break\n      case 'IPOS':\n        this.currentNode.position = this.reader.getFloat32Array(3)\n        break\n      case 'IROT':\n        this.currentNode.rotation = this.reader.getFloat32Array(3)\n        break\n      case 'IFAL':\n        this.currentNode.falloff = this.reader.getFloat32Array(3)\n        break\n\n      case 'IBMP':\n        this.currentNode.amplitude = this.reader.getFloat32()\n        break\n      case 'IUTD':\n        this.currentNode.uTiles = this.reader.getFloat32()\n        break\n      case 'IVTD':\n        this.currentNode.vTiles = this.reader.getFloat32()\n        break\n    }\n\n    this.reader.skip(2) // unknown\n  }\n\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4) // skipping  entirely for now\n  }\n\n  ///\n  // CHUNK PARSING METHODS\n  ///\n\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag()\n\n    // inside surface node\n    if (tag === 'FORM') {\n      this.reader.skip(16)\n\n      this.currentNode.fileName = this.reader.getString()\n\n      return\n    }\n\n    // otherwise top level\n    this.reader.setOffset(this.reader.offset - 4)\n\n    this.currentFormEnd = this.reader.offset + length\n    this.parentForm = this.currentForm\n\n    this.reader.skip(8) // unknown\n\n    var texture = {\n      index: this.reader.getUint32(),\n    }\n    this.tree.textures.push(texture)\n    this.currentForm = texture\n  }\n\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: '',\n    }\n\n    // seach STIL block\n    while (true) {\n      var tag = this.reader.getIDTag()\n      var n_length = this.reader.getUint16()\n      if (tag === 'STIL') {\n        texture.fileName = this.reader.getString()\n        break\n      }\n\n      if (n_length >= length) {\n        break\n      }\n    }\n\n    this.tree.textures.push(texture)\n    this.currentForm = texture\n  }\n\n  parseImage() {\n    this.reader.skip(8) // unknown\n    this.currentForm.fileName = this.reader.getString()\n  }\n\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4\n    this.reader.skip(8)\n\n    this.currentForm[type] = this.reader.getFloat32()\n\n    this.reader.setOffset(endOffset) // set end offset directly to skip optional envelope\n  }\n\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4\n    this.reader.skip(8)\n\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32(),\n    }\n\n    this.reader.setOffset(endOffset)\n  }\n\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {}\n\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString(),\n    }\n  }\n\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(), // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3), // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString(),\n    }\n\n    this.tree.layers.push(layer)\n    this.currentLayer = layer\n\n    var parsedLength = 16 + stringOffset(this.currentLayer.name) // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n\n    // if we have not reached then end of the layer block, there must be a parent defined\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1 // omitted or -1 for no parent\n  }\n\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = []\n    for (var i = 0; i < length / 4; i += 3) {\n      // z -> -z to match three.js right handed coords\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32())\n    }\n  }\n\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length\n\n    var channelName = this.reader.getString()\n\n    if (this.reader.offset === finalOffset) {\n      // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n      this.currentForm.UVChannel = channelName\n      return\n    }\n\n    // otherwise reset to initial length and parse normal VMAP CHUNK\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName))\n\n    var type = this.reader.getIDTag()\n\n    this.reader.getUint16() // dimension\n    var name = this.reader.getString()\n\n    var remainingLength = length - 6 - stringOffset(name)\n\n    switch (type) {\n      case 'TXUV':\n        this.parseUVMapping(name, finalOffset, discontinuous)\n        break\n      case 'MORF':\n      case 'SPOT':\n        this.parseMorphTargets(name, finalOffset, type) // can't be discontinuous\n        break\n      // unsupported VMAPs\n      case 'APSL':\n      case 'NORM':\n      case 'WGHT':\n      case 'MNVW':\n      case 'PICK':\n      case 'RGB ':\n      case 'RGBA':\n        this.reader.skip(remainingLength)\n        break\n      default:\n        console.warn('LWOLoader: unknown vertex map type: ' + type)\n        this.reader.skip(remainingLength)\n    }\n  }\n\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = []\n    var polyIndices = []\n    var uvs = []\n\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex())\n\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex())\n\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32())\n    }\n\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {}\n\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices: uvIndices,\n        polyIndices: polyIndices,\n        uvs: uvs,\n      }\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {}\n\n      this.currentLayer.uvs[name] = {\n        uvIndices: uvIndices,\n        uvs: uvs,\n      }\n    }\n  }\n\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = []\n    var points = []\n\n    type = type === 'MORF' ? 'relative' : 'absolute'\n\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex())\n      // z -> -z to match three.js right handed coords\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32())\n    }\n\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {}\n\n    this.currentLayer.morphTargets[name] = {\n      indices: indices,\n      points: points,\n      type: type,\n    }\n  }\n\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length\n    var type = this.reader.getIDTag()\n\n    var indices = []\n\n    // hold a list of polygon sizes, to be split up later\n    var polygonDimensions = []\n\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16()\n\n      //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n      numverts = numverts & 1023 // remaining ten low order bits are vertex num\n      polygonDimensions.push(numverts)\n\n      for (var j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex())\n    }\n\n    var geometryData = {\n      type: type,\n      vertexIndices: indices,\n      polygonDimensions: polygonDimensions,\n      points: this.currentPoints,\n    }\n\n    // Note: assuming that all polys will be lines or points if the first is\n    if (polygonDimensions[0] === 1) geometryData.type = 'points'\n    else if (polygonDimensions[0] === 2) geometryData.type = 'lines'\n\n    this.currentLayer.geometry = geometryData\n  }\n\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length)\n  }\n\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length\n    var type = this.reader.getIDTag()\n    if (type === 'SURF') this.parseMaterialIndices(finalOffset)\n    else {\n      //PART, SMGP, COLR not supported\n\n      this.reader.skip(length - 4)\n    }\n  }\n\n  parseMaterialIndices(finalOffset) {\n    // array holds polygon index followed by material index\n    this.currentLayer.geometry.materialIndices = []\n\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex()\n      var materialIndex = this.reader.getUint16()\n\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex)\n    }\n  }\n\n  parseUnknownCHUNK(blockID, length) {\n    console.warn('LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length)\n\n    // print the chunk plus some bytes padding either side\n    // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n    var data = this.reader.getString(length)\n\n    this.currentForm[blockID] = data\n  }\n}\n\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer)\n    this.offset = 0\n    this._textDecoder = new TextDecoder()\n    this._bytes = new Uint8Array(buffer)\n  }\n\n  size() {\n    return this.dv.buffer.byteLength\n  }\n\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset\n    } else {\n      console.error('LWOLoader: invalid buffer offset')\n    }\n  }\n\n  endOfFile() {\n    if (this.offset >= this.size()) return true\n    return false\n  }\n\n  skip(length) {\n    this.offset += length\n  }\n\n  getUint8() {\n    var value = this.dv.getUint8(this.offset)\n    this.offset += 1\n    return value\n  }\n\n  getUint16() {\n    var value = this.dv.getUint16(this.offset)\n    this.offset += 2\n    return value\n  }\n\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false)\n    this.offset += 4\n    return value\n  }\n\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false)\n    this.offset += 4\n    return value\n  }\n\n  getUint64() {\n    var low, high\n\n    high = this.getUint32()\n    low = this.getUint32()\n    return high * 0x100000000 + low\n  }\n\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false)\n    this.offset += 4\n    return value\n  }\n\n  getFloat32Array(size) {\n    var a = []\n\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32())\n    }\n\n    return a\n  }\n\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian)\n    this.offset += 8\n    return value\n  }\n\n  getFloat64Array(size) {\n    var a = []\n\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64())\n    }\n\n    return a\n  }\n\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8()\n\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8()\n    }\n\n    return firstByte * 256 + this.getUint8()\n  }\n\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4)\n  }\n\n  getString(size) {\n    if (size === 0) return\n\n    const start = this.offset\n\n    let result\n    let length\n\n    if (size) {\n      length = size\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size))\n    } else {\n      // use 1:1 mapping of buffer to avoid redundant new array creation.\n      length = this._bytes.indexOf(0, start) - start\n\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length))\n\n      // account for null byte in length\n      length++\n\n      // if string with terminating nullbyte is uneven, extra nullbyte is added, skip that too\n      length += length % 2\n    }\n\n    this.skip(length)\n\n    return result\n  }\n\n  getStringArray(size) {\n    var a = this.getString(size)\n    a = a.split('\\0')\n\n    return a.filter(Boolean) // return array with any empty strings removed\n  }\n}\n\n// ************** DEBUGGER  **************\n\nclass Debugger {\n  constructor() {\n    this.active = false\n    this.depth = 0\n    this.formList = []\n  }\n\n  enable() {\n    this.active = true\n  }\n\n  log() {\n    if (!this.active) return\n\n    var nodeType\n\n    switch (this.node) {\n      case 0:\n        nodeType = 'FORM'\n        break\n\n      case 1:\n        nodeType = 'CHK'\n        break\n\n      case 2:\n        nodeType = 'S-CHK'\n        break\n    }\n\n    console.log(\n      '| '.repeat(this.depth) + nodeType,\n      this.nodeID,\n      `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n      this.node == 0 ? ' {' : '',\n      this.skipped ? 'SKIPPED' : '',\n      this.node == 0 && this.skipped ? '}' : '',\n    )\n\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1\n      this.formList.push(this.dataOffset + this.length)\n    }\n\n    this.skipped = false\n  }\n\n  closeForms() {\n    if (!this.active) return\n\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1\n        console.log('| '.repeat(this.depth) + '}')\n        this.formList.splice(-1, 1)\n      }\n    }\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isEven(num) {\n  return num % 2\n}\n\n// calculate the length of the string in the buffer\n// this will be string.length + nullbyte + optional padbyte to make the length even\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0)\n}\n\n// for testing purposes, dump buffer to console\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)))\n}\n\nexport { IFFParser }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 31679, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/LWOLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/LWOLoader.js"],"sourcesContent":["/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nimport {\n  AddOperation,\n  BackSide,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Mesh,\n  MeshPhongMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  Points,\n  PointsMaterial,\n  RepeatWrapping,\n  TextureLoader,\n  Vector2,\n} from 'three'\n\nimport { IFFParser } from './lwo/IFFParser.js'\nimport { UV1 } from '../_polyfill/uv1.ts'\n\nlet _lwoTree\n\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager)\n\n    this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : ''\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path\n\n    // give the mesh a default name based on the filename\n    const modelName = url.split(path).pop().split('.')[0]\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n\n    loader.load(\n      url,\n      function (buffer) {\n        // console.time( 'Total parsing: ' );\n\n        try {\n          onLoad(scope.parse(buffer, path, modelName))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n\n        // console.timeEnd( 'Total parsing: ' );\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer)\n\n    // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new LWOTreeParser(textureLoader).parse(modelName)\n  }\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader\n  }\n\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse()\n    this.defaultLayerName = modelName\n\n    this.meshes = this.parseLayers()\n\n    return {\n      materials: this.materials,\n      meshes: this.meshes,\n    }\n  }\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = []\n\n    // final array containing meshes with scene graph hierarchy set up\n    const finalMeshes = []\n\n    const geometryParser = new GeometryParser()\n\n    const scope = this\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer)\n\n      const mesh = scope.parseMesh(geometry, layer)\n\n      meshes[layer.number] = mesh\n\n      if (layer.parent === -1) finalMeshes.push(mesh)\n      else meshes[layer.parent].add(mesh)\n    })\n\n    this.applyPivots(finalMeshes)\n\n    return finalMeshes\n  }\n\n  parseMesh(geometry, layer) {\n    let mesh\n\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type)\n\n    if (UV1 === 'uv2') this.duplicateUVs(geometry, materials)\n\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials)\n    else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials)\n    else mesh = new Mesh(geometry, materials)\n\n    if (layer.name) mesh.name = layer.name\n    else mesh.name = this.defaultLayerName + '_layer_' + layer.number\n\n    mesh.userData.pivot = layer.pivot\n\n    return mesh\n  }\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot\n\n        child.position.x += pivot[0]\n        child.position.y += pivot[1]\n        child.position.z += pivot[2]\n\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot\n\n          child.position.x -= parentPivot[0]\n          child.position.y -= parentPivot[1]\n          child.position.z -= parentPivot[2]\n        }\n      })\n    })\n  }\n\n  getMaterials(namesArray, type) {\n    const materials = []\n\n    const scope = this\n\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name)\n    })\n\n    // convert materials to line or point mats if required\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color,\n        }\n\n        if (type === 'points') {\n          spec.size = 0.1\n          spec.map = mat.map\n          spec.morphTargets = mat.morphTargets\n          materials[i] = new PointsMaterial(spec)\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec)\n        }\n      })\n    }\n\n    // if there is only one material, return that directly instead of array\n    const filtered = materials.filter(Boolean)\n    if (filtered.length === 1) return filtered[0]\n\n    return materials\n  }\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name\n    })[0]\n  }\n\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true\n      })\n    }\n\n    if (!duplicateUVs) return\n\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2))\n  }\n}\n\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader\n  }\n\n  parse() {\n    const materials = []\n    this.textures = {}\n\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures))\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures))\n      }\n    }\n\n    return materials\n  }\n\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes),\n    }\n\n    const connections = this.parseConnections(materialData.connections, materialData.nodes)\n\n    const maps = this.parseTextureNodes(connections.maps)\n\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps)\n\n    const attributes = this.parseAttributes(connections.attributes, maps)\n\n    this.parseEnvMap(connections, maps, attributes)\n\n    params = Object.assign(maps, params)\n    params = Object.assign(params, attributes)\n\n    const materialType = this.getMaterialType(connections.attributes)\n\n    return new materialType(params)\n  }\n\n  parseMaterialLwo2(materialData, name /*, textures*/) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes),\n    }\n\n    const attributes = this.parseAttributes(materialData.attributes, {})\n    params = Object.assign(params, attributes)\n    return new MeshPhongMaterial(params)\n  }\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide\n      case 2:\n        return FrontSide\n      case 3:\n        return DoubleSide\n    }\n  }\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true\n    return !attributes.smooth\n  }\n\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {},\n    }\n\n    const inputName = connections.inputName\n    const inputNodeName = connections.inputNodeName\n    const nodeName = connections.nodeName\n\n    const scope = this\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes)\n        materialConnections.attributes = matNode.attributes\n        materialConnections.envMap = matNode.fileName\n        materialConnections.name = inputNodeName[index]\n      }\n    })\n\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes)\n      }\n    })\n\n    return materialConnections\n  }\n\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name]\n    }\n  }\n\n  parseTextureNodes(textureNodes) {\n    const maps = {}\n\n    for (const name in textureNodes) {\n      const node = textureNodes[name]\n      const path = node.fileName\n\n      if (!path) return\n\n      const texture = this.loadTexture(path)\n\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode)\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode)\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture\n          break\n        case 'Roughness':\n          maps.roughnessMap = texture\n          maps.roughness = 0.5\n          break\n        case 'Specular':\n          maps.specularMap = texture\n          maps.specular = 0xffffff\n          break\n        case 'Luminous':\n          maps.emissiveMap = texture\n          maps.emissive = 0x808080\n          break\n        case 'Luminous Color':\n          maps.emissive = 0x808080\n          break\n        case 'Metallic':\n          maps.metalnessMap = texture\n          maps.metalness = 0.5\n          break\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture\n          maps.transparent = true\n          break\n        case 'Normal':\n          maps.normalMap = texture\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude)\n          break\n        case 'Bump':\n          maps.bumpMap = texture\n          break\n      }\n    }\n\n    // LWO BSDF materials can have both spec and rough, but this is not valid in three\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap\n\n    return maps\n  }\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name]\n\n      if (attribute.maps) {\n        const mapData = attribute.maps[0]\n\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures)\n        if (!path) return\n\n        const texture = this.loadTexture(path)\n\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w)\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h)\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture\n            break\n          case 'Diffuse':\n            maps.aoMap = texture\n            break\n          case 'Roughness':\n            maps.roughnessMap = texture\n            maps.roughness = 1\n            break\n          case 'Specular':\n            maps.specularMap = texture\n            maps.specular = 0xffffff\n            break\n          case 'Luminosity':\n            maps.emissiveMap = texture\n            maps.emissive = 0x808080\n            break\n          case 'Metallic':\n            maps.metalnessMap = texture\n            maps.metalness = 1\n            break\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture\n            maps.transparent = true\n            break\n          case 'Normal':\n            maps.normalMap = texture\n            break\n          case 'Bump':\n            maps.bumpMap = texture\n            break\n        }\n      }\n    }\n  }\n\n  parseAttributes(attributes, maps) {\n    const params = {}\n\n    // don't use color data if color map is present\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value)\n    } else {\n      params.color = new Color()\n    }\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value\n      params.transparent = true\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1\n\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value\n\n    this.parsePhysicalAttributes(params, attributes, maps)\n    this.parseStandardAttributes(params, attributes, maps)\n    this.parsePhongAttributes(params, attributes, maps)\n\n    return params\n  }\n\n  parsePhysicalAttributes(params, attributes /*, maps*/) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value)\n      }\n    }\n  }\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value)\n      } else {\n        params.emissive = new Color(0x808080)\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value\n  }\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value)\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value\n      params.combine = AddOperation\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color\n      } else {\n        params.emissive = new Color(0x808080)\n      }\n    }\n\n    // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color()\n          .setScalar(attributes.Specular.value)\n          .lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value)\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value)\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2)\n    }\n  }\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap)\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping\n\n        // Reflectivity and refraction mapping don't work well together in Phong materials\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity\n          delete attributes.combine\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping\n      }\n\n      maps.envMap = envMap\n    }\n  }\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = ''\n\n    if (!_lwoTree.textures) return fileName\n\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName\n    })\n\n    return fileName\n  }\n\n  loadTexture(path) {\n    if (!path) return null\n\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn(\n        'LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.',\n      )\n    })\n\n    return texture\n  }\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js')\n        return ClampToEdgeWrapping\n      case 1:\n        return RepeatWrapping\n      case 2:\n        return MirroredRepeatWrapping\n      case 3:\n        return ClampToEdgeWrapping\n    }\n  }\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial\n    if (nodeData.Roughness) return MeshStandardMaterial\n    return MeshPhongMaterial\n  }\n}\n\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry()\n\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3))\n\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions)\n    geometry.setIndex(indices)\n\n    this.parseGroups(geometry, geoData)\n\n    geometry.computeVertexNormals()\n\n    this.parseUVs(geometry, layer, indices)\n    this.parseMorphTargets(geometry, layer, indices)\n\n    // TODO: z may need to be reversed to account for coordinate system change\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2])\n\n    // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry\n  }\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = []\n\n    let i = 0\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k])\n      } else if (dim === 4) {\n        remappedIndices.push(\n          indices[i],\n          indices[i + 1],\n          indices[i + 2],\n\n          indices[i],\n          indices[i + 2],\n          indices[i + 3],\n        )\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1])\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported')\n      }\n\n      i += dim\n    })\n\n    return remappedIndices\n  }\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags\n    const matNames = []\n\n    let elemSize = 3\n    if (geoData.type === 'lines') elemSize = 2\n    if (geoData.type === 'points') elemSize = 1\n\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices)\n\n    let indexNum = 0 // create new indices in numerical order\n    const indexPairs = {} // original indices mapped to numerical indices\n\n    let prevMaterialIndex\n    let materialIndex\n\n    let prevStart = 0\n    let currentCount = 0\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1]\n\n      if (i === 0) matNames[indexNum] = tags[materialIndex]\n\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex\n\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]]\n        } else {\n          currentIndex = indexNum\n          indexPairs[tags[prevMaterialIndex]] = indexNum\n          matNames[indexNum] = tags[prevMaterialIndex]\n          indexNum++\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex)\n\n        prevStart += currentCount\n\n        prevMaterialIndex = materialIndex\n        currentCount = 0\n      }\n\n      currentCount += elemSize\n    }\n\n    // the loop above doesn't add the last group, do that here.\n    if (geometry.groups.length > 0) {\n      let currentIndex\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]]\n      } else {\n        currentIndex = indexNum\n        indexPairs[tags[materialIndex]] = indexNum\n        matNames[indexNum] = tags[materialIndex]\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex)\n    }\n\n    // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n    geometry.userData.matNames = matNames\n  }\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = []\n\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1])\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1])\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1])\n        }\n      }\n    })\n\n    return remappedIndices\n  }\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0\n    })\n\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs\n      const uvIndices = layer.uvs[name].uvIndices\n\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2]\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1]\n      })\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2))\n  }\n\n  parseMorphTargets(geometry, layer) {\n    let num = 0\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice()\n\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = []\n\n      const morphPoints = layer.morphTargets[name].points\n      const morphIndices = layer.morphTargets[name].indices\n      const type = layer.morphTargets[name].type\n\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3]\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1]\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2]\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3]\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1]\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2]\n        }\n      })\n\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3)\n      geometry.morphAttributes.position[num].name = name\n\n      num++\n    }\n\n    geometry.morphTargetsRelative = false\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir)\n\n  if (index === -1) return './'\n\n  return url.substr(0, index)\n}\n\nexport { LWOLoader }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 32282, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/PLYLoader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/loaders/PLYLoader.js"],"sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils } from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * diffuse_(red|green|blue) in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.propertyNameMapping = {}\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping\n  }\n\n  parse(data) {\n    function parseHeader(data) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/\n      let headerText = ''\n      let headerLength = 0\n      const result = patternHeader.exec(data)\n\n      if (result !== null) {\n        headerText = result[1]\n        headerLength = new Blob([result[0]]).size\n      }\n\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: '',\n      }\n\n      const lines = headerText.split('\\n')\n      let currentElement\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = { type: propertValues[0] }\n\n        if (property.type === 'list') {\n          property.name = propertValues[3]\n          property.countType = propertValues[1]\n          property.itemType = propertValues[2]\n        } else {\n          property.name = propertValues[1]\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name]\n        }\n\n        return property\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        line = line.trim()\n\n        if (line === '') continue\n\n        const lineValues = line.split(/\\s+/)\n        const lineType = lineValues.shift()\n        line = lineValues.join(' ')\n\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0]\n            header.version = lineValues[1]\n\n            break\n\n          case 'comment':\n            header.comments.push(line)\n\n            break\n\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement)\n            }\n\n            currentElement = {}\n            currentElement.name = lineValues[0]\n            currentElement.count = parseInt(lineValues[1])\n            currentElement.properties = []\n\n            break\n\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping))\n\n            break\n\n          case 'obj_info':\n            header.objInfo = line\n\n            break\n\n          default:\n            console.log('unhandled', lineType, lineValues)\n        }\n      }\n\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement)\n      }\n\n      return header\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n)\n\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n)\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/)\n\n      const element = {}\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = []\n          const n = parseASCIINumber(values.shift(), properties[i].countType)\n\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType))\n          }\n\n          element[properties[i].name] = list\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type)\n        }\n      }\n\n      return element\n    }\n\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n      }\n\n      let result\n\n      const patternBody = /end_header\\s([\\s\\S]*)$/\n      let body = ''\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1]\n      }\n\n      const lines = body.split('\\n')\n      let currentElement = 0\n      let currentElementCount = 0\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        line = line.trim()\n        if (line === '') {\n          continue\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++\n          currentElementCount = 0\n        }\n\n        const element = parseASCIIElement(header.elements[currentElement].properties, line)\n\n        handleElement(buffer, header.elements[currentElement].name, element)\n\n        currentElementCount++\n      }\n\n      return postProcess(buffer)\n    }\n\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry()\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices)\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3))\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3))\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2))\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3))\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed()\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2))\n      }\n\n      geometry.computeBoundingSphere()\n\n      return geometry\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z)\n\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz)\n        }\n\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t)\n        }\n\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0)\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index // issue #9338\n        const texcoord = element.texcoord\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2])\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1])\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3])\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5])\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3])\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3])\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1]\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1]\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2]\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2]\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4]\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4]\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4]\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8]\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {}\n      let result,\n        read = 0\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = []\n\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian)\n          const n = result[0]\n          read += result[1]\n\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian)\n            list.push(result[0])\n            read += result[1]\n          }\n\n          element[properties[i].name] = list\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian)\n          element[properties[i].name] = result[0]\n          read += result[1]\n        }\n      }\n\n      return [element, read]\n    }\n\n    function parseBinary(data, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n      }\n\n      const little_endian = header.format === 'binary_little_endian'\n      const body = new DataView(data, header.headerLength)\n      let result,\n        loc = 0\n\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (\n          let currentElementCount = 0;\n          currentElementCount < header.elements[currentElement].count;\n          currentElementCount++\n        ) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian)\n          loc += result[1]\n          const element = result[0]\n\n          handleElement(buffer, header.elements[currentElement].name, element)\n        }\n      }\n\n      return postProcess(buffer)\n    }\n\n    //\n\n    let geometry\n    const scope = this\n\n    if (data instanceof ArrayBuffer) {\n      const text = decodeText(new Uint8Array(data))\n      const header = parseHeader(text)\n\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header)\n    } else {\n      geometry = parseASCII(data, parseHeader(data))\n    }\n\n    return geometry\n  }\n}\n\nexport { PLYLoader }\n"],"names":["data","geometry"],"mappings":"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"}}]
}