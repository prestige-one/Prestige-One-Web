{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/libs/chevrotain.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/libs/chevrotain.js"],"sourcesContent":["const { CstParser, Lexer, createToken } = /* @__PURE__ */ (() => {\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global\n\n  const freeGlobal$1 = freeGlobal\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal$1 || freeSelf || Function('return this')()\n\n  const root$1 = root\n\n  /** Built-in value references. */\n  var Symbol$1 = root$1.Symbol\n\n  const Symbol$2 = Symbol$1\n\n  /** Used for built-in method references. */\n  var objectProto$j = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$g = objectProto$j.hasOwnProperty\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$j.toString\n\n  /** Built-in value references. */\n  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty$g.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1]\n\n    try {\n      value[symToStringTag$1] = undefined\n      var unmasked = true\n    } catch (e) {}\n\n    var result = nativeObjectToString$1.call(value)\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag\n      } else {\n        delete value[symToStringTag$1]\n      }\n    }\n    return result\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$i = Object.prototype\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto$i.toString\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value)\n  }\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]'\n\n  /** Built-in value references. */\n  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object'\n  }\n\n  /** `Object#toString` result references. */\n  var symbolTag$3 = '[object Symbol]'\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag$3)\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length)\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array)\n    }\n    return result\n  }\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray\n\n  const isArray$1 = isArray\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$3 = 1 / 0\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value\n    }\n    if (isArray$1(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + ''\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : ''\n    }\n    var result = value + ''\n    return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result\n  }\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index\n  }\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value\n    return value != null && (type == 'object' || type == 'function')\n  }\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value\n    }\n    if (isSymbol(value)) {\n      return NAN\n    }\n    if (isObject(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value\n      value = isObject(other) ? other + '' : other\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value\n    }\n    value = baseTrim(value)\n    var isBinary = reIsBinary.test(value)\n    return isBinary || reIsOctal.test(value)\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : reIsBadHex.test(value)\n      ? NAN\n      : +value\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$2 = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e308\n\n  /**\n   * Converts `value` to a finite number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.12.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted number.\n   * @example\n   *\n   * _.toFinite(3.2);\n   * // => 3.2\n   *\n   * _.toFinite(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toFinite(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toFinite('3.2');\n   * // => 3.2\n   */\n  function toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0\n    }\n    value = toNumber(value)\n    if (value === INFINITY$2 || value === -INFINITY$2) {\n      var sign = value < 0 ? -1 : 1\n      return sign * MAX_INTEGER\n    }\n    return value === value ? value : 0\n  }\n\n  /**\n   * Converts `value` to an integer.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted integer.\n   * @example\n   *\n   * _.toInteger(3.2);\n   * // => 3\n   *\n   * _.toInteger(Number.MIN_VALUE);\n   * // => 0\n   *\n   * _.toInteger(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toInteger('3.2');\n   * // => 3\n   */\n  function toInteger(value) {\n    var result = toFinite(value),\n      remainder = result % 1\n\n    return result === result ? (remainder ? result - remainder : result) : 0\n  }\n\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value\n  }\n\n  /** `Object#toString` result references. */\n  var asyncTag = '[object AsyncFunction]',\n    funcTag$2 = '[object Function]',\n    genTag$1 = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]'\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag(value)\n    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag\n  }\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root$1['__core-js_shared__']\n\n  const coreJsData$1 = coreJsData\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function () {\n    var uid = /[^.]+$/.exec((coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO) || '')\n    return uid ? 'Symbol(src)_1.' + uid : ''\n  })()\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func\n  }\n\n  /** Used for built-in method references. */\n  var funcProto$1 = Function.prototype\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString$1 = funcProto$1.toString\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString$1.call(func)\n      } catch (e) {}\n      try {\n        return func + ''\n      } catch (e) {}\n    }\n    return ''\n  }\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype,\n    objectProto$h = Object.prototype\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$f = objectProto$h.hasOwnProperty\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp(\n    '^' +\n      funcToString\n        .call(hasOwnProperty$f)\n        .replace(reRegExpChar, '\\\\$&')\n        .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') +\n      '$',\n  )\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor\n    return pattern.test(toSource(value))\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key]\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key)\n    return baseIsNative(value) ? value : undefined\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var WeakMap = getNative(root$1, 'WeakMap')\n\n  const WeakMap$1 = WeakMap\n\n  /** Built-in value references. */\n  var objectCreate = Object.create\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} proto The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  var baseCreate = (function () {\n    function object() {}\n    return function (proto) {\n      if (!isObject(proto)) {\n        return {}\n      }\n      if (objectCreate) {\n        return objectCreate(proto)\n      }\n      object.prototype = proto\n      var result = new object()\n      object.prototype = undefined\n      return result\n    }\n  })()\n\n  const baseCreate$1 = baseCreate\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg)\n      case 1:\n        return func.call(thisArg, args[0])\n      case 2:\n        return func.call(thisArg, args[0], args[1])\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2])\n    }\n    return func.apply(thisArg, args)\n  }\n\n  /**\n   * This method returns `undefined`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.3.0\n   * @category Util\n   * @example\n   *\n   * _.times(2, _.noop);\n   * // => [undefined, undefined]\n   */\n  function noop() {\n    // No operation performed.\n  }\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n      length = source.length\n\n    array || (array = Array(length))\n    while (++index < length) {\n      array[index] = source[index]\n    }\n    return array\n  }\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n    HOT_SPAN = 16\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeNow = Date.now\n\n  /**\n   * Creates a function that'll short out and invoke `identity` instead\n   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n   * milliseconds.\n   *\n   * @private\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new shortable function.\n   */\n  function shortOut(func) {\n    var count = 0,\n      lastCalled = 0\n\n    return function () {\n      var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled)\n\n      lastCalled = stamp\n      if (remaining > 0) {\n        if (++count >= HOT_COUNT) {\n          return arguments[0]\n        }\n      } else {\n        count = 0\n      }\n      return func.apply(undefined, arguments)\n    }\n  }\n\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n  function constant(value) {\n    return function () {\n      return value\n    }\n  }\n\n  var defineProperty = (function () {\n    try {\n      var func = getNative(Object, 'defineProperty')\n      func({}, '', {})\n      return func\n    } catch (e) {}\n  })()\n\n  const defineProperty$1 = defineProperty\n\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var baseSetToString = !defineProperty$1\n    ? identity\n    : function (func, string) {\n        return defineProperty$1(func, 'toString', {\n          configurable: true,\n          enumerable: false,\n          value: constant(string),\n          writable: true,\n        })\n      }\n\n  const baseSetToString$1 = baseSetToString\n\n  /**\n   * Sets the `toString` method of `func` to return `string`.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var setToString = shortOut(baseSetToString$1)\n\n  const setToString$1 = setToString\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break\n      }\n    }\n    return array\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1)\n\n    while (fromRight ? index-- : ++index < length) {\n      if (predicate(array[index], index, array)) {\n        return index\n      }\n    }\n    return -1\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n      length = array.length\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index\n      }\n    }\n    return -1\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length\n    return !!length && baseIndexOf(array, value, 0) > -1\n  }\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER$1 = 9007199254740991\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    var type = typeof value\n    length = length == null ? MAX_SAFE_INTEGER$1 : length\n\n    return (\n      !!length &&\n      (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&\n      value > -1 &&\n      value % 1 == 0 &&\n      value < length\n    )\n  }\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && defineProperty$1) {\n      defineProperty$1(object, key, {\n        configurable: true,\n        enumerable: true,\n        value: value,\n        writable: true,\n      })\n    } else {\n      object[key] = value\n    }\n  }\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$g = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$e = objectProto$g.hasOwnProperty\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key]\n    if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {\n      baseAssignValue(object, key, value)\n    }\n  }\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object\n    object || (object = {})\n\n    var index = -1,\n      length = props.length\n\n    while (++index < length) {\n      var key = props[index]\n\n      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined\n\n      if (newValue === undefined) {\n        newValue = source[key]\n      }\n      if (isNew) {\n        baseAssignValue(object, key, newValue)\n      } else {\n        assignValue(object, key, newValue)\n      }\n    }\n    return object\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$3 = Math.max\n\n  /**\n   * A specialized version of `baseRest` which transforms the rest array.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @param {Function} transform The rest array transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overRest(func, start, transform) {\n    start = nativeMax$3(start === undefined ? func.length - 1 : start, 0)\n    return function () {\n      var args = arguments,\n        index = -1,\n        length = nativeMax$3(args.length - start, 0),\n        array = Array(length)\n\n      while (++index < length) {\n        array[index] = args[start + index]\n      }\n      index = -1\n      var otherArgs = Array(start + 1)\n      while (++index < start) {\n        otherArgs[index] = args[index]\n      }\n      otherArgs[start] = transform(array)\n      return apply(func, this, otherArgs)\n    }\n  }\n\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n  function baseRest(func, start) {\n    return setToString$1(overRest(func, start, identity), func + '')\n  }\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER\n  }\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value)\n  }\n\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n  function isIterateeCall(value, index, object) {\n    if (!isObject(object)) {\n      return false\n    }\n    var type = typeof index\n    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n      return eq(object[index], value)\n    }\n    return false\n  }\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return baseRest(function (object, sources) {\n      var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined\n\n      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer\n        length = 1\n      }\n      object = Object(object)\n      while (++index < length) {\n        var source = sources[index]\n        if (source) {\n          assigner(object, source, index, customizer)\n        }\n      }\n      return object\n    })\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$f = Object.prototype\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$f\n\n    return value === proto\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n      result = Array(n)\n\n    while (++index < n) {\n      result[index] = iteratee(index)\n    }\n    return result\n  }\n\n  /** `Object#toString` result references. */\n  var argsTag$3 = '[object Arguments]'\n\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag$3\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$e = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$d = objectProto$e.hasOwnProperty\n\n  /** Built-in value references. */\n  var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  var isArguments = baseIsArguments(\n    (function () {\n      return arguments\n    })(),\n  )\n    ? baseIsArguments\n    : function (value) {\n        return (\n          isObjectLike(value) && hasOwnProperty$d.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee')\n        )\n      }\n\n  const isArguments$1 = isArguments\n\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2\n\n  /** Built-in value references. */\n  var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined\n\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n  var isBuffer = nativeIsBuffer || stubFalse\n\n  const isBuffer$1 = isBuffer\n\n  /** `Object#toString` result references. */\n  var argsTag$2 = '[object Arguments]',\n    arrayTag$2 = '[object Array]',\n    boolTag$3 = '[object Boolean]',\n    dateTag$3 = '[object Date]',\n    errorTag$2 = '[object Error]',\n    funcTag$1 = '[object Function]',\n    mapTag$6 = '[object Map]',\n    numberTag$3 = '[object Number]',\n    objectTag$3 = '[object Object]',\n    regexpTag$4 = '[object RegExp]',\n    setTag$6 = '[object Set]',\n    stringTag$4 = '[object String]',\n    weakMapTag$2 = '[object WeakMap]'\n\n  var arrayBufferTag$3 = '[object ArrayBuffer]',\n    dataViewTag$4 = '[object DataView]',\n    float32Tag$2 = '[object Float32Array]',\n    float64Tag$2 = '[object Float64Array]',\n    int8Tag$2 = '[object Int8Array]',\n    int16Tag$2 = '[object Int16Array]',\n    int32Tag$2 = '[object Int32Array]',\n    uint8Tag$2 = '[object Uint8Array]',\n    uint8ClampedTag$2 = '[object Uint8ClampedArray]',\n    uint16Tag$2 = '[object Uint16Array]',\n    uint32Tag$2 = '[object Uint32Array]'\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {}\n  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[\n    int16Tag$2\n  ] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[\n    uint16Tag$2\n  ] = typedArrayTags[uint32Tag$2] = true\n  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[\n    boolTag$3\n  ] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[\n    funcTag$1\n  ] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[\n    regexpTag$4\n  ] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false\n\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function (value) {\n      return func(value)\n    }\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports$1 && freeGlobal$1.process\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function () {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types\n\n      if (types) {\n        return types\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util')\n    } catch (e) {}\n  })()\n\n  const nodeUtil$1 = nodeUtil\n\n  /* Node.js helper references. */\n  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray\n\n  const isTypedArray$1 = isTypedArray\n\n  /** Used for built-in method references. */\n  var objectProto$d = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$c = objectProto$d.hasOwnProperty\n\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray$1(value),\n      isArg = !isArr && isArguments$1(value),\n      isBuff = !isArr && !isArg && isBuffer$1(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length\n\n    for (var key in value) {\n      if (\n        (inherited || hasOwnProperty$c.call(value, key)) &&\n        !(\n          skipIndexes &&\n          // Safari 9 has enumerable `arguments.length` in strict mode.\n          (key == 'length' ||\n            // Node.js 0.10 has enumerable non-index properties on buffers.\n            (isBuff && (key == 'offset' || key == 'parent')) ||\n            // PhantomJS 2 has enumerable non-index properties on typed arrays.\n            (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n            // Skip index properties.\n            isIndex(key, length))\n        )\n      ) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg))\n    }\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeKeys = overArg(Object.keys, Object)\n\n  const nativeKeys$1 = nativeKeys\n\n  /** Used for built-in method references. */\n  var objectProto$c = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$b = objectProto$c.hasOwnProperty\n\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys$1(object)\n    }\n    var result = []\n    for (var key in Object(object)) {\n      if (hasOwnProperty$b.call(object, key) && key != 'constructor') {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$b = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$a = objectProto$b.hasOwnProperty\n\n  /**\n   * Assigns own enumerable string keyed properties of source objects to the\n   * destination object. Source objects are applied from left to right.\n   * Subsequent sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object` and is loosely based on\n   * [`Object.assign`](https://mdn.io/Object/assign).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.10.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.assignIn\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * function Bar() {\n   *   this.c = 3;\n   * }\n   *\n   * Foo.prototype.b = 2;\n   * Bar.prototype.d = 4;\n   *\n   * _.assign({ 'a': 0 }, new Foo, new Bar);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  var assign = createAssigner(function (object, source) {\n    if (isPrototype(source) || isArrayLike(source)) {\n      copyObject(source, keys(source), object)\n      return\n    }\n    for (var key in source) {\n      if (hasOwnProperty$a.call(source, key)) {\n        assignValue(object, key, source[key])\n      }\n    }\n  })\n\n  const assign$1 = assign\n\n  /**\n   * This function is like\n   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * except that it includes inherited enumerable properties.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function nativeKeysIn(object) {\n    var result = []\n    if (object != null) {\n      for (var key in Object(object)) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$a = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$9 = objectProto$a.hasOwnProperty\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    if (!isObject(object)) {\n      return nativeKeysIn(object)\n    }\n    var isProto = isPrototype(object),\n      result = []\n\n    for (var key in object) {\n      if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n  function keysIn(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object)\n  }\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray$1(value)) {\n      return false\n    }\n    var type = typeof value\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object))\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var nativeCreate = getNative(Object, 'create')\n\n  const nativeCreate$1 = nativeCreate\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}\n    this.size = 0\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key]\n    this.size -= result ? 1 : 0\n    return result\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__'\n\n  /** Used for built-in method references. */\n  var objectProto$9 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$8 = objectProto$9.hasOwnProperty\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__\n    if (nativeCreate$1) {\n      var result = data[key]\n      return result === HASH_UNDEFINED$2 ? undefined : result\n    }\n    return hasOwnProperty$8.call(data, key) ? data[key] : undefined\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$8 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$7 = objectProto$8.hasOwnProperty\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__\n    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$7.call(data, key)\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__'\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__\n    this.size += this.has(key) ? 0 : 1\n    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$1 : value\n    return this\n  }\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear\n  Hash.prototype['delete'] = hashDelete\n  Hash.prototype.get = hashGet\n  Hash.prototype.has = hashHas\n  Hash.prototype.set = hashSet\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = []\n    this.size = 0\n  }\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length\n      }\n    }\n    return -1\n  }\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    if (index < 0) {\n      return false\n    }\n    var lastIndex = data.length - 1\n    if (index == lastIndex) {\n      data.pop()\n    } else {\n      splice.call(data, index, 1)\n    }\n    --this.size\n    return true\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    return index < 0 ? undefined : data[index][1]\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    if (index < 0) {\n      ++this.size\n      data.push([key, value])\n    } else {\n      data[index][1] = value\n    }\n    return this\n  }\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear\n  ListCache.prototype['delete'] = listCacheDelete\n  ListCache.prototype.get = listCacheGet\n  ListCache.prototype.has = listCacheHas\n  ListCache.prototype.set = listCacheSet\n\n  /* Built-in method references that are verified to be native. */\n  var Map$1 = getNative(root$1, 'Map')\n\n  const Map$2 = Map$1\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.size = 0\n    this.__data__ = {\n      hash: new Hash(),\n      map: new (Map$2 || ListCache)(),\n      string: new Hash(),\n    }\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'\n      ? value !== '__proto__'\n      : value === null\n  }\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key)\n    this.size -= result ? 1 : 0\n    return result\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key)\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key)\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n      size = data.size\n\n    data.set(key, value)\n    this.size += data.size == size ? 0 : 1\n    return this\n  }\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear\n  MapCache.prototype['delete'] = mapCacheDelete\n  MapCache.prototype.get = mapCacheGet\n  MapCache.prototype.has = mapCacheHas\n  MapCache.prototype.set = mapCacheSet\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT$1 = 'Expected a function'\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT$1)\n    }\n    var memoized = function () {\n      var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache\n\n      if (cache.has(key)) {\n        return cache.get(key)\n      }\n      var result = func.apply(this, args)\n      memoized.cache = cache.set(key, result) || cache\n      return result\n    }\n    memoized.cache = new (memoize.Cache || MapCache)()\n    return memoized\n  }\n\n  // Expose `MapCache`.\n  memoize.Cache = MapCache\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500\n\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear()\n      }\n      return key\n    })\n\n    var cache = result.cache\n    return result\n  }\n\n  /** Used to match property names within property paths. */\n  var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = memoizeCapped(function (string) {\n    var result = []\n    if (string.charCodeAt(0) === 46 /* . */) {\n      result.push('')\n    }\n    string.replace(rePropName, function (match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match)\n    })\n    return result\n  })\n\n  const stringToPath$1 = stringToPath\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value)\n  }\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value, object) {\n    if (isArray$1(value)) {\n      return value\n    }\n    return isKey(value, object) ? [value] : stringToPath$1(toString(value))\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$1 = 1 / 0\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value\n    }\n    var result = value + ''\n    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result\n  }\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = castPath(path, object)\n\n    var index = 0,\n      length = path.length\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])]\n    }\n    return index && index == length ? object : undefined\n  }\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path)\n    return result === undefined ? defaultValue : result\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n      length = values.length,\n      offset = array.length\n\n    while (++index < length) {\n      array[offset + index] = values[index]\n    }\n    return array\n  }\n\n  /** Built-in value references. */\n  var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined\n\n  /**\n   * Checks if `value` is a flattenable `arguments` object or array.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n   */\n  function isFlattenable(value) {\n    return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol])\n  }\n\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n      length = array.length\n\n    predicate || (predicate = isFlattenable)\n    result || (result = [])\n\n    while (++index < length) {\n      var value = array[index]\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result)\n        } else {\n          arrayPush(result, value)\n        }\n      } else if (!isStrict) {\n        result[result.length] = value\n      }\n    }\n    return result\n  }\n\n  /**\n   * Flattens `array` a single level deep.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to flatten.\n   * @returns {Array} Returns the new flattened array.\n   * @example\n   *\n   * _.flatten([1, [2, [3, [4]], 5]]);\n   * // => [1, 2, [3, [4]], 5]\n   */\n  function flatten(array) {\n    var length = array == null ? 0 : array.length\n    return length ? baseFlatten(array, 1) : []\n  }\n\n  /** Built-in value references. */\n  var getPrototype = overArg(Object.getPrototypeOf, Object)\n\n  const getPrototype$1 = getPrototype\n\n  /**\n   * The base implementation of `_.slice` without an iteratee call guard.\n   *\n   * @private\n   * @param {Array} array The array to slice.\n   * @param {number} [start=0] The start position.\n   * @param {number} [end=array.length] The end position.\n   * @returns {Array} Returns the slice of `array`.\n   */\n  function baseSlice(array, start, end) {\n    var index = -1,\n      length = array.length\n\n    if (start < 0) {\n      start = -start > length ? 0 : length + start\n    }\n    end = end > length ? length : end\n    if (end < 0) {\n      end += length\n    }\n    length = start > end ? 0 : (end - start) >>> 0\n    start >>>= 0\n\n    var result = Array(length)\n    while (++index < length) {\n      result[index] = array[index + start]\n    }\n    return result\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    if (initAccum && length) {\n      accumulator = array[++index]\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array)\n    }\n    return accumulator\n  }\n\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n  function stackClear() {\n    this.__data__ = new ListCache()\n    this.size = 0\n  }\n\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function stackDelete(key) {\n    var data = this.__data__,\n      result = data['delete'](key)\n\n    this.size = data.size\n    return result\n  }\n\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function stackGet(key) {\n    return this.__data__.get(key)\n  }\n\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function stackHas(key) {\n    return this.__data__.has(key)\n  }\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE$2 = 200\n\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n  function stackSet(key, value) {\n    var data = this.__data__\n    if (data instanceof ListCache) {\n      var pairs = data.__data__\n      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {\n        pairs.push([key, value])\n        this.size = ++data.size\n        return this\n      }\n      data = this.__data__ = new MapCache(pairs)\n    }\n    data.set(key, value)\n    this.size = data.size\n    return this\n  }\n\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Stack(entries) {\n    var data = (this.__data__ = new ListCache(entries))\n    this.size = data.size\n  }\n\n  // Add methods to `Stack`.\n  Stack.prototype.clear = stackClear\n  Stack.prototype['delete'] = stackDelete\n  Stack.prototype.get = stackGet\n  Stack.prototype.has = stackHas\n  Stack.prototype.set = stackSet\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object)\n  }\n\n  /**\n   * The base implementation of `_.assignIn` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssignIn(object, source) {\n    return object && copyObject(source, keysIn(source), object)\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root$1.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice()\n    }\n    var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length)\n\n    buffer.copy(result)\n    return result\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = []\n\n    while (++index < length) {\n      var value = array[index]\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value\n      }\n    }\n    return result\n  }\n\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n  function stubArray() {\n    return []\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$7 = Object.prototype\n\n  /** Built-in value references. */\n  var propertyIsEnumerable = objectProto$7.propertyIsEnumerable\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols$1 = Object.getOwnPropertySymbols\n\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbols = !nativeGetSymbols$1\n    ? stubArray\n    : function (object) {\n        if (object == null) {\n          return []\n        }\n        object = Object(object)\n        return arrayFilter(nativeGetSymbols$1(object), function (symbol) {\n          return propertyIsEnumerable.call(object, symbol)\n        })\n      }\n\n  const getSymbols$1 = getSymbols\n\n  /**\n   * Copies own symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols$1(source), object)\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols = Object.getOwnPropertySymbols\n\n  /**\n   * Creates an array of the own and inherited enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbolsIn = !nativeGetSymbols\n    ? stubArray\n    : function (object) {\n        var result = []\n        while (object) {\n          arrayPush(result, getSymbols$1(object))\n          object = getPrototype$1(object)\n        }\n        return result\n      }\n\n  const getSymbolsIn$1 = getSymbolsIn\n\n  /**\n   * Copies own and inherited symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbolsIn(source, object) {\n    return copyObject(source, getSymbolsIn$1(source), object)\n  }\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object)\n    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object))\n  }\n\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols$1)\n  }\n\n  /**\n   * Creates an array of own and inherited enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeysIn(object) {\n    return baseGetAllKeys(object, keysIn, getSymbolsIn$1)\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var DataView = getNative(root$1, 'DataView')\n\n  const DataView$1 = DataView\n\n  /* Built-in method references that are verified to be native. */\n  var Promise$1 = getNative(root$1, 'Promise')\n\n  const Promise$2 = Promise$1\n\n  /* Built-in method references that are verified to be native. */\n  var Set = getNative(root$1, 'Set')\n\n  const Set$1 = Set\n\n  /** `Object#toString` result references. */\n  var mapTag$5 = '[object Map]',\n    objectTag$2 = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag$5 = '[object Set]',\n    weakMapTag$1 = '[object WeakMap]'\n\n  var dataViewTag$3 = '[object DataView]'\n\n  /** Used to detect maps, sets, and weakmaps. */\n  var dataViewCtorString = toSource(DataView$1),\n    mapCtorString = toSource(Map$2),\n    promiseCtorString = toSource(Promise$2),\n    setCtorString = toSource(Set$1),\n    weakMapCtorString = toSource(WeakMap$1)\n\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  var getTag = baseGetTag\n\n  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n  if (\n    (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3) ||\n    (Map$2 && getTag(new Map$2()) != mapTag$5) ||\n    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||\n    (Set$1 && getTag(new Set$1()) != setTag$5) ||\n    (WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1)\n  ) {\n    getTag = function (value) {\n      var result = baseGetTag(value),\n        Ctor = result == objectTag$2 ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : ''\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag$3\n          case mapCtorString:\n            return mapTag$5\n          case promiseCtorString:\n            return promiseTag\n          case setCtorString:\n            return setTag$5\n          case weakMapCtorString:\n            return weakMapTag$1\n        }\n      }\n      return result\n    }\n  }\n\n  const getTag$1 = getTag\n\n  /** Used for built-in method references. */\n  var objectProto$6 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$6 = objectProto$6.hasOwnProperty\n\n  /**\n   * Initializes an array clone.\n   *\n   * @private\n   * @param {Array} array The array to clone.\n   * @returns {Array} Returns the initialized clone.\n   */\n  function initCloneArray(array) {\n    var length = array.length,\n      result = new array.constructor(length)\n\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty$6.call(array, 'index')) {\n      result.index = array.index\n      result.input = array.input\n    }\n    return result\n  }\n\n  /** Built-in value references. */\n  var Uint8Array = root$1.Uint8Array\n\n  const Uint8Array$1 = Uint8Array\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength)\n    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer))\n    return result\n  }\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)\n  }\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp))\n    result.lastIndex = regexp.lastIndex\n    return result\n  }\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {}\n  }\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)\n  }\n\n  /** `Object#toString` result references. */\n  var boolTag$2 = '[object Boolean]',\n    dateTag$2 = '[object Date]',\n    mapTag$4 = '[object Map]',\n    numberTag$2 = '[object Number]',\n    regexpTag$3 = '[object RegExp]',\n    setTag$4 = '[object Set]',\n    stringTag$3 = '[object String]',\n    symbolTag$2 = '[object Symbol]'\n\n  var arrayBufferTag$2 = '[object ArrayBuffer]',\n    dataViewTag$2 = '[object DataView]',\n    float32Tag$1 = '[object Float32Array]',\n    float64Tag$1 = '[object Float64Array]',\n    int8Tag$1 = '[object Int8Array]',\n    int16Tag$1 = '[object Int16Array]',\n    int32Tag$1 = '[object Int32Array]',\n    uint8Tag$1 = '[object Uint8Array]',\n    uint8ClampedTag$1 = '[object Uint8ClampedArray]',\n    uint16Tag$1 = '[object Uint16Array]',\n    uint32Tag$1 = '[object Uint32Array]'\n\n  /**\n   * Initializes an object clone based on its `toStringTag`.\n   *\n   * **Note:** This function only supports cloning values with tags of\n   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {string} tag The `toStringTag` of the object to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneByTag(object, tag, isDeep) {\n    var Ctor = object.constructor\n    switch (tag) {\n      case arrayBufferTag$2:\n        return cloneArrayBuffer(object)\n\n      case boolTag$2:\n      case dateTag$2:\n        return new Ctor(+object)\n\n      case dataViewTag$2:\n        return cloneDataView(object, isDeep)\n\n      case float32Tag$1:\n      case float64Tag$1:\n      case int8Tag$1:\n      case int16Tag$1:\n      case int32Tag$1:\n      case uint8Tag$1:\n      case uint8ClampedTag$1:\n      case uint16Tag$1:\n      case uint32Tag$1:\n        return cloneTypedArray(object, isDeep)\n\n      case mapTag$4:\n        return new Ctor()\n\n      case numberTag$2:\n      case stringTag$3:\n        return new Ctor(object)\n\n      case regexpTag$3:\n        return cloneRegExp(object)\n\n      case setTag$4:\n        return new Ctor()\n\n      case symbolTag$2:\n        return cloneSymbol(object)\n    }\n  }\n\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneObject(object) {\n    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {}\n  }\n\n  /** `Object#toString` result references. */\n  var mapTag$3 = '[object Map]'\n\n  /**\n   * The base implementation of `_.isMap` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   */\n  function baseIsMap(value) {\n    return isObjectLike(value) && getTag$1(value) == mapTag$3\n  }\n\n  /* Node.js helper references. */\n  var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap\n\n  /**\n   * Checks if `value` is classified as a `Map` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   * @example\n   *\n   * _.isMap(new Map);\n   * // => true\n   *\n   * _.isMap(new WeakMap);\n   * // => false\n   */\n  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap\n\n  const isMap$1 = isMap\n\n  /** `Object#toString` result references. */\n  var setTag$3 = '[object Set]'\n\n  /**\n   * The base implementation of `_.isSet` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   */\n  function baseIsSet(value) {\n    return isObjectLike(value) && getTag$1(value) == setTag$3\n  }\n\n  /* Node.js helper references. */\n  var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet\n\n  /**\n   * Checks if `value` is classified as a `Set` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   * @example\n   *\n   * _.isSet(new Set);\n   * // => true\n   *\n   * _.isSet(new WeakSet);\n   * // => false\n   */\n  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet\n\n  const isSet$1 = isSet\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG$1 = 4\n\n  /** `Object#toString` result references. */\n  var argsTag$1 = '[object Arguments]',\n    arrayTag$1 = '[object Array]',\n    boolTag$1 = '[object Boolean]',\n    dateTag$1 = '[object Date]',\n    errorTag$1 = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag$2 = '[object Map]',\n    numberTag$1 = '[object Number]',\n    objectTag$1 = '[object Object]',\n    regexpTag$2 = '[object RegExp]',\n    setTag$2 = '[object Set]',\n    stringTag$2 = '[object String]',\n    symbolTag$1 = '[object Symbol]',\n    weakMapTag = '[object WeakMap]'\n\n  var arrayBufferTag$1 = '[object ArrayBuffer]',\n    dataViewTag$1 = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]'\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {}\n  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[\n    dataViewTag$1\n  ] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[\n    float64Tag\n  ] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[\n    mapTag$2\n  ] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[\n    setTag$2\n  ] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[\n    uint8ClampedTag\n  ] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true\n  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Deep clone\n   *  2 - Flatten inherited properties\n   *  4 - Clone symbols\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, bitmask, customizer, key, object, stack) {\n    var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG$1\n\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value)\n    }\n    if (result !== undefined) {\n      return result\n    }\n    if (!isObject(value)) {\n      return value\n    }\n    var isArr = isArray$1(value)\n    if (isArr) {\n      result = initCloneArray(value)\n      if (!isDeep) {\n        return copyArray(value, result)\n      }\n    } else {\n      var tag = getTag$1(value),\n        isFunc = tag == funcTag || tag == genTag\n\n      if (isBuffer$1(value)) {\n        return cloneBuffer(value, isDeep)\n      }\n      if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {\n        result = isFlat || isFunc ? {} : initCloneObject(value)\n        if (!isDeep) {\n          return isFlat\n            ? copySymbolsIn(value, baseAssignIn(result, value))\n            : copySymbols(value, baseAssign(result, value))\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {}\n        }\n        result = initCloneByTag(value, tag, isDeep)\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack())\n    var stacked = stack.get(value)\n    if (stacked) {\n      return stacked\n    }\n    stack.set(value, result)\n\n    if (isSet$1(value)) {\n      value.forEach(function (subValue) {\n        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))\n      })\n    } else if (isMap$1(value)) {\n      value.forEach(function (subValue, key) {\n        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))\n      })\n    }\n\n    var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys\n\n    var props = isArr ? undefined : keysFunc(value)\n    arrayEach(props || value, function (subValue, key) {\n      if (props) {\n        key = subValue\n        subValue = value[key]\n      }\n      // Recursively populate clone (susceptible to call stack limits).\n      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))\n    })\n    return result\n  }\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_SYMBOLS_FLAG = 4\n\n  /**\n   * Creates a shallow clone of `value`.\n   *\n   * **Note:** This method is loosely based on the\n   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n   * and supports cloning arrays, array buffers, booleans, date objects, maps,\n   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n   * arrays. The own enumerable properties of `arguments` objects are cloned\n   * as plain objects. An empty object is returned for uncloneable values such\n   * as error objects, functions, DOM nodes, and WeakMaps.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to clone.\n   * @returns {*} Returns the cloned value.\n   * @see _.cloneDeep\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var shallow = _.clone(objects);\n   * console.log(shallow[0] === objects[0]);\n   * // => true\n   */\n  function clone(value) {\n    return baseClone(value, CLONE_SYMBOLS_FLAG)\n  }\n\n  /**\n   * Creates an array with all falsey values removed. The values `false`, `null`,\n   * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to compact.\n   * @returns {Array} Returns the new array of filtered values.\n   * @example\n   *\n   * _.compact([0, 1, false, 2, '', 3]);\n   * // => [1, 2, 3]\n   */\n  function compact(array) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = []\n\n    while (++index < length) {\n      var value = array[index]\n      if (value) {\n        result[resIndex++] = value\n      }\n    }\n    return result\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__'\n\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED)\n    return this\n  }\n\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n  function setCacheHas(value) {\n    return this.__data__.has(value)\n  }\n\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n  function SetCache(values) {\n    var index = -1,\n      length = values == null ? 0 : values.length\n\n    this.__data__ = new MapCache()\n    while (++index < length) {\n      this.add(values[index])\n    }\n  }\n\n  // Add methods to `SetCache`.\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd\n  SetCache.prototype.has = setCacheHas\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$5 = 1,\n    COMPARE_UNORDERED_FLAG$3 = 2\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,\n      arrLength = array.length,\n      othLength = other.length\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false\n    }\n    // Check that cyclic values are equal.\n    var arrStacked = stack.get(array)\n    var othStacked = stack.get(other)\n    if (arrStacked && othStacked) {\n      return arrStacked == other && othStacked == array\n    }\n    var index = -1,\n      result = true,\n      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined\n\n    stack.set(array, other)\n    stack.set(other, array)\n\n    // Ignore non-index properties.\n    while (++index < arrLength) {\n      var arrValue = array[index],\n        othValue = other[index]\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, arrValue, index, other, array, stack)\n          : customizer(arrValue, othValue, index, array, other, stack)\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue\n        }\n        result = false\n        break\n      }\n      // Recursively compare arrays (susceptible to call stack limits).\n      if (seen) {\n        if (\n          !arraySome(other, function (othValue, othIndex) {\n            if (\n              !cacheHas(seen, othIndex) &&\n              (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))\n            ) {\n              return seen.push(othIndex)\n            }\n          })\n        ) {\n          result = false\n          break\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false\n        break\n      }\n    }\n    stack['delete'](array)\n    stack['delete'](other)\n    return result\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n      result = Array(map.size)\n\n    map.forEach(function (value, key) {\n      result[++index] = [key, value]\n    })\n    return result\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n      result = Array(set.size)\n\n    set.forEach(function (value) {\n      result[++index] = value\n    })\n    return result\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$4 = 1,\n    COMPARE_UNORDERED_FLAG$2 = 2\n\n  /** `Object#toString` result references. */\n  var boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag$1 = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag$1 = '[object RegExp]',\n    setTag$1 = '[object Set]',\n    stringTag$1 = '[object String]',\n    symbolTag = '[object Symbol]'\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]'\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false\n        }\n        object = object.buffer\n        other = other.buffer\n\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n          return false\n        }\n        return true\n\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        // Coerce booleans to `1` or `0` and dates to milliseconds.\n        // Invalid dates are coerced to `NaN`.\n        return eq(+object, +other)\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message\n\n      case regexpTag$1:\n      case stringTag$1:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == other + ''\n\n      case mapTag$1:\n        var convert = mapToArray\n\n      case setTag$1:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4\n        convert || (convert = setToArray)\n\n        if (object.size != other.size && !isPartial) {\n          return false\n        }\n        // Assume cyclic values are equal.\n        var stacked = stack.get(object)\n        if (stacked) {\n          return stacked == other\n        }\n        bitmask |= COMPARE_UNORDERED_FLAG$2\n\n        // Recursively compare objects (susceptible to call stack limits).\n        stack.set(object, other)\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack)\n        stack['delete'](object)\n        return result\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other)\n        }\n    }\n    return false\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$3 = 1\n\n  /** Used for built-in method references. */\n  var objectProto$5 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$5 = objectProto$5.hasOwnProperty\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length\n\n    if (objLength != othLength && !isPartial) {\n      return false\n    }\n    var index = objLength\n    while (index--) {\n      var key = objProps[index]\n      if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n        return false\n      }\n    }\n    // Check that cyclic values are equal.\n    var objStacked = stack.get(object)\n    var othStacked = stack.get(other)\n    if (objStacked && othStacked) {\n      return objStacked == other && othStacked == object\n    }\n    var result = true\n    stack.set(object, other)\n    stack.set(other, object)\n\n    var skipCtor = isPartial\n    while (++index < objLength) {\n      key = objProps[index]\n      var objValue = object[key],\n        othValue = other[key]\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, objValue, key, other, object, stack)\n          : customizer(objValue, othValue, key, object, other, stack)\n      }\n      // Recursively compare objects (susceptible to call stack limits).\n      if (\n        !(compared === undefined\n          ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)\n          : compared)\n      ) {\n        result = false\n        break\n      }\n      skipCtor || (skipCtor = key == 'constructor')\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n        othCtor = other.constructor\n\n      // Non `Object` object instances with different constructors are not equal.\n      if (\n        objCtor != othCtor &&\n        'constructor' in object &&\n        'constructor' in other &&\n        !(\n          typeof objCtor == 'function' &&\n          objCtor instanceof objCtor &&\n          typeof othCtor == 'function' &&\n          othCtor instanceof othCtor\n        )\n      ) {\n        result = false\n      }\n    }\n    stack['delete'](object)\n    stack['delete'](other)\n    return result\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$2 = 1\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]'\n\n  /** Used for built-in method references. */\n  var objectProto$4 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$4 = objectProto$4.hasOwnProperty\n\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray$1(object),\n      othIsArr = isArray$1(other),\n      objTag = objIsArr ? arrayTag : getTag$1(object),\n      othTag = othIsArr ? arrayTag : getTag$1(other)\n\n    objTag = objTag == argsTag ? objectTag : objTag\n    othTag = othTag == argsTag ? objectTag : othTag\n\n    var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag\n\n    if (isSameTag && isBuffer$1(object)) {\n      if (!isBuffer$1(other)) {\n        return false\n      }\n      objIsArr = true\n      objIsObj = false\n    }\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack())\n      return objIsArr || isTypedArray$1(object)\n        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n      var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__')\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other\n\n        stack || (stack = new Stack())\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)\n      }\n    }\n    if (!isSameTag) {\n      return false\n    }\n    stack || (stack = new Stack())\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack)\n  }\n\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Unordered comparison\n   *  2 - Partial comparison\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true\n    }\n    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n      return value !== value && other !== other\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$1 = 1,\n    COMPARE_UNORDERED_FLAG$1 = 2\n\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer\n\n    if (object == null) {\n      return !length\n    }\n    object = Object(object)\n    while (index--) {\n      var data = matchData[index]\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false\n      }\n    }\n    while (++index < length) {\n      data = matchData[index]\n      var key = data[0],\n        objValue = object[key],\n        srcValue = data[1]\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false\n        }\n      } else {\n        var stack = new Stack()\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack)\n        }\n        if (\n          !(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)\n            : result)\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n  function isStrictComparable(value) {\n    return value === value && !isObject(value)\n  }\n\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n  function getMatchData(object) {\n    var result = keys(object),\n      length = result.length\n\n    while (length--) {\n      var key = result[length],\n        value = object[key]\n\n      result[length] = [key, value, isStrictComparable(value)]\n    }\n    return result\n  }\n\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false\n      }\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object))\n    }\n  }\n\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatches(source) {\n    var matchData = getMatchData(source)\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1])\n    }\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData)\n    }\n  }\n\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object)\n  }\n\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object)\n\n    var index = -1,\n      length = path.length,\n      result = false\n\n    while (++index < length) {\n      var key = toKey(path[index])\n      if (!(result = object != null && hasFunc(object, key))) {\n        break\n      }\n      object = object[key]\n    }\n    if (result || ++index != length) {\n      return result\n    }\n    length = object == null ? 0 : object.length\n    return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object))\n  }\n\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2\n\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue)\n    }\n    return function (object) {\n      var objValue = get(object, path)\n      return objValue === undefined && objValue === srcValue\n        ? hasIn(object, path)\n        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)\n    }\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key]\n    }\n  }\n\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path)\n    }\n  }\n\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)\n  }\n\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value\n    }\n    if (value == null) {\n      return identity\n    }\n    if (typeof value == 'object') {\n      return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value)\n    }\n    return property(value)\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      var value = array[index]\n      setter(accumulator, value, iteratee(value), array)\n    }\n    return accumulator\n  }\n\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index]\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break\n        }\n      }\n      return object\n    }\n  }\n\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseFor = createBaseFor()\n\n  const baseFor$1 = baseFor\n\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwn(object, iteratee) {\n    return object && baseFor$1(object, iteratee, keys)\n  }\n\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee)\n      }\n      var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection)\n\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break\n        }\n      }\n      return collection\n    }\n  }\n\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEach = createBaseEach(baseForOwn)\n\n  const baseEach$1 = baseEach\n\n  /**\n   * Aggregates elements of `collection` on `accumulator` with keys transformed\n   * by `iteratee` and values set by `setter`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function baseAggregator(collection, setter, iteratee, accumulator) {\n    baseEach$1(collection, function (value, key, collection) {\n      setter(accumulator, value, iteratee(value), collection)\n    })\n    return accumulator\n  }\n\n  /**\n   * Creates a function like `_.groupBy`.\n   *\n   * @private\n   * @param {Function} setter The function to set accumulator values.\n   * @param {Function} [initializer] The accumulator object initializer.\n   * @returns {Function} Returns the new aggregator function.\n   */\n  function createAggregator(setter, initializer) {\n    return function (collection, iteratee) {\n      var func = isArray$1(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {}\n\n      return func(collection, setter, baseIteratee(iteratee), accumulator)\n    }\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$3 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$3 = objectProto$3.hasOwnProperty\n\n  /**\n   * Assigns own and inherited enumerable string keyed properties of source\n   * objects to the destination object for all destination properties that\n   * resolve to `undefined`. Source objects are applied from left to right.\n   * Once a property is set, additional values of the same property are ignored.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.defaultsDeep\n   * @example\n   *\n   * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n   * // => { 'a': 1, 'b': 2 }\n   */\n  var defaults = baseRest(function (object, sources) {\n    object = Object(object)\n\n    var index = -1\n    var length = sources.length\n    var guard = length > 2 ? sources[2] : undefined\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      length = 1\n    }\n\n    while (++index < length) {\n      var source = sources[index]\n      var props = keysIn(source)\n      var propsIndex = -1\n      var propsLength = props.length\n\n      while (++propsIndex < propsLength) {\n        var key = props[propsIndex]\n        var value = object[key]\n\n        if (value === undefined || (eq(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key))) {\n          object[key] = source[key]\n        }\n      }\n    }\n\n    return object\n  })\n\n  const defaults$1 = defaults\n\n  /**\n   * This method is like `_.isArrayLike` except that it also checks if `value`\n   * is an object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array-like object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArrayLikeObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLikeObject(document.body.children);\n   * // => true\n   *\n   * _.isArrayLikeObject('abc');\n   * // => false\n   *\n   * _.isArrayLikeObject(_.noop);\n   * // => false\n   */\n  function isArrayLikeObject(value) {\n    return isObjectLike(value) && isArrayLike(value)\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE$1 = 200\n\n  /**\n   * The base implementation of methods like `_.difference` without support\n   * for excluding multiple arrays or iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Array} values The values to exclude.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new array of filtered values.\n   */\n  function baseDifference(array, values, iteratee, comparator) {\n    var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length\n\n    if (!length) {\n      return result\n    }\n    if (iteratee) {\n      values = arrayMap(values, baseUnary(iteratee))\n    }\n    if (comparator) {\n      includes = arrayIncludesWith\n      isCommon = false\n    } else if (values.length >= LARGE_ARRAY_SIZE$1) {\n      includes = cacheHas\n      isCommon = false\n      values = new SetCache(values)\n    }\n    outer: while (++index < length) {\n      var value = array[index],\n        computed = iteratee == null ? value : iteratee(value)\n\n      value = comparator || value !== 0 ? value : 0\n      if (isCommon && computed === computed) {\n        var valuesIndex = valuesLength\n        while (valuesIndex--) {\n          if (values[valuesIndex] === computed) {\n            continue outer\n          }\n        }\n        result.push(value)\n      } else if (!includes(values, computed, comparator)) {\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of `array` values not included in the other given arrays\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons. The order and references of result values are\n   * determined by the first array.\n   *\n   * **Note:** Unlike `_.pullAll`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {...Array} [values] The values to exclude.\n   * @returns {Array} Returns the new array of filtered values.\n   * @see _.without, _.xor\n   * @example\n   *\n   * _.difference([2, 1], [2, 3]);\n   * // => [1]\n   */\n  var difference = baseRest(function (array, values) {\n    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []\n  })\n\n  const difference$1 = difference\n\n  /**\n   * Gets the last element of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @returns {*} Returns the last element of `array`.\n   * @example\n   *\n   * _.last([1, 2, 3]);\n   * // => 3\n   */\n  function last(array) {\n    var length = array == null ? 0 : array.length\n    return length ? array[length - 1] : undefined\n  }\n\n  /**\n   * Creates a slice of `array` with `n` elements dropped from the beginning.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @param {number} [n=1] The number of elements to drop.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the slice of `array`.\n   * @example\n   *\n   * _.drop([1, 2, 3]);\n   * // => [2, 3]\n   *\n   * _.drop([1, 2, 3], 2);\n   * // => [3]\n   *\n   * _.drop([1, 2, 3], 5);\n   * // => []\n   *\n   * _.drop([1, 2, 3], 0);\n   * // => [1, 2, 3]\n   */\n  function drop(array, n, guard) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return []\n    }\n    n = guard || n === undefined ? 1 : toInteger(n)\n    return baseSlice(array, n < 0 ? 0 : n, length)\n  }\n\n  /**\n   * Creates a slice of `array` with `n` elements dropped from the end.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @param {number} [n=1] The number of elements to drop.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the slice of `array`.\n   * @example\n   *\n   * _.dropRight([1, 2, 3]);\n   * // => [1, 2]\n   *\n   * _.dropRight([1, 2, 3], 2);\n   * // => [1]\n   *\n   * _.dropRight([1, 2, 3], 5);\n   * // => []\n   *\n   * _.dropRight([1, 2, 3], 0);\n   * // => [1, 2, 3]\n   */\n  function dropRight(array, n, guard) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return []\n    }\n    n = guard || n === undefined ? 1 : toInteger(n)\n    n = length - n\n    return baseSlice(array, 0, n < 0 ? 0 : n)\n  }\n\n  /**\n   * Casts `value` to `identity` if it's not a function.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Function} Returns cast function.\n   */\n  function castFunction(value) {\n    return typeof value == 'function' ? value : identity\n  }\n\n  /**\n   * Iterates over elements of `collection` and invokes `iteratee` for each element.\n   * The iteratee is invoked with three arguments: (value, index|key, collection).\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n   * property are iterated like arrays. To avoid this behavior use `_.forIn`\n   * or `_.forOwn` for object iteration.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias each\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   * @see _.forEachRight\n   * @example\n   *\n   * _.forEach([1, 2], function(value) {\n   *   console.log(value);\n   * });\n   * // => Logs `1` then `2`.\n   *\n   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n   *   console.log(key);\n   * });\n   * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n   */\n  function forEach(collection, iteratee) {\n    var func = isArray$1(collection) ? arrayEach : baseEach$1\n    return func(collection, castFunction(iteratee))\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * The base implementation of `_.every` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`\n   */\n  function baseEvery(collection, predicate) {\n    var result = true\n    baseEach$1(collection, function (value, index, collection) {\n      result = !!predicate(value, index, collection)\n      return result\n    })\n    return result\n  }\n\n  /**\n   * Checks if `predicate` returns truthy for **all** elements of `collection`.\n   * Iteration is stopped once `predicate` returns falsey. The predicate is\n   * invoked with three arguments: (value, index|key, collection).\n   *\n   * **Note:** This method returns `true` for\n   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n   * elements of empty collections.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   * @example\n   *\n   * _.every([true, 1, null, 'yes'], Boolean);\n   * // => false\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': false },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.every(users, { 'user': 'barney', 'active': false });\n   * // => false\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.every(users, ['active', false]);\n   * // => true\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.every(users, 'active');\n   * // => false\n   */\n  function every(collection, predicate, guard) {\n    var func = isArray$1(collection) ? arrayEvery : baseEvery\n    if (guard && isIterateeCall(collection, predicate, guard)) {\n      predicate = undefined\n    }\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /**\n   * The base implementation of `_.filter` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function baseFilter(collection, predicate) {\n    var result = []\n    baseEach$1(collection, function (value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value)\n      }\n    })\n    return result\n  }\n\n  /**\n   * Iterates over elements of `collection`, returning an array of all elements\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * **Note:** Unlike `_.remove`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.reject\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': true },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * _.filter(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.filter(users, { 'age': 36, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.filter(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.filter(users, 'active');\n   * // => objects for ['barney']\n   *\n   * // Combining several predicates using `_.overEvery` or `_.overSome`.\n   * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n   * // => objects for ['fred', 'barney']\n   */\n  function filter(collection, predicate) {\n    var func = isArray$1(collection) ? arrayFilter : baseFilter\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /**\n   * Creates a `_.find` or `_.findLast` function.\n   *\n   * @private\n   * @param {Function} findIndexFunc The function to find the collection index.\n   * @returns {Function} Returns the new find function.\n   */\n  function createFind(findIndexFunc) {\n    return function (collection, predicate, fromIndex) {\n      var iterable = Object(collection)\n      if (!isArrayLike(collection)) {\n        var iteratee = baseIteratee(predicate)\n        collection = keys(collection)\n        predicate = function (key) {\n          return iteratee(iterable[key], key, iterable)\n        }\n      }\n      var index = findIndexFunc(collection, predicate, fromIndex)\n      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined\n    }\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$2 = Math.max\n\n  /**\n   * This method is like `_.find` except that it returns the index of the first\n   * element `predicate` returns truthy for instead of the element itself.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the found element, else `-1`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'active': false },\n   *   { 'user': 'fred',    'active': false },\n   *   { 'user': 'pebbles', 'active': true }\n   * ];\n   *\n   * _.findIndex(users, function(o) { return o.user == 'barney'; });\n   * // => 0\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.findIndex(users, { 'user': 'fred', 'active': false });\n   * // => 1\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.findIndex(users, ['active', false]);\n   * // => 0\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.findIndex(users, 'active');\n   * // => 2\n   */\n  function findIndex(array, predicate, fromIndex) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return -1\n    }\n    var index = fromIndex == null ? 0 : toInteger(fromIndex)\n    if (index < 0) {\n      index = nativeMax$2(length + index, 0)\n    }\n    return baseFindIndex(array, baseIteratee(predicate), index)\n  }\n\n  /**\n   * Iterates over elements of `collection`, returning the first element\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {*} Returns the matched element, else `undefined`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'age': 36, 'active': true },\n   *   { 'user': 'fred',    'age': 40, 'active': false },\n   *   { 'user': 'pebbles', 'age': 1,  'active': true }\n   * ];\n   *\n   * _.find(users, function(o) { return o.age < 40; });\n   * // => object for 'barney'\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.find(users, { 'age': 1, 'active': true });\n   * // => object for 'pebbles'\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.find(users, ['active', false]);\n   * // => object for 'fred'\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.find(users, 'active');\n   * // => object for 'barney'\n   */\n  var find = createFind(findIndex)\n\n  const find$1 = find\n\n  /**\n   * Gets the first element of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias first\n   * @category Array\n   * @param {Array} array The array to query.\n   * @returns {*} Returns the first element of `array`.\n   * @example\n   *\n   * _.head([1, 2, 3]);\n   * // => 1\n   *\n   * _.head([]);\n   * // => undefined\n   */\n  function head(array) {\n    return array && array.length ? array[0] : undefined\n  }\n\n  /**\n   * The base implementation of `_.map` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function baseMap(collection, iteratee) {\n    var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : []\n\n    baseEach$1(collection, function (value, key, collection) {\n      result[++index] = iteratee(value, key, collection)\n    })\n    return result\n  }\n\n  /**\n   * Creates an array of values by running each element in `collection` thru\n   * `iteratee`. The iteratee is invoked with three arguments:\n   * (value, index|key, collection).\n   *\n   * Many lodash methods are guarded to work as iteratees for methods like\n   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n   *\n   * The guarded methods are:\n   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   * @example\n   *\n   * function square(n) {\n   *   return n * n;\n   * }\n   *\n   * _.map([4, 8], square);\n   * // => [16, 64]\n   *\n   * _.map({ 'a': 4, 'b': 8 }, square);\n   * // => [16, 64] (iteration order is not guaranteed)\n   *\n   * var users = [\n   *   { 'user': 'barney' },\n   *   { 'user': 'fred' }\n   * ];\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.map(users, 'user');\n   * // => ['barney', 'fred']\n   */\n  function map(collection, iteratee) {\n    var func = isArray$1(collection) ? arrayMap : baseMap\n    return func(collection, baseIteratee(iteratee))\n  }\n\n  /**\n   * Creates a flattened array of values by running each element in `collection`\n   * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n   * with three arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new flattened array.\n   * @example\n   *\n   * function duplicate(n) {\n   *   return [n, n];\n   * }\n   *\n   * _.flatMap([1, 2], duplicate);\n   * // => [1, 1, 2, 2]\n   */\n  function flatMap(collection, iteratee) {\n    return baseFlatten(map(collection, iteratee), 1)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$2 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$2 = objectProto$2.hasOwnProperty\n\n  /**\n   * Creates an object composed of keys generated from the results of running\n   * each element of `collection` thru `iteratee`. The order of grouped values\n   * is determined by the order they occur in `collection`. The corresponding\n   * value of each key is an array of elements responsible for generating the\n   * key. The iteratee is invoked with one argument: (value).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n   * @returns {Object} Returns the composed aggregate object.\n   * @example\n   *\n   * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n   * // => { '4': [4.2], '6': [6.1, 6.3] }\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.groupBy(['one', 'two', 'three'], 'length');\n   * // => { '3': ['one', 'two'], '5': ['three'] }\n   */\n  var groupBy = createAggregator(function (result, value, key) {\n    if (hasOwnProperty$2.call(result, key)) {\n      result[key].push(value)\n    } else {\n      baseAssignValue(result, key, [value])\n    }\n  })\n\n  const groupBy$1 = groupBy\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$1 = objectProto$1.hasOwnProperty\n\n  /**\n   * The base implementation of `_.has` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHas(object, key) {\n    return object != null && hasOwnProperty$1.call(object, key)\n  }\n\n  /**\n   * Checks if `path` is a direct property of `object`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = { 'a': { 'b': 2 } };\n   * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.has(object, 'a');\n   * // => true\n   *\n   * _.has(object, 'a.b');\n   * // => true\n   *\n   * _.has(object, ['a', 'b']);\n   * // => true\n   *\n   * _.has(other, 'a');\n   * // => false\n   */\n  function has(object, path) {\n    return object != null && hasPath(object, path, baseHas)\n  }\n\n  /** `Object#toString` result references. */\n  var stringTag = '[object String]'\n\n  /**\n   * Checks if `value` is classified as a `String` primitive or object.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n   * @example\n   *\n   * _.isString('abc');\n   * // => true\n   *\n   * _.isString(1);\n   * // => false\n   */\n  function isString(value) {\n    return typeof value == 'string' || (!isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag)\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function (key) {\n      return object[key]\n    })\n  }\n\n  /**\n   * Creates an array of the own enumerable string keyed property values of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property values.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.values(new Foo);\n   * // => [1, 2] (iteration order is not guaranteed)\n   *\n   * _.values('hi');\n   * // => ['h', 'i']\n   */\n  function values(object) {\n    return object == null ? [] : baseValues(object, keys(object))\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$1 = Math.max\n\n  /**\n   * Checks if `value` is in `collection`. If `collection` is a string, it's\n   * checked for a substring of `value`, otherwise\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * is used for equality comparisons. If `fromIndex` is negative, it's used as\n   * the offset from the end of `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object|string} collection The collection to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n   * @returns {boolean} Returns `true` if `value` is found, else `false`.\n   * @example\n   *\n   * _.includes([1, 2, 3], 1);\n   * // => true\n   *\n   * _.includes([1, 2, 3], 1, 2);\n   * // => false\n   *\n   * _.includes({ 'a': 1, 'b': 2 }, 1);\n   * // => true\n   *\n   * _.includes('abcd', 'bc');\n   * // => true\n   */\n  function includes(collection, value, fromIndex, guard) {\n    collection = isArrayLike(collection) ? collection : values(collection)\n    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0\n\n    var length = collection.length\n    if (fromIndex < 0) {\n      fromIndex = nativeMax$1(length + fromIndex, 0)\n    }\n    return isString(collection)\n      ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1\n      : !!length && baseIndexOf(collection, value, fromIndex) > -1\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max\n\n  /**\n   * Gets the index at which the first occurrence of `value` is found in `array`\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons. If `fromIndex` is negative, it's used as the\n   * offset from the end of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   * @example\n   *\n   * _.indexOf([1, 2, 1, 2], 2);\n   * // => 1\n   *\n   * // Search from the `fromIndex`.\n   * _.indexOf([1, 2, 1, 2], 2, 2);\n   * // => 3\n   */\n  function indexOf(array, value, fromIndex) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return -1\n    }\n    var index = fromIndex == null ? 0 : toInteger(fromIndex)\n    if (index < 0) {\n      index = nativeMax(length + index, 0)\n    }\n    return baseIndexOf(array, value, index)\n  }\n\n  /** `Object#toString` result references. */\n  var mapTag = '[object Map]',\n    setTag = '[object Set]'\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty\n\n  /**\n   * Checks if `value` is an empty object, collection, map, or set.\n   *\n   * Objects are considered empty if they have no own enumerable string keyed\n   * properties.\n   *\n   * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n   * jQuery-like collections are considered empty if they have a `length` of `0`.\n   * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n   * @example\n   *\n   * _.isEmpty(null);\n   * // => true\n   *\n   * _.isEmpty(true);\n   * // => true\n   *\n   * _.isEmpty(1);\n   * // => true\n   *\n   * _.isEmpty([1, 2, 3]);\n   * // => false\n   *\n   * _.isEmpty({ 'a': 1 });\n   * // => false\n   */\n  function isEmpty(value) {\n    if (value == null) {\n      return true\n    }\n    if (\n      isArrayLike(value) &&\n      (isArray$1(value) ||\n        typeof value == 'string' ||\n        typeof value.splice == 'function' ||\n        isBuffer$1(value) ||\n        isTypedArray$1(value) ||\n        isArguments$1(value))\n    ) {\n      return !value.length\n    }\n    var tag = getTag$1(value)\n    if (tag == mapTag || tag == setTag) {\n      return !value.size\n    }\n    if (isPrototype(value)) {\n      return !baseKeys(value).length\n    }\n    for (var key in value) {\n      if (hasOwnProperty.call(value, key)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /** `Object#toString` result references. */\n  var regexpTag = '[object RegExp]'\n\n  /**\n   * The base implementation of `_.isRegExp` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   */\n  function baseIsRegExp(value) {\n    return isObjectLike(value) && baseGetTag(value) == regexpTag\n  }\n\n  /* Node.js helper references. */\n  var nodeIsRegExp = nodeUtil$1 && nodeUtil$1.isRegExp\n\n  /**\n   * Checks if `value` is classified as a `RegExp` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   * @example\n   *\n   * _.isRegExp(/abc/);\n   * // => true\n   *\n   * _.isRegExp('/abc/');\n   * // => false\n   */\n  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp\n\n  const isRegExp$1 = isRegExp\n\n  /**\n   * Checks if `value` is `undefined`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n   * @example\n   *\n   * _.isUndefined(void 0);\n   * // => true\n   *\n   * _.isUndefined(null);\n   * // => false\n   */\n  function isUndefined(value) {\n    return value === undefined\n  }\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function'\n\n  /**\n   * Creates a function that negates the result of the predicate `func`. The\n   * `func` predicate is invoked with the `this` binding and arguments of the\n   * created function.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Function\n   * @param {Function} predicate The predicate to negate.\n   * @returns {Function} Returns the new negated function.\n   * @example\n   *\n   * function isEven(n) {\n   *   return n % 2 == 0;\n   * }\n   *\n   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n   * // => [1, 3, 5]\n   */\n  function negate(predicate) {\n    if (typeof predicate != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT)\n    }\n    return function () {\n      var args = arguments\n      switch (args.length) {\n        case 0:\n          return !predicate.call(this)\n        case 1:\n          return !predicate.call(this, args[0])\n        case 2:\n          return !predicate.call(this, args[0], args[1])\n        case 3:\n          return !predicate.call(this, args[0], args[1], args[2])\n      }\n      return !predicate.apply(this, args)\n    }\n  }\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    if (!isObject(object)) {\n      return object\n    }\n    path = castPath(path, object)\n\n    var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object\n\n    while (nested != null && ++index < length) {\n      var key = toKey(path[index]),\n        newValue = value\n\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        return object\n      }\n\n      if (index != lastIndex) {\n        var objValue = nested[key]\n        newValue = customizer ? customizer(objValue, key, nested) : undefined\n        if (newValue === undefined) {\n          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {}\n        }\n      }\n      assignValue(nested, key, newValue)\n      nested = nested[key]\n    }\n    return object\n  }\n\n  /**\n   * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The source object.\n   * @param {string[]} paths The property paths to pick.\n   * @param {Function} predicate The function invoked per property.\n   * @returns {Object} Returns the new object.\n   */\n  function basePickBy(object, paths, predicate) {\n    var index = -1,\n      length = paths.length,\n      result = {}\n\n    while (++index < length) {\n      var path = paths[index],\n        value = baseGet(object, path)\n\n      if (predicate(value, path)) {\n        baseSet(result, castPath(path, object), value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an object composed of the `object` properties `predicate` returns\n   * truthy for. The predicate is invoked with two arguments: (value, key).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The source object.\n   * @param {Function} [predicate=_.identity] The function invoked per property.\n   * @returns {Object} Returns the new object.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': '2', 'c': 3 };\n   *\n   * _.pickBy(object, _.isNumber);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  function pickBy(object, predicate) {\n    if (object == null) {\n      return {}\n    }\n    var props = arrayMap(getAllKeysIn(object), function (prop) {\n      return [prop]\n    })\n    predicate = baseIteratee(predicate)\n    return basePickBy(object, props, function (value, path) {\n      return predicate(value, path[0])\n    })\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function (value, index, collection) {\n      accumulator = initAccum ? ((initAccum = false), value) : iteratee(accumulator, value, index, collection)\n    })\n    return accumulator\n  }\n\n  /**\n   * Reduces `collection` to a value which is the accumulated result of running\n   * each element in `collection` thru `iteratee`, where each successive\n   * invocation is supplied the return value of the previous. If `accumulator`\n   * is not given, the first element of `collection` is used as the initial\n   * value. The iteratee is invoked with four arguments:\n   * (accumulator, value, index|key, collection).\n   *\n   * Many lodash methods are guarded to work as iteratees for methods like\n   * `_.reduce`, `_.reduceRight`, and `_.transform`.\n   *\n   * The guarded methods are:\n   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n   * and `sortBy`\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @returns {*} Returns the accumulated value.\n   * @see _.reduceRight\n   * @example\n   *\n   * _.reduce([1, 2], function(sum, n) {\n   *   return sum + n;\n   * }, 0);\n   * // => 3\n   *\n   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n   *   (result[value] || (result[value] = [])).push(key);\n   *   return result;\n   * }, {});\n   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n   */\n  function reduce(collection, iteratee, accumulator) {\n    var func = isArray$1(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3\n\n    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach$1)\n  }\n\n  /**\n   * The opposite of `_.filter`; this method returns the elements of `collection`\n   * that `predicate` does **not** return truthy for.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.filter\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': false },\n   *   { 'user': 'fred',   'age': 40, 'active': true }\n   * ];\n   *\n   * _.reject(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.reject(users, { 'age': 40, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.reject(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.reject(users, 'active');\n   * // => objects for ['barney']\n   */\n  function reject(collection, predicate) {\n    var func = isArray$1(collection) ? arrayFilter : baseFilter\n    return func(collection, negate(baseIteratee(predicate)))\n  }\n\n  /**\n   * The base implementation of `_.some` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function baseSome(collection, predicate) {\n    var result\n\n    baseEach$1(collection, function (value, index, collection) {\n      result = predicate(value, index, collection)\n      return !result\n    })\n    return !!result\n  }\n\n  /**\n   * Checks if `predicate` returns truthy for **any** element of `collection`.\n   * Iteration is stopped once `predicate` returns truthy. The predicate is\n   * invoked with three arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   * @example\n   *\n   * _.some([null, 0, 'yes', false], Boolean);\n   * // => true\n   *\n   * var users = [\n   *   { 'user': 'barney', 'active': true },\n   *   { 'user': 'fred',   'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.some(users, { 'user': 'barney', 'active': false });\n   * // => false\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.some(users, ['active', false]);\n   * // => true\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.some(users, 'active');\n   * // => true\n   */\n  function some(collection, predicate, guard) {\n    var func = isArray$1(collection) ? arraySome : baseSome\n    if (guard && isIterateeCall(collection, predicate, guard)) {\n      predicate = undefined\n    }\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0\n\n  /**\n   * Creates a set object of `values`.\n   *\n   * @private\n   * @param {Array} values The values to add to the set.\n   * @returns {Object} Returns the new set.\n   */\n  var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY)\n    ? noop\n    : function (values) {\n        return new Set$1(values)\n      }\n\n  const createSet$1 = createSet\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200\n\n  /**\n   * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseUniq(array, iteratee, comparator) {\n    var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result\n\n    if (comparator) {\n      isCommon = false\n      includes = arrayIncludesWith\n    } else if (length >= LARGE_ARRAY_SIZE) {\n      var set = iteratee ? null : createSet$1(array)\n      if (set) {\n        return setToArray(set)\n      }\n      isCommon = false\n      includes = cacheHas\n      seen = new SetCache()\n    } else {\n      seen = iteratee ? [] : result\n    }\n    outer: while (++index < length) {\n      var value = array[index],\n        computed = iteratee ? iteratee(value) : value\n\n      value = comparator || value !== 0 ? value : 0\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer\n          }\n        }\n        if (iteratee) {\n          seen.push(computed)\n        }\n        result.push(value)\n      } else if (!includes(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed)\n        }\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates a duplicate-free version of an array, using\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons, in which only the first occurrence of each element\n   * is kept. The order of result values is determined by the order they occur\n   * in the array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @returns {Array} Returns the new duplicate free array.\n   * @example\n   *\n   * _.uniq([2, 1, 2]);\n   * // => [2, 1]\n   */\n  function uniq(array) {\n    return array && array.length ? baseUniq(array) : []\n  }\n\n  function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n      console.error(`Error: ${msg}`)\n    }\n  }\n  function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n      // TODO: modify docs accordingly\n      console.warn(`Warning: ${msg}`)\n    }\n  }\n\n  function timer(func) {\n    const start = new Date().getTime()\n    const val = func()\n    const end = new Date().getTime()\n    const total = end - start\n    return { time: total, value: val }\n  }\n\n  // based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\n  function toFastProperties(toBecomeFast) {\n    function FakeConstructor() {}\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast\n    const fakeInstance = new FakeConstructor()\n    function fakeAccess() {\n      return typeof fakeInstance.bar\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess()\n    fakeAccess()\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    return toBecomeFast\n  }\n\n  // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n  function tokenLabel$1(tokType) {\n    if (hasTokenLabel$1(tokType)) {\n      return tokType.LABEL\n    } else {\n      return tokType.name\n    }\n  }\n  // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n  function hasTokenLabel$1(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== ''\n  }\n  class AbstractProduction {\n    get definition() {\n      return this._definition\n    }\n    set definition(value) {\n      this._definition = value\n    }\n    constructor(_definition) {\n      this._definition = _definition\n    }\n    accept(visitor) {\n      visitor.visit(this)\n      forEach(this.definition, (prod) => {\n        prod.accept(visitor)\n      })\n    }\n  }\n  class NonTerminal extends AbstractProduction {\n    constructor(options) {\n      super([])\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n    set definition(definition) {\n      // immutable\n    }\n    get definition() {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition\n      }\n      return []\n    }\n    accept(visitor) {\n      visitor.visit(this)\n      // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n  }\n  class Rule extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.orgText = ''\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Alternative extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.ignoreAmbiguities = false\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Option extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Repetition extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Alternation extends AbstractProduction {\n    get definition() {\n      return this._definition\n    }\n    set definition(value) {\n      this._definition = value\n    }\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      this.ignoreAmbiguities = false\n      this.hasPredicates = false\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Terminal {\n    constructor(options) {\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n    accept(visitor) {\n      visitor.visit(this)\n    }\n  }\n  function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction)\n  }\n  function serializeProduction(node) {\n    function convertDefinition(definition) {\n      return map(definition, serializeProduction)\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n      const serializedNonTerminal = {\n        type: 'NonTerminal',\n        name: node.nonTerminalName,\n        idx: node.idx,\n      }\n      if (isString(node.label)) {\n        serializedNonTerminal.label = node.label\n      }\n      return serializedNonTerminal\n    } else if (node instanceof Alternative) {\n      return {\n        type: 'Alternative',\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Option) {\n      return {\n        type: 'Option',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionMandatory) {\n      return {\n        type: 'RepetitionMandatory',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionMandatoryWithSeparator) {\n      return {\n        type: 'RepetitionMandatoryWithSeparator',\n        idx: node.idx,\n        separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionWithSeparator) {\n      return {\n        type: 'RepetitionWithSeparator',\n        idx: node.idx,\n        separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Repetition) {\n      return {\n        type: 'Repetition',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Alternation) {\n      return {\n        type: 'Alternation',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Terminal) {\n      const serializedTerminal = {\n        type: 'Terminal',\n        name: node.terminalType.name,\n        label: tokenLabel$1(node.terminalType),\n        idx: node.idx,\n      }\n      if (isString(node.label)) {\n        serializedTerminal.terminalLabel = node.label\n      }\n      const pattern = node.terminalType.PATTERN\n      if (node.terminalType.PATTERN) {\n        serializedTerminal.pattern = isRegExp$1(pattern) ? pattern.source : pattern\n      }\n      return serializedTerminal\n    } else if (node instanceof Rule) {\n      return {\n        type: 'Rule',\n        name: node.name,\n        orgText: node.orgText,\n        definition: convertDefinition(node.definition),\n      }\n      /* c8 ignore next 3 */\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n\n  class GAstVisitor {\n    visit(node) {\n      const nodeAny = node\n      switch (nodeAny.constructor) {\n        case NonTerminal:\n          return this.visitNonTerminal(nodeAny)\n        case Alternative:\n          return this.visitAlternative(nodeAny)\n        case Option:\n          return this.visitOption(nodeAny)\n        case RepetitionMandatory:\n          return this.visitRepetitionMandatory(nodeAny)\n        case RepetitionMandatoryWithSeparator:\n          return this.visitRepetitionMandatoryWithSeparator(nodeAny)\n        case RepetitionWithSeparator:\n          return this.visitRepetitionWithSeparator(nodeAny)\n        case Repetition:\n          return this.visitRepetition(nodeAny)\n        case Alternation:\n          return this.visitAlternation(nodeAny)\n        case Terminal:\n          return this.visitTerminal(nodeAny)\n        case Rule:\n          return this.visitRule(nodeAny)\n        /* c8 ignore next 2 */\n        default:\n          throw Error('non exhaustive match')\n      }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) {}\n    /* c8 ignore next */\n    visitAlternative(node) {}\n    /* c8 ignore next */\n    visitOption(node) {}\n    /* c8 ignore next */\n    visitRepetition(node) {}\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) {}\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) {}\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) {}\n    /* c8 ignore next */\n    visitAlternation(node) {}\n    /* c8 ignore next */\n    visitTerminal(node) {}\n    /* c8 ignore next */\n    visitRule(node) {}\n  }\n\n  function isSequenceProd(prod) {\n    return (\n      prod instanceof Alternative ||\n      prod instanceof Option ||\n      prod instanceof Repetition ||\n      prod instanceof RepetitionMandatory ||\n      prod instanceof RepetitionMandatoryWithSeparator ||\n      prod instanceof RepetitionWithSeparator ||\n      prod instanceof Terminal ||\n      prod instanceof Rule\n    )\n  }\n  function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional =\n      prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator\n    if (isDirectlyOptional) {\n      return true\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n      // for OR its enough for just one of the alternatives to be optional\n      return some(prod.definition, (subProd) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      })\n    } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n      // avoiding stack overflow due to infinite recursion\n      return false\n    } else if (prod instanceof AbstractProduction) {\n      if (prod instanceof NonTerminal) {\n        alreadyVisited.push(prod)\n      }\n      return every(prod.definition, (subProd) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      })\n    } else {\n      return false\n    }\n  }\n  function isBranchingProd(prod) {\n    return prod instanceof Alternation\n  }\n  function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n      return 'SUBRULE'\n    } else if (prod instanceof Option) {\n      return 'OPTION'\n    } else if (prod instanceof Alternation) {\n      return 'OR'\n    } else if (prod instanceof RepetitionMandatory) {\n      return 'AT_LEAST_ONE'\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      return 'AT_LEAST_ONE_SEP'\n    } else if (prod instanceof RepetitionWithSeparator) {\n      return 'MANY_SEP'\n    } else if (prod instanceof Repetition) {\n      return 'MANY'\n    } else if (prod instanceof Terminal) {\n      return 'CONSUME'\n      /* c8 ignore next 3 */\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n\n  /**\n   *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n   */\n  class RestWalker {\n    walk(prod, prevRest = []) {\n      forEach(prod.definition, (subProd, index) => {\n        const currRest = drop(prod.definition, index + 1)\n        /* istanbul ignore else */\n        if (subProd instanceof NonTerminal) {\n          this.walkProdRef(subProd, currRest, prevRest)\n        } else if (subProd instanceof Terminal) {\n          this.walkTerminal(subProd, currRest, prevRest)\n        } else if (subProd instanceof Alternative) {\n          this.walkFlat(subProd, currRest, prevRest)\n        } else if (subProd instanceof Option) {\n          this.walkOption(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionMandatory) {\n          this.walkAtLeastOne(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n          this.walkAtLeastOneSep(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionWithSeparator) {\n          this.walkManySep(subProd, currRest, prevRest)\n        } else if (subProd instanceof Repetition) {\n          this.walkMany(subProd, currRest, prevRest)\n        } else if (subProd instanceof Alternation) {\n          this.walkOr(subProd, currRest, prevRest)\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n    }\n    walkTerminal(terminal, currRest, prevRest) {}\n    walkProdRef(refProd, currRest, prevRest) {}\n    walkFlat(flatProd, currRest, prevRest) {\n      // ABCDEF => after the D the rest is EF\n      const fullOrRest = currRest.concat(prevRest)\n      this.walk(flatProd, fullOrRest)\n    }\n    walkOption(optionProd, currRest, prevRest) {\n      // ABC(DE)?F => after the (DE)? the rest is F\n      const fullOrRest = currRest.concat(prevRest)\n      this.walk(optionProd, fullOrRest)\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n      const fullAtLeastOneRest = [new Option({ definition: atLeastOneProd.definition })].concat(currRest, prevRest)\n      this.walk(atLeastOneProd, fullAtLeastOneRest)\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n      // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n      const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest)\n      this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n    }\n    walkMany(manyProd, currRest, prevRest) {\n      // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n      const fullManyRest = [new Option({ definition: manyProd.definition })].concat(currRest, prevRest)\n      this.walk(manyProd, fullManyRest)\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n      // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n      const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest)\n      this.walk(manySepProd, fullManySepRest)\n    }\n    walkOr(orProd, currRest, prevRest) {\n      // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n      const fullOrRest = currRest.concat(prevRest)\n      // walk all different alternatives\n      forEach(orProd.definition, (alt) => {\n        // wrapping each alternative in a single definition wrapper\n        // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n        // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n        const prodWrapper = new Alternative({ definition: [alt] })\n        this.walk(prodWrapper, fullOrRest)\n      })\n    }\n  }\n  function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n      new Option({\n        definition: [new Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition),\n      }),\n    ]\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest)\n    return fullRepSepRest\n  }\n\n  function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n      // this could in theory cause infinite loops if\n      // (1) prod A refs prod B.\n      // (2) prod B refs prod A\n      // (3) AB can match the empty set\n      // in other words a cycle where everything is optional so the first will keep\n      // looking ahead for the next optional part and will never exit\n      // currently there is no safeguard for this unique edge case because\n      // (1) not sure a grammar in which this can happen is useful for anything (productive)\n      return first(prod.referencedRule)\n    } else if (prod instanceof Terminal) {\n      return firstForTerminal(prod)\n    } else if (isSequenceProd(prod)) {\n      return firstForSequence(prod)\n    } else if (isBranchingProd(prod)) {\n      return firstForBranching(prod)\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function firstForSequence(prod) {\n    let firstSet = []\n    const seq = prod.definition\n    let nextSubProdIdx = 0\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n    let currSubProd\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n      currSubProd = seq[nextSubProdIdx]\n      isLastInnerProdOptional = isOptionalProd(currSubProd)\n      firstSet = firstSet.concat(first(currSubProd))\n      nextSubProdIdx = nextSubProdIdx + 1\n      hasInnerProdsRemaining = seq.length > nextSubProdIdx\n    }\n    return uniq(firstSet)\n  }\n  function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n      return first(innerProd)\n    })\n    return uniq(flatten(allAlternativesFirsts))\n  }\n  function firstForTerminal(terminal) {\n    return [terminal.terminalType]\n  }\n\n  // TODO: can this be removed? where is it used?\n  const IN = '_~IN~_'\n\n  // This ResyncFollowsWalker computes all of the follows required for RESYNC\n  // (skipping reference production).\n  class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n      super()\n      this.topProd = topProd\n      this.follows = {}\n    }\n    startWalking() {\n      this.walk(this.topProd)\n      return this.follows\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n      // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n      const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name\n      const fullRest = currRest.concat(prevRest)\n      const restProd = new Alternative({ definition: fullRest })\n      const t_in_topProd_follows = first(restProd)\n      this.follows[followName] = t_in_topProd_follows\n    }\n  }\n  function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {}\n    forEach(topProductions, (topProd) => {\n      const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking()\n      assign$1(reSyncFollows, currRefsFollow)\n    })\n    return reSyncFollows\n  }\n  function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN\n  }\n\n  function cc(char) {\n    return char.charCodeAt(0)\n  }\n  function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n      item.forEach(function (subItem) {\n        set.push(subItem)\n      })\n    } else {\n      set.push(item)\n    }\n  }\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw 'duplicate flag ' + flagKey\n    }\n    flagObj[flagKey]\n    flagObj[flagKey] = true\n  }\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error('Internal Error - Should never get here!')\n    }\n    return true\n  }\n  // istanbul ignore next\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error('Internal Error - Should never get here!')\n  }\n  function isCharacter(obj) {\n    return obj['type'] === 'Character'\n  }\n\n  const digitsCharCodes = []\n  for (let i = cc('0'); i <= cc('9'); i++) {\n    digitsCharCodes.push(i)\n  }\n  const wordCharCodes = [cc('_')].concat(digitsCharCodes)\n  for (let i = cc('a'); i <= cc('z'); i++) {\n    wordCharCodes.push(i)\n  }\n  for (let i = cc('A'); i <= cc('Z'); i++) {\n    wordCharCodes.push(i)\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n  const whitespaceCodes = [\n    cc(' '),\n    cc('\\f'),\n    cc('\\n'),\n    cc('\\r'),\n    cc('\\t'),\n    cc('\\v'),\n    cc('\\t'),\n    cc('\\u00a0'),\n    cc('\\u1680'),\n    cc('\\u2000'),\n    cc('\\u2001'),\n    cc('\\u2002'),\n    cc('\\u2003'),\n    cc('\\u2004'),\n    cc('\\u2005'),\n    cc('\\u2006'),\n    cc('\\u2007'),\n    cc('\\u2008'),\n    cc('\\u2009'),\n    cc('\\u200a'),\n    cc('\\u2028'),\n    cc('\\u2029'),\n    cc('\\u202f'),\n    cc('\\u205f'),\n    cc('\\u3000'),\n    cc('\\ufeff'),\n  ]\n\n  // consts and utilities\n  const hexDigitPattern = /[0-9a-fA-F]/\n  const decimalPattern = /[0-9]/\n  const decimalPatternNoZero = /[1-9]/\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  class RegExpParser {\n    constructor() {\n      this.idx = 0\n      this.input = ''\n      this.groupIdx = 0\n    }\n    saveState() {\n      return {\n        idx: this.idx,\n        input: this.input,\n        groupIdx: this.groupIdx,\n      }\n    }\n    restoreState(newState) {\n      this.idx = newState.idx\n      this.input = newState.input\n      this.groupIdx = newState.groupIdx\n    }\n    pattern(input) {\n      // parser state\n      this.idx = 0\n      this.input = input\n      this.groupIdx = 0\n      this.consumeChar('/')\n      const value = this.disjunction()\n      this.consumeChar('/')\n      const flags = {\n        type: 'Flags',\n        loc: { begin: this.idx, end: input.length },\n        global: false,\n        ignoreCase: false,\n        multiLine: false,\n        unicode: false,\n        sticky: false,\n      }\n      while (this.isRegExpFlag()) {\n        switch (this.popChar()) {\n          case 'g':\n            addFlag(flags, 'global')\n            break\n          case 'i':\n            addFlag(flags, 'ignoreCase')\n            break\n          case 'm':\n            addFlag(flags, 'multiLine')\n            break\n          case 'u':\n            addFlag(flags, 'unicode')\n            break\n          case 'y':\n            addFlag(flags, 'sticky')\n            break\n        }\n      }\n      if (this.idx !== this.input.length) {\n        throw Error('Redundant input: ' + this.input.substring(this.idx))\n      }\n      return {\n        type: 'Pattern',\n        flags: flags,\n        value: value,\n        loc: this.loc(0),\n      }\n    }\n    disjunction() {\n      const alts = []\n      const begin = this.idx\n      alts.push(this.alternative())\n      while (this.peekChar() === '|') {\n        this.consumeChar('|')\n        alts.push(this.alternative())\n      }\n      return { type: 'Disjunction', value: alts, loc: this.loc(begin) }\n    }\n    alternative() {\n      const terms = []\n      const begin = this.idx\n      while (this.isTerm()) {\n        terms.push(this.term())\n      }\n      return { type: 'Alternative', value: terms, loc: this.loc(begin) }\n    }\n    term() {\n      if (this.isAssertion()) {\n        return this.assertion()\n      } else {\n        return this.atom()\n      }\n    }\n    assertion() {\n      const begin = this.idx\n      switch (this.popChar()) {\n        case '^':\n          return {\n            type: 'StartAnchor',\n            loc: this.loc(begin),\n          }\n        case '$':\n          return { type: 'EndAnchor', loc: this.loc(begin) }\n        // '\\b' or '\\B'\n        case '\\\\':\n          switch (this.popChar()) {\n            case 'b':\n              return {\n                type: 'WordBoundary',\n                loc: this.loc(begin),\n              }\n            case 'B':\n              return {\n                type: 'NonWordBoundary',\n                loc: this.loc(begin),\n              }\n          }\n          // istanbul ignore next\n          throw Error('Invalid Assertion Escape')\n        // '(?=' or '(?!'\n        case '(':\n          this.consumeChar('?')\n          let type\n          switch (this.popChar()) {\n            case '=':\n              type = 'Lookahead'\n              break\n            case '!':\n              type = 'NegativeLookahead'\n              break\n          }\n          ASSERT_EXISTS(type)\n          const disjunction = this.disjunction()\n          this.consumeChar(')')\n          return {\n            type: type,\n            value: disjunction,\n            loc: this.loc(begin),\n          }\n      }\n      // istanbul ignore next\n      return ASSERT_NEVER_REACH_HERE()\n    }\n    quantifier(isBacktracking = false) {\n      let range = undefined\n      const begin = this.idx\n      switch (this.popChar()) {\n        case '*':\n          range = {\n            atLeast: 0,\n            atMost: Infinity,\n          }\n          break\n        case '+':\n          range = {\n            atLeast: 1,\n            atMost: Infinity,\n          }\n          break\n        case '?':\n          range = {\n            atLeast: 0,\n            atMost: 1,\n          }\n          break\n        case '{':\n          const atLeast = this.integerIncludingZero()\n          switch (this.popChar()) {\n            case '}':\n              range = {\n                atLeast: atLeast,\n                atMost: atLeast,\n              }\n              break\n            case ',':\n              let atMost\n              if (this.isDigit()) {\n                atMost = this.integerIncludingZero()\n                range = {\n                  atLeast: atLeast,\n                  atMost: atMost,\n                }\n              } else {\n                range = {\n                  atLeast: atLeast,\n                  atMost: Infinity,\n                }\n              }\n              this.consumeChar('}')\n              break\n          }\n          // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n          // causes severe performance degradations\n          if (isBacktracking === true && range === undefined) {\n            return undefined\n          }\n          ASSERT_EXISTS(range)\n          break\n      }\n      // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n      // causes severe performance degradations\n      if (isBacktracking === true && range === undefined) {\n        return undefined\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(range)) {\n        if (this.peekChar(0) === '?') {\n          this.consumeChar('?')\n          range.greedy = false\n        } else {\n          range.greedy = true\n        }\n        range.type = 'Quantifier'\n        range.loc = this.loc(begin)\n        return range\n      }\n    }\n    atom() {\n      let atom\n      const begin = this.idx\n      switch (this.peekChar()) {\n        case '.':\n          atom = this.dotAll()\n          break\n        case '\\\\':\n          atom = this.atomEscape()\n          break\n        case '[':\n          atom = this.characterClass()\n          break\n        case '(':\n          atom = this.group()\n          break\n      }\n      if (atom === undefined && this.isPatternCharacter()) {\n        atom = this.patternCharacter()\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(atom)) {\n        atom.loc = this.loc(begin)\n        if (this.isQuantifier()) {\n          atom.quantifier = this.quantifier()\n        }\n        return atom\n      }\n    }\n    dotAll() {\n      this.consumeChar('.')\n      return {\n        type: 'Set',\n        complement: true,\n        value: [cc('\\n'), cc('\\r'), cc('\\u2028'), cc('\\u2029')],\n      }\n    }\n    atomEscape() {\n      this.consumeChar('\\\\')\n      switch (this.peekChar()) {\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          return this.decimalEscapeAtom()\n        case 'd':\n        case 'D':\n        case 's':\n        case 'S':\n        case 'w':\n        case 'W':\n          return this.characterClassEscape()\n        case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n        case 'v':\n          return this.controlEscapeAtom()\n        case 'c':\n          return this.controlLetterEscapeAtom()\n        case '0':\n          return this.nulCharacterAtom()\n        case 'x':\n          return this.hexEscapeSequenceAtom()\n        case 'u':\n          return this.regExpUnicodeEscapeSequenceAtom()\n        default:\n          return this.identityEscapeAtom()\n      }\n    }\n    decimalEscapeAtom() {\n      const value = this.positiveInteger()\n      return { type: 'GroupBackReference', value: value }\n    }\n    characterClassEscape() {\n      let set\n      let complement = false\n      switch (this.popChar()) {\n        case 'd':\n          set = digitsCharCodes\n          break\n        case 'D':\n          set = digitsCharCodes\n          complement = true\n          break\n        case 's':\n          set = whitespaceCodes\n          break\n        case 'S':\n          set = whitespaceCodes\n          complement = true\n          break\n        case 'w':\n          set = wordCharCodes\n          break\n        case 'W':\n          set = wordCharCodes\n          complement = true\n          break\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(set)) {\n        return { type: 'Set', value: set, complement: complement }\n      }\n    }\n    controlEscapeAtom() {\n      let escapeCode\n      switch (this.popChar()) {\n        case 'f':\n          escapeCode = cc('\\f')\n          break\n        case 'n':\n          escapeCode = cc('\\n')\n          break\n        case 'r':\n          escapeCode = cc('\\r')\n          break\n        case 't':\n          escapeCode = cc('\\t')\n          break\n        case 'v':\n          escapeCode = cc('\\v')\n          break\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(escapeCode)) {\n        return { type: 'Character', value: escapeCode }\n      }\n    }\n    controlLetterEscapeAtom() {\n      this.consumeChar('c')\n      const letter = this.popChar()\n      if (/[a-zA-Z]/.test(letter) === false) {\n        throw Error('Invalid ')\n      }\n      const letterCode = letter.toUpperCase().charCodeAt(0) - 64\n      return { type: 'Character', value: letterCode }\n    }\n    nulCharacterAtom() {\n      // TODO implement '[lookahead  DecimalDigit]'\n      // TODO: for the deprecated octal escape sequence\n      this.consumeChar('0')\n      return { type: 'Character', value: cc('\\0') }\n    }\n    hexEscapeSequenceAtom() {\n      this.consumeChar('x')\n      return this.parseHexDigits(2)\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n      this.consumeChar('u')\n      return this.parseHexDigits(4)\n    }\n    identityEscapeAtom() {\n      // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n      // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n      const escapedChar = this.popChar()\n      return { type: 'Character', value: cc(escapedChar) }\n    }\n    classPatternCharacterAtom() {\n      switch (this.peekChar()) {\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n        // istanbul ignore next\n        case '\\\\':\n        // istanbul ignore next\n        case ']':\n          throw Error('TBD')\n        default:\n          const nextChar = this.popChar()\n          return { type: 'Character', value: cc(nextChar) }\n      }\n    }\n    characterClass() {\n      const set = []\n      let complement = false\n      this.consumeChar('[')\n      if (this.peekChar(0) === '^') {\n        this.consumeChar('^')\n        complement = true\n      }\n      while (this.isClassAtom()) {\n        const from = this.classAtom()\n        from.type === 'Character'\n        if (isCharacter(from) && this.isRangeDash()) {\n          this.consumeChar('-')\n          const to = this.classAtom()\n          to.type === 'Character'\n          // a range can only be used when both sides are single characters\n          if (isCharacter(to)) {\n            if (to.value < from.value) {\n              throw Error('Range out of order in character class')\n            }\n            set.push({ from: from.value, to: to.value })\n          } else {\n            // literal dash\n            insertToSet(from.value, set)\n            set.push(cc('-'))\n            insertToSet(to.value, set)\n          }\n        } else {\n          insertToSet(from.value, set)\n        }\n      }\n      this.consumeChar(']')\n      return { type: 'Set', complement: complement, value: set }\n    }\n    classAtom() {\n      switch (this.peekChar()) {\n        // istanbul ignore next\n        case ']':\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n          throw Error('TBD')\n        case '\\\\':\n          return this.classEscape()\n        default:\n          return this.classPatternCharacterAtom()\n      }\n    }\n    classEscape() {\n      this.consumeChar('\\\\')\n      switch (this.peekChar()) {\n        // Matches a backspace.\n        // (Not to be confused with \\b word boundary outside characterClass)\n        case 'b':\n          this.consumeChar('b')\n          return { type: 'Character', value: cc('\\u0008') }\n        case 'd':\n        case 'D':\n        case 's':\n        case 'S':\n        case 'w':\n        case 'W':\n          return this.characterClassEscape()\n        case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n        case 'v':\n          return this.controlEscapeAtom()\n        case 'c':\n          return this.controlLetterEscapeAtom()\n        case '0':\n          return this.nulCharacterAtom()\n        case 'x':\n          return this.hexEscapeSequenceAtom()\n        case 'u':\n          return this.regExpUnicodeEscapeSequenceAtom()\n        default:\n          return this.identityEscapeAtom()\n      }\n    }\n    group() {\n      let capturing = true\n      this.consumeChar('(')\n      switch (this.peekChar(0)) {\n        case '?':\n          this.consumeChar('?')\n          this.consumeChar(':')\n          capturing = false\n          break\n        default:\n          this.groupIdx++\n          break\n      }\n      const value = this.disjunction()\n      this.consumeChar(')')\n      const groupAst = {\n        type: 'Group',\n        capturing: capturing,\n        value: value,\n      }\n      if (capturing) {\n        groupAst['idx'] = this.groupIdx\n      }\n      return groupAst\n    }\n    positiveInteger() {\n      let number = this.popChar()\n      // istanbul ignore next - can't ever get here due to previous lookahead checks\n      // still implementing this error checking in case this ever changes.\n      if (decimalPatternNoZero.test(number) === false) {\n        throw Error('Expecting a positive integer')\n      }\n      while (decimalPattern.test(this.peekChar(0))) {\n        number += this.popChar()\n      }\n      return parseInt(number, 10)\n    }\n    integerIncludingZero() {\n      let number = this.popChar()\n      if (decimalPattern.test(number) === false) {\n        throw Error('Expecting an integer')\n      }\n      while (decimalPattern.test(this.peekChar(0))) {\n        number += this.popChar()\n      }\n      return parseInt(number, 10)\n    }\n    patternCharacter() {\n      const nextChar = this.popChar()\n      switch (nextChar) {\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n        // istanbul ignore next\n        case '^':\n        // istanbul ignore next\n        case '$':\n        // istanbul ignore next\n        case '\\\\':\n        // istanbul ignore next\n        case '.':\n        // istanbul ignore next\n        case '*':\n        // istanbul ignore next\n        case '+':\n        // istanbul ignore next\n        case '?':\n        // istanbul ignore next\n        case '(':\n        // istanbul ignore next\n        case ')':\n        // istanbul ignore next\n        case '[':\n        // istanbul ignore next\n        case '|':\n          // istanbul ignore next\n          throw Error('TBD')\n        default:\n          return { type: 'Character', value: cc(nextChar) }\n      }\n    }\n    isRegExpFlag() {\n      switch (this.peekChar(0)) {\n        case 'g':\n        case 'i':\n        case 'm':\n        case 'u':\n        case 'y':\n          return true\n        default:\n          return false\n      }\n    }\n    isRangeDash() {\n      return this.peekChar() === '-' && this.isClassAtom(1)\n    }\n    isDigit() {\n      return decimalPattern.test(this.peekChar(0))\n    }\n    isClassAtom(howMuch = 0) {\n      switch (this.peekChar(howMuch)) {\n        case ']':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n          return false\n        default:\n          return true\n      }\n    }\n    isTerm() {\n      return this.isAtom() || this.isAssertion()\n    }\n    isAtom() {\n      if (this.isPatternCharacter()) {\n        return true\n      }\n      switch (this.peekChar(0)) {\n        case '.':\n        case '\\\\': // atomEscape\n        case '[': // characterClass\n        // TODO: isAtom must be called before isAssertion - disambiguate\n        case '(': // group\n          return true\n        default:\n          return false\n      }\n    }\n    isAssertion() {\n      switch (this.peekChar(0)) {\n        case '^':\n        case '$':\n          return true\n        // '\\b' or '\\B'\n        case '\\\\':\n          switch (this.peekChar(1)) {\n            case 'b':\n            case 'B':\n              return true\n            default:\n              return false\n          }\n        // '(?=' or '(?!'\n        case '(':\n          return this.peekChar(1) === '?' && (this.peekChar(2) === '=' || this.peekChar(2) === '!')\n        default:\n          return false\n      }\n    }\n    isQuantifier() {\n      const prevState = this.saveState()\n      try {\n        return this.quantifier(true) !== undefined\n      } catch (e) {\n        return false\n      } finally {\n        this.restoreState(prevState)\n      }\n    }\n    isPatternCharacter() {\n      switch (this.peekChar()) {\n        case '^':\n        case '$':\n        case '\\\\':\n        case '.':\n        case '*':\n        case '+':\n        case '?':\n        case '(':\n        case ')':\n        case '[':\n        case '|':\n        case '/':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n          return false\n        default:\n          return true\n      }\n    }\n    parseHexDigits(howMany) {\n      let hexString = ''\n      for (let i = 0; i < howMany; i++) {\n        const hexChar = this.popChar()\n        if (hexDigitPattern.test(hexChar) === false) {\n          throw Error('Expecting a HexDecimal digits')\n        }\n        hexString += hexChar\n      }\n      const charCode = parseInt(hexString, 16)\n      return { type: 'Character', value: charCode }\n    }\n    peekChar(howMuch = 0) {\n      return this.input[this.idx + howMuch]\n    }\n    popChar() {\n      const nextChar = this.peekChar(0)\n      this.consumeChar(undefined)\n      return nextChar\n    }\n    consumeChar(char) {\n      if (char !== undefined && this.input[this.idx] !== char) {\n        throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx)\n      }\n      if (this.idx >= this.input.length) {\n        throw Error('Unexpected end of input')\n      }\n      this.idx++\n    }\n    loc(begin) {\n      return { begin: begin, end: this.idx }\n    }\n  }\n\n  class BaseRegExpVisitor {\n    visitChildren(node) {\n      for (const key in node) {\n        const child = node[key]\n        /* istanbul ignore else */\n        if (node.hasOwnProperty(key)) {\n          if (child.type !== undefined) {\n            this.visit(child)\n          } else if (Array.isArray(child)) {\n            child.forEach((subChild) => {\n              this.visit(subChild)\n            }, this)\n          }\n        }\n      }\n    }\n    visit(node) {\n      switch (node.type) {\n        case 'Pattern':\n          this.visitPattern(node)\n          break\n        case 'Flags':\n          this.visitFlags(node)\n          break\n        case 'Disjunction':\n          this.visitDisjunction(node)\n          break\n        case 'Alternative':\n          this.visitAlternative(node)\n          break\n        case 'StartAnchor':\n          this.visitStartAnchor(node)\n          break\n        case 'EndAnchor':\n          this.visitEndAnchor(node)\n          break\n        case 'WordBoundary':\n          this.visitWordBoundary(node)\n          break\n        case 'NonWordBoundary':\n          this.visitNonWordBoundary(node)\n          break\n        case 'Lookahead':\n          this.visitLookahead(node)\n          break\n        case 'NegativeLookahead':\n          this.visitNegativeLookahead(node)\n          break\n        case 'Character':\n          this.visitCharacter(node)\n          break\n        case 'Set':\n          this.visitSet(node)\n          break\n        case 'Group':\n          this.visitGroup(node)\n          break\n        case 'GroupBackReference':\n          this.visitGroupBackReference(node)\n          break\n        case 'Quantifier':\n          this.visitQuantifier(node)\n          break\n      }\n      this.visitChildren(node)\n    }\n    visitPattern(node) {}\n    visitFlags(node) {}\n    visitDisjunction(node) {}\n    visitAlternative(node) {}\n    // Assertion\n    visitStartAnchor(node) {}\n    visitEndAnchor(node) {}\n    visitWordBoundary(node) {}\n    visitNonWordBoundary(node) {}\n    visitLookahead(node) {}\n    visitNegativeLookahead(node) {}\n    // atoms\n    visitCharacter(node) {}\n    visitSet(node) {}\n    visitGroup(node) {}\n    visitGroupBackReference(node) {}\n    visitQuantifier(node) {}\n  }\n\n  let regExpAstCache = {}\n  const regExpParser = new RegExpParser()\n  function getRegExpAst(regExp) {\n    const regExpStr = regExp.toString()\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n      return regExpAstCache[regExpStr]\n    } else {\n      const regExpAst = regExpParser.pattern(regExpStr)\n      regExpAstCache[regExpStr] = regExpAst\n      return regExpAst\n    }\n  }\n  function clearRegExpParserCache() {\n    regExpAstCache = {}\n  }\n\n  const complementErrorMessage = 'Complement Sets are not supported for first char optimization'\n  const failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n'\n  function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n      const ast = getRegExpAst(regExp)\n      const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase)\n      return firstChars\n    } catch (e) {\n      /* istanbul ignore next */\n      // Testing this relies on the regexp-to-ast library having a bug... */\n      // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n      if (e.message === complementErrorMessage) {\n        if (ensureOptimizations) {\n          PRINT_WARNING(\n            `${failedOptimizationPrefixMsg}` +\n              `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n              '\\tComplement Sets cannot be automatically optimized.\\n' +\n              \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n              '\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.',\n          )\n        }\n      } else {\n        let msgSuffix = ''\n        if (ensureOptimizations) {\n          msgSuffix =\n            \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n            '\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.'\n        }\n        PRINT_ERROR(\n          `${failedOptimizationPrefixMsg}\\n` +\n            `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n            `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n            '\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues' +\n            msgSuffix,\n        )\n      }\n    }\n    return []\n  }\n  function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n      case 'Disjunction':\n        for (let i = 0; i < ast.value.length; i++) {\n          firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n        }\n        break\n      case 'Alternative':\n        const terms = ast.value\n        for (let i = 0; i < terms.length; i++) {\n          const term = terms[i]\n          // skip terms that cannot effect the first char results\n          switch (term.type) {\n            case 'EndAnchor':\n            // A group back reference cannot affect potential starting char.\n            // because if a back reference is the first production than automatically\n            // the group being referenced has had to come BEFORE so its codes have already been added\n            case 'GroupBackReference':\n            // assertions do not affect potential starting codes\n            case 'Lookahead':\n            case 'NegativeLookahead':\n            case 'StartAnchor':\n            case 'WordBoundary':\n            case 'NonWordBoundary':\n              continue\n          }\n          const atom = term\n          switch (atom.type) {\n            case 'Character':\n              addOptimizedIdxToResult(atom.value, result, ignoreCase)\n              break\n            case 'Set':\n              if (atom.complement === true) {\n                throw Error(complementErrorMessage)\n              }\n              forEach(atom.value, (code) => {\n                if (typeof code === 'number') {\n                  addOptimizedIdxToResult(code, result, ignoreCase)\n                } else {\n                  // range\n                  const range = code\n                  // cannot optimize when ignoreCase is\n                  if (ignoreCase === true) {\n                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                    }\n                  }\n                  // Optimization (2 orders of magnitude less work for very large ranges)\n                  else {\n                    // handle unoptimized values\n                    for (\n                      let rangeCode = range.from;\n                      rangeCode <= range.to && rangeCode < minOptimizationVal;\n                      rangeCode++\n                    ) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                    }\n                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                    if (range.to >= minOptimizationVal) {\n                      const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal\n                      const maxUnOptVal = range.to\n                      const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                      const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n                      for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                        result[currOptIdx] = currOptIdx\n                      }\n                    }\n                  }\n                }\n              })\n              break\n            case 'Group':\n              firstCharOptimizedIndices(atom.value, result, ignoreCase)\n              break\n            /* istanbul ignore next */\n            default:\n              throw Error('Non Exhaustive Match')\n          }\n          // reached a mandatory production, no more **start** codes can be found on this alternative\n          const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n          if (\n            // A group may be optional due to empty contents /(?:)/\n            // or if everything inside it is optional /((a)?)/\n            (atom.type === 'Group' && isWholeOptional(atom) === false) ||\n            // If this term is not a group it may only be optional if it has an optional quantifier\n            (atom.type !== 'Group' && isOptionalQuantifier === false)\n          ) {\n            break\n          }\n        }\n        break\n      /* istanbul ignore next */\n      default:\n        throw Error('non exhaustive match!')\n    }\n    // console.log(Object.keys(result).length)\n    return values(result)\n  }\n  function addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code)\n    result[optimizedCharIdx] = optimizedCharIdx\n    if (ignoreCase === true) {\n      handleIgnoreCase(code, result)\n    }\n  }\n  function handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code)\n    const upperChar = char.toUpperCase()\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    } else {\n      const lowerChar = char.toLowerCase()\n      if (lowerChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n        result[optimizedCharIdx] = optimizedCharIdx\n      }\n    }\n  }\n  function findCode(setNode, targetCharCodes) {\n    return find$1(setNode.value, (codeOrRange) => {\n      if (typeof codeOrRange === 'number') {\n        return includes(targetCharCodes, codeOrRange)\n      } else {\n        // range\n        const range = codeOrRange\n        return find$1(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined\n      }\n    })\n  }\n  function isWholeOptional(ast) {\n    const quantifier = ast.quantifier\n    if (quantifier && quantifier.atLeast === 0) {\n      return true\n    }\n    if (!ast.value) {\n      return false\n    }\n    return isArray$1(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value)\n  }\n  class CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n      super()\n      this.targetCharCodes = targetCharCodes\n      this.found = false\n    }\n    visitChildren(node) {\n      // No need to keep looking...\n      if (this.found === true) {\n        return\n      }\n      // switch lookaheads as they do not actually consume any characters thus\n      // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n      switch (node.type) {\n        case 'Lookahead':\n          this.visitLookahead(node)\n          return\n        case 'NegativeLookahead':\n          this.visitNegativeLookahead(node)\n          return\n      }\n      super.visitChildren(node)\n    }\n    visitCharacter(node) {\n      if (includes(this.targetCharCodes, node.value)) {\n        this.found = true\n      }\n    }\n    visitSet(node) {\n      if (node.complement) {\n        if (findCode(node, this.targetCharCodes) === undefined) {\n          this.found = true\n        }\n      } else {\n        if (findCode(node, this.targetCharCodes) !== undefined) {\n          this.found = true\n        }\n      }\n    }\n  }\n  function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n      const ast = getRegExpAst(pattern)\n      const charCodeFinder = new CharCodeFinder(charCodes)\n      charCodeFinder.visit(ast)\n      return charCodeFinder.found\n    } else {\n      return (\n        find$1(pattern, (char) => {\n          return includes(charCodes, char.charCodeAt(0))\n        }) !== undefined\n      )\n    }\n  }\n\n  const PATTERN = 'PATTERN'\n  const DEFAULT_MODE = 'defaultMode'\n  const MODES = 'modes'\n  let SUPPORT_STICKY = typeof new RegExp('(?:)').sticky === 'boolean'\n  function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults$1(options, {\n      useSticky: SUPPORT_STICKY,\n      debug: false,\n      safeMode: false,\n      positionTracking: 'full',\n      lineTerminatorCharacters: ['\\r', '\\n'],\n      tracer: (msg, action) => action(),\n    })\n    const tracer = options.tracer\n    tracer('initCharCodeToOptimizedIndexMap', () => {\n      initCharCodeToOptimizedIndexMap()\n    })\n    let onlyRelevantTypes\n    tracer('Reject Lexer.NA', () => {\n      onlyRelevantTypes = reject(tokenTypes, (currType) => {\n        return currType[PATTERN] === Lexer.NA\n      })\n    })\n    let hasCustom = false\n    let allTransformedPatterns\n    tracer('Transform Patterns', () => {\n      hasCustom = false\n      allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n        const currPattern = currType[PATTERN]\n        /* istanbul ignore else */\n        if (isRegExp$1(currPattern)) {\n          const regExpSource = currPattern.source\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== '^' &&\n            regExpSource !== '$' &&\n            regExpSource !== '.' &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === '\\\\' &&\n            // not a meta character\n            !includes(['d', 'D', 's', 'S', 't', 'r', 'n', 't', '0', 'c', 'b', 'B', 'f', 'v', 'w', 'W'], regExpSource[1])\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1]\n          } else {\n            return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern)\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern }\n        } else if (typeof currPattern === 'object') {\n          hasCustom = true\n          // ICustomPattern\n          return currPattern\n        } else if (typeof currPattern === 'string') {\n          if (currPattern.length === 1) {\n            return currPattern\n          } else {\n            const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n            const wrappedRegExp = new RegExp(escapedRegExpString)\n            return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp)\n          }\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n    })\n    let patternIdxToType\n    let patternIdxToGroup\n    let patternIdxToLongerAltIdxArr\n    let patternIdxToPushMode\n    let patternIdxToPopMode\n    tracer('misc mapping', () => {\n      patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx)\n      patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n        const groupName = clazz.GROUP\n        /* istanbul ignore next */\n        if (groupName === Lexer.SKIPPED) {\n          return undefined\n        } else if (isString(groupName)) {\n          return groupName\n        } else if (isUndefined(groupName)) {\n          return false\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n      patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n        const longerAltType = clazz.LONGER_ALT\n        if (longerAltType) {\n          const longerAltIdxArr = isArray$1(longerAltType)\n            ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type))\n            : [indexOf(onlyRelevantTypes, longerAltType)]\n          return longerAltIdxArr\n        }\n      })\n      patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE)\n      patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, 'POP_MODE'))\n    })\n    let patternIdxToCanLineTerminator\n    tracer('Line Terminator Handling', () => {\n      const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters)\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n      if (options.positionTracking !== 'onlyOffset') {\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n          if (has(tokType, 'LINE_BREAKS')) {\n            return !!tokType.LINE_BREAKS\n          } else {\n            return (\n              checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n              canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n            )\n          }\n        })\n      }\n    })\n    let patternIdxToIsCustom\n    let patternIdxToShort\n    let emptyGroups\n    let patternIdxToConfig\n    tracer('Misc Mapping #2', () => {\n      patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n      patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n      emptyGroups = reduce(\n        onlyRelevantTypes,\n        (acc, clazz) => {\n          const groupName = clazz.GROUP\n          if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n            acc[groupName] = []\n          }\n          return acc\n        },\n        {},\n      )\n      patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx],\n        }\n      })\n    })\n    let canBeOptimized = true\n    let charCodeToPatternIdxToConfig = []\n    if (!options.safeMode) {\n      tracer('First Char Optimization', () => {\n        charCodeToPatternIdxToConfig = reduce(\n          onlyRelevantTypes,\n          (result, currTokType, idx) => {\n            if (typeof currTokType.PATTERN === 'string') {\n              const charCode = currTokType.PATTERN.charCodeAt(0)\n              const optimizedIdx = charCodeToOptimizedIndex(charCode)\n              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n            } else if (isArray$1(currTokType.START_CHARS_HINT)) {\n              let lastOptimizedIdx\n              forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n                const charCode = typeof charOrInt === 'string' ? charOrInt.charCodeAt(0) : charOrInt\n                const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n                // Avoid adding the config multiple times\n                /* istanbul ignore else */\n                // - Difficult to check this scenario effects as it is only a performance\n                //   optimization that does not change correctness\n                if (lastOptimizedIdx !== currOptimizedIdx) {\n                  lastOptimizedIdx = currOptimizedIdx\n                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx])\n                }\n              })\n            } else if (isRegExp$1(currTokType.PATTERN)) {\n              if (currTokType.PATTERN.unicode) {\n                canBeOptimized = false\n                if (options.ensureOptimizations) {\n                  PRINT_ERROR(\n                    `${failedOptimizationPrefixMsg}` +\n                      `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                      '\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n' +\n                      \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                      '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE',\n                  )\n                }\n              } else {\n                const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations)\n                /* istanbul ignore if */\n                // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                // the first should be a different validation and the second cannot be tested.\n                if (isEmpty(optimizedCodes)) {\n                  // we cannot understand what codes may start possible matches\n                  // The optimization correctness requires knowing start codes for ALL patterns.\n                  // Not actually sure this is an error, no debug message\n                  canBeOptimized = false\n                }\n                forEach(optimizedCodes, (code) => {\n                  addToMapOfArrays(result, code, patternIdxToConfig[idx])\n                })\n              }\n            } else {\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE',\n                )\n              }\n              canBeOptimized = false\n            }\n            return result\n          },\n          [],\n        )\n      })\n    }\n    return {\n      emptyGroups: emptyGroups,\n      patternIdxToConfig: patternIdxToConfig,\n      charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n      hasCustom: hasCustom,\n      canBeOptimized: canBeOptimized,\n    }\n  }\n  function validatePatterns(tokenTypes, validModesNames) {\n    let errors = []\n    const missingResult = findMissingPatterns(tokenTypes)\n    errors = errors.concat(missingResult.errors)\n    const invalidResult = findInvalidPatterns(missingResult.valid)\n    const validTokenTypes = invalidResult.valid\n    errors = errors.concat(invalidResult.errors)\n    errors = errors.concat(validateRegExpPattern(validTokenTypes))\n    errors = errors.concat(findInvalidGroupType(validTokenTypes))\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames))\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n    return errors\n  }\n  function validateRegExpPattern(tokenTypes) {\n    let errors = []\n    const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp$1(currTokType[PATTERN]))\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n    return errors\n  }\n  function findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n      return !has(currType, PATTERN)\n    })\n    const errors = map(tokenTypesWithMissingPattern, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- missing static 'PATTERN' property\",\n        type: LexerDefinitionErrorType.MISSING_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    const valid = difference$1(tokenTypes, tokenTypesWithMissingPattern)\n    return { errors, valid }\n  }\n  function findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n      const pattern = currType[PATTERN]\n      return !isRegExp$1(pattern) && !isFunction(pattern) && !has(pattern, 'exec') && !isString(pattern)\n    })\n    const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n      return {\n        message:\n          'Token Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' can only be a RegExp, a\" +\n          ' Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.',\n        type: LexerDefinitionErrorType.INVALID_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    const valid = difference$1(tokenTypes, tokenTypesWithInvalidPattern)\n    return { errors, valid }\n  }\n  const end_of_input = /[^\\\\][$]/\n  function findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n      constructor() {\n        super(...arguments)\n        this.found = false\n      }\n      visitEndAnchor(node) {\n        this.found = true\n      }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      try {\n        const regexpAst = getRegExpAst(pattern)\n        const endAnchorVisitor = new EndAnchorFinder()\n        endAnchorVisitor.visit(regexpAst)\n        return endAnchorVisitor.found\n      } catch (e) {\n        // old behavior in case of runtime exceptions with regexp-to-ast.\n        /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n        return end_of_input.test(pattern.source)\n      }\n    })\n    const errors = map(invalidRegex, (currType) => {\n      return {\n        message:\n          'Unexpected RegExp Anchor Error:\\n' +\n          '\\tToken Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n          '\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      return pattern.test('')\n    })\n    const errors = map(matchesEmptyString, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n        type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  const start_of_input = /[^\\\\[][\\^]|^\\^/\n  function findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n      constructor() {\n        super(...arguments)\n        this.found = false\n      }\n      visitStartAnchor(node) {\n        this.found = true\n      }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      try {\n        const regexpAst = getRegExpAst(pattern)\n        const startAnchorVisitor = new StartAnchorFinder()\n        startAnchorVisitor.visit(regexpAst)\n        return startAnchorVisitor.found\n      } catch (e) {\n        // old behavior in case of runtime exceptions with regexp-to-ast.\n        /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n        return start_of_input.test(pattern.source)\n      }\n    })\n    const errors = map(invalidRegex, (currType) => {\n      return {\n        message:\n          'Unexpected RegExp Anchor Error:\\n' +\n          '\\tToken Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n          '\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = filter(tokenTypes, (currType) => {\n      const pattern = currType[PATTERN]\n      return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n    })\n    const errors = map(invalidFlags, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n        type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  // This can only test for identical duplicate RegExps, not semantically equivalent ones.\n  function findDuplicatePatterns(tokenTypes) {\n    const found = []\n    let identicalPatterns = map(tokenTypes, (outerType) => {\n      return reduce(\n        tokenTypes,\n        (result, innerType) => {\n          if (\n            outerType.PATTERN.source === innerType.PATTERN.source &&\n            !includes(found, innerType) &&\n            innerType.PATTERN !== Lexer.NA\n          ) {\n            // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n            // in essence we are creating Equivalence classes on equality relation.\n            found.push(innerType)\n            result.push(innerType)\n            return result\n          }\n          return result\n        },\n        [],\n      )\n    })\n    identicalPatterns = compact(identicalPatterns)\n    const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n      return currIdenticalSet.length > 1\n    })\n    const errors = map(duplicatePatterns, (setOfIdentical) => {\n      const tokenTypeNames = map(setOfIdentical, (currType) => {\n        return currType.name\n      })\n      const dupPatternSrc = head(setOfIdentical).PATTERN\n      return {\n        message:\n          `The same RegExp pattern ->${dupPatternSrc}<-` +\n          `has been used in all of the following Token Types: ${tokenTypeNames.join(', ')} <-`,\n        type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n        tokenTypes: setOfIdentical,\n      }\n    })\n    return errors\n  }\n  function findInvalidGroupType(tokenTypes) {\n    const invalidTypes = filter(tokenTypes, (clazz) => {\n      if (!has(clazz, 'GROUP')) {\n        return false\n      }\n      const group = clazz.GROUP\n      return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n    })\n    const errors = map(invalidTypes, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n        type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = filter(tokenTypes, (clazz) => {\n      return clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    })\n    const errors = map(invalidModes, (tokType) => {\n      const msg =\n        `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n        `which does not exist`\n      return {\n        message: msg,\n        type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n        tokenTypes: [tokType],\n      }\n    })\n    return errors\n  }\n  function findUnreachablePatterns(tokenTypes) {\n    const errors = []\n    const canBeTested = reduce(\n      tokenTypes,\n      (result, tokType, idx) => {\n        const pattern = tokType.PATTERN\n        if (pattern === Lexer.NA) {\n          return result\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n          result.push({ str: pattern, idx, tokenType: tokType })\n        } else if (isRegExp$1(pattern) && noMetaChar(pattern)) {\n          result.push({ str: pattern.source, idx, tokenType: tokType })\n        }\n        return result\n      },\n      [],\n    )\n    forEach(tokenTypes, (tokType, testIdx) => {\n      forEach(canBeTested, ({ str, idx, tokenType }) => {\n        if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n          const msg =\n            `Token: ->${tokenType.name}<- can never be matched.\\n` +\n            `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n            `in the lexer's definition.\\n` +\n            `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n          errors.push({\n            message: msg,\n            type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n            tokenTypes: [tokType, tokenType],\n          })\n        }\n      })\n    })\n    return errors\n  }\n  function testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp$1(pattern)) {\n      const regExpArray = pattern.exec(str)\n      return regExpArray !== null && regExpArray.index === 0\n    } else if (isFunction(pattern)) {\n      // maintain the API of custom patterns\n      return pattern(str, 0, [], {})\n    } else if (has(pattern, 'exec')) {\n      // maintain the API of custom patterns\n      return pattern.exec(str, 0, [], {})\n    } else if (typeof pattern === 'string') {\n      return pattern === str\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = ['.', '\\\\', '[', ']', '|', '^', '$', '(', ')', '?', '*', '+', '{']\n    return find$1(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  }\n  function addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? 'i' : ''\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags)\n  }\n  function addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? 'iy' : 'y'\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags)\n  }\n  function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = []\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n      errors.push({\n        message:\n          'A MultiMode Lexer cannot be initialized without a <' + DEFAULT_MODE + '> property in its definition\\n',\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n      })\n    }\n    if (!has(lexerDefinition, MODES)) {\n      errors.push({\n        message: 'A MultiMode Lexer cannot be initialized without a <' + MODES + '> property in its definition\\n',\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n      })\n    }\n    if (\n      has(lexerDefinition, MODES) &&\n      has(lexerDefinition, DEFAULT_MODE) &&\n      !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n    ) {\n      errors.push({\n        message:\n          `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n          `which does not exist\\n`,\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n      })\n    }\n    if (has(lexerDefinition, MODES)) {\n      forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n        forEach(currModeValue, (currTokType, currIdx) => {\n          if (isUndefined(currTokType)) {\n            errors.push({\n              message:\n                `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                `<${currModeName}> at index: <${currIdx}>\\n`,\n              type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n            })\n          } else if (has(currTokType, 'LONGER_ALT')) {\n            const longerAlt = isArray$1(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT]\n            forEach(longerAlt, (currLongerAlt) => {\n              if (!isUndefined(currLongerAlt) && !includes(currModeValue, currLongerAlt)) {\n                errors.push({\n                  message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                  type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                })\n              }\n            })\n          }\n        })\n      })\n    }\n    return errors\n  }\n  function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = []\n    let hasAnyLineBreak = false\n    const allTokenTypes = compact(flatten(values(lexerDefinition.modes)))\n    const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA)\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n    if (trackLines) {\n      forEach(concreteTokenTypes, (tokType) => {\n        const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n        if (currIssue !== false) {\n          const message = buildLineBreakIssueMessage(tokType, currIssue)\n          const warningDescriptor = {\n            message,\n            type: currIssue.issue,\n            tokenType: tokType,\n          }\n          warnings.push(warningDescriptor)\n        } else {\n          // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n          if (has(tokType, 'LINE_BREAKS')) {\n            if (tokType.LINE_BREAKS === true) {\n              hasAnyLineBreak = true\n            }\n          } else {\n            if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n              hasAnyLineBreak = true\n            }\n          }\n        }\n      })\n    }\n    if (trackLines && !hasAnyLineBreak) {\n      warnings.push({\n        message:\n          'Warning: No LINE_BREAKS Found.\\n' +\n          '\\tThis Lexer has been defined to track line and column information,\\n' +\n          '\\tBut none of the Token Types can be identified as matching a line terminator.\\n' +\n          '\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n      })\n    }\n    return warnings\n  }\n  function cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {}\n    const groupKeys = keys(emptyGroups)\n    forEach(groupKeys, (currKey) => {\n      const currGroupValue = emptyGroups[currKey]\n      /* istanbul ignore else */\n      if (isArray$1(currGroupValue)) {\n        clonedResult[currKey] = []\n      } else {\n        throw Error('non exhaustive match')\n      }\n    })\n    return clonedResult\n  }\n  // TODO: refactor to avoid duplication\n  function isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN\n    /* istanbul ignore else */\n    if (isRegExp$1(pattern)) {\n      return false\n    } else if (isFunction(pattern)) {\n      // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n      return true\n    } else if (has(pattern, 'exec')) {\n      // ICustomPattern\n      return true\n    } else if (isString(pattern)) {\n      return false\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n      return pattern.charCodeAt(0)\n    } else {\n      return false\n    }\n  }\n  /**\n   * Faster than using a RegExp for default newline detection during lexing.\n   */\n  const LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n      const len = text.length\n      for (let i = this.lastIndex; i < len; i++) {\n        const c = text.charCodeAt(i)\n        if (c === 10) {\n          this.lastIndex = i + 1\n          return true\n        } else if (c === 13) {\n          if (text.charCodeAt(i + 1) === 10) {\n            this.lastIndex = i + 2\n          } else {\n            this.lastIndex = i + 1\n          }\n          return true\n        }\n      }\n      return false\n    },\n    lastIndex: 0,\n  }\n  function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, 'LINE_BREAKS')) {\n      // if the user explicitly declared the line_breaks option we will respect their choice\n      // and assume it is correct.\n      return false\n    } else {\n      /* istanbul ignore else */\n      if (isRegExp$1(tokType.PATTERN)) {\n        try {\n          // TODO: why is the casting suddenly needed?\n          canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n        } catch (e) {\n          /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n          return {\n            issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n            errMsg: e.message,\n          }\n        }\n        return false\n      } else if (isString(tokType.PATTERN)) {\n        // string literal patterns can always be analyzed to detect line terminator usage\n        return false\n      } else if (isCustomPattern(tokType)) {\n        // custom token types\n        return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n      } else {\n        throw Error('non exhaustive match')\n      }\n    }\n  }\n  function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n      return (\n        'Warning: unable to identify line terminator usage in pattern.\\n' +\n        `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n        `\\t Root cause: ${details.errMsg}.\\n` +\n        '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR'\n      )\n    } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n      return (\n        'Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n' +\n        `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n        '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK'\n      )\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function getCharCodes(charsOrCodes) {\n    const charCodes = map(charsOrCodes, (numOrString) => {\n      if (isString(numOrString)) {\n        return numOrString.charCodeAt(0)\n      } else {\n        return numOrString\n      }\n    })\n    return charCodes\n  }\n  function addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n      map[key] = [value]\n    } else {\n      map[key].push(value)\n    }\n  }\n  const minOptimizationVal = 256\n  /**\n   * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n   * This is because ASCI are the most common start chars so each one of those will get its own\n   * possible token configs vector.\n   *\n   * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n   * to place these into buckets of possible token configs, What we gain from\n   * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n   * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n   * Our 'charCodeToPatternIdxToConfig' max size will now be:\n   * 256 + (2^16 / 2^8) - 1 === 511\n   *\n   * note the hack for fast division integer part extraction\n   * See: https://stackoverflow.com/a/4228528\n   */\n  let charCodeToOptimizedIdxMap = []\n  function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode]\n  }\n  /**\n   * This is a compromise between cold start / hot running performance\n   * Creating this array takes ~3ms on a modern machine,\n   * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n   * performance degrades by ~10%\n   *\n   * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n   */\n  function initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n      charCodeToOptimizedIdxMap = new Array(65536)\n      for (let i = 0; i < 65536; i++) {\n        charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n      }\n    }\n  }\n\n  function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n      return true\n    } else {\n      return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true\n    }\n  }\n  // Optimized tokenMatcher in case our grammar does not use token categories\n  // Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n  function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx\n  }\n  let tokenShortNameIdx = 1\n  const tokenIdxToClass = {}\n  function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes)\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents)\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents)\n    assignCategoriesTokensProp(tokenTypesAndParents)\n    forEach(tokenTypesAndParents, (tokType) => {\n      tokType.isParent = tokType.categoryMatches.length > 0\n    })\n  }\n  function expandCategories(tokenTypes) {\n    let result = clone(tokenTypes)\n    let categories = tokenTypes\n    let searching = true\n    while (searching) {\n      categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)))\n      const newCategories = difference$1(categories, result)\n      result = result.concat(newCategories)\n      if (isEmpty(newCategories)) {\n        searching = false\n      } else {\n        categories = newCategories\n      }\n    }\n    return result\n  }\n  function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      if (!hasShortKeyProperty(currTokType)) {\n        tokenIdxToClass[tokenShortNameIdx] = currTokType\n        currTokType.tokenTypeIdx = tokenShortNameIdx++\n      }\n      // CATEGORIES? : TokenType | TokenType[]\n      if (\n        hasCategoriesProperty(currTokType) &&\n        !isArray$1(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n      ) {\n        currTokType.CATEGORIES = [currTokType.CATEGORIES]\n      }\n      if (!hasCategoriesProperty(currTokType)) {\n        currTokType.CATEGORIES = []\n      }\n      if (!hasExtendingTokensTypesProperty(currTokType)) {\n        currTokType.categoryMatches = []\n      }\n      if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n        currTokType.categoryMatchesMap = {}\n      }\n    })\n  }\n  function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      // avoid duplications\n      currTokType.categoryMatches = []\n      forEach(currTokType.categoryMatchesMap, (val, key) => {\n        currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx)\n      })\n    })\n  }\n  function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      singleAssignCategoriesToksMap([], currTokType)\n    })\n  }\n  function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, (pathNode) => {\n      nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true\n    })\n    forEach(nextNode.CATEGORIES, (nextCategory) => {\n      const newPath = path.concat(nextNode)\n      // avoids infinite loops due to cyclic categories.\n      if (!includes(newPath, nextCategory)) {\n        singleAssignCategoriesToksMap(newPath, nextCategory)\n      }\n    })\n  }\n  function hasShortKeyProperty(tokType) {\n    return has(tokType, 'tokenTypeIdx')\n  }\n  function hasCategoriesProperty(tokType) {\n    return has(tokType, 'CATEGORIES')\n  }\n  function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, 'categoryMatches')\n  }\n  function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, 'categoryMatchesMap')\n  }\n  function isTokenType(tokType) {\n    return has(tokType, 'tokenTypeIdx')\n  }\n\n  const defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n      return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n      return (\n        `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` +\n        ` skipped ${length} characters.`\n      )\n    },\n  }\n\n  var LexerDefinitionErrorType\n  ;(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MISSING_PATTERN'] = 0)] = 'MISSING_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['INVALID_PATTERN'] = 1)] = 'INVALID_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['EOI_ANCHOR_FOUND'] = 2)] = 'EOI_ANCHOR_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['UNSUPPORTED_FLAGS_FOUND'] = 3)] = 'UNSUPPORTED_FLAGS_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['DUPLICATE_PATTERNS_FOUND'] = 4)] = 'DUPLICATE_PATTERNS_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['INVALID_GROUP_TYPE_FOUND'] = 5)] = 'INVALID_GROUP_TYPE_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['PUSH_MODE_DOES_NOT_EXIST'] = 6)] = 'PUSH_MODE_DOES_NOT_EXIST'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'] = 7)] =\n      'MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'] = 8)] =\n      'MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'] = 9)] =\n      'MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'] = 10)] =\n      'LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['SOI_ANCHOR_FOUND'] = 11)] = 'SOI_ANCHOR_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['EMPTY_MATCH_PATTERN'] = 12)] = 'EMPTY_MATCH_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['NO_LINE_BREAKS_FLAGS'] = 13)] = 'NO_LINE_BREAKS_FLAGS'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['UNREACHABLE_PATTERN'] = 14)] = 'UNREACHABLE_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['IDENTIFY_TERMINATOR'] = 15)] = 'IDENTIFY_TERMINATOR'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['CUSTOM_LINE_BREAK'] = 16)] = 'CUSTOM_LINE_BREAK'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE'] = 17)] =\n      'MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE'\n  })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}))\n  const DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: 'full',\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: ['\\n', '\\r'],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n  }\n  Object.freeze(DEFAULT_LEXER_CONFIG)\n  class Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n      this.lexerDefinition = lexerDefinition\n      this.lexerDefinitionErrors = []\n      this.lexerDefinitionWarning = []\n      this.patternIdxToConfig = {}\n      this.charCodeToPatternIdxToConfig = {}\n      this.modes = []\n      this.emptyGroups = {}\n      this.trackStartLines = true\n      this.trackEndLines = true\n      this.hasCustom = false\n      this.canModeBeOptimized = {}\n      // Duplicated from the parser's perf trace trait to allow future extraction\n      // of the lexer to a separate package.\n      this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n          this.traceInitIndent++\n          const indent = new Array(this.traceInitIndent + 1).join('\\t')\n          if (this.traceInitIndent < this.traceInitMaxIdent) {\n            console.log(`${indent}--> <${phaseDesc}>`)\n          }\n          const { time, value } = timer(phaseImpl)\n          /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n          const traceMethod = time > 10 ? console.warn : console.log\n          if (this.traceInitIndent < this.traceInitMaxIdent) {\n            traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n          }\n          this.traceInitIndent--\n          return value\n        } else {\n          return phaseImpl()\n        }\n      }\n      if (typeof config === 'boolean') {\n        throw Error(\n          'The second argument to the Lexer constructor is now an ILexerConfig Object.\\n' +\n            'a boolean 2nd argument is no longer supported',\n        )\n      }\n      // todo: defaults func?\n      this.config = assign$1({}, DEFAULT_LEXER_CONFIG, config)\n      const traceInitVal = this.config.traceInitPerf\n      if (traceInitVal === true) {\n        this.traceInitMaxIdent = Infinity\n        this.traceInitPerf = true\n      } else if (typeof traceInitVal === 'number') {\n        this.traceInitMaxIdent = traceInitVal\n        this.traceInitPerf = true\n      }\n      this.traceInitIndent = -1\n      this.TRACE_INIT('Lexer Constructor', () => {\n        let actualDefinition\n        let hasOnlySingleMode = true\n        this.TRACE_INIT('Lexer Config handling', () => {\n          if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n            // optimized built-in implementation for the defaults definition of lineTerminators\n            this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n          } else {\n            if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n              throw Error(\n                'Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n' +\n                  '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS',\n              )\n            }\n          }\n          if (config.safeMode && config.ensureOptimizations) {\n            throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.')\n          }\n          this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking)\n          this.trackEndLines = /full/i.test(this.config.positionTracking)\n          // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n          if (isArray$1(lexerDefinition)) {\n            actualDefinition = {\n              modes: { defaultMode: clone(lexerDefinition) },\n              defaultMode: DEFAULT_MODE,\n            }\n          } else {\n            // no conversion needed, input should already be a IMultiModeLexerDefinition\n            hasOnlySingleMode = false\n            actualDefinition = clone(lexerDefinition)\n          }\n        })\n        if (this.config.skipValidations === false) {\n          this.TRACE_INIT('performRuntimeChecks', () => {\n            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n              performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters),\n            )\n          })\n          this.TRACE_INIT('performWarningRuntimeChecks', () => {\n            this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n              performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters),\n            )\n          })\n        }\n        // for extra robustness to avoid throwing an none informative error message\n        actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}\n        // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n        // this transformation is to increase robustness in the case of partially invalid lexer definition.\n        forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n          actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType))\n        })\n        const allModeNames = keys(actualDefinition.modes)\n        forEach(actualDefinition.modes, (currModDef, currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames),\n                )\n              })\n            }\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n              let currAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT,\n                })\n              })\n              this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig\n              this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig\n              this.emptyGroups = assign$1({}, this.emptyGroups, currAnalyzeResult.emptyGroups)\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n              this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized\n            }\n          })\n        })\n        this.defaultMode = actualDefinition.defaultMode\n        if (!isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n          const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n            return error.message\n          })\n          const allErrMessagesString = allErrMessages.join('-----------------------\\n')\n          throw new Error('Errors detected in definition of Lexer:\\n' + allErrMessagesString)\n        }\n        // Only print warning if there are no errors, This will avoid pl\n        forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n          PRINT_WARNING(warningDescriptor.message)\n        })\n        this.TRACE_INIT('Choosing sub-methods implementations', () => {\n          // Choose the relevant internal implementations for this specific parser.\n          // These implementations should be in-lined by the JavaScript engine\n          // to provide optimal performance in each scenario.\n          if (SUPPORT_STICKY) {\n            this.chopInput = identity\n            this.match = this.matchWithTest\n          } else {\n            this.updateLastIndex = noop\n            this.match = this.matchWithExec\n          }\n          if (hasOnlySingleMode) {\n            this.handleModes = noop\n          }\n          if (this.trackStartLines === false) {\n            this.computeNewColumn = identity\n          }\n          if (this.trackEndLines === false) {\n            this.updateTokenEndLineColumnLocation = noop\n          }\n          if (/full/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createFullToken\n          } else if (/onlyStart/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createStartOnlyToken\n          } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createOffsetOnlyToken\n          } else {\n            throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`)\n          }\n          if (this.hasCustom) {\n            this.addToken = this.addTokenUsingPush\n            this.handlePayload = this.handlePayloadWithCustom\n          } else {\n            this.addToken = this.addTokenUsingMemberAccess\n            this.handlePayload = this.handlePayloadNoCustom\n          }\n        })\n        this.TRACE_INIT('Failed Optimization Warnings', () => {\n          const unOptimizedModes = reduce(\n            this.canModeBeOptimized,\n            (cannotBeOptimized, canBeOptimized, modeName) => {\n              if (canBeOptimized === false) {\n                cannotBeOptimized.push(modeName)\n              }\n              return cannotBeOptimized\n            },\n            [],\n          )\n          if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n            throw Error(\n              `Lexer Modes: < ${unOptimizedModes.join(', ')} > cannot be optimized.\\n` +\n                '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                '\\t Or inspect the console log for details on how to resolve these issues.',\n            )\n          }\n        })\n        this.TRACE_INIT('clearRegExpParserCache', () => {\n          clearRegExpParserCache()\n        })\n        this.TRACE_INIT('toFastProperties', () => {\n          toFastProperties(this)\n        })\n      })\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n      if (!isEmpty(this.lexerDefinitionErrors)) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join('-----------------------\\n')\n        throw new Error('Unable to Tokenize because Errors detected in definition of Lexer:\\n' + allErrMessagesString)\n      }\n      return this.tokenizeInternal(text, initialMode)\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n      let i,\n        j,\n        k,\n        matchAltImage,\n        longerAlt,\n        matchedImage,\n        payload,\n        altPayload,\n        imageLength,\n        group,\n        tokType,\n        newToken,\n        errLength,\n        msg,\n        match\n      const orgText = text\n      const orgLength = orgText.length\n      let offset = 0\n      let matchedTokensIndex = 0\n      // initializing the tokensArray to the \"guessed\" size.\n      // guessing too little will still reduce the number of array re-sizes on pushes.\n      // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n      // but would still have a faster runtime by avoiding (All but one) array resizing.\n      const guessedNumberOfTokens = this.hasCustom\n        ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n        : Math.floor(text.length / 10)\n      const matchedTokens = new Array(guessedNumberOfTokens)\n      const errors = []\n      let line = this.trackStartLines ? 1 : undefined\n      let column = this.trackStartLines ? 1 : undefined\n      const groups = cloneEmptyGroups(this.emptyGroups)\n      const trackLines = this.trackStartLines\n      const lineTerminatorPattern = this.config.lineTerminatorsPattern\n      let currModePatternsLength = 0\n      let patternIdxToConfig = []\n      let currCharCodeToPatternIdxToConfig = []\n      const modeStack = []\n      const emptyArray = []\n      Object.freeze(emptyArray)\n      let getPossiblePatterns\n      function getPossiblePatternsSlow() {\n        return patternIdxToConfig\n      }\n      function getPossiblePatternsOptimized(charCode) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n        const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n        if (possiblePatterns === undefined) {\n          return emptyArray\n        } else {\n          return possiblePatterns\n        }\n      }\n      const pop_mode = (popToken) => {\n        // TODO: perhaps avoid this error in the edge case there is no more input?\n        if (\n          modeStack.length === 1 &&\n          // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n          // So no error should occur.\n          popToken.tokenType.PUSH_MODE === undefined\n        ) {\n          // if we try to pop the last mode there lexer will no longer have ANY mode.\n          // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n          const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken)\n          errors.push({\n            offset: popToken.startOffset,\n            line: popToken.startLine,\n            column: popToken.startColumn,\n            length: popToken.image.length,\n            message: msg,\n          })\n        } else {\n          modeStack.pop()\n          const newMode = last(modeStack)\n          patternIdxToConfig = this.patternIdxToConfig[newMode]\n          currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode]\n          currModePatternsLength = patternIdxToConfig.length\n          const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false\n          if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n            getPossiblePatterns = getPossiblePatternsOptimized\n          } else {\n            getPossiblePatterns = getPossiblePatternsSlow\n          }\n        }\n      }\n      function push_mode(newMode) {\n        modeStack.push(newMode)\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode]\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currModePatternsLength = patternIdxToConfig.length\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n      // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n      // seem to matter performance wise.\n      push_mode.call(this, initialMode)\n      let currConfig\n      const recoveryEnabled = this.config.recoveryEnabled\n      while (offset < orgLength) {\n        matchedImage = null\n        const nextCharCode = orgText.charCodeAt(offset)\n        const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n        const chosenPatternsLength = chosenPatternIdxToConfig.length\n        for (i = 0; i < chosenPatternsLength; i++) {\n          currConfig = chosenPatternIdxToConfig[i]\n          const currPattern = currConfig.pattern\n          payload = null\n          // manually in-lined because > 600 chars won't be in-lined in V8\n          const singleCharCode = currConfig.short\n          if (singleCharCode !== false) {\n            if (nextCharCode === singleCharCode) {\n              // single character string\n              matchedImage = currPattern\n            }\n          } else if (currConfig.isCustom === true) {\n            match = currPattern.exec(orgText, offset, matchedTokens, groups)\n            if (match !== null) {\n              matchedImage = match[0]\n              if (match.payload !== undefined) {\n                payload = match.payload\n              }\n            } else {\n              matchedImage = null\n            }\n          } else {\n            this.updateLastIndex(currPattern, offset)\n            matchedImage = this.match(currPattern, text, offset)\n          }\n          if (matchedImage !== null) {\n            // even though this pattern matched we must try a another longer alternative.\n            // this can be used to prioritize keywords over identifiers\n            longerAlt = currConfig.longerAlt\n            if (longerAlt !== undefined) {\n              // TODO: micro optimize, avoid extra prop access\n              // by saving/linking longerAlt on the original config?\n              const longerAltLength = longerAlt.length\n              for (k = 0; k < longerAltLength; k++) {\n                const longerAltConfig = patternIdxToConfig[longerAlt[k]]\n                const longerAltPattern = longerAltConfig.pattern\n                altPayload = null\n                // single Char can never be a longer alt so no need to test it.\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                if (longerAltConfig.isCustom === true) {\n                  match = longerAltPattern.exec(orgText, offset, matchedTokens, groups)\n                  if (match !== null) {\n                    matchAltImage = match[0]\n                    if (match.payload !== undefined) {\n                      altPayload = match.payload\n                    }\n                  } else {\n                    matchAltImage = null\n                  }\n                } else {\n                  this.updateLastIndex(longerAltPattern, offset)\n                  matchAltImage = this.match(longerAltPattern, text, offset)\n                }\n                if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                  matchedImage = matchAltImage\n                  payload = altPayload\n                  currConfig = longerAltConfig\n                  // Exit the loop early after matching one of the longer alternatives\n                  // The first matched alternative takes precedence\n                  break\n                }\n              }\n            }\n            break\n          }\n        }\n        // successful match\n        if (matchedImage !== null) {\n          imageLength = matchedImage.length\n          group = currConfig.group\n          if (group !== undefined) {\n            tokType = currConfig.tokenTypeIdx\n            // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n            // createFullToken method\n            newToken = this.createTokenInstance(\n              matchedImage,\n              offset,\n              tokType,\n              currConfig.tokenType,\n              line,\n              column,\n              imageLength,\n            )\n            this.handlePayload(newToken, payload)\n            // TODO: optimize NOOP in case there are no special groups?\n            if (group === false) {\n              matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken)\n            } else {\n              groups[group].push(newToken)\n            }\n          }\n          text = this.chopInput(text, imageLength)\n          offset = offset + imageLength\n          // TODO: with newlines the column may be assigned twice\n          column = this.computeNewColumn(column, imageLength)\n          if (trackLines === true && currConfig.canLineTerminator === true) {\n            let numOfLTsInMatch = 0\n            let foundTerminator\n            let lastLTEndOffset\n            lineTerminatorPattern.lastIndex = 0\n            do {\n              foundTerminator = lineTerminatorPattern.test(matchedImage)\n              if (foundTerminator === true) {\n                lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n                numOfLTsInMatch++\n              }\n            } while (foundTerminator === true)\n            if (numOfLTsInMatch !== 0) {\n              line = line + numOfLTsInMatch\n              column = imageLength - lastLTEndOffset\n              this.updateTokenEndLineColumnLocation(\n                newToken,\n                group,\n                lastLTEndOffset,\n                numOfLTsInMatch,\n                line,\n                column,\n                imageLength,\n              )\n            }\n          }\n          // will be NOOP if no modes present\n          this.handleModes(currConfig, pop_mode, push_mode, newToken)\n        } else {\n          // error recovery, drop characters until we identify a valid token's start point\n          const errorStartOffset = offset\n          const errorLine = line\n          const errorColumn = column\n          let foundResyncPoint = recoveryEnabled === false\n          while (foundResyncPoint === false && offset < orgLength) {\n            // Identity Func (when sticky flag is enabled)\n            text = this.chopInput(text, 1)\n            offset++\n            for (j = 0; j < currModePatternsLength; j++) {\n              const currConfig = patternIdxToConfig[j]\n              const currPattern = currConfig.pattern\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              const singleCharCode = currConfig.short\n              if (singleCharCode !== false) {\n                if (orgText.charCodeAt(offset) === singleCharCode) {\n                  // single character string\n                  foundResyncPoint = true\n                }\n              } else if (currConfig.isCustom === true) {\n                foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null\n              } else {\n                this.updateLastIndex(currPattern, offset)\n                foundResyncPoint = currPattern.exec(text) !== null\n              }\n              if (foundResyncPoint === true) {\n                break\n              }\n            }\n          }\n          errLength = offset - errorStartOffset\n          column = this.computeNewColumn(column, errLength)\n          // at this point we either re-synced or reached the end of the input text\n          msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n            orgText,\n            errorStartOffset,\n            errLength,\n            errorLine,\n            errorColumn,\n          )\n          errors.push({\n            offset: errorStartOffset,\n            line: errorLine,\n            column: errorColumn,\n            length: errLength,\n            message: msg,\n          })\n          if (recoveryEnabled === false) {\n            break\n          }\n        }\n      }\n      // if we do have custom patterns which push directly into the\n      // TODO: custom tokens should not push directly??\n      if (!this.hasCustom) {\n        // if we guessed a too large size for the tokens array this will shrink it to the right size.\n        matchedTokens.length = matchedTokensIndex\n      }\n      return {\n        tokens: matchedTokens,\n        groups: groups,\n        errors: errors,\n      }\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n      if (config.pop === true) {\n        // need to save the PUSH_MODE property as if the mode is popped\n        // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n        const pushMode = config.push\n        pop_mode(newToken)\n        if (pushMode !== undefined) {\n          push_mode.call(this, pushMode)\n        }\n      } else if (config.push !== undefined) {\n        push_mode.call(this, config.push)\n      }\n    }\n    chopInput(text, length) {\n      return text.substring(length)\n    }\n    updateLastIndex(regExp, newLastIndex) {\n      regExp.lastIndex = newLastIndex\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n      let lastCharIsLT, fixForEndingInLT\n      if (group !== undefined) {\n        // a none skipped multi line Token, need to update endLine/endColumn\n        lastCharIsLT = lastLTIdx === imageLength - 1\n        fixForEndingInLT = lastCharIsLT ? -1 : 0\n        if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n          // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n          newToken.endLine = line + fixForEndingInLT\n          // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n          // inclusive to exclusive range.\n          newToken.endColumn = column - 1 + -fixForEndingInLT\n        }\n        // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n      }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n      return oldColumn + imageLength\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n      return {\n        image,\n        startOffset,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n      return {\n        image,\n        startOffset,\n        startLine,\n        startColumn,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n      return {\n        image,\n        startOffset,\n        endOffset: startOffset + imageLength - 1,\n        startLine,\n        endLine: startLine,\n        startColumn,\n        endColumn: startColumn + imageLength - 1,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n      tokenVector.push(tokenToAdd)\n      return index\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n      tokenVector[index] = tokenToAdd\n      index++\n      return index\n    }\n    handlePayloadNoCustom(token, payload) {}\n    handlePayloadWithCustom(token, payload) {\n      if (payload !== null) {\n        token.payload = payload\n      }\n    }\n    matchWithTest(pattern, text, offset) {\n      const found = pattern.test(text)\n      if (found === true) {\n        return text.substring(offset, pattern.lastIndex)\n      }\n      return null\n    }\n    matchWithExec(pattern, text) {\n      const regExpArray = pattern.exec(text)\n      return regExpArray !== null ? regExpArray[0] : null\n    }\n  }\n  Lexer.SKIPPED =\n    'This marks a skipped Token pattern, this means each token identified by it will' +\n    'be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.'\n  Lexer.NA = /NOT_APPLICABLE/\n\n  function tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n      return tokType.LABEL\n    } else {\n      return tokType.name\n    }\n  }\n  function hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== ''\n  }\n  const PARENT = 'parent'\n  const CATEGORIES = 'categories'\n  const LABEL = 'label'\n  const GROUP = 'group'\n  const PUSH_MODE = 'push_mode'\n  const POP_MODE = 'pop_mode'\n  const LONGER_ALT = 'longer_alt'\n  const LINE_BREAKS = 'line_breaks'\n  const START_CHARS_HINT = 'start_chars_hint'\n  function createToken(config) {\n    return createTokenInternal(config)\n  }\n  function createTokenInternal(config) {\n    const pattern = config.pattern\n    const tokenType = {}\n    tokenType.name = config.name\n    if (!isUndefined(pattern)) {\n      tokenType.PATTERN = pattern\n    }\n    if (has(config, PARENT)) {\n      throw (\n        'The parent property is no longer supported.\\n' +\n        'See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.'\n      )\n    }\n    if (has(config, CATEGORIES)) {\n      // casting to ANY as this will be fixed inside `augmentTokenTypes``\n      tokenType.CATEGORIES = config[CATEGORIES]\n    }\n    augmentTokenTypes([tokenType])\n    if (has(config, LABEL)) {\n      tokenType.LABEL = config[LABEL]\n    }\n    if (has(config, GROUP)) {\n      tokenType.GROUP = config[GROUP]\n    }\n    if (has(config, POP_MODE)) {\n      tokenType.POP_MODE = config[POP_MODE]\n    }\n    if (has(config, PUSH_MODE)) {\n      tokenType.PUSH_MODE = config[PUSH_MODE]\n    }\n    if (has(config, LONGER_ALT)) {\n      tokenType.LONGER_ALT = config[LONGER_ALT]\n    }\n    if (has(config, LINE_BREAKS)) {\n      tokenType.LINE_BREAKS = config[LINE_BREAKS]\n    }\n    if (has(config, START_CHARS_HINT)) {\n      tokenType.START_CHARS_HINT = config[START_CHARS_HINT]\n    }\n    return tokenType\n  }\n  const EOF = createToken({ name: 'EOF', pattern: Lexer.NA })\n  augmentTokenTypes([EOF])\n  function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n      image,\n      startOffset,\n      endOffset,\n      startLine,\n      endLine,\n      startColumn,\n      endColumn,\n      tokenTypeIdx: tokType.tokenTypeIdx,\n      tokenType: tokType,\n    }\n  }\n  function tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType)\n  }\n\n  const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n      const hasLabel = hasTokenLabel(expected)\n      const expectedMsg = hasLabel ? `--> ${tokenLabel(expected)} <--` : `token of type --> ${expected.name} <--`\n      const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n      return msg\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n      return 'Redundant input, expecting EOF but found: ' + firstRedundant.image\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n      const errPrefix = 'Expecting: '\n      // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n      const actualText = head(actual).image\n      const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n      if (customUserDescription) {\n        return errPrefix + customUserDescription + errSuffix\n      } else {\n        const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), [])\n        const nextValidTokenSequences = map(\n          allLookAheadPaths,\n          (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(', ')}]`,\n        )\n        const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`)\n        const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join('\\n')}`\n        return errPrefix + calculatedDescription + errSuffix\n      }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n      const errPrefix = 'Expecting: '\n      // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n      const actualText = head(actual).image\n      const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n      if (customUserDescription) {\n        return errPrefix + customUserDescription + errSuffix\n      } else {\n        const nextValidTokenSequences = map(\n          expectedIterationPaths,\n          (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(',')}]`,\n        )\n        const calculatedDescription =\n          `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n          `<${nextValidTokenSequences.join(' ,')}>`\n        return errPrefix + calculatedDescription + errSuffix\n      }\n    },\n  }\n  Object.freeze(defaultParserErrorProvider)\n  const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n      const msg =\n        'Invalid grammar, reference to a rule which is not defined: ->' +\n        undefinedRule.nonTerminalName +\n        '<-\\n' +\n        'inside top level rule: ->' +\n        topLevelRule.name +\n        '<-'\n      return msg\n    },\n  }\n  const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n      function getExtraProductionArgument(prod) {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return ''\n        }\n      }\n      const topLevelName = topLevelRule.name\n      const duplicateProd = head(duplicateProds)\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : ''}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : ''\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, ' ')\n      msg = msg.replace(/\\s\\s+/g, '\\n')\n      return msg\n    },\n    buildNamespaceConflictError(rule) {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n      return errMsg\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n      const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(', ')\n      const occurrence = options.alternation.idx === 0 ? '' : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(' ,')}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n      return errMsg\n    },\n    buildAlternationAmbiguityError(options) {\n      const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(', ')\n      const occurrence = options.alternation.idx === 0 ? '' : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(' ,')}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n    buildEmptyRepetitionError(options) {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n      return errMsg\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n      /* istanbul ignore next */\n      return 'deprecated'\n    },\n    buildEmptyAlternationError(options) {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n      return errMsg\n    },\n    buildTooManyAlternativesError(options) {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n      return errMsg\n    },\n    buildLeftRecursionError(options) {\n      const ruleName = options.topLevelRule.name\n      const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name)\n      const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(' --> ')}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\n      return errMsg\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n      /* istanbul ignore next */\n      return 'deprecated'\n    },\n    buildDuplicateRuleNameError(options) {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n      return errMsg\n    },\n  }\n\n  function resolveGrammar$1(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider)\n    refResolver.resolveRefs()\n    return refResolver.errors\n  }\n  class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n      super()\n      this.nameToTopRule = nameToTopRule\n      this.errMsgProvider = errMsgProvider\n      this.errors = []\n    }\n    resolveRefs() {\n      forEach(values(this.nameToTopRule), (prod) => {\n        this.currTopLevel = prod\n        prod.accept(this)\n      })\n    }\n    visitNonTerminal(node) {\n      const ref = this.nameToTopRule[node.nonTerminalName]\n      if (!ref) {\n        const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node)\n        this.errors.push({\n          message: msg,\n          type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n          ruleName: this.currTopLevel.name,\n          unresolvedRefName: node.nonTerminalName,\n        })\n      } else {\n        node.referencedRule = ref\n      }\n    }\n  }\n\n  class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n      super()\n      this.topProd = topProd\n      this.path = path\n      this.possibleTokTypes = []\n      this.nextProductionName = ''\n      this.nextProductionOccurrence = 0\n      this.found = false\n      this.isAtEndOfPath = false\n    }\n    startWalking() {\n      this.found = false\n      if (this.path.ruleStack[0] !== this.topProd.name) {\n        throw Error(\"The path does not start with the walker's top Rule!\")\n      }\n      // immutable for the win\n      this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\n      this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n      // already verified that the first production is valid, we now seek the 2nd production\n      this.ruleStack.pop()\n      this.occurrenceStack.pop()\n      this.updateExpectedNext()\n      this.walk(this.topProd)\n      return this.possibleTokTypes\n    }\n    walk(prod, prevRest = []) {\n      // stop scanning once we found the path\n      if (!this.found) {\n        super.walk(prod, prevRest)\n      }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n      // found the next production, need to keep walking in it\n      if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n        const fullRest = currRest.concat(prevRest)\n        this.updateExpectedNext()\n        this.walk(refProd.referencedRule, fullRest)\n      }\n    }\n    updateExpectedNext() {\n      // need to consume the Terminal\n      if (isEmpty(this.ruleStack)) {\n        // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n        // really seeking is the last Terminal...\n        this.nextProductionName = ''\n        this.nextProductionOccurrence = 0\n        this.isAtEndOfPath = true\n      } else {\n        this.nextProductionName = this.ruleStack.pop()\n        this.nextProductionOccurrence = this.occurrenceStack.pop()\n      }\n    }\n  }\n  class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n      super(topProd, path)\n      this.path = path\n      this.nextTerminalName = ''\n      this.nextTerminalOccurrence = 0\n      this.nextTerminalName = this.path.lastTok.name\n      this.nextTerminalOccurrence = this.path.lastTokOccurrence\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n      if (\n        this.isAtEndOfPath &&\n        terminal.terminalType.name === this.nextTerminalName &&\n        terminal.idx === this.nextTerminalOccurrence &&\n        !this.found\n      ) {\n        const fullRest = currRest.concat(prevRest)\n        const restProd = new Alternative({ definition: fullRest })\n        this.possibleTokTypes = first(restProd)\n        this.found = true\n      }\n    }\n  }\n  /**\n   * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n   * it never \"follows\" production refs\n   */\n  class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n      super()\n      this.topRule = topRule\n      this.occurrence = occurrence\n      this.result = {\n        token: undefined,\n        occurrence: undefined,\n        isEndOfRule: undefined,\n      }\n    }\n    startWalking() {\n      this.walk(this.topRule)\n      return this.result\n    }\n  }\n  class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n      if (manyProd.idx === this.occurrence) {\n        const firstAfterMany = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterMany === undefined\n        if (firstAfterMany instanceof Terminal) {\n          this.result.token = firstAfterMany.terminalType\n          this.result.occurrence = firstAfterMany.idx\n        }\n      } else {\n        super.walkMany(manyProd, currRest, prevRest)\n      }\n    }\n  }\n  class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n      if (manySepProd.idx === this.occurrence) {\n        const firstAfterManySep = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterManySep === undefined\n        if (firstAfterManySep instanceof Terminal) {\n          this.result.token = firstAfterManySep.terminalType\n          this.result.occurrence = firstAfterManySep.idx\n        }\n      } else {\n        super.walkManySep(manySepProd, currRest, prevRest)\n      }\n    }\n  }\n  class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      if (atLeastOneProd.idx === this.occurrence) {\n        const firstAfterAtLeastOne = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n        if (firstAfterAtLeastOne instanceof Terminal) {\n          this.result.token = firstAfterAtLeastOne.terminalType\n          this.result.occurrence = firstAfterAtLeastOne.idx\n        }\n      } else {\n        super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n      }\n    }\n  }\n  // TODO: reduce code duplication in the AfterWalkers\n  class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n      if (atleastOneSepProd.idx === this.occurrence) {\n        const firstAfterfirstAfterAtLeastOneSep = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n        if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n          this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n          this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n        }\n      } else {\n        super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n      }\n    }\n  }\n  function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath)\n    let result = []\n    let i = 0\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n      return nextDef.concat(drop(targetDef, i + 1))\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n      const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath)\n      return result.concat(alternatives)\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n      const prod = targetDef[i]\n      /* istanbul ignore else */\n      if (prod instanceof Alternative) {\n        return getAlternativesForProd(prod.definition)\n      } else if (prod instanceof NonTerminal) {\n        return getAlternativesForProd(prod.definition)\n      } else if (prod instanceof Option) {\n        result = getAlternativesForProd(prod.definition)\n      } else if (prod instanceof RepetitionMandatory) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: prod.definition,\n          }),\n        ])\n        return getAlternativesForProd(newDef)\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        const newDef = [\n          new Alternative({ definition: prod.definition }),\n          new Repetition({\n            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n          }),\n        ]\n        return getAlternativesForProd(newDef)\n      } else if (prod instanceof RepetitionWithSeparator) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n          }),\n        ])\n        result = getAlternativesForProd(newDef)\n      } else if (prod instanceof Repetition) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: prod.definition,\n          }),\n        ])\n        result = getAlternativesForProd(newDef)\n      } else if (prod instanceof Alternation) {\n        forEach(prod.definition, (currAlt) => {\n          // TODO: this is a limited check for empty alternatives\n          //   It would prevent a common case of infinite loops during parser initialization.\n          //   However **in-directly** empty alternatives may still cause issues.\n          if (isEmpty(currAlt.definition) === false) {\n            result = getAlternativesForProd(currAlt.definition)\n          }\n        })\n        return result\n      } else if (prod instanceof Terminal) {\n        currPath.push(prod.terminalType)\n      } else {\n        throw Error('non exhaustive match')\n      }\n      i++\n    }\n    result.push({\n      partialPath: currPath,\n      suffixDef: drop(targetDef, i),\n    })\n    return result\n  }\n  function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = 'EXIT_NONE_TERMINAL'\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n    const EXIT_ALTERNATIVE = 'EXIT_ALTERNATIVE'\n    let foundCompletePath = false\n    const tokenVectorLength = tokenVector.length\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n    const result = []\n    const possiblePaths = []\n    possiblePaths.push({\n      idx: -1,\n      def: initialDef,\n      ruleStack: [],\n      occurrenceStack: [],\n    })\n    while (!isEmpty(possiblePaths)) {\n      const currPath = possiblePaths.pop()\n      // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n      if (currPath === EXIT_ALTERNATIVE) {\n        if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n          // remove irrelevant alternative\n          possiblePaths.pop()\n        }\n        continue\n      }\n      const currDef = currPath.def\n      const currIdx = currPath.idx\n      const currRuleStack = currPath.ruleStack\n      const currOccurrenceStack = currPath.occurrenceStack\n      // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n      if (isEmpty(currDef)) {\n        continue\n      }\n      const prod = currDef[0]\n      /* istanbul ignore else */\n      if (prod === EXIT_NON_TERMINAL) {\n        const nextPath = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: dropRight(currRuleStack),\n          occurrenceStack: dropRight(currOccurrenceStack),\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof Terminal) {\n        /* istanbul ignore else */\n        if (currIdx < tokenVectorLength - 1) {\n          const nextIdx = currIdx + 1\n          const actualToken = tokenVector[nextIdx]\n          if (tokMatcher(actualToken, prod.terminalType)) {\n            const nextPath = {\n              idx: nextIdx,\n              def: drop(currDef),\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack,\n            }\n            possiblePaths.push(nextPath)\n          }\n          // end of the line\n        } else if (currIdx === tokenVectorLength - 1) {\n          // IGNORE ABOVE ELSE\n          result.push({\n            nextTokenType: prod.terminalType,\n            nextTokenOccurrence: prod.idx,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          })\n          foundCompletePath = true\n        } else {\n          throw Error('non exhaustive match')\n        }\n      } else if (prod instanceof NonTerminal) {\n        const newRuleStack = clone(currRuleStack)\n        newRuleStack.push(prod.nonTerminalName)\n        const newOccurrenceStack = clone(currOccurrenceStack)\n        newOccurrenceStack.push(prod.idx)\n        const nextPath = {\n          idx: currIdx,\n          def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n          ruleStack: newRuleStack,\n          occurrenceStack: newOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof Option) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        const nextPathWith = {\n          idx: currIdx,\n          def: prod.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof RepetitionMandatory) {\n        // TODO:(THE NEW operators here take a while...) (convert once?)\n        const secondIteration = new Repetition({\n          definition: prod.definition,\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n        const nextPath = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        // TODO:(THE NEW operators here take a while...) (convert once?)\n        const separatorGast = new Terminal({\n          terminalType: prod.separator,\n        })\n        const secondIteration = new Repetition({\n          definition: [separatorGast].concat(prod.definition),\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n        const nextPath = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof RepetitionWithSeparator) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        const separatorGast = new Terminal({\n          terminalType: prod.separator,\n        })\n        const nthRepetition = new Repetition({\n          definition: [separatorGast].concat(prod.definition),\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n        const nextPathWith = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof Repetition) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n        const nthRepetition = new Repetition({\n          definition: prod.definition,\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n        const nextPathWith = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof Alternation) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        for (let i = prod.definition.length - 1; i >= 0; i--) {\n          const currAlt = prod.definition[i]\n          const currAltPath = {\n            idx: currIdx,\n            def: currAlt.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          }\n          possiblePaths.push(currAltPath)\n          possiblePaths.push(EXIT_ALTERNATIVE)\n        }\n      } else if (prod instanceof Alternative) {\n        possiblePaths.push({\n          idx: currIdx,\n          def: prod.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        })\n      } else if (prod instanceof Rule) {\n        // last because we should only encounter at most a single one of these per invocation.\n        possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack))\n      } else {\n        throw Error('non exhaustive match')\n      }\n    }\n    return result\n  }\n  function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack)\n    newRuleStack.push(topRule.name)\n    const newCurrOccurrenceStack = clone(currOccurrenceStack)\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1)\n    return {\n      idx: currIdx,\n      def: topRule.definition,\n      ruleStack: newRuleStack,\n      occurrenceStack: newCurrOccurrenceStack,\n    }\n  }\n\n  var PROD_TYPE\n  ;(function (PROD_TYPE) {\n    PROD_TYPE[(PROD_TYPE['OPTION'] = 0)] = 'OPTION'\n    PROD_TYPE[(PROD_TYPE['REPETITION'] = 1)] = 'REPETITION'\n    PROD_TYPE[(PROD_TYPE['REPETITION_MANDATORY'] = 2)] = 'REPETITION_MANDATORY'\n    PROD_TYPE[(PROD_TYPE['REPETITION_MANDATORY_WITH_SEPARATOR'] = 3)] = 'REPETITION_MANDATORY_WITH_SEPARATOR'\n    PROD_TYPE[(PROD_TYPE['REPETITION_WITH_SEPARATOR'] = 4)] = 'REPETITION_WITH_SEPARATOR'\n    PROD_TYPE[(PROD_TYPE['ALTERNATION'] = 5)] = 'ALTERNATION'\n  })(PROD_TYPE || (PROD_TYPE = {}))\n  function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === 'Option') {\n      return PROD_TYPE.OPTION\n    } else if (prod instanceof Repetition || prod === 'Repetition') {\n      return PROD_TYPE.REPETITION\n    } else if (prod instanceof RepetitionMandatory || prod === 'RepetitionMandatory') {\n      return PROD_TYPE.REPETITION_MANDATORY\n    } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === 'RepetitionMandatoryWithSeparator') {\n      return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n    } else if (prod instanceof RepetitionWithSeparator || prod === 'RepetitionWithSeparator') {\n      return PROD_TYPE.REPETITION_WITH_SEPARATOR\n    } else if (prod instanceof Alternation || prod === 'Alternation') {\n      return PROD_TYPE.ALTERNATION\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function buildLookaheadFuncForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead,\n    hasPredicates,\n    dynamicTokensEnabled,\n    laFuncBuilder,\n  ) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead)\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled)\n  }\n  /**\n   *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n   *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n   *\n   *  Example: given a production:\n   *  ABC(DE)?DF\n   *\n   *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n   *  alternatives.\n   *\n   *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n   */\n  function buildLookaheadFuncForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    k,\n    dynamicTokensEnabled,\n    prodType,\n    lookaheadBuilder,\n  ) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k)\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n  }\n  function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n      return every(currAlt, (currPath) => {\n        return currPath.length === 1\n      })\n    })\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function (orAlts) {\n        // unfortunately the predicates must be extracted every single time\n        // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n        // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n        const predicates = map(orAlts, (currAlt) => currAlt.GATE)\n        for (let t = 0; t < numOfAlts; t++) {\n          const currAlt = alts[t]\n          const currNumOfPaths = currAlt.length\n          const currPredicate = predicates[t]\n          if (currPredicate !== undefined && currPredicate.call(this) === false) {\n            // if the predicate does not match there is no point in checking the paths\n            continue\n          }\n          nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j]\n            const currPathLength = currPath.length\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1)\n              if (tokenMatcher(nextToken, currPath[i]) === false) {\n                // mismatch in current path\n                // try the next pth\n                continue nextPath\n              }\n            }\n            // found a full path that matches.\n            // this will also work for an empty ALT as the loop will be skipped\n            return t\n          }\n          // none of the paths for the current alternative matched\n          // try the next alternative\n        }\n        // none of the alternatives could be matched\n        return undefined\n      }\n    } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n      // optimized (common) case of all the lookaheads paths requiring only\n      // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n      const singleTokenAlts = map(alts, (currAlt) => {\n        return flatten(currAlt)\n      })\n      const choiceToAlt = reduce(\n        singleTokenAlts,\n        (result, currAlt, idx) => {\n          forEach(currAlt, (currTokType) => {\n            if (!has(result, currTokType.tokenTypeIdx)) {\n              result[currTokType.tokenTypeIdx] = idx\n            }\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              if (!has(result, currExtendingType)) {\n                result[currExtendingType] = idx\n              }\n            })\n          })\n          return result\n        },\n        {},\n      )\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function () {\n        const nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx]\n      }\n    } else {\n      // optimized lookahead without needing to check the predicates at all.\n      // this causes code duplication which is intentional to improve performance.\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function () {\n        for (let t = 0; t < numOfAlts; t++) {\n          const currAlt = alts[t]\n          const currNumOfPaths = currAlt.length\n          nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j]\n            const currPathLength = currPath.length\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1)\n              if (tokenMatcher(nextToken, currPath[i]) === false) {\n                // mismatch in current path\n                // try the next pth\n                continue nextPath\n              }\n            }\n            // found a full path that matches.\n            // this will also work for an empty ALT as the loop will be skipped\n            return t\n          }\n          // none of the paths for the current alternative matched\n          // try the next alternative\n        }\n        // none of the alternatives could be matched\n        return undefined\n      }\n    }\n  }\n  function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n      return currPath.length === 1\n    })\n    const numOfPaths = alt.length\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n      const singleTokensTypes = flatten(alt)\n      if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n        const expectedTokenType = singleTokensTypes[0]\n        const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx\n        return function () {\n          return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n        }\n      } else {\n        const choiceToAlt = reduce(\n          singleTokensTypes,\n          (result, currTokType, idx) => {\n            result[currTokType.tokenTypeIdx] = true\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = true\n            })\n            return result\n          },\n          [],\n        )\n        return function () {\n          const nextToken = this.LA(1)\n          return choiceToAlt[nextToken.tokenTypeIdx] === true\n        }\n      }\n    } else {\n      return function () {\n        nextPath: for (let j = 0; j < numOfPaths; j++) {\n          const currPath = alt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          return true\n        }\n        // none of the paths matched\n        return false\n      }\n    }\n  }\n  class RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n      super()\n      this.topProd = topProd\n      this.targetOccurrence = targetOccurrence\n      this.targetProdType = targetProdType\n    }\n    startWalking() {\n      this.walk(this.topProd)\n      return this.restDef\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n      if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n        this.restDef = currRest.concat(prevRest)\n        return true\n      }\n      // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n      return false\n    }\n    walkOption(optionProd, currRest, prevRest) {\n      if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n        super.walkOption(optionProd, currRest, prevRest)\n      }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n        super.walkOption(atLeastOneProd, currRest, prevRest)\n      }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n      if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n        super.walkOption(atLeastOneSepProd, currRest, prevRest)\n      }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n      if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n        super.walkOption(manyProd, currRest, prevRest)\n      }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n      if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n        super.walkOption(manySepProd, currRest, prevRest)\n      }\n    }\n  }\n  /**\n   * Returns the definition of a target production in a top level level rule.\n   */\n  class InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n      super()\n      this.targetOccurrence = targetOccurrence\n      this.targetProdType = targetProdType\n      this.targetRef = targetRef\n      this.result = []\n    }\n    checkIsTarget(node, expectedProdName) {\n      if (\n        node.idx === this.targetOccurrence &&\n        this.targetProdType === expectedProdName &&\n        (this.targetRef === undefined || node === this.targetRef)\n      ) {\n        this.result = node.definition\n      }\n    }\n    visitOption(node) {\n      this.checkIsTarget(node, PROD_TYPE.OPTION)\n    }\n    visitRepetition(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION)\n    }\n    visitRepetitionMandatory(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n    }\n    visitRepetitionWithSeparator(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n    }\n    visitAlternation(node) {\n      this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n    }\n  }\n  function initializeArrayOfArrays(size) {\n    const result = new Array(size)\n    for (let i = 0; i < size; i++) {\n      result[i] = []\n    }\n    return result\n  }\n  /**\n   * A sort of hash function between a Path in the grammar and a string.\n   * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n   * -  A single path with categories may match multiple **actual** paths.\n   */\n  function pathToHashKeys(path) {\n    let keys = ['']\n    for (let i = 0; i < path.length; i++) {\n      const tokType = path[i]\n      const longerKeys = []\n      for (let j = 0; j < keys.length; j++) {\n        const currShorterKey = keys[j]\n        longerKeys.push(currShorterKey + '_' + tokType.tokenTypeIdx)\n        for (let t = 0; t < tokType.categoryMatches.length; t++) {\n          const categoriesKeySuffix = '_' + tokType.categoryMatches[t]\n          longerKeys.push(currShorterKey + categoriesKeySuffix)\n        }\n      }\n      keys = longerKeys\n    }\n    return keys\n  }\n  /**\n   * Imperative style due to being called from a hot spot\n   */\n  function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n      // We only want to test vs the other alternatives\n      if (currAltIdx === idx) {\n        continue\n      }\n      const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n      for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n        const searchKey = searchPathKeys[searchIdx]\n        if (otherAltKnownPathsKeys[searchKey] === true) {\n          return false\n        }\n      }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true\n  }\n  function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1))\n    const finalResult = initializeArrayOfArrays(partialAlts.length)\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n      const dict = {}\n      forEach(currAltPaths, (item) => {\n        const keys = pathToHashKeys(item.partialPath)\n        forEach(keys, (currKey) => {\n          dict[currKey] = true\n        })\n      })\n      return dict\n    })\n    let newData = partialAlts\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n      const currDataset = newData\n      newData = initializeArrayOfArrays(currDataset.length)\n      // alternatives loop\n      for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n        const currAltPathsAndSuffixes = currDataset[altIdx]\n        // paths in current alternative loop\n        for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n          const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n          const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n          const prefixKeys = pathToHashKeys(currPathPrefix)\n          const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n          // End of the line for this path.\n          if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n            const currAltResult = finalResult[altIdx]\n            // TODO: Can we implement a containsPath using Maps/Dictionaries?\n            if (containsPath(currAltResult, currPathPrefix) === false) {\n              currAltResult.push(currPathPrefix)\n              // Update all new  keys for the current path.\n              for (let j = 0; j < prefixKeys.length; j++) {\n                const currKey = prefixKeys[j]\n                altsHashes[altIdx][currKey] = true\n              }\n            }\n          }\n          // Expand longer paths\n          else {\n            const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix)\n            newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n            // Update keys for new known paths\n            forEach(newPartialPathsAndSuffixes, (item) => {\n              const prefixKeys = pathToHashKeys(item.partialPath)\n              forEach(prefixKeys, (key) => {\n                altsHashes[altIdx][key] = true\n              })\n            })\n          }\n        }\n      }\n    }\n    return finalResult\n  }\n  function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd)\n    ruleGrammar.accept(visitor)\n    return lookAheadSequenceFromAlternatives(visitor.result, k)\n  }\n  function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType)\n    ruleGrammar.accept(insideDefVisitor)\n    const insideDef = insideDefVisitor.result\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType)\n    const afterDef = afterDefWalker.startWalking()\n    const insideFlat = new Alternative({ definition: insideDef })\n    const afterFlat = new Alternative({ definition: afterDef })\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n  }\n  function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n      const otherPath = alternative[i]\n      if (otherPath.length !== searchPath.length) {\n        continue\n      }\n      for (let j = 0; j < otherPath.length; j++) {\n        const searchTok = searchPath[j]\n        const otherTok = otherPath[j]\n        const matchingTokens =\n          searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined\n        if (matchingTokens === false) {\n          continue compareOtherPath\n        }\n      }\n      return true\n    }\n    return false\n  }\n  function isStrictPrefixOfPath(prefix, other) {\n    return (\n      prefix.length < other.length &&\n      every(prefix, (tokType, idx) => {\n        const otherTokType = other[idx]\n        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]\n      })\n    )\n  }\n  function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) =>\n      every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))),\n    )\n  }\n\n  function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n      rules: options.rules,\n      tokenTypes: options.tokenTypes,\n      grammarName: options.grammarName,\n    })\n    return map(lookaheadValidationErrorMessages, (errorMessage) =>\n      Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage),\n    )\n  }\n  function validateGrammar$1(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) =>\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\n    )\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider)\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider))\n    const duplicateRulesError = flatMap(topLevels, (curRule) =>\n      validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider),\n    )\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)\n  }\n  function validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector()\n    topLevelRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    const productionGroups = groupBy$1(allRuleProductions, identifyProductionForDuplicates)\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n      return currGroup.length > 1\n    })\n    const errors = map(values(duplicates), (currDuplicates) => {\n      const firstProd = head(currDuplicates)\n      const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates)\n      const dslName = getProductionDslName(firstProd)\n      const defError = {\n        message: msg,\n        type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n        ruleName: topLevelRule.name,\n        dslName: dslName,\n        occurrence: firstProd.idx,\n      }\n      const param = getExtraProductionArgument(firstProd)\n      if (param) {\n        defError.parameter = param\n      }\n      return defError\n    })\n    return errors\n  }\n  function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`\n  }\n  function getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n      return prod.terminalType.name\n    } else if (prod instanceof NonTerminal) {\n      return prod.nonTerminalName\n    } else {\n      return ''\n    }\n  }\n  class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.allProductions = []\n    }\n    visitNonTerminal(subrule) {\n      this.allProductions.push(subrule)\n    }\n    visitOption(option) {\n      this.allProductions.push(option)\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.allProductions.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.allProductions.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.allProductions.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.allProductions.push(many)\n    }\n    visitAlternation(or) {\n      this.allProductions.push(or)\n    }\n    visitTerminal(terminal) {\n      this.allProductions.push(terminal)\n    }\n  }\n  function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = []\n    const occurrences = reduce(\n      allRules,\n      (result, curRule) => {\n        if (curRule.name === rule.name) {\n          return result + 1\n        }\n        return result\n      },\n      0,\n    )\n    if (occurrences > 1) {\n      const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n        topLevelRule: rule,\n        grammarName: className,\n      })\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: rule.name,\n      })\n    }\n    return errors\n  }\n  // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n  // This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n  // The grammar structure, only at runtime.\n  function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = []\n    let errMsg\n    if (!includes(definedRulesNames, ruleName)) {\n      errMsg =\n        `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n        `as it is not defined in any of the super grammars `\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n        ruleName: ruleName,\n      })\n    }\n    return errors\n  }\n  function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = []\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n    if (isEmpty(nextNonTerminals)) {\n      return []\n    } else {\n      const ruleName = topRule.name\n      const foundLeftRecursion = includes(nextNonTerminals, topRule)\n      if (foundLeftRecursion) {\n        errors.push({\n          message: errMsgProvider.buildLeftRecursionError({\n            topLevelRule: topRule,\n            leftRecursionPath: path,\n          }),\n          type: ParserDefinitionErrorType.LEFT_RECURSION,\n          ruleName: ruleName,\n        })\n      }\n      // we are only looking for cyclic paths leading back to the specific topRule\n      // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n      const validNextSteps = difference$1(nextNonTerminals, path.concat([topRule]))\n      const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n        const newPath = clone(path)\n        newPath.push(currRefRule)\n        return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath)\n      })\n      return errors.concat(errorsFromNextSteps)\n    }\n  }\n  function getFirstNoneTerminal(definition) {\n    let result = []\n    if (isEmpty(definition)) {\n      return result\n    }\n    const firstProd = head(definition)\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n      result.push(firstProd.referencedRule)\n    } else if (\n      firstProd instanceof Alternative ||\n      firstProd instanceof Option ||\n      firstProd instanceof RepetitionMandatory ||\n      firstProd instanceof RepetitionMandatoryWithSeparator ||\n      firstProd instanceof RepetitionWithSeparator ||\n      firstProd instanceof Repetition\n    ) {\n      result = result.concat(getFirstNoneTerminal(firstProd.definition))\n    } else if (firstProd instanceof Alternation) {\n      // each sub definition in alternation is a FLAT\n      result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)))\n    } else if (firstProd instanceof Terminal);\n    else {\n      throw Error('non exhaustive match')\n    }\n    const isFirstOptional = isOptionalProd(firstProd)\n    const hasMore = definition.length > 1\n    if (isFirstOptional && hasMore) {\n      const rest = drop(definition)\n      return result.concat(getFirstNoneTerminal(rest))\n    } else {\n      return result\n    }\n  }\n  class OrCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.alternations = []\n    }\n    visitAlternation(node) {\n      this.alternations.push(node)\n    }\n  }\n  function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    const ors = orCollector.alternations\n    const errors = flatMap(ors, (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1)\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx,\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1,\n            },\n          ]\n        } else {\n          return []\n        }\n      })\n    })\n    return errors\n  }\n  function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    let ors = orCollector.alternations\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n    const errors = flatMap(ors, (currOr) => {\n      const currOccurrence = currOr.idx\n      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n      const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr)\n      const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider)\n      const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider,\n      )\n      return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n    })\n    return errors\n  }\n  class RepetitionCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.allProductions = []\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.allProductions.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.allProductions.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.allProductions.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.allProductions.push(many)\n    }\n  }\n  function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    const ors = orCollector.alternations\n    const errors = flatMap(ors, (currOr) => {\n      if (currOr.definition.length > 255) {\n        return [\n          {\n            message: errMsgProvider.buildTooManyAlternativesError({\n              topLevelRule: topLevelRule,\n              alternation: currOr,\n            }),\n            type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx,\n          },\n        ]\n      } else {\n        return []\n      }\n    })\n    return errors\n  }\n  function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = []\n    forEach(topLevelRules, (currTopRule) => {\n      const collectorVisitor = new RepetitionCollector()\n      currTopRule.accept(collectorVisitor)\n      const allRuleProductions = collectorVisitor.allProductions\n      forEach(allRuleProductions, (currProd) => {\n        const prodType = getProdType(currProd)\n        const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n        const currOccurrence = currProd.idx\n        const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead)\n        const pathsInsideProduction = paths[0]\n        if (isEmpty(flatten(pathsInsideProduction))) {\n          const errMsg = errMsgProvider.buildEmptyRepetitionError({\n            topLevelRule: currTopRule,\n            repetition: currProd,\n          })\n          errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n            ruleName: currTopRule.name,\n          })\n        }\n      })\n    })\n    return errors\n  }\n  function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = []\n    const identicalAmbiguities = reduce(\n      alternatives,\n      (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n          return result\n        }\n        forEach(currAlt, (currPath) => {\n          const altsCurrPathAppearsIn = [currAltIdx]\n          forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n            if (\n              currAltIdx !== currOtherAltIdx &&\n              containsPath(currOtherAlt, currPath) &&\n              // ignore (skip) ambiguities with this \"other\" alternative\n              alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n            ) {\n              altsCurrPathAppearsIn.push(currOtherAltIdx)\n            }\n          })\n          if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n            foundAmbiguousPaths.push(currPath)\n            result.push({\n              alts: altsCurrPathAppearsIn,\n              path: currPath,\n            })\n          }\n        })\n        return result\n      },\n      [],\n    )\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n      const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1)\n      const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbDescriptor.path,\n      })\n      return {\n        message: currMessage,\n        type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n        ruleName: rule.name,\n        occurrence: alternation.idx,\n        alternatives: currAmbDescriptor.alts,\n      }\n    })\n    return currErrors\n  }\n  function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(\n      alternatives,\n      (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n          return { idx: idx, path: currPath }\n        })\n        return result.concat(currPathsAndIdx)\n      },\n      [],\n    )\n    const errors = compact(\n      flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx]\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n          return []\n        }\n        const targetIdx = currPathAndIdx.idx\n        const targetPath = currPathAndIdx.path\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        })\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? '' : alternation.idx\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path,\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices,\n          }\n        })\n        return currPathPrefixErrors\n      }),\n    )\n    return errors\n  }\n  function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = []\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n    forEach(topLevels, (currRule) => {\n      const currRuleName = currRule.name\n      if (includes(tokenNames, currRuleName)) {\n        const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n          ruleName: currRuleName,\n        })\n      }\n    })\n    return errors\n  }\n\n  function resolveGrammar(options) {\n    const actualOptions = defaults$1(options, {\n      errMsgProvider: defaultGrammarResolverErrorProvider,\n    })\n    const topRulesTable = {}\n    forEach(options.rules, (rule) => {\n      topRulesTable[rule.name] = rule\n    })\n    return resolveGrammar$1(topRulesTable, actualOptions.errMsgProvider)\n  }\n  function validateGrammar(options) {\n    options = defaults$1(options, {\n      errMsgProvider: defaultGrammarValidatorErrorProvider,\n    })\n    return validateGrammar$1(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName)\n  }\n\n  const MISMATCHED_TOKEN_EXCEPTION = 'MismatchedTokenException'\n  const NO_VIABLE_ALT_EXCEPTION = 'NoViableAltException'\n  const EARLY_EXIT_EXCEPTION = 'EarlyExitException'\n  const NOT_ALL_INPUT_PARSED_EXCEPTION = 'NotAllInputParsedException'\n  const RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n  ]\n  Object.freeze(RECOGNITION_EXCEPTION_NAMES)\n  // hacks to bypass no support for custom Errors in javascript/typescript\n  function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name)\n  }\n  class RecognitionException extends Error {\n    constructor(message, token) {\n      super(message)\n      this.token = token\n      this.resyncedTokens = []\n      // fix prototype chain when typescript target is ES5\n      Object.setPrototypeOf(this, new.target.prototype)\n      /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor)\n      }\n    }\n  }\n  class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = MISMATCHED_TOKEN_EXCEPTION\n    }\n  }\n  class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = NO_VIABLE_ALT_EXCEPTION\n    }\n  }\n  class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n      super(message, token)\n      this.name = NOT_ALL_INPUT_PARSED_EXCEPTION\n    }\n  }\n  class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = EARLY_EXIT_EXCEPTION\n    }\n  }\n\n  const EOF_FOLLOW_KEY = {}\n  const IN_RULE_RECOVERY_EXCEPTION = 'InRuleRecoveryException'\n  class InRuleRecoveryException extends Error {\n    constructor(message) {\n      super(message)\n      this.name = IN_RULE_RECOVERY_EXCEPTION\n    }\n  }\n  /**\n   * This trait is responsible for the error recovery and fault tolerant logic\n   */\n  class Recoverable {\n    initRecoverable(config) {\n      this.firstAfterRepMap = {}\n      this.resyncFollows = {}\n      this.recoveryEnabled = has(config, 'recoveryEnabled')\n        ? config.recoveryEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.recoveryEnabled\n      // performance optimization, NOOP will be inlined which\n      // effectively means that this optional feature does not exist\n      // when not used.\n      if (this.recoveryEnabled) {\n        this.attemptInRepetitionRecovery = attemptInRepetitionRecovery\n      }\n    }\n    getTokenToInsert(tokType) {\n      const tokToInsert = createTokenInstance(tokType, '', NaN, NaN, NaN, NaN, NaN, NaN)\n      tokToInsert.isInsertedInRecovery = true\n      return tokToInsert\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n      return true\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n      return true\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n      // TODO: can the resyncTokenType be cached?\n      const reSyncTokType = this.findReSyncTokenType()\n      const savedLexerState = this.exportLexerState()\n      const resyncedTokens = []\n      let passedResyncPoint = false\n      const nextTokenWithoutResync = this.LA(1)\n      let currToken = this.LA(1)\n      const generateErrorMessage = () => {\n        const previousToken = this.LA(0)\n        // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n        // the error that would have been thrown\n        const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n          expected: expectedTokType,\n          actual: nextTokenWithoutResync,\n          previous: previousToken,\n          ruleName: this.getCurrRuleFullName(),\n        })\n        const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0))\n        // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n        error.resyncedTokens = dropRight(resyncedTokens)\n        this.SAVE_ERROR(error)\n      }\n      while (!passedResyncPoint) {\n        // re-synced to a point where we can safely exit the repetition/\n        if (this.tokenMatcher(currToken, expectedTokType)) {\n          generateErrorMessage()\n          return // must return here to avoid reverting the inputIdx\n        } else if (lookAheadFunc.call(this)) {\n          // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n          generateErrorMessage()\n          // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n          grammarRule.apply(this, grammarRuleArgs)\n          return // must return here to avoid reverting the inputIdx\n        } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n          passedResyncPoint = true\n        } else {\n          currToken = this.SKIP_TOKEN()\n          this.addToResyncTokens(currToken, resyncedTokens)\n        }\n      }\n      // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n      // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n      // \"between rules\" resync recovery later in the flow.\n      this.importLexerState(savedLexerState)\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n      // Edge case of arriving from a MANY repetition which is stuck\n      // Attempting recovery in this case could cause an infinite loop\n      if (notStuck === false) {\n        return false\n      }\n      // no need to recover, next token is what we expect...\n      if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n        return false\n      }\n      // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n      // and prefer some backtracking path that includes recovered errors.\n      if (this.isBackTracking()) {\n        return false\n      }\n      // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n      // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n      //noinspection RedundantIfStatementJS\n      if (\n        this.canPerformInRuleRecovery(\n          expectTokAfterLastMatch,\n          this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx),\n        )\n      ) {\n        return false\n      }\n      return true\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n      const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule)\n      const follows = this.getNextPossibleTokenTypes(grammarPath)\n      return follows\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n      if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n        const tokToInsert = this.getTokenToInsert(expectedTokType)\n        return tokToInsert\n      }\n      if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n        const nextTok = this.SKIP_TOKEN()\n        this.consumeToken()\n        return nextTok\n      }\n      throw new InRuleRecoveryException('sad sad panda')\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n      return (\n        this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n        this.canRecoverWithSingleTokenDeletion(expectedToken)\n      )\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n      if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n        return false\n      }\n      // must know the possible following tokens to perform single token insertion\n      if (isEmpty(follows)) {\n        return false\n      }\n      const mismatchedTok = this.LA(1)\n      const isMisMatchedTokInFollows =\n        find$1(follows, (possibleFollowsTokType) => {\n          return this.tokenMatcher(mismatchedTok, possibleFollowsTokType)\n        }) !== undefined\n      return isMisMatchedTokInFollows\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n      if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n        return false\n      }\n      const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType)\n      return isNextTokenWhatIsExpected\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n      const followKey = this.getCurrFollowKey()\n      const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey)\n      return includes(currentRuleReSyncSet, tokenTypeIdx)\n    }\n    findReSyncTokenType() {\n      const allPossibleReSyncTokTypes = this.flattenFollowSet()\n      // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n      let nextToken = this.LA(1)\n      let k = 2\n      while (true) {\n        const foundMatch = find$1(allPossibleReSyncTokTypes, (resyncTokType) => {\n          const canMatch = tokenMatcher(nextToken, resyncTokType)\n          return canMatch\n        })\n        if (foundMatch !== undefined) {\n          return foundMatch\n        }\n        nextToken = this.LA(k)\n        k++\n      }\n    }\n    getCurrFollowKey() {\n      // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n      if (this.RULE_STACK.length === 1) {\n        return EOF_FOLLOW_KEY\n      }\n      const currRuleShortName = this.getLastExplicitRuleShortName()\n      const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex()\n      const prevRuleShortName = this.getPreviousExplicitRuleShortName()\n      return {\n        ruleName: this.shortRuleNameToFullName(currRuleShortName),\n        idxInCallingRule: currRuleIdx,\n        inRule: this.shortRuleNameToFullName(prevRuleShortName),\n      }\n    }\n    buildFullFollowKeyStack() {\n      const explicitRuleStack = this.RULE_STACK\n      const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK\n      return map(explicitRuleStack, (ruleName, idx) => {\n        if (idx === 0) {\n          return EOF_FOLLOW_KEY\n        }\n        return {\n          ruleName: this.shortRuleNameToFullName(ruleName),\n          idxInCallingRule: explicitOccurrenceStack[idx],\n          inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n        }\n      })\n    }\n    flattenFollowSet() {\n      const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n        return this.getFollowSetFromFollowKey(currKey)\n      })\n      return flatten(followStack)\n    }\n    getFollowSetFromFollowKey(followKey) {\n      if (followKey === EOF_FOLLOW_KEY) {\n        return [EOF]\n      }\n      const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule\n      return this.resyncFollows[followName]\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n      if (!this.tokenMatcher(token, EOF)) {\n        resyncTokens.push(token)\n      }\n      return resyncTokens\n    }\n    reSyncTo(tokType) {\n      const resyncedTokens = []\n      let nextTok = this.LA(1)\n      while (this.tokenMatcher(nextTok, tokType) === false) {\n        nextTok = this.SKIP_TOKEN()\n        this.addToResyncTokens(nextTok, resyncedTokens)\n      }\n      // the last token is not part of the error.\n      return dropRight(resyncedTokens)\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n      // by default this is a NO-OP\n      // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n      const pathRuleStack = this.getHumanReadableRuleStack()\n      const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK)\n      const grammarPath = {\n        ruleStack: pathRuleStack,\n        occurrenceStack: pathOccurrenceStack,\n        lastTok: tokType,\n        lastTokOccurrence: tokIdxInRule,\n      }\n      return grammarPath\n    }\n    getHumanReadableRuleStack() {\n      return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName))\n    }\n  }\n  function attemptInRepetitionRecovery(\n    prodFunc,\n    args,\n    lookaheadFunc,\n    dslMethodIdx,\n    prodOccurrence,\n    nextToksWalker,\n    notStuck,\n  ) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence)\n    let firstAfterRepInfo = this.firstAfterRepMap[key]\n    if (firstAfterRepInfo === undefined) {\n      const currRuleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[currRuleName]\n      const walker = new nextToksWalker(ruleGrammar, prodOccurrence)\n      firstAfterRepInfo = walker.startWalking()\n      this.firstAfterRepMap[key] = firstAfterRepInfo\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token\n    let nextTokIdx = firstAfterRepInfo.occurrence\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n      expectTokAfterLastMatch = EOF\n      nextTokIdx = 1\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n      // TODO: performance optimization: instead of passing the original args here, we modify\n      // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n      // to avoid searching the cache for it once more.\n      this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch)\n    }\n  }\n\n  // Lookahead keys are 32Bit integers in the form\n  // TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n  // XXXX -> Occurrence Index bitmap.\n  // YYYY -> DSL Method Type bitmap.\n  // ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n  // TTTTTTTTT -> alternation alternative index bitmap\n  const BITS_FOR_METHOD_TYPE = 4\n  const BITS_FOR_OCCURRENCE_IDX = 8\n  // short string used as part of mapping keys.\n  // being short improves the performance when composing KEYS for maps out of these\n  // The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n  const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\n  const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\n  const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\n  const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\n  const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\n  const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n  // this actually returns a number, but it is always used as a string (object prop key)\n  function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx\n  }\n\n  class LLkLookaheadStrategy {\n    constructor(options) {\n      var _a\n      this.maxLookahead =\n        (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0\n          ? _a\n          : DEFAULT_PARSER_CONFIG.maxLookahead\n    }\n    validate(options) {\n      const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n      if (isEmpty(leftRecursionErrors)) {\n        const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n        const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead)\n        const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead)\n        const allErrors = [...leftRecursionErrors, ...emptyAltErrors, ...ambiguousAltsErrors, ...emptyRepetitionErrors]\n        return allErrors\n      }\n      return leftRecursionErrors\n    }\n    validateNoLeftRecursion(rules) {\n      return flatMap(rules, (currTopRule) =>\n        validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateEmptyOrAlternatives(rules) {\n      return flatMap(rules, (currTopRule) =>\n        validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n      return flatMap(rules, (currTopRule) =>\n        validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n      return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider)\n    }\n    buildLookaheadForAlternation(options) {\n      return buildLookaheadFuncForOr(\n        options.prodOccurrence,\n        options.rule,\n        options.maxLookahead,\n        options.hasPredicates,\n        options.dynamicTokensEnabled,\n        buildAlternativesLookAheadFunc,\n      )\n    }\n    buildLookaheadForOptional(options) {\n      return buildLookaheadFuncForOptionalProd(\n        options.prodOccurrence,\n        options.rule,\n        options.maxLookahead,\n        options.dynamicTokensEnabled,\n        getProdType(options.prodType),\n        buildSingleAlternativeLookaheadFunction,\n      )\n    }\n  }\n\n  /**\n   * Trait responsible for the lookahead related utilities and optimizations.\n   */\n  class LooksAhead {\n    initLooksAhead(config) {\n      this.dynamicTokensEnabled = has(config, 'dynamicTokensEnabled')\n        ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n      this.maxLookahead = has(config, 'maxLookahead')\n        ? config.maxLookahead // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.maxLookahead\n      this.lookaheadStrategy = has(config, 'lookaheadStrategy')\n        ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n        : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n      this.lookAheadFuncsCache = new Map()\n    }\n    preComputeLookaheadFunctions(rules) {\n      forEach(rules, (currRule) => {\n        this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n          const {\n            alternation,\n            repetition,\n            option,\n            repetitionMandatory,\n            repetitionMandatoryWithSeparator,\n            repetitionWithSeparator,\n          } = collectMethods(currRule)\n          forEach(alternation, (currProd) => {\n            const prodIdx = currProd.idx === 0 ? '' : currProd.idx\n            this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n              const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                prodOccurrence: currProd.idx,\n                rule: currRule,\n                maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                hasPredicates: currProd.hasPredicates,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n              })\n              const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx)\n              this.setLaFuncCache(key, laFunc)\n            })\n          })\n          forEach(repetition, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              MANY_IDX,\n              'Repetition',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(option, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              OPTION_IDX,\n              'Option',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionMandatory, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              AT_LEAST_ONE_IDX,\n              'RepetitionMandatory',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionMandatoryWithSeparator, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              AT_LEAST_ONE_SEP_IDX,\n              'RepetitionMandatoryWithSeparator',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionWithSeparator, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              MANY_SEP_IDX,\n              'RepetitionWithSeparator',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n        })\n      })\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n      this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? '' : prodOccurrence}`, () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType,\n        })\n        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence)\n        this.setLaFuncCache(key, laFunc)\n      })\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n      const currRuleShortName = this.getLastExplicitRuleShortName()\n      return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence)\n    }\n    getLaFuncFromCache(key) {\n      return this.lookAheadFuncsCache.get(key)\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n      this.lookAheadFuncsCache.set(key, value)\n    }\n  }\n  class DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.dslMethods = {\n        option: [],\n        alternation: [],\n        repetition: [],\n        repetitionWithSeparator: [],\n        repetitionMandatory: [],\n        repetitionMandatoryWithSeparator: [],\n      }\n    }\n    reset() {\n      this.dslMethods = {\n        option: [],\n        alternation: [],\n        repetition: [],\n        repetitionWithSeparator: [],\n        repetitionMandatory: [],\n        repetitionMandatoryWithSeparator: [],\n      }\n    }\n    visitOption(option) {\n      this.dslMethods.option.push(option)\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.dslMethods.repetitionWithSeparator.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.dslMethods.repetitionMandatory.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.dslMethods.repetition.push(many)\n    }\n    visitAlternation(or) {\n      this.dslMethods.alternation.push(or)\n    }\n  }\n  const collectorVisitor = new DslMethodsCollectorVisitor()\n  function collectMethods(rule) {\n    collectorVisitor.reset()\n    rule.accept(collectorVisitor)\n    const dslMethods = collectorVisitor.dslMethods\n    // avoid uncleaned references\n    collectorVisitor.reset()\n    return dslMethods\n  }\n\n  /**\n   * This nodeLocation tracking is not efficient and should only be used\n   * when error recovery is enabled or the Token Vector contains virtual Tokens\n   * (e.g, Python Indent/Outdent)\n   * As it executes the calculation for every single terminal/nonTerminal\n   * and does not rely on the fact the token vector is **sorted**\n   */\n  function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n      // assumption1: Token location information is either NaN or a valid number\n      // assumption2: Token location information is fully valid if it exist\n      // (both start/end offsets exist and are numbers).\n      currNodeLocation.startOffset = newLocationInfo.startOffset\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n    }\n  }\n  /**\n   * This nodeLocation tracking is not efficient and should only be used\n   * when error recovery is enabled or the Token Vector contains virtual Tokens\n   * (e.g, Python Indent/Outdent)\n   * As it executes the calculation for every single terminal/nonTerminal\n   * and does not rely on the fact the token vector is **sorted**\n   */\n  function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n      // assumption1: Token location information is either NaN or a valid number\n      // assumption2: Token location information is fully valid if it exist\n      // (all start/end props exist and are numbers).\n      currNodeLocation.startOffset = newLocationInfo.startOffset\n      currNodeLocation.startColumn = newLocationInfo.startColumn\n      currNodeLocation.startLine = newLocationInfo.startLine\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n      currNodeLocation.endColumn = newLocationInfo.endColumn\n      currNodeLocation.endLine = newLocationInfo.endLine\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n      currNodeLocation.endColumn = newLocationInfo.endColumn\n      currNodeLocation.endLine = newLocationInfo.endLine\n    }\n  }\n  function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n      node.children[tokenTypeName] = [token]\n    } else {\n      node.children[tokenTypeName].push(token)\n    }\n  }\n  function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n      node.children[ruleName] = [ruleResult]\n    } else {\n      node.children[ruleName].push(ruleResult)\n    }\n  }\n\n  const NAME = 'name'\n  function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: nameValue,\n    })\n  }\n\n  function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx)\n    const childrenNamesLength = childrenNames.length\n    for (let i = 0; i < childrenNamesLength; i++) {\n      const currChildName = childrenNames[i]\n      const currChildArray = ctx[currChildName]\n      const currChildArrayLength = currChildArray.length\n      for (let j = 0; j < currChildArrayLength; j++) {\n        const currChild = currChildArray[j]\n        // distinction between Tokens Children and CstNode children\n        if (currChild.tokenTypeIdx === undefined) {\n          this[currChild.name](currChild.children, param)\n        }\n      }\n    }\n    // defaultVisit does not support generic out param\n  }\n  function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () {}\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + 'BaseSemantics')\n    const semanticProto = {\n      visit: function (cstNode, param) {\n        // enables writing more concise visitor methods when CstNode has only a single child\n        if (isArray$1(cstNode)) {\n          // A CST Node's children dictionary can never have empty arrays as values\n          // If a key is defined there will be at least one element in the corresponding value array.\n          cstNode = cstNode[0]\n        }\n        // enables passing optional CstNodes concisely.\n        if (isUndefined(cstNode)) {\n          return undefined\n        }\n        return this[cstNode.name](cstNode.children, param)\n      },\n      validateVisitor: function () {\n        const semanticDefinitionErrors = validateVisitor(this, ruleNames)\n        if (!isEmpty(semanticDefinitionErrors)) {\n          const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg)\n          throw Error(\n            `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n              `${errorMessages.join('\\n\\n').replace(/\\n/g, '\\n\\t')}`,\n          )\n        }\n      },\n    }\n    derivedConstructor.prototype = semanticProto\n    derivedConstructor.prototype.constructor = derivedConstructor\n    derivedConstructor._RULE_NAMES = ruleNames\n    return derivedConstructor\n  }\n  function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () {}\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + 'BaseSemanticsWithDefaults')\n    const withDefaultsProto = Object.create(baseConstructor.prototype)\n    forEach(ruleNames, (ruleName) => {\n      withDefaultsProto[ruleName] = defaultVisit\n    })\n    derivedConstructor.prototype = withDefaultsProto\n    derivedConstructor.prototype.constructor = derivedConstructor\n    return derivedConstructor\n  }\n  var CstVisitorDefinitionError\n  ;(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[(CstVisitorDefinitionError['REDUNDANT_METHOD'] = 0)] = 'REDUNDANT_METHOD'\n    CstVisitorDefinitionError[(CstVisitorDefinitionError['MISSING_METHOD'] = 1)] = 'MISSING_METHOD'\n  })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}))\n  function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames)\n    return missingErrors\n  }\n  function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n      return isFunction(visitorInstance[currRuleName]) === false\n    })\n    const errors = map(missingRuleNames, (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName,\n      }\n    })\n    return compact(errors)\n  }\n\n  /**\n   * This trait is responsible for the CST building logic.\n   */\n  class TreeBuilder {\n    initTreeBuilder(config) {\n      this.CST_STACK = []\n      // outputCst is no longer exposed/defined in the pubic API\n      this.outputCst = config.outputCst\n      this.nodeLocationTracking = has(config, 'nodeLocationTracking')\n        ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n      if (!this.outputCst) {\n        this.cstInvocationStateUpdate = noop\n        this.cstFinallyStateUpdate = noop\n        this.cstPostTerminal = noop\n        this.cstPostNonTerminal = noop\n        this.cstPostRule = noop\n      } else {\n        if (/full/i.test(this.nodeLocationTracking)) {\n          if (this.recoveryEnabled) {\n            this.setNodeLocationFromToken = setNodeLocationFull\n            this.setNodeLocationFromNode = setNodeLocationFull\n            this.cstPostRule = noop\n            this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n          } else {\n            this.setNodeLocationFromToken = noop\n            this.setNodeLocationFromNode = noop\n            this.cstPostRule = this.cstPostRuleFull\n            this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n          }\n        } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n          if (this.recoveryEnabled) {\n            this.setNodeLocationFromToken = setNodeLocationOnlyOffset\n            this.setNodeLocationFromNode = setNodeLocationOnlyOffset\n            this.cstPostRule = noop\n            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery\n          } else {\n            this.setNodeLocationFromToken = noop\n            this.setNodeLocationFromNode = noop\n            this.cstPostRule = this.cstPostRuleOnlyOffset\n            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular\n          }\n        } else if (/none/i.test(this.nodeLocationTracking)) {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = noop\n          this.setInitialNodeLocation = noop\n        } else {\n          throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`)\n        }\n      }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n      cstNode.location = {\n        startOffset: NaN,\n        endOffset: NaN,\n      }\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n      cstNode.location = {\n        // without error recovery the starting Location of a new CstNode is guaranteed\n        // To be the next Token's startOffset (for valid inputs).\n        // For invalid inputs there won't be any CSTOutput so this potential\n        // inaccuracy does not matter\n        startOffset: this.LA(1).startOffset,\n        endOffset: NaN,\n      }\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n      cstNode.location = {\n        startOffset: NaN,\n        startLine: NaN,\n        startColumn: NaN,\n        endOffset: NaN,\n        endLine: NaN,\n        endColumn: NaN,\n      }\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n      const nextToken = this.LA(1)\n      cstNode.location = {\n        startOffset: nextToken.startOffset,\n        startLine: nextToken.startLine,\n        startColumn: nextToken.startColumn,\n        endOffset: NaN,\n        endLine: NaN,\n        endColumn: NaN,\n      }\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n      const cstNode = {\n        name: fullRuleName,\n        children: Object.create(null),\n      }\n      this.setInitialNodeLocation(cstNode)\n      this.CST_STACK.push(cstNode)\n    }\n    cstFinallyStateUpdate() {\n      this.CST_STACK.pop()\n    }\n    cstPostRuleFull(ruleCstNode) {\n      // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n      const prevToken = this.LA(0)\n      const loc = ruleCstNode.location\n      // If this condition is true it means we consumed at least one Token\n      // In this CstNode.\n      if (loc.startOffset <= prevToken.startOffset === true) {\n        loc.endOffset = prevToken.endOffset\n        loc.endLine = prevToken.endLine\n        loc.endColumn = prevToken.endColumn\n      }\n      // \"empty\" CstNode edge case\n      else {\n        loc.startOffset = NaN\n        loc.startLine = NaN\n        loc.startColumn = NaN\n      }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n      const prevToken = this.LA(0)\n      // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n      const loc = ruleCstNode.location\n      // If this condition is true it means we consumed at least one Token\n      // In this CstNode.\n      if (loc.startOffset <= prevToken.startOffset === true) {\n        loc.endOffset = prevToken.endOffset\n      }\n      // \"empty\" CstNode edge case\n      else {\n        loc.startOffset = NaN\n      }\n    }\n    cstPostTerminal(key, consumedToken) {\n      const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n      addTerminalToCst(rootCst, consumedToken, key)\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromToken(rootCst.location, consumedToken)\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n      const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location)\n    }\n    getBaseCstVisitorConstructor() {\n      if (isUndefined(this.baseCstVisitorConstructor)) {\n        const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n          this.className,\n          keys(this.gastProductionsCache),\n        )\n        this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n        return newBaseCstVisitorConstructor\n      }\n      return this.baseCstVisitorConstructor\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n      if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n        const newConstructor = createBaseVisitorConstructorWithDefaults(\n          this.className,\n          keys(this.gastProductionsCache),\n          this.getBaseCstVisitorConstructor(),\n        )\n        this.baseCstVisitorWithDefaultsConstructor = newConstructor\n        return newConstructor\n      }\n      return this.baseCstVisitorWithDefaultsConstructor\n    }\n    getLastExplicitRuleShortName() {\n      const ruleStack = this.RULE_STACK\n      return ruleStack[ruleStack.length - 1]\n    }\n    getPreviousExplicitRuleShortName() {\n      const ruleStack = this.RULE_STACK\n      return ruleStack[ruleStack.length - 2]\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n      const occurrenceStack = this.RULE_OCCURRENCE_STACK\n      return occurrenceStack[occurrenceStack.length - 1]\n    }\n  }\n\n  /**\n   * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n   *\n   * This could be generalized to support other kinds of lexers, e.g.\n   * - Just in Time Lexing / Lexer-Less parsing.\n   * - Streaming Lexer.\n   */\n  class LexerAdapter {\n    initLexerAdapter() {\n      this.tokVector = []\n      this.tokVectorLength = 0\n      this.currIdx = -1\n    }\n    set input(newInput) {\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      if (this.selfAnalysisDone !== true) {\n        throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`)\n      }\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      this.reset()\n      this.tokVector = newInput\n      this.tokVectorLength = newInput.length\n    }\n    get input() {\n      return this.tokVector\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n      if (this.currIdx <= this.tokVector.length - 2) {\n        this.consumeToken()\n        return this.LA(1)\n      } else {\n        return END_OF_FILE\n      }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n      const soughtIdx = this.currIdx + howMuch\n      if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n        return END_OF_FILE\n      } else {\n        return this.tokVector[soughtIdx]\n      }\n    }\n    consumeToken() {\n      this.currIdx++\n    }\n    exportLexerState() {\n      return this.currIdx\n    }\n    importLexerState(newState) {\n      this.currIdx = newState\n    }\n    resetLexerState() {\n      this.currIdx = -1\n    }\n    moveToTerminatedState() {\n      this.currIdx = this.tokVector.length - 1\n    }\n    getLexerPosition() {\n      return this.exportLexerState()\n    }\n  }\n\n  /**\n   * This trait is responsible for implementing the public API\n   * for defining Chevrotain parsers, i.e:\n   * - CONSUME\n   * - RULE\n   * - OPTION\n   * - ...\n   */\n  class RecognizerApi {\n    ACTION(impl) {\n      return impl.call(this)\n    }\n    consume(idx, tokType, options) {\n      return this.consumeInternal(tokType, idx, options)\n    }\n    subrule(idx, ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, idx, options)\n    }\n    option(idx, actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, idx)\n    }\n    or(idx, altsOrOpts) {\n      return this.orInternal(altsOrOpts, idx)\n    }\n    many(idx, actionORMethodDef) {\n      return this.manyInternal(idx, actionORMethodDef)\n    }\n    atLeastOne(idx, actionORMethodDef) {\n      return this.atLeastOneInternal(idx, actionORMethodDef)\n    }\n    CONSUME(tokType, options) {\n      return this.consumeInternal(tokType, 0, options)\n    }\n    CONSUME1(tokType, options) {\n      return this.consumeInternal(tokType, 1, options)\n    }\n    CONSUME2(tokType, options) {\n      return this.consumeInternal(tokType, 2, options)\n    }\n    CONSUME3(tokType, options) {\n      return this.consumeInternal(tokType, 3, options)\n    }\n    CONSUME4(tokType, options) {\n      return this.consumeInternal(tokType, 4, options)\n    }\n    CONSUME5(tokType, options) {\n      return this.consumeInternal(tokType, 5, options)\n    }\n    CONSUME6(tokType, options) {\n      return this.consumeInternal(tokType, 6, options)\n    }\n    CONSUME7(tokType, options) {\n      return this.consumeInternal(tokType, 7, options)\n    }\n    CONSUME8(tokType, options) {\n      return this.consumeInternal(tokType, 8, options)\n    }\n    CONSUME9(tokType, options) {\n      return this.consumeInternal(tokType, 9, options)\n    }\n    SUBRULE(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 0, options)\n    }\n    SUBRULE1(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 1, options)\n    }\n    SUBRULE2(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 2, options)\n    }\n    SUBRULE3(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 3, options)\n    }\n    SUBRULE4(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 4, options)\n    }\n    SUBRULE5(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 5, options)\n    }\n    SUBRULE6(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 6, options)\n    }\n    SUBRULE7(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 7, options)\n    }\n    SUBRULE8(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 8, options)\n    }\n    SUBRULE9(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 9, options)\n    }\n    OPTION(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 0)\n    }\n    OPTION1(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 1)\n    }\n    OPTION2(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 2)\n    }\n    OPTION3(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 3)\n    }\n    OPTION4(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 4)\n    }\n    OPTION5(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 5)\n    }\n    OPTION6(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 6)\n    }\n    OPTION7(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 7)\n    }\n    OPTION8(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 8)\n    }\n    OPTION9(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 9)\n    }\n    OR(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 0)\n    }\n    OR1(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 1)\n    }\n    OR2(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 2)\n    }\n    OR3(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 3)\n    }\n    OR4(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 4)\n    }\n    OR5(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 5)\n    }\n    OR6(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 6)\n    }\n    OR7(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 7)\n    }\n    OR8(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 8)\n    }\n    OR9(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 9)\n    }\n    MANY(actionORMethodDef) {\n      this.manyInternal(0, actionORMethodDef)\n    }\n    MANY1(actionORMethodDef) {\n      this.manyInternal(1, actionORMethodDef)\n    }\n    MANY2(actionORMethodDef) {\n      this.manyInternal(2, actionORMethodDef)\n    }\n    MANY3(actionORMethodDef) {\n      this.manyInternal(3, actionORMethodDef)\n    }\n    MANY4(actionORMethodDef) {\n      this.manyInternal(4, actionORMethodDef)\n    }\n    MANY5(actionORMethodDef) {\n      this.manyInternal(5, actionORMethodDef)\n    }\n    MANY6(actionORMethodDef) {\n      this.manyInternal(6, actionORMethodDef)\n    }\n    MANY7(actionORMethodDef) {\n      this.manyInternal(7, actionORMethodDef)\n    }\n    MANY8(actionORMethodDef) {\n      this.manyInternal(8, actionORMethodDef)\n    }\n    MANY9(actionORMethodDef) {\n      this.manyInternal(9, actionORMethodDef)\n    }\n    MANY_SEP(options) {\n      this.manySepFirstInternal(0, options)\n    }\n    MANY_SEP1(options) {\n      this.manySepFirstInternal(1, options)\n    }\n    MANY_SEP2(options) {\n      this.manySepFirstInternal(2, options)\n    }\n    MANY_SEP3(options) {\n      this.manySepFirstInternal(3, options)\n    }\n    MANY_SEP4(options) {\n      this.manySepFirstInternal(4, options)\n    }\n    MANY_SEP5(options) {\n      this.manySepFirstInternal(5, options)\n    }\n    MANY_SEP6(options) {\n      this.manySepFirstInternal(6, options)\n    }\n    MANY_SEP7(options) {\n      this.manySepFirstInternal(7, options)\n    }\n    MANY_SEP8(options) {\n      this.manySepFirstInternal(8, options)\n    }\n    MANY_SEP9(options) {\n      this.manySepFirstInternal(9, options)\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n      this.atLeastOneInternal(0, actionORMethodDef)\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n      return this.atLeastOneInternal(1, actionORMethodDef)\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n      this.atLeastOneInternal(2, actionORMethodDef)\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n      this.atLeastOneInternal(3, actionORMethodDef)\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n      this.atLeastOneInternal(4, actionORMethodDef)\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n      this.atLeastOneInternal(5, actionORMethodDef)\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n      this.atLeastOneInternal(6, actionORMethodDef)\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n      this.atLeastOneInternal(7, actionORMethodDef)\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n      this.atLeastOneInternal(8, actionORMethodDef)\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n      this.atLeastOneInternal(9, actionORMethodDef)\n    }\n    AT_LEAST_ONE_SEP(options) {\n      this.atLeastOneSepFirstInternal(0, options)\n    }\n    AT_LEAST_ONE_SEP1(options) {\n      this.atLeastOneSepFirstInternal(1, options)\n    }\n    AT_LEAST_ONE_SEP2(options) {\n      this.atLeastOneSepFirstInternal(2, options)\n    }\n    AT_LEAST_ONE_SEP3(options) {\n      this.atLeastOneSepFirstInternal(3, options)\n    }\n    AT_LEAST_ONE_SEP4(options) {\n      this.atLeastOneSepFirstInternal(4, options)\n    }\n    AT_LEAST_ONE_SEP5(options) {\n      this.atLeastOneSepFirstInternal(5, options)\n    }\n    AT_LEAST_ONE_SEP6(options) {\n      this.atLeastOneSepFirstInternal(6, options)\n    }\n    AT_LEAST_ONE_SEP7(options) {\n      this.atLeastOneSepFirstInternal(7, options)\n    }\n    AT_LEAST_ONE_SEP8(options) {\n      this.atLeastOneSepFirstInternal(8, options)\n    }\n    AT_LEAST_ONE_SEP9(options) {\n      this.atLeastOneSepFirstInternal(9, options)\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n      if (includes(this.definedRulesNames, name)) {\n        const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className,\n        })\n        const error = {\n          message: errMsg,\n          type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n          ruleName: name,\n        }\n        this.definitionErrors.push(error)\n      }\n      this.definedRulesNames.push(name)\n      const ruleImplementation = this.defineRule(name, implementation, config)\n      this[name] = ruleImplementation\n      return ruleImplementation\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n      const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className)\n      this.definitionErrors = this.definitionErrors.concat(ruleErrors)\n      const ruleImplementation = this.defineRule(name, impl, config)\n      this[name] = ruleImplementation\n      return ruleImplementation\n    }\n    BACKTRACK(grammarRule, args) {\n      return function () {\n        // save org state\n        this.isBackTrackingStack.push(1)\n        const orgState = this.saveRecogState()\n        try {\n          grammarRule.apply(this, args)\n          // if no exception was thrown we have succeed parsing the rule.\n          return true\n        } catch (e) {\n          if (isRecognitionException(e)) {\n            return false\n          } else {\n            throw e\n          }\n        } finally {\n          this.reloadRecogState(orgState)\n          this.isBackTrackingStack.pop()\n        }\n      }\n    }\n    // GAST export APIs\n    getGAstProductions() {\n      return this.gastProductionsCache\n    }\n    getSerializedGastProductions() {\n      return serializeGrammar(values(this.gastProductionsCache))\n    }\n  }\n\n  /**\n   * This trait is responsible for the runtime parsing engine\n   * Used by the official API (recognizer_api.ts)\n   */\n  class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n      this.className = this.constructor.name\n      // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n      this.shortRuleNameToFull = {}\n      this.fullRuleNameToShort = {}\n      this.ruleShortNameIdx = 256\n      this.tokenMatcher = tokenStructuredMatcherNoCategories\n      this.subruleIdx = 0\n      this.definedRulesNames = []\n      this.tokensMap = {}\n      this.isBackTrackingStack = []\n      this.RULE_STACK = []\n      this.RULE_OCCURRENCE_STACK = []\n      this.gastProductionsCache = {}\n      if (has(config, 'serializedGrammar')) {\n        throw Error(\n          \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n            '\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n' +\n            '\\tFor Further details.',\n        )\n      }\n      if (isArray$1(tokenVocabulary)) {\n        // This only checks for Token vocabularies provided as arrays.\n        // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n        // rather than all edge cases of empty Token vocabularies.\n        if (isEmpty(tokenVocabulary)) {\n          throw Error(\n            'A Token Vocabulary cannot be empty.\\n' +\n              '\\tNote that the first argument for the parser constructor\\n' +\n              '\\tis no longer a Token vector (since v4.0).',\n          )\n        }\n        if (typeof tokenVocabulary[0].startOffset === 'number') {\n          throw Error(\n            'The Parser constructor no longer accepts a token vector as the first argument.\\n' +\n              '\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n' +\n              '\\tFor Further details.',\n          )\n        }\n      }\n      if (isArray$1(tokenVocabulary)) {\n        this.tokensMap = reduce(\n          tokenVocabulary,\n          (acc, tokType) => {\n            acc[tokType.name] = tokType\n            return acc\n          },\n          {},\n        )\n      } else if (has(tokenVocabulary, 'modes') && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n        const allTokenTypes = flatten(values(tokenVocabulary.modes))\n        const uniqueTokens = uniq(allTokenTypes)\n        this.tokensMap = reduce(\n          uniqueTokens,\n          (acc, tokType) => {\n            acc[tokType.name] = tokType\n            return acc\n          },\n          {},\n        )\n      } else if (isObject(tokenVocabulary)) {\n        this.tokensMap = clone(tokenVocabulary)\n      } else {\n        throw new Error(\n          '<tokensDictionary> argument must be An Array of Token constructors,' +\n            ' A dictionary of Token constructors or an IMultiModeLexerDefinition',\n        )\n      }\n      // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n      // parsed with a clear error message (\"expecting EOF but found ...\")\n      this.tokensMap['EOF'] = EOF\n      const allTokenTypes = has(tokenVocabulary, 'modes')\n        ? flatten(values(tokenVocabulary.modes))\n        : values(tokenVocabulary)\n      const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n        isEmpty(tokenConstructor.categoryMatches),\n      )\n      this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher\n      // Because ES2015+ syntax should be supported for creating Token classes\n      // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n      // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n      augmentTokenTypes(values(this.tokensMap))\n    }\n    defineRule(ruleName, impl, config) {\n      if (this.selfAnalysisDone) {\n        throw Error(\n          `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n            `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`,\n        )\n      }\n      const resyncEnabled = has(config, 'resyncEnabled')\n        ? config.resyncEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_RULE_CONFIG.resyncEnabled\n      const recoveryValueFunc = has(config, 'recoveryValueFunc')\n        ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n        : DEFAULT_RULE_CONFIG.recoveryValueFunc\n      // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n      // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n      const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n      this.ruleShortNameIdx++\n      this.shortRuleNameToFull[shortName] = ruleName\n      this.fullRuleNameToShort[ruleName] = shortName\n      let invokeRuleWithTry\n      // Micro optimization, only check the condition **once** on rule definition\n      // instead of **every single** rule invocation.\n      if (this.outputCst === true) {\n        invokeRuleWithTry = function invokeRuleWithTry(...args) {\n          try {\n            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n            impl.apply(this, args)\n            const cst = this.CST_STACK[this.CST_STACK.length - 1]\n            this.cstPostRule(cst)\n            return cst\n          } catch (e) {\n            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n          } finally {\n            this.ruleFinallyStateUpdate()\n          }\n        }\n      } else {\n        invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n          try {\n            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n            return impl.apply(this, args)\n          } catch (e) {\n            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n          } finally {\n            this.ruleFinallyStateUpdate()\n          }\n        }\n      }\n      const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl })\n      return wrappedGrammarRule\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n      const isFirstInvokedRule = this.RULE_STACK.length === 1\n      // note the reSync is always enabled for the first rule invocation, because we must always be able to\n      // reSync with EOF and just output some INVALID ParseTree\n      // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n      // path is really the most valid one\n      const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n      if (isRecognitionException(e)) {\n        const recogError = e\n        if (reSyncEnabled) {\n          const reSyncTokType = this.findReSyncTokenType()\n          if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n            recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n            if (this.outputCst) {\n              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1]\n              partialCstResult.recoveredNode = true\n              return partialCstResult\n            } else {\n              return recoveryValueFunc(e)\n            }\n          } else {\n            if (this.outputCst) {\n              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1]\n              partialCstResult.recoveredNode = true\n              recogError.partialCstResult = partialCstResult\n            }\n            // to be handled Further up the call stack\n            throw recogError\n          }\n        } else if (isFirstInvokedRule) {\n          // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n          this.moveToTerminatedState()\n          // the parser should never throw one of its own errors outside its flow.\n          // even if error recovery is disabled\n          return recoveryValueFunc(e)\n        } else {\n          // to be recovered Further up the call stack\n          throw recogError\n        }\n      } else {\n        // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n        throw e\n      }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n      const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n      return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n      let lookAheadFunc = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookAheadFunc\n          lookAheadFunc = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      if (lookAheadFunc.call(this) === true) {\n        return action.call(this)\n      }\n      return undefined\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence)\n      return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n      let lookAheadFunc = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookAheadFunc\n          lookAheadFunc = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      if (lookAheadFunc.call(this) === true) {\n        let notStuck = this.doSingleRepetition(action)\n        while (lookAheadFunc.call(this) === true && notStuck === true) {\n          notStuck = this.doSingleRepetition(action)\n        }\n      } else {\n        throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG)\n      }\n      // note that while it may seem that this can cause an error because by using a recursive call to\n      // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n      // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.atLeastOneInternal,\n        [prodOccurrence, actionORMethodDef],\n        lookAheadFunc,\n        AT_LEAST_ONE_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneWalker,\n      )\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence)\n      this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n      const action = options.DEF\n      const separator = options.SEP\n      const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n      // 1st iteration\n      if (firstIterationLookaheadFunc.call(this) === true) {\n        action.call(this)\n        //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n        //  because it is only needed in error recovery scenarios.\n        const separatorLookAheadFunc = () => {\n          return this.tokenMatcher(this.LA(1), separator)\n        }\n        // 2nd..nth iterations\n        while (this.tokenMatcher(this.LA(1), separator) === true) {\n          // note that this CONSUME will never enter recovery because\n          // the separatorLookAheadFunc checks that the separator really does exist.\n          this.CONSUME(separator)\n          // No need for checking infinite loop here due to consuming the separator.\n          action.call(this)\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(\n          this.repetitionSepSecondInternal,\n          [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker],\n          separatorLookAheadFunc,\n          AT_LEAST_ONE_SEP_IDX,\n          prodOccurrence,\n          NextTerminalAfterAtLeastOneSepWalker,\n        )\n      } else {\n        throw this.raiseEarlyExitException(\n          prodOccurrence,\n          PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n          options.ERR_MSG,\n        )\n      }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n      const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n      return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n      let lookaheadFunction = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookaheadFunction\n          lookaheadFunction = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      let notStuck = true\n      while (lookaheadFunction.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action)\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.manyInternal,\n        [prodOccurrence, actionORMethodDef],\n        lookaheadFunction,\n        MANY_IDX,\n        prodOccurrence,\n        NextTerminalAfterManyWalker,\n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck,\n      )\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n      const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n      this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n      const action = options.DEF\n      const separator = options.SEP\n      const firstIterationLaFunc = this.getLaFuncFromCache(key)\n      // 1st iteration\n      if (firstIterationLaFunc.call(this) === true) {\n        action.call(this)\n        const separatorLookAheadFunc = () => {\n          return this.tokenMatcher(this.LA(1), separator)\n        }\n        // 2nd..nth iterations\n        while (this.tokenMatcher(this.LA(1), separator) === true) {\n          // note that this CONSUME will never enter recovery because\n          // the separatorLookAheadFunc checks that the separator really does exist.\n          this.CONSUME(separator)\n          // No need for checking infinite loop here due to consuming the separator.\n          action.call(this)\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(\n          this.repetitionSepSecondInternal,\n          [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker],\n          separatorLookAheadFunc,\n          MANY_SEP_IDX,\n          prodOccurrence,\n          NextTerminalAfterManySepWalker,\n        )\n      }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n      while (separatorLookAheadFunc()) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        action.call(this)\n      }\n      // we can only arrive to this function after an error\n      // has occurred (hence the name 'second') so the following\n      // IF will always be entered, its possible to remove it...\n      // however it is kept to avoid confusion and be consistent.\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      /* istanbul ignore else */\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        nextTerminalAfterWalker,\n      )\n    }\n    doSingleRepetition(action) {\n      const beforeIteration = this.getLexerPosition()\n      action.call(this)\n      const afterIteration = this.getLexerPosition()\n      // This boolean will indicate if this repetition progressed\n      // or if we are \"stuck\" (potential infinite loop in the repetition).\n      return afterIteration > beforeIteration\n    }\n    orInternal(altsOrOpts, occurrence) {\n      const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n      const alts = isArray$1(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF\n      const laFunc = this.getLaFuncFromCache(laKey)\n      const altIdxToTake = laFunc.call(this, alts)\n      if (altIdxToTake !== undefined) {\n        const chosenAlternative = alts[altIdxToTake]\n        return chosenAlternative.ALT.call(this)\n      }\n      this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG)\n    }\n    ruleFinallyStateUpdate() {\n      this.RULE_STACK.pop()\n      this.RULE_OCCURRENCE_STACK.pop()\n      // NOOP when cst is disabled\n      this.cstFinallyStateUpdate()\n      if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n        const firstRedundantTok = this.LA(1)\n        const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n          firstRedundant: firstRedundantTok,\n          ruleName: this.getCurrRuleFullName(),\n        })\n        this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n      }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n      let ruleResult\n      try {\n        const args = options !== undefined ? options.ARGS : undefined\n        this.subruleIdx = idx\n        ruleResult = ruleToCall.apply(this, args)\n        this.cstPostNonTerminal(\n          ruleResult,\n          options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName,\n        )\n        return ruleResult\n      } catch (e) {\n        throw this.subruleInternalError(e, options, ruleToCall.ruleName)\n      }\n    }\n    subruleInternalError(e, options, ruleName) {\n      if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n        this.cstPostNonTerminal(\n          e.partialCstResult,\n          options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName,\n        )\n        delete e.partialCstResult\n      }\n      throw e\n    }\n    consumeInternal(tokType, idx, options) {\n      let consumedToken\n      try {\n        const nextToken = this.LA(1)\n        if (this.tokenMatcher(nextToken, tokType) === true) {\n          this.consumeToken()\n          consumedToken = nextToken\n        } else {\n          this.consumeInternalError(tokType, nextToken, options)\n        }\n      } catch (eFromConsumption) {\n        consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption)\n      }\n      this.cstPostTerminal(\n        options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name,\n        consumedToken,\n      )\n      return consumedToken\n    }\n    consumeInternalError(tokType, nextToken, options) {\n      let msg\n      const previousToken = this.LA(0)\n      if (options !== undefined && options.ERR_MSG) {\n        msg = options.ERR_MSG\n      } else {\n        msg = this.errorMessageProvider.buildMismatchTokenMessage({\n          expected: tokType,\n          actual: nextToken,\n          previous: previousToken,\n          ruleName: this.getCurrRuleFullName(),\n        })\n      }\n      throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken))\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n      // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n      // but the original syntax could have been parsed successfully without any backtracking + recovery\n      if (\n        this.recoveryEnabled &&\n        // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n        eFromConsumption.name === 'MismatchedTokenException' &&\n        !this.isBackTracking()\n      ) {\n        const follows = this.getFollowsForInRuleRecovery(tokType, idx)\n        try {\n          return this.tryInRuleRecovery(tokType, follows)\n        } catch (eFromInRuleRecovery) {\n          if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n            // failed in RuleRecovery.\n            // throw the original error in order to trigger reSync error recovery\n            throw eFromConsumption\n          } else {\n            throw eFromInRuleRecovery\n          }\n        }\n      } else {\n        throw eFromConsumption\n      }\n    }\n    saveRecogState() {\n      // errors is a getter which will clone the errors array\n      const savedErrors = this.errors\n      const savedRuleStack = clone(this.RULE_STACK)\n      return {\n        errors: savedErrors,\n        lexerState: this.exportLexerState(),\n        RULE_STACK: savedRuleStack,\n        CST_STACK: this.CST_STACK,\n      }\n    }\n    reloadRecogState(newState) {\n      this.errors = newState.errors\n      this.importLexerState(newState.lexerState)\n      this.RULE_STACK = newState.RULE_STACK\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n      this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n      this.RULE_STACK.push(shortName)\n      // NOOP when cst is disabled\n      this.cstInvocationStateUpdate(fullName)\n    }\n    isBackTracking() {\n      return this.isBackTrackingStack.length !== 0\n    }\n    getCurrRuleFullName() {\n      const shortName = this.getLastExplicitRuleShortName()\n      return this.shortRuleNameToFull[shortName]\n    }\n    shortRuleNameToFullName(shortName) {\n      return this.shortRuleNameToFull[shortName]\n    }\n    isAtEndOfInput() {\n      return this.tokenMatcher(this.LA(1), EOF)\n    }\n    reset() {\n      this.resetLexerState()\n      this.subruleIdx = 0\n      this.isBackTrackingStack = []\n      this.errors = []\n      this.RULE_STACK = []\n      // TODO: extract a specific reset for TreeBuilder trait\n      this.CST_STACK = []\n      this.RULE_OCCURRENCE_STACK = []\n    }\n  }\n\n  /**\n   * Trait responsible for runtime parsing errors.\n   */\n  class ErrorHandler {\n    initErrorHandler(config) {\n      this._errors = []\n      this.errorMessageProvider = has(config, 'errorMessageProvider')\n        ? config.errorMessageProvider // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.errorMessageProvider\n    }\n    SAVE_ERROR(error) {\n      if (isRecognitionException(error)) {\n        error.context = {\n          ruleStack: this.getHumanReadableRuleStack(),\n          ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n        }\n        this._errors.push(error)\n        return error\n      } else {\n        throw Error('Trying to save an Error which is not a RecognitionException')\n      }\n    }\n    get errors() {\n      return clone(this._errors)\n    }\n    set errors(newErrors) {\n      this._errors = newErrors\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n      const ruleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[ruleName]\n      const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n        occurrence,\n        ruleGrammar,\n        prodType,\n        this.maxLookahead,\n      )\n      const insideProdPaths = lookAheadPathsPerAlternative[0]\n      const actualTokens = []\n      for (let i = 1; i <= this.maxLookahead; i++) {\n        actualTokens.push(this.LA(i))\n      }\n      const msg = this.errorMessageProvider.buildEarlyExitMessage({\n        expectedIterationPaths: insideProdPaths,\n        actual: actualTokens,\n        previous: this.LA(0),\n        customUserDescription: userDefinedErrMsg,\n        ruleName: ruleName,\n      })\n      throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n      const ruleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[ruleName]\n      // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n      const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead)\n      const actualTokens = []\n      for (let i = 1; i <= this.maxLookahead; i++) {\n        actualTokens.push(this.LA(i))\n      }\n      const previousToken = this.LA(0)\n      const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n        expectedPathsPerAlt: lookAheadPathsPerAlternative,\n        actual: actualTokens,\n        previous: previousToken,\n        customUserDescription: errMsgTypes,\n        ruleName: this.getCurrRuleFullName(),\n      })\n      throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken))\n    }\n  }\n\n  class ContentAssist {\n    initContentAssist() {}\n    computeContentAssist(startRuleName, precedingInput) {\n      const startRuleGast = this.gastProductionsCache[startRuleName]\n      if (isUndefined(startRuleGast)) {\n        throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n      }\n      return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead)\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n      const topRuleName = head(grammarPath.ruleStack)\n      const gastProductions = this.getGAstProductions()\n      const topProduction = gastProductions[topRuleName]\n      const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking()\n      return nextPossibleTokenTypes\n    }\n  }\n\n  const RECORDING_NULL_OBJECT = {\n    description: 'This Object indicates the Parser is during Recording Phase',\n  }\n  Object.freeze(RECORDING_NULL_OBJECT)\n  const HANDLE_SEPARATOR = true\n  const MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n  const RFT = createToken({ name: 'RECORDING_PHASE_TOKEN', pattern: Lexer.NA })\n  augmentTokenTypes([RFT])\n  const RECORDING_PHASE_TOKEN = createTokenInstance(\n    RFT,\n    'This IToken indicates the Parser is in Recording Phase\\n\\t' +\n      '' +\n      'See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details',\n    // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n    // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n  )\n  Object.freeze(RECORDING_PHASE_TOKEN)\n  const RECORDING_PHASE_CSTNODE = {\n    name:\n      'This CSTNode indicates the Parser is in Recording Phase\\n\\t' +\n      'See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details',\n    children: {},\n  }\n  /**\n   * This trait handles the creation of the GAST structure for Chevrotain Grammars\n   */\n  class GastRecorder {\n    initGastRecorder(config) {\n      this.recordingProdStack = []\n      this.RECORDING_PHASE = false\n    }\n    enableRecording() {\n      this.RECORDING_PHASE = true\n      this.TRACE_INIT('Enable Recording', () => {\n        /**\n         * Warning Dark Voodoo Magic upcoming!\n         * We are \"replacing\" the public parsing DSL methods API\n         * With **new** alternative implementations on the Parser **instance**\n         *\n         * So far this is the only way I've found to avoid performance regressions during parsing time.\n         * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n         *   implementations directly instead.\n         */\n        for (let i = 0; i < 10; i++) {\n          const idx = i > 0 ? i : ''\n          this[`CONSUME${idx}`] = function (arg1, arg2) {\n            return this.consumeInternalRecord(arg1, i, arg2)\n          }\n          this[`SUBRULE${idx}`] = function (arg1, arg2) {\n            return this.subruleInternalRecord(arg1, i, arg2)\n          }\n          this[`OPTION${idx}`] = function (arg1) {\n            return this.optionInternalRecord(arg1, i)\n          }\n          this[`OR${idx}`] = function (arg1) {\n            return this.orInternalRecord(arg1, i)\n          }\n          this[`MANY${idx}`] = function (arg1) {\n            this.manyInternalRecord(i, arg1)\n          }\n          this[`MANY_SEP${idx}`] = function (arg1) {\n            this.manySepFirstInternalRecord(i, arg1)\n          }\n          this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n            this.atLeastOneInternalRecord(i, arg1)\n          }\n          this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n            this.atLeastOneSepFirstInternalRecord(i, arg1)\n          }\n        }\n        // DSL methods with the idx(suffix) as an argument\n        this[`consume`] = function (idx, arg1, arg2) {\n          return this.consumeInternalRecord(arg1, idx, arg2)\n        }\n        this[`subrule`] = function (idx, arg1, arg2) {\n          return this.subruleInternalRecord(arg1, idx, arg2)\n        }\n        this[`option`] = function (idx, arg1) {\n          return this.optionInternalRecord(arg1, idx)\n        }\n        this[`or`] = function (idx, arg1) {\n          return this.orInternalRecord(arg1, idx)\n        }\n        this[`many`] = function (idx, arg1) {\n          this.manyInternalRecord(idx, arg1)\n        }\n        this[`atLeastOne`] = function (idx, arg1) {\n          this.atLeastOneInternalRecord(idx, arg1)\n        }\n        this.ACTION = this.ACTION_RECORD\n        this.BACKTRACK = this.BACKTRACK_RECORD\n        this.LA = this.LA_RECORD\n      })\n    }\n    disableRecording() {\n      this.RECORDING_PHASE = false\n      // By deleting these **instance** properties, any future invocation\n      // will be deferred to the original methods on the **prototype** object\n      // This seems to get rid of any incorrect optimizations that V8 may\n      // do during the recording phase.\n      this.TRACE_INIT('Deleting Recording methods', () => {\n        const that = this\n        for (let i = 0; i < 10; i++) {\n          const idx = i > 0 ? i : ''\n          delete that[`CONSUME${idx}`]\n          delete that[`SUBRULE${idx}`]\n          delete that[`OPTION${idx}`]\n          delete that[`OR${idx}`]\n          delete that[`MANY${idx}`]\n          delete that[`MANY_SEP${idx}`]\n          delete that[`AT_LEAST_ONE${idx}`]\n          delete that[`AT_LEAST_ONE_SEP${idx}`]\n        }\n        delete that[`consume`]\n        delete that[`subrule`]\n        delete that[`option`]\n        delete that[`or`]\n        delete that[`many`]\n        delete that[`atLeastOne`]\n        delete that.ACTION\n        delete that.BACKTRACK\n        delete that.LA\n      })\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n      // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n      return () => true\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n      // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n      // On LA return EOF at the end of the input so an infinite loop may occur.\n      return END_OF_FILE\n    }\n    topLevelRuleRecord(name, def) {\n      try {\n        const newTopLevelRule = new Rule({ definition: [], name: name })\n        newTopLevelRule.name = name\n        this.recordingProdStack.push(newTopLevelRule)\n        def.call(this)\n        this.recordingProdStack.pop()\n        return newTopLevelRule\n      } catch (originalError) {\n        if (originalError.KNOWN_RECORDER_ERROR !== true) {\n          try {\n            originalError.message =\n              originalError.message +\n              '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n              'https://chevrotain.io/docs/guide/internals.html#grammar-recording'\n          } catch (mutabilityError) {\n            // We may not be able to modify the original error object\n            throw originalError\n          }\n        }\n        throw originalError\n      }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n      return recordProd.call(this, Option, actionORMethodDef, occurrence)\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n      recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n      recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR)\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n      recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n      recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR)\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n      return recordOrProd.call(this, altsOrOpts, occurrence)\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n      assertMethodIdxIsValid(occurrence)\n      if (!ruleToCall || has(ruleToCall, 'ruleName') === false) {\n        const error = new Error(\n          `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n            ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n            `\\n inside top level rule: <${this.recordingProdStack[0].name}>`,\n        )\n        error.KNOWN_RECORDER_ERROR = true\n        throw error\n      }\n      const prevProd = last(this.recordingProdStack)\n      const ruleName = ruleToCall.ruleName\n      const newNoneTerminal = new NonTerminal({\n        idx: occurrence,\n        nonTerminalName: ruleName,\n        label: options === null || options === void 0 ? void 0 : options.LABEL,\n        // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n        referencedRule: undefined,\n      })\n      prevProd.definition.push(newNoneTerminal)\n      return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n      assertMethodIdxIsValid(occurrence)\n      if (!hasShortKeyProperty(tokType)) {\n        const error = new Error(\n          `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n            ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n            `\\n inside top level rule: <${this.recordingProdStack[0].name}>`,\n        )\n        error.KNOWN_RECORDER_ERROR = true\n        throw error\n      }\n      const prevProd = last(this.recordingProdStack)\n      const newNoneTerminal = new Terminal({\n        idx: occurrence,\n        terminalType: tokType,\n        label: options === null || options === void 0 ? void 0 : options.LABEL,\n      })\n      prevProd.definition.push(newNoneTerminal)\n      return RECORDING_PHASE_TOKEN\n    }\n  }\n  function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence)\n    const prevProd = last(this.recordingProdStack)\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n    const newProd = new prodConstructor({ definition: [], idx: occurrence })\n    if (handleSep) {\n      newProd.separator = mainProdArg.SEP\n    }\n    if (has(mainProdArg, 'MAX_LOOKAHEAD')) {\n      newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n    }\n    this.recordingProdStack.push(newProd)\n    grammarAction.call(this)\n    prevProd.definition.push(newProd)\n    this.recordingProdStack.pop()\n    return RECORDING_NULL_OBJECT\n  }\n  function recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence)\n    const prevProd = last(this.recordingProdStack)\n    // Only an array of alternatives\n    const hasOptions = isArray$1(mainProdArg) === false\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF\n    const newOrProd = new Alternation({\n      definition: [],\n      idx: occurrence,\n      ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    })\n    if (has(mainProdArg, 'MAX_LOOKAHEAD')) {\n      newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE))\n    newOrProd.hasPredicates = hasPredicates\n    prevProd.definition.push(newOrProd)\n    forEach(alts, (currAlt) => {\n      const currAltFlat = new Alternative({ definition: [] })\n      newOrProd.definition.push(currAltFlat)\n      if (has(currAlt, 'IGNORE_AMBIGUITIES')) {\n        currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES // assumes end user provides the correct config value/type\n      }\n      // **implicit** ignoreAmbiguities due to usage of gate\n      else if (has(currAlt, 'GATE')) {\n        currAltFlat.ignoreAmbiguities = true\n      }\n      this.recordingProdStack.push(currAltFlat)\n      currAlt.ALT.call(this)\n      this.recordingProdStack.pop()\n    })\n    return RECORDING_NULL_OBJECT\n  }\n  function getIdxSuffix(idx) {\n    return idx === 0 ? '' : `${idx}`\n  }\n  function assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n      const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n          `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`,\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n  }\n\n  /**\n   * Trait responsible for runtime parsing errors.\n   */\n  class PerformanceTracer {\n    initPerformanceTracer(config) {\n      if (has(config, 'traceInitPerf')) {\n        const userTraceInitPerf = config.traceInitPerf\n        const traceIsNumber = typeof userTraceInitPerf === 'number'\n        this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity\n        this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf // assumes end user provides the correct config value/type\n      } else {\n        this.traceInitMaxIdent = 0\n        this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf\n      }\n      this.traceInitIndent = -1\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n      // No need to optimize this using NOOP pattern because\n      // It is not called in a hot spot...\n      if (this.traceInitPerf === true) {\n        this.traceInitIndent++\n        const indent = new Array(this.traceInitIndent + 1).join('\\t')\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          console.log(`${indent}--> <${phaseDesc}>`)\n        }\n        const { time, value } = timer(phaseImpl)\n        /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n        const traceMethod = time > 10 ? console.warn : console.log\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n        }\n        this.traceInitIndent--\n        return value\n      } else {\n        return phaseImpl()\n      }\n    }\n  }\n\n  function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n      const baseProto = baseCtor.prototype\n      Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n        if (propName === 'constructor') {\n          return\n        }\n        const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName)\n        // Handle Accessors\n        if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n          Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor)\n        } else {\n          derivedCtor.prototype[propName] = baseCtor.prototype[propName]\n        }\n      })\n    })\n  }\n\n  const END_OF_FILE = createTokenInstance(EOF, '', NaN, NaN, NaN, NaN, NaN, NaN)\n  Object.freeze(END_OF_FILE)\n  const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: 'none',\n    traceInitPerf: false,\n    skipValidations: false,\n  })\n  const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n  })\n  var ParserDefinitionErrorType\n  ;(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_RULE_NAME'] = 0)] = 'INVALID_RULE_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['DUPLICATE_RULE_NAME'] = 1)] = 'DUPLICATE_RULE_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_RULE_OVERRIDE'] = 2)] = 'INVALID_RULE_OVERRIDE'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['DUPLICATE_PRODUCTIONS'] = 3)] = 'DUPLICATE_PRODUCTIONS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['UNRESOLVED_SUBRULE_REF'] = 4)] = 'UNRESOLVED_SUBRULE_REF'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['LEFT_RECURSION'] = 5)] = 'LEFT_RECURSION'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['NONE_LAST_EMPTY_ALT'] = 6)] = 'NONE_LAST_EMPTY_ALT'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['AMBIGUOUS_ALTS'] = 7)] = 'AMBIGUOUS_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['CONFLICT_TOKENS_RULES_NAMESPACE'] = 8)] =\n      'CONFLICT_TOKENS_RULES_NAMESPACE'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_TOKEN_NAME'] = 9)] = 'INVALID_TOKEN_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['NO_NON_EMPTY_LOOKAHEAD'] = 10)] = 'NO_NON_EMPTY_LOOKAHEAD'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['AMBIGUOUS_PREFIX_ALTS'] = 11)] = 'AMBIGUOUS_PREFIX_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['TOO_MANY_ALTS'] = 12)] = 'TOO_MANY_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['CUSTOM_LOOKAHEAD_VALIDATION'] = 13)] =\n      'CUSTOM_LOOKAHEAD_VALIDATION'\n  })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}))\n  class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n      throw Error(\n        'The **static** `performSelfAnalysis` method has been deprecated.' +\n          '\\t\\nUse the **instance** method with the same name instead.',\n      )\n    }\n    performSelfAnalysis() {\n      this.TRACE_INIT('performSelfAnalysis', () => {\n        let defErrorsMsgs\n        this.selfAnalysisDone = true\n        const className = this.className\n        this.TRACE_INIT('toFastProps', () => {\n          // Without this voodoo magic the parser would be x3-x4 slower\n          // It seems it is better to invoke `toFastProperties` **before**\n          // Any manipulations of the `this` object done during the recording phase.\n          toFastProperties(this)\n        })\n        this.TRACE_INIT('Grammar Recording', () => {\n          try {\n            this.enableRecording()\n            // Building the GAST\n            forEach(this.definedRulesNames, (currRuleName) => {\n              const wrappedRule = this[currRuleName]\n              const originalGrammarAction = wrappedRule['originalGrammarAction']\n              let recordedRuleGast\n              this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction)\n              })\n              this.gastProductionsCache[currRuleName] = recordedRuleGast\n            })\n          } finally {\n            this.disableRecording()\n          }\n        })\n        let resolverErrors = []\n        this.TRACE_INIT('Grammar Resolving', () => {\n          resolverErrors = resolveGrammar({\n            rules: values(this.gastProductionsCache),\n          })\n          this.definitionErrors = this.definitionErrors.concat(resolverErrors)\n        })\n        this.TRACE_INIT('Grammar Validations', () => {\n          // only perform additional grammar validations IFF no resolving errors have occurred.\n          // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n          if (isEmpty(resolverErrors) && this.skipValidations === false) {\n            const validationErrors = validateGrammar({\n              rules: values(this.gastProductionsCache),\n              tokenTypes: values(this.tokensMap),\n              errMsgProvider: defaultGrammarValidatorErrorProvider,\n              grammarName: className,\n            })\n            const lookaheadValidationErrors = validateLookahead({\n              lookaheadStrategy: this.lookaheadStrategy,\n              rules: values(this.gastProductionsCache),\n              tokenTypes: values(this.tokensMap),\n              grammarName: className,\n            })\n            this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors)\n          }\n        })\n        // this analysis may fail if the grammar is not perfectly valid\n        if (isEmpty(this.definitionErrors)) {\n          // The results of these computations are not needed unless error recovery is enabled.\n          if (this.recoveryEnabled) {\n            this.TRACE_INIT('computeAllProdsFollows', () => {\n              const allFollows = computeAllProdsFollows(values(this.gastProductionsCache))\n              this.resyncFollows = allFollows\n            })\n          }\n          this.TRACE_INIT('ComputeLookaheadFunctions', () => {\n            var _a, _b\n            ;(_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0\n              ? void 0\n              : _b.call(_a, {\n                  rules: values(this.gastProductionsCache),\n                })\n            this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n          })\n        }\n        if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty(this.definitionErrors)) {\n          defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message)\n          throw new Error(\n            `Parser Definition Errors detected:\\n ${defErrorsMsgs.join('\\n-------------------------------\\n')}`,\n          )\n        }\n      })\n    }\n    constructor(tokenVocabulary, config) {\n      this.definitionErrors = []\n      this.selfAnalysisDone = false\n      const that = this\n      that.initErrorHandler(config)\n      that.initLexerAdapter()\n      that.initLooksAhead(config)\n      that.initRecognizerEngine(tokenVocabulary, config)\n      that.initRecoverable(config)\n      that.initTreeBuilder(config)\n      that.initContentAssist()\n      that.initGastRecorder(config)\n      that.initPerformanceTracer(config)\n      if (has(config, 'ignoredIssues')) {\n        throw new Error(\n          'The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t' +\n            'Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t' +\n            'See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t' +\n            'For further details.',\n        )\n      }\n      this.skipValidations = has(config, 'skipValidations')\n        ? config.skipValidations // casting assumes the end user passing the correct type\n        : DEFAULT_PARSER_CONFIG.skipValidations\n    }\n  }\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  Parser.DEFER_DEFINITION_ERRORS_HANDLING = false\n  applyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n  ])\n  class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n      const configClone = clone(config)\n      configClone.outputCst = true\n      super(tokenVocabulary, configClone)\n    }\n  }\n\n  return { CstParser, Lexer, createToken }\n})()\n\nexport { CstParser, Lexer, createToken }\n"],"names":["map","values","key","othValue","collection","includes","Lexer","LexerDefinitionErrorType","msg","currConfig","createToken","getExtraProductionArgument","PROD_TYPE","tokenMatcher","keys","prefixKeys","collectorVisitor","CstVisitorDefinitionError","allTokenTypes","invokeRuleWithTry","ParserDefinitionErrorType","CstParser"],"mappings":"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"}}]
}