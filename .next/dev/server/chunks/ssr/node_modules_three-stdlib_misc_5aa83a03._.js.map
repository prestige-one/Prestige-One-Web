{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/MorphBlendMesh.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/MorphBlendMesh.js"],"sourcesContent":["import { MathUtils, Mesh } from 'three'\n\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material)\n\n    this.animationsMap = {}\n    this.animationsList = []\n\n    // prepare default animation\n    // (all frames played together in 1 second)\n\n    const numFrames = Object.keys(this.morphTargetDictionary).length\n\n    const name = '__default'\n\n    const startFrame = 0\n    const endFrame = numFrames - 1\n\n    const fps = numFrames / 1\n\n    this.createAnimation(name, startFrame, endFrame, fps)\n    this.setAnimationWeight(name, 1)\n  }\n\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start: start,\n      end: end,\n\n      length: end - start + 1,\n\n      fps: fps,\n      duration: (end - start) / fps,\n\n      lastFrame: 0,\n      currentFrame: 0,\n\n      active: false,\n\n      time: 0,\n      direction: 1,\n      weight: 1,\n\n      directionBackwards: false,\n      mirroredLoop: false,\n    }\n\n    this.animationsMap[name] = animation\n    this.animationsList.push(animation)\n  }\n\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i\n\n    let firstAnimation\n\n    const frameRanges = {}\n\n    let i = 0\n\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern)\n\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1]\n\n        if (!frameRanges[name]) frameRanges[name] = { start: Infinity, end: -Infinity }\n\n        const range = frameRanges[name]\n\n        if (i < range.start) range.start = i\n        if (i > range.end) range.end = i\n\n        if (!firstAnimation) firstAnimation = name\n      }\n\n      i++\n    }\n\n    for (const name in frameRanges) {\n      const range = frameRanges[name]\n      this.createAnimation(name, range.start, range.end, fps)\n    }\n\n    this.firstAnimation = firstAnimation\n  }\n\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.direction = 1\n      animation.directionBackwards = false\n    }\n  }\n\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.direction = -1\n      animation.directionBackwards = true\n    }\n  }\n\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.fps = fps\n      animation.duration = (animation.end - animation.start) / animation.fps\n    }\n  }\n\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.duration = duration\n      animation.fps = (animation.end - animation.start) / animation.duration\n    }\n  }\n\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.weight = weight\n    }\n  }\n\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.time = time\n    }\n  }\n\n  getAnimationTime(name) {\n    let time = 0\n\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      time = animation.time\n    }\n\n    return time\n  }\n\n  getAnimationDuration(name) {\n    let duration = -1\n\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      duration = animation.duration\n    }\n\n    return duration\n  }\n\n  playAnimation(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.time = 0\n      animation.active = true\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()')\n    }\n  }\n\n  stopAnimation(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.active = false\n    }\n  }\n\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i]\n\n      if (!animation.active) continue\n\n      const frameTime = animation.duration / animation.length\n\n      animation.time += animation.direction * delta\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration\n            animation.directionBackwards = true\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0\n            animation.directionBackwards = false\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration\n\n        if (animation.time < 0) animation.time += animation.duration\n      }\n\n      const keyframe =\n        animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1)\n      const weight = animation.weight\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight\n\n        this.morphTargetInfluences[keyframe] = 0\n\n        animation.lastFrame = animation.currentFrame\n        animation.currentFrame = keyframe\n      }\n\n      let mix = (animation.time % frameTime) / frameTime\n\n      if (animation.directionBackwards) mix = 1 - mix\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight\n      }\n    }\n  }\n}\n\nexport { MorphBlendMesh }\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,uBAAuB,uJAAA,CAAK;IAChC,YAAY,QAAA,EAAU,QAAA,CAAU;QAC9B,KAAA,CAAM,UAAU,QAAQ;QAExB,IAAA,CAAK,aAAA,GAAgB,CAAE;QACvB,IAAA,CAAK,cAAA,GAAiB,CAAE,CAAA;QAKxB,MAAM,YAAY,OAAO,IAAA,CAAK,IAAA,CAAK,qBAAqB,EAAE,MAAA;QAE1D,MAAM,OAAO;QAEb,MAAM,aAAa;QACnB,MAAM,WAAW,YAAY;QAE7B,MAAM,MAAM,YAAY;QAExB,IAAA,CAAK,eAAA,CAAgB,MAAM,YAAY,UAAU,GAAG;QACpD,IAAA,CAAK,kBAAA,CAAmB,MAAM,CAAC;IAChC;IAED,gBAAgB,IAAA,EAAM,KAAA,EAAO,GAAA,EAAK,GAAA,EAAK;QACrC,MAAM,YAAY;YAChB;YACA;YAEA,QAAQ,MAAM,QAAQ;YAEtB;YACA,UAAA,CAAW,MAAM,KAAA,IAAS;YAE1B,WAAW;YACX,cAAc;YAEd,QAAQ;YAER,MAAM;YACN,WAAW;YACX,QAAQ;YAER,oBAAoB;YACpB,cAAc;QACf;QAED,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,GAAI;QAC3B,IAAA,CAAK,cAAA,CAAe,IAAA,CAAK,SAAS;IACnC;IAED,qBAAqB,GAAA,EAAK;QACxB,MAAM,UAAU;QAEhB,IAAI;QAEJ,MAAM,cAAc,CAAE;QAEtB,IAAI,IAAI;QAER,IAAA,MAAW,OAAO,IAAA,CAAK,qBAAA,CAAuB;YAC5C,MAAM,SAAS,IAAI,KAAA,CAAM,OAAO;YAEhC,IAAI,UAAU,OAAO,MAAA,GAAS,GAAG;gBAC/B,MAAM,OAAO,MAAA,CAAO,CAAC,CAAA;gBAErB,IAAI,CAAC,WAAA,CAAY,IAAI,CAAA,EAAG,WAAA,CAAY,IAAI,CAAA,GAAI;oBAAE,OAAO;oBAAU,KAAK,CAAA;gBAAW;gBAE/E,MAAM,QAAQ,WAAA,CAAY,IAAI,CAAA;gBAE9B,IAAI,IAAI,MAAM,KAAA,EAAO,MAAM,KAAA,GAAQ;gBACnC,IAAI,IAAI,MAAM,GAAA,EAAK,MAAM,GAAA,GAAM;gBAE/B,IAAI,CAAC,gBAAgB,iBAAiB;YACvC;YAED;QACD;QAED,IAAA,MAAW,QAAQ,YAAa;YAC9B,MAAM,QAAQ,WAAA,CAAY,IAAI,CAAA;YAC9B,IAAA,CAAK,eAAA,CAAgB,MAAM,MAAM,KAAA,EAAO,MAAM,GAAA,EAAK,GAAG;QACvD;QAED,IAAA,CAAK,cAAA,GAAiB;IACvB;IAED,6BAA6B,IAAA,EAAM;QACjC,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,SAAA,GAAY;YACtB,UAAU,kBAAA,GAAqB;QAChC;IACF;IAED,8BAA8B,IAAA,EAAM;QAClC,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,SAAA,GAAY,CAAA;YACtB,UAAU,kBAAA,GAAqB;QAChC;IACF;IAED,gBAAgB,IAAA,EAAM,GAAA,EAAK;QACzB,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,GAAA,GAAM;YAChB,UAAU,QAAA,GAAA,CAAY,UAAU,GAAA,GAAM,UAAU,KAAA,IAAS,UAAU,GAAA;QACpE;IACF;IAED,qBAAqB,IAAA,EAAM,QAAA,EAAU;QACnC,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,QAAA,GAAW;YACrB,UAAU,GAAA,GAAA,CAAO,UAAU,GAAA,GAAM,UAAU,KAAA,IAAS,UAAU,QAAA;QAC/D;IACF;IAED,mBAAmB,IAAA,EAAM,MAAA,EAAQ;QAC/B,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,MAAA,GAAS;QACpB;IACF;IAED,iBAAiB,IAAA,EAAM,IAAA,EAAM;QAC3B,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,IAAA,GAAO;QAClB;IACF;IAED,iBAAiB,IAAA,EAAM;QACrB,IAAI,OAAO;QAEX,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,OAAO,UAAU,IAAA;QAClB;QAED,OAAO;IACR;IAED,qBAAqB,IAAA,EAAM;QACzB,IAAI,WAAW,CAAA;QAEf,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,WAAW,UAAU,QAAA;QACtB;QAED,OAAO;IACR;IAED,cAAc,IAAA,EAAM;QAClB,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,IAAA,GAAO;YACjB,UAAU,MAAA,GAAS;QACzB,OAAW;YACL,QAAQ,IAAA,CAAK,qCAAqC,OAAO,iCAAiC;QAC3F;IACF;IAED,cAAc,IAAA,EAAM;QAClB,MAAM,YAAY,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA;QAEzC,IAAI,WAAW;YACb,UAAU,MAAA,GAAS;QACpB;IACF;IAED,OAAO,KAAA,EAAO;QACZ,IAAA,IAAS,IAAI,GAAG,KAAK,IAAA,CAAK,cAAA,CAAe,MAAA,EAAQ,IAAI,IAAI,IAAK;YAC5D,MAAM,YAAY,IAAA,CAAK,cAAA,CAAe,CAAC,CAAA;YAEvC,IAAI,CAAC,UAAU,MAAA,EAAQ;YAEvB,MAAM,YAAY,UAAU,QAAA,GAAW,UAAU,MAAA;YAEjD,UAAU,IAAA,IAAQ,UAAU,SAAA,GAAY;YAExC,IAAI,UAAU,YAAA,EAAc;gBAC1B,IAAI,UAAU,IAAA,GAAO,UAAU,QAAA,IAAY,UAAU,IAAA,GAAO,GAAG;oBAC7D,UAAU,SAAA,IAAa,CAAA;oBAEvB,IAAI,UAAU,IAAA,GAAO,UAAU,QAAA,EAAU;wBACvC,UAAU,IAAA,GAAO,UAAU,QAAA;wBAC3B,UAAU,kBAAA,GAAqB;oBAChC;oBAED,IAAI,UAAU,IAAA,GAAO,GAAG;wBACtB,UAAU,IAAA,GAAO;wBACjB,UAAU,kBAAA,GAAqB;oBAChC;gBACF;YACT,OAAa;gBACL,UAAU,IAAA,GAAO,UAAU,IAAA,GAAO,UAAU,QAAA;gBAE5C,IAAI,UAAU,IAAA,GAAO,GAAG,UAAU,IAAA,IAAQ,UAAU,QAAA;YACrD;YAED,MAAM,WACJ,UAAU,KAAA,GAAQ,4JAAA,CAAU,KAAA,CAAM,KAAK,KAAA,CAAM,UAAU,IAAA,GAAO,SAAS,GAAG,GAAG,UAAU,MAAA,GAAS,CAAC;YACnG,MAAM,SAAS,UAAU,MAAA;YAEzB,IAAI,aAAa,UAAU,YAAA,EAAc;gBACvC,IAAA,CAAK,qBAAA,CAAsB,UAAU,SAAS,CAAA,GAAI;gBAClD,IAAA,CAAK,qBAAA,CAAsB,UAAU,YAAY,CAAA,GAAI,IAAI;gBAEzD,IAAA,CAAK,qBAAA,CAAsB,QAAQ,CAAA,GAAI;gBAEvC,UAAU,SAAA,GAAY,UAAU,YAAA;gBAChC,UAAU,YAAA,GAAe;YAC1B;YAED,IAAI,MAAO,UAAU,IAAA,GAAO,YAAa;YAEzC,IAAI,UAAU,kBAAA,EAAoB,MAAM,IAAI;YAE5C,IAAI,UAAU,YAAA,KAAiB,UAAU,SAAA,EAAW;gBAClD,IAAA,CAAK,qBAAA,CAAsB,UAAU,YAAY,CAAA,GAAI,MAAM;gBAC3D,IAAA,CAAK,qBAAA,CAAsB,UAAU,SAAS,CAAA,GAAA,CAAK,IAAI,GAAA,IAAO;YACtE,OAAa;gBACL,IAAA,CAAK,qBAAA,CAAsB,UAAU,YAAY,CAAA,GAAI;YACtD;QACF;IACF;AACH"}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/MD2CharacterComplex.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/MD2CharacterComplex.js"],"sourcesContent":["import { Box3, MathUtils, MeshLambertMaterial, Object3D, TextureLoader, UVMapping } from 'three'\nimport { MD2Loader } from '../loaders/MD2Loader'\nimport { MorphBlendMesh } from '../misc/MorphBlendMesh'\n\nclass MD2CharacterComplex {\n  constructor() {\n    this.scale = 1\n\n    // animation parameters\n\n    this.animationFPS = 6\n    this.transitionFrames = 15\n\n    // movement model parameters\n\n    this.maxSpeed = 275\n    this.maxReverseSpeed = -275\n\n    this.frontAcceleration = 600\n    this.backAcceleration = 600\n\n    this.frontDecceleration = 600\n\n    this.angularSpeed = 2.5\n\n    // rig\n\n    this.root = new Object3D()\n\n    this.meshBody = null\n    this.meshWeapon = null\n\n    this.controls = null\n\n    // skins\n\n    this.skinsBody = []\n    this.skinsWeapon = []\n\n    this.weapons = []\n\n    this.currentSkin = undefined\n\n    //\n\n    this.onLoadComplete = function () {}\n\n    // internals\n\n    this.meshes = []\n    this.animations = {}\n\n    this.loadCounter = 0\n\n    // internal movement control variables\n\n    this.speed = 0\n    this.bodyOrientation = 0\n\n    this.walkSpeed = this.maxSpeed\n    this.crouchSpeed = this.maxSpeed * 0.5\n\n    // internal animation parameters\n\n    this.activeAnimation = null\n    this.oldAnimation = null\n\n    // API\n  }\n\n  enableShadows(enable) {\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.meshes[i].castShadow = enable\n      this.meshes[i].receiveShadow = enable\n    }\n  }\n\n  setVisible(enable) {\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.meshes[i].visible = enable\n      this.meshes[i].visible = enable\n    }\n  }\n\n  shareParts(original) {\n    this.animations = original.animations\n    this.walkSpeed = original.walkSpeed\n    this.crouchSpeed = original.crouchSpeed\n\n    this.skinsBody = original.skinsBody\n    this.skinsWeapon = original.skinsWeapon\n\n    // BODY\n\n    const mesh = this._createPart(original.meshBody.geometry, this.skinsBody[0])\n    mesh.scale.set(this.scale, this.scale, this.scale)\n\n    this.root.position.y = original.root.position.y\n    this.root.add(mesh)\n\n    this.meshBody = mesh\n\n    this.meshes.push(mesh)\n\n    // WEAPONS\n\n    for (let i = 0; i < original.weapons.length; i++) {\n      const meshWeapon = this._createPart(original.weapons[i].geometry, this.skinsWeapon[i])\n      meshWeapon.scale.set(this.scale, this.scale, this.scale)\n      meshWeapon.visible = false\n\n      meshWeapon.name = original.weapons[i].name\n\n      this.root.add(meshWeapon)\n\n      this.weapons[i] = meshWeapon\n      this.meshWeapon = meshWeapon\n\n      this.meshes.push(meshWeapon)\n    }\n  }\n\n  loadParts(config) {\n    const scope = this\n\n    function loadTextures(baseUrl, textureUrls) {\n      const textureLoader = new TextureLoader()\n      const textures = []\n\n      for (let i = 0; i < textureUrls.length; i++) {\n        textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete)\n        textures[i].mapping = UVMapping\n        textures[i].name = textureUrls[i]\n        if ('colorSpace' in textures[i]) textures[i].colorSpace = 'srgb'\n        else textures[i].encoding = 3001 // sRGBEncoding\n      }\n\n      return textures\n    }\n\n    function checkLoadingComplete() {\n      scope.loadCounter -= 1\n      if (scope.loadCounter === 0) scope.onLoadComplete()\n    }\n\n    this.animations = config.animations\n    this.walkSpeed = config.walkSpeed\n    this.crouchSpeed = config.crouchSpeed\n\n    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1\n\n    const weaponsTextures = []\n    for (let i = 0; i < config.weapons.length; i++) weaponsTextures[i] = config.weapons[i][1]\n\n    // SKINS\n\n    this.skinsBody = loadTextures(config.baseUrl + 'skins/', config.skins)\n    this.skinsWeapon = loadTextures(config.baseUrl + 'skins/', weaponsTextures)\n\n    // BODY\n\n    const loader = new MD2Loader()\n\n    loader.load(config.baseUrl + config.body, function (geo) {\n      const boundingBox = new Box3()\n      boundingBox.setFromBufferAttribute(geo.attributes.position)\n\n      scope.root.position.y = -scope.scale * boundingBox.min.y\n\n      const mesh = scope._createPart(geo, scope.skinsBody[0])\n      mesh.scale.set(scope.scale, scope.scale, scope.scale)\n\n      scope.root.add(mesh)\n\n      scope.meshBody = mesh\n      scope.meshes.push(mesh)\n\n      checkLoadingComplete()\n    })\n\n    // WEAPONS\n\n    const generateCallback = function (index, name) {\n      return function (geo) {\n        const mesh = scope._createPart(geo, scope.skinsWeapon[index])\n        mesh.scale.set(scope.scale, scope.scale, scope.scale)\n        mesh.visible = false\n\n        mesh.name = name\n\n        scope.root.add(mesh)\n\n        scope.weapons[index] = mesh\n        scope.meshWeapon = mesh\n        scope.meshes.push(mesh)\n\n        checkLoadingComplete()\n      }\n    }\n\n    for (let i = 0; i < config.weapons.length; i++) {\n      loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]))\n    }\n  }\n\n  setPlaybackRate(rate) {\n    if (this.meshBody) this.meshBody.duration = this.meshBody.baseDuration / rate\n    if (this.meshWeapon) this.meshWeapon.duration = this.meshWeapon.baseDuration / rate\n  }\n\n  setWireframe(wireframeEnabled) {\n    if (wireframeEnabled) {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe\n    } else {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture\n    }\n  }\n\n  setSkin(index) {\n    if (this.meshBody && this.meshBody.material.wireframe === false) {\n      this.meshBody.material.map = this.skinsBody[index]\n      this.currentSkin = index\n    }\n  }\n\n  setWeapon(index) {\n    for (let i = 0; i < this.weapons.length; i++) this.weapons[i].visible = false\n\n    const activeWeapon = this.weapons[index]\n\n    if (activeWeapon) {\n      activeWeapon.visible = true\n      this.meshWeapon = activeWeapon\n\n      if (this.activeAnimation) {\n        activeWeapon.playAnimation(this.activeAnimation)\n        this.meshWeapon.setAnimationTime(this.activeAnimation, this.meshBody.getAnimationTime(this.activeAnimation))\n      }\n    }\n  }\n\n  setAnimation(animationName) {\n    if (animationName === this.activeAnimation || !animationName) return\n\n    if (this.meshBody) {\n      this.meshBody.setAnimationWeight(animationName, 0)\n      this.meshBody.playAnimation(animationName)\n\n      this.oldAnimation = this.activeAnimation\n      this.activeAnimation = animationName\n\n      this.blendCounter = this.transitionFrames\n    }\n\n    if (this.meshWeapon) {\n      this.meshWeapon.setAnimationWeight(animationName, 0)\n      this.meshWeapon.playAnimation(animationName)\n    }\n  }\n\n  update(delta) {\n    if (this.controls) this.updateMovementModel(delta)\n\n    if (this.animations) {\n      this.updateBehaviors()\n      this.updateAnimations(delta)\n    }\n  }\n\n  updateAnimations(delta) {\n    let mix = 1\n\n    if (this.blendCounter > 0) {\n      mix = (this.transitionFrames - this.blendCounter) / this.transitionFrames\n      this.blendCounter -= 1\n    }\n\n    if (this.meshBody) {\n      this.meshBody.update(delta)\n\n      this.meshBody.setAnimationWeight(this.activeAnimation, mix)\n      this.meshBody.setAnimationWeight(this.oldAnimation, 1 - mix)\n    }\n\n    if (this.meshWeapon) {\n      this.meshWeapon.update(delta)\n\n      this.meshWeapon.setAnimationWeight(this.activeAnimation, mix)\n      this.meshWeapon.setAnimationWeight(this.oldAnimation, 1 - mix)\n    }\n  }\n\n  updateBehaviors() {\n    const controls = this.controls\n    const animations = this.animations\n\n    let moveAnimation, idleAnimation\n\n    // crouch vs stand\n\n    if (controls.crouch) {\n      moveAnimation = animations['crouchMove']\n      idleAnimation = animations['crouchIdle']\n    } else {\n      moveAnimation = animations['move']\n      idleAnimation = animations['idle']\n    }\n\n    // actions\n\n    if (controls.jump) {\n      moveAnimation = animations['jump']\n      idleAnimation = animations['jump']\n    }\n\n    if (controls.attack) {\n      if (controls.crouch) {\n        moveAnimation = animations['crouchAttack']\n        idleAnimation = animations['crouchAttack']\n      } else {\n        moveAnimation = animations['attack']\n        idleAnimation = animations['attack']\n      }\n    }\n\n    // set animations\n\n    if (controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight) {\n      if (this.activeAnimation !== moveAnimation) {\n        this.setAnimation(moveAnimation)\n      }\n    }\n\n    if (\n      Math.abs(this.speed) < 0.2 * this.maxSpeed &&\n      !(controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward)\n    ) {\n      if (this.activeAnimation !== idleAnimation) {\n        this.setAnimation(idleAnimation)\n      }\n    }\n\n    // set animation direction\n\n    if (controls.moveForward) {\n      if (this.meshBody) {\n        this.meshBody.setAnimationDirectionForward(this.activeAnimation)\n        this.meshBody.setAnimationDirectionForward(this.oldAnimation)\n      }\n\n      if (this.meshWeapon) {\n        this.meshWeapon.setAnimationDirectionForward(this.activeAnimation)\n        this.meshWeapon.setAnimationDirectionForward(this.oldAnimation)\n      }\n    }\n\n    if (controls.moveBackward) {\n      if (this.meshBody) {\n        this.meshBody.setAnimationDirectionBackward(this.activeAnimation)\n        this.meshBody.setAnimationDirectionBackward(this.oldAnimation)\n      }\n\n      if (this.meshWeapon) {\n        this.meshWeapon.setAnimationDirectionBackward(this.activeAnimation)\n        this.meshWeapon.setAnimationDirectionBackward(this.oldAnimation)\n      }\n    }\n  }\n\n  updateMovementModel(delta) {\n    function exponentialEaseOut(k) {\n      return k === 1 ? 1 : -Math.pow(2, -10 * k) + 1\n    }\n\n    const controls = this.controls\n\n    // speed based on controls\n\n    if (controls.crouch) this.maxSpeed = this.crouchSpeed\n    else this.maxSpeed = this.walkSpeed\n\n    this.maxReverseSpeed = -this.maxSpeed\n\n    if (controls.moveForward)\n      this.speed = MathUtils.clamp(this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed)\n    if (controls.moveBackward)\n      this.speed = MathUtils.clamp(this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed)\n\n    // orientation based on controls\n    // (don't just stand while turning)\n\n    const dir = 1\n\n    if (controls.moveLeft) {\n      this.bodyOrientation += delta * this.angularSpeed\n      this.speed = MathUtils.clamp(\n        this.speed + dir * delta * this.frontAcceleration,\n        this.maxReverseSpeed,\n        this.maxSpeed,\n      )\n    }\n\n    if (controls.moveRight) {\n      this.bodyOrientation -= delta * this.angularSpeed\n      this.speed = MathUtils.clamp(\n        this.speed + dir * delta * this.frontAcceleration,\n        this.maxReverseSpeed,\n        this.maxSpeed,\n      )\n    }\n\n    // speed decay\n\n    if (!(controls.moveForward || controls.moveBackward)) {\n      if (this.speed > 0) {\n        const k = exponentialEaseOut(this.speed / this.maxSpeed)\n        this.speed = MathUtils.clamp(this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed)\n      } else {\n        const k = exponentialEaseOut(this.speed / this.maxReverseSpeed)\n        this.speed = MathUtils.clamp(this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0)\n      }\n    }\n\n    // displacement\n\n    const forwardDelta = this.speed * delta\n\n    this.root.position.x += Math.sin(this.bodyOrientation) * forwardDelta\n    this.root.position.z += Math.cos(this.bodyOrientation) * forwardDelta\n\n    // steering\n\n    this.root.rotation.y = this.bodyOrientation\n  }\n\n  // internal\n\n  _createPart(geometry, skinMap) {\n    const materialWireframe = new MeshLambertMaterial({\n      color: 0xffaa00,\n      wireframe: true,\n      morphTargets: true,\n      morphNormals: true,\n    })\n    const materialTexture = new MeshLambertMaterial({\n      color: 0xffffff,\n      wireframe: false,\n      map: skinMap,\n      morphTargets: true,\n      morphNormals: true,\n    })\n\n    //\n\n    const mesh = new MorphBlendMesh(geometry, materialTexture)\n    mesh.rotation.y = -Math.PI / 2\n\n    //\n\n    mesh.materialTexture = materialTexture\n    mesh.materialWireframe = materialWireframe\n\n    //\n\n    mesh.autoCreateAnimations(this.animationFPS)\n\n    return mesh\n  }\n}\n\nexport { MD2CharacterComplex }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/ConvexObjectBreaker.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/ConvexObjectBreaker.js"],"sourcesContent":["import { Line3, Mesh, Plane, Vector3 } from 'three'\nimport { ConvexGeometry } from '../geometries/ConvexGeometry'\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a buffer geometry and a material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nconst _v1 = /* @__PURE__ */ new Vector3()\n\nconst ConvexObjectBreaker = /* @__PURE__ */ (() => {\n  class ConvexObjectBreaker {\n    constructor(minSizeForBreak = 1.4, smallDelta = 0.0001) {\n      this.minSizeForBreak = minSizeForBreak\n      this.smallDelta = smallDelta\n\n      this.tempLine1 = new Line3()\n      this.tempPlane1 = new Plane()\n      this.tempPlane2 = new Plane()\n      this.tempPlane_Cut = new Plane()\n      this.tempCM1 = new Vector3()\n      this.tempCM2 = new Vector3()\n      this.tempVector3 = new Vector3()\n      this.tempVector3_2 = new Vector3()\n      this.tempVector3_3 = new Vector3()\n      this.tempVector3_P0 = new Vector3()\n      this.tempVector3_P1 = new Vector3()\n      this.tempVector3_P2 = new Vector3()\n      this.tempVector3_N0 = new Vector3()\n      this.tempVector3_N1 = new Vector3()\n      this.tempVector3_AB = new Vector3()\n      this.tempVector3_CB = new Vector3()\n      this.tempResultObjects = { object1: null, object2: null }\n\n      this.segments = []\n      const n = 30 * 30\n      for (let i = 0; i < n; i++) this.segments[i] = false\n    }\n\n    prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n      // object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n      // Its material property is propagated to its children (sub-pieces)\n      // mass must be > 0\n\n      const userData = object.userData\n      userData.mass = mass\n      userData.velocity = velocity.clone()\n      userData.angularVelocity = angularVelocity.clone()\n      userData.breakable = breakable\n    }\n\n    /*\n     * @param {int} maxRadialIterations Iterations for radial cuts.\n     * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n     *\n     * Returns the array of pieces\n     */\n    subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n      const debris = []\n\n      const tempPlane1 = this.tempPlane1\n      const tempPlane2 = this.tempPlane2\n\n      this.tempVector3.addVectors(pointOfImpact, normal)\n      tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3)\n\n      const maxTotalIterations = maxRandomIterations + maxRadialIterations\n\n      const scope = this\n\n      function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n        if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n          debris.push(subObject)\n\n          return\n        }\n\n        let angle = Math.PI\n\n        if (numIterations === 0) {\n          tempPlane2.normal.copy(tempPlane1.normal)\n          tempPlane2.constant = tempPlane1.constant\n        } else {\n          if (numIterations <= maxRadialIterations) {\n            angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle\n\n            // Rotate tempPlane2 at impact point around normal axis and the angle\n            scope.tempVector3_2\n              .copy(object.position)\n              .sub(pointOfImpact)\n              .applyAxisAngle(normal, angle)\n              .add(pointOfImpact)\n            tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2)\n          } else {\n            angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI\n\n            // Rotate tempPlane2 at object position around normal axis and the angle\n            scope.tempVector3_2\n              .copy(pointOfImpact)\n              .sub(subObject.position)\n              .applyAxisAngle(normal, angle)\n              .add(subObject.position)\n            scope.tempVector3_3.copy(normal).add(subObject.position)\n            tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2)\n          }\n        }\n\n        // Perform the cut\n        scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects)\n\n        const obj1 = scope.tempResultObjects.object1\n        const obj2 = scope.tempResultObjects.object2\n\n        if (obj1) {\n          subdivideRadial(obj1, startAngle, angle, numIterations + 1)\n        }\n\n        if (obj2) {\n          subdivideRadial(obj2, angle, endAngle, numIterations + 1)\n        }\n      }\n\n      subdivideRadial(object, 0, 2 * Math.PI, 0)\n\n      return debris\n    }\n\n    cutByPlane(object, plane, output) {\n      // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n      // object2 can be null if the plane doesn't cut the object.\n      // object1 can be null only in case of internal error\n      // Returned value is number of pieces, 0 for error.\n\n      const geometry = object.geometry\n      const coords = geometry.attributes.position.array\n      const normals = geometry.attributes.normal.array\n\n      const numPoints = coords.length / 3\n      let numFaces = numPoints / 3\n\n      let indices = geometry.getIndex()\n\n      if (indices) {\n        indices = indices.array\n        numFaces = indices.length / 3\n      }\n\n      function getVertexIndex(faceIdx, vert) {\n        // vert = 0, 1 or 2.\n\n        const idx = faceIdx * 3 + vert\n\n        return indices ? indices[idx] : idx\n      }\n\n      const points1 = []\n      const points2 = []\n\n      const delta = this.smallDelta\n\n      // Reset segments mark\n      const numPointPairs = numPoints * numPoints\n      for (let i = 0; i < numPointPairs; i++) this.segments[i] = false\n\n      const p0 = this.tempVector3_P0\n      const p1 = this.tempVector3_P1\n      const n0 = this.tempVector3_N0\n      const n1 = this.tempVector3_N1\n\n      // Iterate through the faces to mark edges shared by coplanar faces\n      for (let i = 0; i < numFaces - 1; i++) {\n        const a1 = getVertexIndex(i, 0)\n        const b1 = getVertexIndex(i, 1)\n        const c1 = getVertexIndex(i, 2)\n\n        // Assuming all 3 vertices have the same normal\n        n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2)\n\n        for (let j = i + 1; j < numFaces; j++) {\n          const a2 = getVertexIndex(j, 0)\n          const b2 = getVertexIndex(j, 1)\n          const c2 = getVertexIndex(j, 2)\n\n          // Assuming all 3 vertices have the same normal\n          n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2)\n\n          const coplanar = 1 - n0.dot(n1) < delta\n\n          if (coplanar) {\n            if (a1 === a2 || a1 === b2 || a1 === c2) {\n              if (b1 === a2 || b1 === b2 || b1 === c2) {\n                this.segments[a1 * numPoints + b1] = true\n                this.segments[b1 * numPoints + a1] = true\n              } else {\n                this.segments[c1 * numPoints + a1] = true\n                this.segments[a1 * numPoints + c1] = true\n              }\n            } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[c1 * numPoints + b1] = true\n              this.segments[b1 * numPoints + c1] = true\n            }\n          }\n        }\n      }\n\n      // Transform the plane to object local space\n      const localPlane = this.tempPlane_Cut\n      object.updateMatrix()\n      ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane)\n\n      // Iterate through the faces adding points to both pieces\n      for (let i = 0; i < numFaces; i++) {\n        const va = getVertexIndex(i, 0)\n        const vb = getVertexIndex(i, 1)\n        const vc = getVertexIndex(i, 2)\n\n        for (let segment = 0; segment < 3; segment++) {\n          const i0 = segment === 0 ? va : segment === 1 ? vb : vc\n          const i1 = segment === 0 ? vb : segment === 1 ? vc : va\n\n          const segmentState = this.segments[i0 * numPoints + i1]\n\n          if (segmentState) continue // The segment already has been processed in another face\n\n          // Mark segment as processed (also inverted segment)\n          this.segments[i0 * numPoints + i1] = true\n          this.segments[i1 * numPoints + i0] = true\n\n          p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2])\n          p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2])\n\n          // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n          let mark0 = 0\n\n          let d = localPlane.distanceToPoint(p0)\n\n          if (d > delta) {\n            mark0 = 2\n            points2.push(p0.clone())\n          } else if (d < -delta) {\n            mark0 = 1\n            points1.push(p0.clone())\n          } else {\n            mark0 = 3\n            points1.push(p0.clone())\n            points2.push(p0.clone())\n          }\n\n          // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n          let mark1 = 0\n\n          d = localPlane.distanceToPoint(p1)\n\n          if (d > delta) {\n            mark1 = 2\n            points2.push(p1.clone())\n          } else if (d < -delta) {\n            mark1 = 1\n            points1.push(p1.clone())\n          } else {\n            mark1 = 3\n            points1.push(p1.clone())\n            points2.push(p1.clone())\n          }\n\n          if ((mark0 === 1 && mark1 === 2) || (mark0 === 2 && mark1 === 1)) {\n            // Intersection of segment with the plane\n\n            this.tempLine1.start.copy(p0)\n            this.tempLine1.end.copy(p1)\n\n            let intersection = new Vector3()\n            intersection = localPlane.intersectLine(this.tempLine1, intersection)\n\n            if (intersection === null) {\n              // Shouldn't happen\n              console.error('Internal error: segment does not intersect plane.')\n              output.segmentedObject1 = null\n              output.segmentedObject2 = null\n              return 0\n            }\n\n            points1.push(intersection)\n            points2.push(intersection.clone())\n          }\n        }\n      }\n\n      // Calculate debris mass (very fast and imprecise):\n      const newMass = object.userData.mass * 0.5\n\n      // Calculate debris Center of Mass (again fast and imprecise)\n      this.tempCM1.set(0, 0, 0)\n      let radius1 = 0\n      const numPoints1 = points1.length\n\n      if (numPoints1 > 0) {\n        for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i])\n\n        this.tempCM1.divideScalar(numPoints1)\n        for (let i = 0; i < numPoints1; i++) {\n          const p = points1[i]\n          p.sub(this.tempCM1)\n          radius1 = Math.max(radius1, p.x, p.y, p.z)\n        }\n\n        this.tempCM1.add(object.position)\n      }\n\n      this.tempCM2.set(0, 0, 0)\n      let radius2 = 0\n      const numPoints2 = points2.length\n      if (numPoints2 > 0) {\n        for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i])\n\n        this.tempCM2.divideScalar(numPoints2)\n        for (let i = 0; i < numPoints2; i++) {\n          const p = points2[i]\n          p.sub(this.tempCM2)\n          radius2 = Math.max(radius2, p.x, p.y, p.z)\n        }\n\n        this.tempCM2.add(object.position)\n      }\n\n      let object1 = null\n      let object2 = null\n\n      let numObjects = 0\n\n      if (numPoints1 > 4) {\n        object1 = new Mesh(new ConvexGeometry(points1), object.material)\n        object1.position.copy(this.tempCM1)\n        object1.quaternion.copy(object.quaternion)\n\n        this.prepareBreakableObject(\n          object1,\n          newMass,\n          object.userData.velocity,\n          object.userData.angularVelocity,\n          2 * radius1 > this.minSizeForBreak,\n        )\n\n        numObjects++\n      }\n\n      if (numPoints2 > 4) {\n        object2 = new Mesh(new ConvexGeometry(points2), object.material)\n        object2.position.copy(this.tempCM2)\n        object2.quaternion.copy(object.quaternion)\n\n        this.prepareBreakableObject(\n          object2,\n          newMass,\n          object.userData.velocity,\n          object.userData.angularVelocity,\n          2 * radius2 > this.minSizeForBreak,\n        )\n\n        numObjects++\n      }\n\n      output.object1 = object1\n      output.object2 = object2\n\n      return numObjects\n    }\n\n    static transformFreeVector(v, m) {\n      // input:\n      // vector interpreted as a free vector\n      // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n      const x = v.x,\n        y = v.y,\n        z = v.z\n      const e = m.elements\n\n      v.x = e[0] * x + e[4] * y + e[8] * z\n      v.y = e[1] * x + e[5] * y + e[9] * z\n      v.z = e[2] * x + e[6] * y + e[10] * z\n\n      return v\n    }\n\n    static transformFreeVectorInverse(v, m) {\n      // input:\n      // vector interpreted as a free vector\n      // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n      const x = v.x,\n        y = v.y,\n        z = v.z\n      const e = m.elements\n\n      v.x = e[0] * x + e[1] * y + e[2] * z\n      v.y = e[4] * x + e[5] * y + e[6] * z\n      v.z = e[8] * x + e[9] * y + e[10] * z\n\n      return v\n    }\n\n    static transformTiedVectorInverse(v, m) {\n      // input:\n      // vector interpreted as a tied (ordinary) vector\n      // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n      const x = v.x,\n        y = v.y,\n        z = v.z\n      const e = m.elements\n\n      v.x = e[0] * x + e[1] * y + e[2] * z - e[12]\n      v.y = e[4] * x + e[5] * y + e[6] * z - e[13]\n      v.z = e[8] * x + e[9] * y + e[10] * z - e[14]\n\n      return v\n    }\n\n    static transformPlaneToLocalSpace(plane, m, resultPlane) {\n      resultPlane.normal.copy(plane.normal)\n      resultPlane.constant = plane.constant\n\n      const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m)\n\n      ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m)\n\n      // recalculate constant (like in setFromNormalAndCoplanarPoint)\n      resultPlane.constant = -referencePoint.dot(resultPlane.normal)\n    }\n  }\n\n  return ConvexObjectBreaker\n})()\n\nexport { ConvexObjectBreaker }\n"],"names":["ConvexObjectBreaker"],"mappings":"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"}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/GPUComputationRenderer.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/GPUComputationRenderer.js"],"sourcesContent":["import {\n  Camera,\n  ClampToEdgeWrapping,\n  DataTexture,\n  FloatType,\n  Mesh,\n  NearestFilter,\n  NoToneMapping,\n  PlaneGeometry,\n  RGBAFormat,\n  Scene,\n  ShaderMaterial,\n  WebGLRenderTarget,\n} from 'three'\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n */\n\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = []\n\n    this.currentTextureIndex = 0\n\n    let dataType = FloatType\n\n    const scene = new Scene()\n\n    const camera = new Camera()\n    camera.position.z = 1\n\n    const passThruUniforms = {\n      passThruTexture: { value: null },\n    }\n\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms)\n\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader)\n    scene.add(mesh)\n\n    this.setDataType = function (type) {\n      dataType = type\n      return this\n    }\n\n    this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader)\n\n      const variable = {\n        name: variableName,\n        initialValueTexture: initialValueTexture,\n        material: material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n      }\n\n      this.variables.push(variable)\n\n      return variable\n    }\n\n    this.setVariableDependencies = function (variable, dependencies) {\n      variable.dependencies = dependencies\n    }\n\n    this.init = function () {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\n        return 'No OES_texture_float support for float textures.'\n      }\n\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return 'No support for vertex shader textures.'\n      }\n\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i]\n\n        // Creates rendertargets and initialize them with input texture\n        variable.renderTargets[0] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter,\n        )\n        variable.renderTargets[1] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter,\n        )\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0])\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1])\n\n        // Adds dependencies uniforms to the ShaderMaterial\n        const material = variable.material\n        const uniforms = material.uniforms\n\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d]\n\n            if (depVar.name !== variable.name) {\n              // Checks if variable exists\n              let found = false\n\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true\n                  break\n                }\n              }\n\n              if (!found) {\n                return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name\n              }\n            }\n\n            uniforms[depVar.name] = { value: null }\n\n            material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader\n          }\n        }\n      }\n\n      this.currentTextureIndex = 0\n\n      return null\n    }\n\n    this.compute = function () {\n      const currentTextureIndex = this.currentTextureIndex\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0\n\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i]\n\n        // Sets texture dependencies uniforms\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms\n\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d]\n\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture\n          }\n        }\n\n        // Performs the computation for this variable\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex])\n      }\n\n      this.currentTextureIndex = nextTextureIndex\n    }\n\n    this.getCurrentRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex]\n    }\n\n    this.getAlternateRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0]\n    }\n\n    this.dispose = function () {\n      mesh.geometry.dispose()\n      mesh.material.dispose()\n\n      const variables = this.variables\n\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i]\n\n        if (variable.initialValueTexture) variable.initialValueTexture.dispose()\n\n        const renderTargets = variable.renderTargets\n\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j]\n          renderTarget.dispose()\n        }\n      }\n    }\n\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )'\n    }\n\n    this.addResolutionDefine = addResolutionDefine\n\n    // The following functions can be used to compute things manually\n\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {}\n\n      const material = new ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader,\n      })\n\n      addResolutionDefine(material)\n\n      return material\n    }\n\n    this.createShaderMaterial = createShaderMaterial\n\n    this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX\n      sizeYTexture = sizeYTexture || sizeY\n\n      wrapS = wrapS || ClampToEdgeWrapping\n      wrapT = wrapT || ClampToEdgeWrapping\n\n      minFilter = minFilter || NearestFilter\n      magFilter = magFilter || NearestFilter\n\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS: wrapS,\n        wrapT: wrapT,\n        minFilter: minFilter,\n        magFilter: magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false,\n      })\n\n      return renderTarget\n    }\n\n    this.createTexture = function () {\n      const data = new Float32Array(sizeX * sizeY * 4)\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType)\n      texture.needsUpdate = true\n      return texture\n    }\n\n    this.renderTexture = function (input, output) {\n      // Takes a texture, and render out in rendertarget\n      // input = Texture\n      // output = RenderTarget\n\n      passThruUniforms.passThruTexture.value = input\n\n      this.doRenderTarget(passThruShader, output)\n\n      passThruUniforms.passThruTexture.value = null\n    }\n\n    this.doRenderTarget = function (material, output) {\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentOutputColorSpace = renderer.outputColorSpace\n      const currentToneMapping = renderer.toneMapping\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.encoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      mesh.material = material\n      renderer.setRenderTarget(output)\n      renderer.render(scene, camera)\n      mesh.material = passThruShader\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.outputColorSpace = currentOutputColorSpace\n      renderer.toneMapping = currentToneMapping\n\n      renderer.setRenderTarget(currentRenderTarget)\n    }\n\n    // Shaders\n\n    function getPassThroughVertexShader() {\n      return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n'\n    }\n\n    function getPassThroughFragmentShader() {\n      return (\n        'uniform sampler2D passThruTexture;\\n' +\n        '\\n' +\n        'void main() {\\n' +\n        '\\n' +\n        '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n        '\\n' +\n        '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n        '\\n' +\n        '}\\n'\n      )\n    }\n  }\n}\n\nexport { GPUComputationRenderer }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 992, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/Gyroscope.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/Gyroscope.js"],"sourcesContent":["import { Object3D, Quaternion, Vector3 } from 'three'\n\nconst _translationObject = /* @__PURE__ */ new Vector3()\nconst _quaternionObject = /* @__PURE__ */ new Quaternion()\nconst _scaleObject = /* @__PURE__ */ new Vector3()\n\nconst _translationWorld = /* @__PURE__ */ new Vector3()\nconst _quaternionWorld = /* @__PURE__ */ new Quaternion()\nconst _scaleWorld = /* @__PURE__ */ new Vector3()\n\nclass Gyroscope extends Object3D {\n  constructor() {\n    super()\n  }\n\n  updateMatrixWorld(force) {\n    this.matrixAutoUpdate && this.updateMatrix()\n\n    // update matrixWorld\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent !== null) {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)\n\n        this.matrixWorld.decompose(_translationWorld, _quaternionWorld, _scaleWorld)\n        this.matrix.decompose(_translationObject, _quaternionObject, _scaleObject)\n\n        this.matrixWorld.compose(_translationWorld, _quaternionObject, _scaleWorld)\n      } else {\n        this.matrixWorld.copy(this.matrix)\n      }\n\n      this.matrixWorldNeedsUpdate = false\n\n      force = true\n    }\n\n    // update children\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].updateMatrixWorld(force)\n    }\n  }\n}\n\nexport { Gyroscope }\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,qBAAqC,aAAA,GAAA,IAAI,0JAAA,CAAS;AACxD,MAAM,oBAAoC,aAAA,GAAA,IAAI,6JAAA,CAAY;AAC1D,MAAM,eAA+B,aAAA,GAAA,IAAI,0JAAA,CAAS;AAElD,MAAM,oBAAoC,aAAA,GAAA,IAAI,0JAAA,CAAS;AACvD,MAAM,mBAAmC,aAAA,GAAA,IAAI,6JAAA,CAAY;AACzD,MAAM,cAA8B,aAAA,GAAA,IAAI,0JAAA,CAAS;AAEjD,MAAM,kBAAkB,2JAAA,CAAS;IAC/B,aAAc;QACZ,KAAA,CAAO;IACR;IAED,kBAAkB,KAAA,EAAO;QACvB,IAAA,CAAK,gBAAA,IAAoB,IAAA,CAAK,YAAA,CAAc;QAI5C,IAAI,IAAA,CAAK,sBAAA,IAA0B,OAAO;YACxC,IAAI,IAAA,CAAK,MAAA,KAAW,MAAM;gBACxB,IAAA,CAAK,WAAA,CAAY,gBAAA,CAAiB,IAAA,CAAK,MAAA,CAAO,WAAA,EAAa,IAAA,CAAK,MAAM;gBAEtE,IAAA,CAAK,WAAA,CAAY,SAAA,CAAU,mBAAmB,kBAAkB,WAAW;gBAC3E,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,oBAAoB,mBAAmB,YAAY;gBAEzE,IAAA,CAAK,WAAA,CAAY,OAAA,CAAQ,mBAAmB,mBAAmB,WAAW;YAClF,OAAa;gBACL,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,IAAA,CAAK,MAAM;YAClC;YAED,IAAA,CAAK,sBAAA,GAAyB;YAE9B,QAAQ;QACT;QAID,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,IAAI,GAAG,IAAK;YACpD,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA,CAAE,iBAAA,CAAkB,KAAK;QACzC;IACF;AACH"}},
    {"offset": {"line": 1033, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/MorphAnimMesh.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/MorphAnimMesh.js"],"sourcesContent":["import { AnimationClip, AnimationMixer, Mesh } from 'three'\n\nclass MorphAnimMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material)\n\n    this.type = 'MorphAnimMesh'\n\n    this.mixer = new AnimationMixer(this)\n    this.activeAction = null\n  }\n\n  setDirectionForward() {\n    this.mixer.timeScale = 1.0\n  }\n\n  setDirectionBackward() {\n    this.mixer.timeScale = -1.0\n  }\n\n  playAnimation(label, fps) {\n    if (this.activeAction) {\n      this.activeAction.stop()\n      this.activeAction = null\n    }\n\n    const clip = AnimationClip.findByName(this, label)\n\n    if (clip) {\n      const action = this.mixer.clipAction(clip)\n      action.timeScale = (clip.tracks.length * fps) / clip.duration\n      this.activeAction = action.play()\n    } else {\n      throw new Error('THREE.MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()')\n    }\n  }\n\n  updateAnimation(delta) {\n    this.mixer.update(delta)\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.mixer = new AnimationMixer(this)\n\n    return this\n  }\n}\n\nexport { MorphAnimMesh }\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,sBAAsB,uJAAA,CAAK;IAC/B,YAAY,QAAA,EAAU,QAAA,CAAU;QAC9B,KAAA,CAAM,UAAU,QAAQ;QAExB,IAAA,CAAK,IAAA,GAAO;QAEZ,IAAA,CAAK,KAAA,GAAQ,IAAI,iKAAA,CAAe,IAAI;QACpC,IAAA,CAAK,YAAA,GAAe;IACrB;IAED,sBAAsB;QACpB,IAAA,CAAK,KAAA,CAAM,SAAA,GAAY;IACxB;IAED,uBAAuB;QACrB,IAAA,CAAK,KAAA,CAAM,SAAA,GAAY,CAAA;IACxB;IAED,cAAc,KAAA,EAAO,GAAA,EAAK;QACxB,IAAI,IAAA,CAAK,YAAA,EAAc;YACrB,IAAA,CAAK,YAAA,CAAa,IAAA,CAAM;YACxB,IAAA,CAAK,YAAA,GAAe;QACrB;QAED,MAAM,OAAO,gKAAA,CAAc,UAAA,CAAW,IAAA,EAAM,KAAK;QAEjD,IAAI,MAAM;YACR,MAAM,SAAS,IAAA,CAAK,KAAA,CAAM,UAAA,CAAW,IAAI;YACzC,OAAO,SAAA,GAAa,KAAK,MAAA,CAAO,MAAA,GAAS,MAAO,KAAK,QAAA;YACrD,IAAA,CAAK,YAAA,GAAe,OAAO,IAAA,CAAM;QACvC,OAAW;YACL,MAAM,IAAI,MAAM,qCAAqC,QAAQ,iCAAiC;QAC/F;IACF;IAED,gBAAgB,KAAA,EAAO;QACrB,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,KAAK;IACxB;IAED,KAAK,MAAA,EAAQ,SAAA,EAAW;QACtB,KAAA,CAAM,KAAK,QAAQ,SAAS;QAE5B,IAAA,CAAK,KAAA,GAAQ,IAAI,iKAAA,CAAe,IAAI;QAEpC,OAAO,IAAA;IACR;AACH"}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/RollerCoaster.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/RollerCoaster.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, Color, Quaternion, Raycaster, Vector3 } from 'three'\n\nclass RollerCoasterGeometry extends BufferGeometry {\n  constructor(curve, divisions) {\n    super()\n\n    const vertices = []\n    const normals = []\n    const colors = []\n\n    const color1 = [1, 1, 1]\n    const color2 = [1, 1, 0]\n\n    const up = new Vector3(0, 1, 0)\n    const forward = new Vector3()\n    const right = new Vector3()\n\n    const quaternion = new Quaternion()\n    const prevQuaternion = new Quaternion()\n    prevQuaternion.setFromAxisAngle(up, Math.PI / 2)\n\n    const point = new Vector3()\n    const prevPoint = new Vector3()\n    prevPoint.copy(curve.getPointAt(0))\n\n    // shapes\n\n    const step = [\n      new Vector3(-0.225, 0, 0),\n      new Vector3(0, -0.05, 0),\n      new Vector3(0, -0.175, 0),\n\n      new Vector3(0, -0.05, 0),\n      new Vector3(0.225, 0, 0),\n      new Vector3(0, -0.175, 0),\n    ]\n\n    const PI2 = Math.PI * 2\n\n    let sides = 5\n    const tube1 = []\n\n    for (let i = 0; i < sides; i++) {\n      const angle = (i / sides) * PI2\n      tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0))\n    }\n\n    sides = 6\n    const tube2 = []\n\n    for (let i = 0; i < sides; i++) {\n      const angle = (i / sides) * PI2\n      tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0))\n    }\n\n    const vector = new Vector3()\n    const normal = new Vector3()\n\n    function drawShape(shape, color) {\n      normal.set(0, 0, -1).applyQuaternion(quaternion)\n\n      for (let j = 0; j < shape.length; j++) {\n        vector.copy(shape[j])\n        vector.applyQuaternion(quaternion)\n        vector.add(point)\n\n        vertices.push(vector.x, vector.y, vector.z)\n        normals.push(normal.x, normal.y, normal.z)\n        colors.push(color[0], color[1], color[2])\n      }\n\n      normal.set(0, 0, 1).applyQuaternion(quaternion)\n\n      for (let j = shape.length - 1; j >= 0; j--) {\n        vector.copy(shape[j])\n        vector.applyQuaternion(quaternion)\n        vector.add(point)\n\n        vertices.push(vector.x, vector.y, vector.z)\n        normals.push(normal.x, normal.y, normal.z)\n        colors.push(color[0], color[1], color[2])\n      }\n    }\n\n    const vector1 = new Vector3()\n    const vector2 = new Vector3()\n    const vector3 = new Vector3()\n    const vector4 = new Vector3()\n\n    const normal1 = new Vector3()\n    const normal2 = new Vector3()\n    const normal3 = new Vector3()\n    const normal4 = new Vector3()\n\n    function extrudeShape(shape, offset, color) {\n      for (let j = 0, jl = shape.length; j < jl; j++) {\n        const point1 = shape[j]\n        const point2 = shape[(j + 1) % jl]\n\n        vector1.copy(point1).add(offset)\n        vector1.applyQuaternion(quaternion)\n        vector1.add(point)\n\n        vector2.copy(point2).add(offset)\n        vector2.applyQuaternion(quaternion)\n        vector2.add(point)\n\n        vector3.copy(point2).add(offset)\n        vector3.applyQuaternion(prevQuaternion)\n        vector3.add(prevPoint)\n\n        vector4.copy(point1).add(offset)\n        vector4.applyQuaternion(prevQuaternion)\n        vector4.add(prevPoint)\n\n        vertices.push(vector1.x, vector1.y, vector1.z)\n        vertices.push(vector2.x, vector2.y, vector2.z)\n        vertices.push(vector4.x, vector4.y, vector4.z)\n\n        vertices.push(vector2.x, vector2.y, vector2.z)\n        vertices.push(vector3.x, vector3.y, vector3.z)\n        vertices.push(vector4.x, vector4.y, vector4.z)\n\n        //\n\n        normal1.copy(point1)\n        normal1.applyQuaternion(quaternion)\n        normal1.normalize()\n\n        normal2.copy(point2)\n        normal2.applyQuaternion(quaternion)\n        normal2.normalize()\n\n        normal3.copy(point2)\n        normal3.applyQuaternion(prevQuaternion)\n        normal3.normalize()\n\n        normal4.copy(point1)\n        normal4.applyQuaternion(prevQuaternion)\n        normal4.normalize()\n\n        normals.push(normal1.x, normal1.y, normal1.z)\n        normals.push(normal2.x, normal2.y, normal2.z)\n        normals.push(normal4.x, normal4.y, normal4.z)\n\n        normals.push(normal2.x, normal2.y, normal2.z)\n        normals.push(normal3.x, normal3.y, normal3.z)\n        normals.push(normal4.x, normal4.y, normal4.z)\n\n        colors.push(color[0], color[1], color[2])\n        colors.push(color[0], color[1], color[2])\n        colors.push(color[0], color[1], color[2])\n\n        colors.push(color[0], color[1], color[2])\n        colors.push(color[0], color[1], color[2])\n        colors.push(color[0], color[1], color[2])\n      }\n    }\n\n    const offset = new Vector3()\n\n    for (let i = 1; i <= divisions; i++) {\n      point.copy(curve.getPointAt(i / divisions))\n\n      up.set(0, 1, 0)\n\n      forward.subVectors(point, prevPoint).normalize()\n      right.crossVectors(up, forward).normalize()\n      up.crossVectors(forward, right)\n\n      const angle = Math.atan2(forward.x, forward.z)\n\n      quaternion.setFromAxisAngle(up, angle)\n\n      if (i % 2 === 0) {\n        drawShape(step, color2)\n      }\n\n      extrudeShape(tube1, offset.set(0, -0.125, 0), color2)\n      extrudeShape(tube2, offset.set(0.2, 0, 0), color1)\n      extrudeShape(tube2, offset.set(-0.2, 0, 0), color1)\n\n      prevPoint.copy(point)\n      prevQuaternion.copy(quaternion)\n    }\n\n    // console.log( vertices.length );\n\n    this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3))\n    this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3))\n    this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3))\n  }\n}\n\nclass RollerCoasterLiftersGeometry extends BufferGeometry {\n  constructor(curve, divisions) {\n    super()\n\n    const vertices = []\n    const normals = []\n\n    const quaternion = new Quaternion()\n\n    const up = new Vector3(0, 1, 0)\n\n    const point = new Vector3()\n    const tangent = new Vector3()\n\n    // shapes\n\n    const tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)]\n\n    const tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)]\n\n    const tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)]\n\n    const vector1 = new Vector3()\n    const vector2 = new Vector3()\n    const vector3 = new Vector3()\n    const vector4 = new Vector3()\n\n    const normal1 = new Vector3()\n    const normal2 = new Vector3()\n    const normal3 = new Vector3()\n    const normal4 = new Vector3()\n\n    function extrudeShape(shape, fromPoint, toPoint) {\n      for (let j = 0, jl = shape.length; j < jl; j++) {\n        const point1 = shape[j]\n        const point2 = shape[(j + 1) % jl]\n\n        vector1.copy(point1)\n        vector1.applyQuaternion(quaternion)\n        vector1.add(fromPoint)\n\n        vector2.copy(point2)\n        vector2.applyQuaternion(quaternion)\n        vector2.add(fromPoint)\n\n        vector3.copy(point2)\n        vector3.applyQuaternion(quaternion)\n        vector3.add(toPoint)\n\n        vector4.copy(point1)\n        vector4.applyQuaternion(quaternion)\n        vector4.add(toPoint)\n\n        vertices.push(vector1.x, vector1.y, vector1.z)\n        vertices.push(vector2.x, vector2.y, vector2.z)\n        vertices.push(vector4.x, vector4.y, vector4.z)\n\n        vertices.push(vector2.x, vector2.y, vector2.z)\n        vertices.push(vector3.x, vector3.y, vector3.z)\n        vertices.push(vector4.x, vector4.y, vector4.z)\n\n        //\n\n        normal1.copy(point1)\n        normal1.applyQuaternion(quaternion)\n        normal1.normalize()\n\n        normal2.copy(point2)\n        normal2.applyQuaternion(quaternion)\n        normal2.normalize()\n\n        normal3.copy(point2)\n        normal3.applyQuaternion(quaternion)\n        normal3.normalize()\n\n        normal4.copy(point1)\n        normal4.applyQuaternion(quaternion)\n        normal4.normalize()\n\n        normals.push(normal1.x, normal1.y, normal1.z)\n        normals.push(normal2.x, normal2.y, normal2.z)\n        normals.push(normal4.x, normal4.y, normal4.z)\n\n        normals.push(normal2.x, normal2.y, normal2.z)\n        normals.push(normal3.x, normal3.y, normal3.z)\n        normals.push(normal4.x, normal4.y, normal4.z)\n      }\n    }\n\n    const fromPoint = new Vector3()\n    const toPoint = new Vector3()\n\n    for (let i = 1; i <= divisions; i++) {\n      point.copy(curve.getPointAt(i / divisions))\n      tangent.copy(curve.getTangentAt(i / divisions))\n\n      const angle = Math.atan2(tangent.x, tangent.z)\n\n      quaternion.setFromAxisAngle(up, angle)\n\n      //\n\n      if (point.y > 10) {\n        fromPoint.set(-0.75, -0.35, 0)\n        fromPoint.applyQuaternion(quaternion)\n        fromPoint.add(point)\n\n        toPoint.set(0.75, -0.35, 0)\n        toPoint.applyQuaternion(quaternion)\n        toPoint.add(point)\n\n        extrudeShape(tube1, fromPoint, toPoint)\n\n        fromPoint.set(-0.7, -0.3, 0)\n        fromPoint.applyQuaternion(quaternion)\n        fromPoint.add(point)\n\n        toPoint.set(-0.7, -point.y, 0)\n        toPoint.applyQuaternion(quaternion)\n        toPoint.add(point)\n\n        extrudeShape(tube2, fromPoint, toPoint)\n\n        fromPoint.set(0.7, -0.3, 0)\n        fromPoint.applyQuaternion(quaternion)\n        fromPoint.add(point)\n\n        toPoint.set(0.7, -point.y, 0)\n        toPoint.applyQuaternion(quaternion)\n        toPoint.add(point)\n\n        extrudeShape(tube3, fromPoint, toPoint)\n      } else {\n        fromPoint.set(0, -0.2, 0)\n        fromPoint.applyQuaternion(quaternion)\n        fromPoint.add(point)\n\n        toPoint.set(0, -point.y, 0)\n        toPoint.applyQuaternion(quaternion)\n        toPoint.add(point)\n\n        extrudeShape(tube3, fromPoint, toPoint)\n      }\n    }\n\n    this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3))\n    this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3))\n  }\n}\n\nclass RollerCoasterShadowGeometry extends BufferGeometry {\n  constructor(curve, divisions) {\n    super()\n\n    const vertices = []\n\n    const up = new Vector3(0, 1, 0)\n    const forward = new Vector3()\n\n    const quaternion = new Quaternion()\n    const prevQuaternion = new Quaternion()\n    prevQuaternion.setFromAxisAngle(up, Math.PI / 2)\n\n    const point = new Vector3()\n\n    const prevPoint = new Vector3()\n    prevPoint.copy(curve.getPointAt(0))\n    prevPoint.y = 0\n\n    const vector1 = new Vector3()\n    const vector2 = new Vector3()\n    const vector3 = new Vector3()\n    const vector4 = new Vector3()\n\n    for (let i = 1; i <= divisions; i++) {\n      point.copy(curve.getPointAt(i / divisions))\n      point.y = 0\n\n      forward.subVectors(point, prevPoint)\n\n      const angle = Math.atan2(forward.x, forward.z)\n\n      quaternion.setFromAxisAngle(up, angle)\n\n      vector1.set(-0.3, 0, 0)\n      vector1.applyQuaternion(quaternion)\n      vector1.add(point)\n\n      vector2.set(0.3, 0, 0)\n      vector2.applyQuaternion(quaternion)\n      vector2.add(point)\n\n      vector3.set(0.3, 0, 0)\n      vector3.applyQuaternion(prevQuaternion)\n      vector3.add(prevPoint)\n\n      vector4.set(-0.3, 0, 0)\n      vector4.applyQuaternion(prevQuaternion)\n      vector4.add(prevPoint)\n\n      vertices.push(vector1.x, vector1.y, vector1.z)\n      vertices.push(vector2.x, vector2.y, vector2.z)\n      vertices.push(vector4.x, vector4.y, vector4.z)\n\n      vertices.push(vector2.x, vector2.y, vector2.z)\n      vertices.push(vector3.x, vector3.y, vector3.z)\n      vertices.push(vector4.x, vector4.y, vector4.z)\n\n      prevPoint.copy(point)\n      prevQuaternion.copy(quaternion)\n    }\n\n    this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3))\n  }\n}\n\nclass SkyGeometry extends BufferGeometry {\n  constructor() {\n    super()\n\n    const vertices = []\n\n    for (let i = 0; i < 100; i++) {\n      const x = Math.random() * 800 - 400\n      const y = Math.random() * 50 + 50\n      const z = Math.random() * 800 - 400\n\n      const size = Math.random() * 40 + 20\n\n      vertices.push(x - size, y, z - size)\n      vertices.push(x + size, y, z - size)\n      vertices.push(x - size, y, z + size)\n\n      vertices.push(x + size, y, z - size)\n      vertices.push(x + size, y, z + size)\n      vertices.push(x - size, y, z + size)\n    }\n\n    this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3))\n  }\n}\n\nclass TreesGeometry extends BufferGeometry {\n  constructor(landscape) {\n    super()\n\n    const vertices = []\n    const colors = []\n\n    const raycaster = new Raycaster()\n    raycaster.ray.direction.set(0, -1, 0)\n\n    const _color = new Color()\n\n    for (let i = 0; i < 2000; i++) {\n      const x = Math.random() * 500 - 250\n      const z = Math.random() * 500 - 250\n\n      raycaster.ray.origin.set(x, 50, z)\n\n      const intersections = raycaster.intersectObject(landscape)\n\n      if (intersections.length === 0) continue\n\n      const y = intersections[0].point.y\n\n      const height = Math.random() * 5 + 0.5\n\n      let angle = Math.random() * Math.PI * 2\n\n      vertices.push(x + Math.sin(angle), y, z + Math.cos(angle))\n      vertices.push(x, y + height, z)\n      vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI))\n\n      angle += Math.PI / 2\n\n      vertices.push(x + Math.sin(angle), y, z + Math.cos(angle))\n      vertices.push(x, y + height, z)\n      vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI))\n\n      const random = Math.random() * 0.1\n\n      for (let j = 0; j < 6; j++) {\n        _color.setRGB(0.2 + random, 0.4 + random, 0, 'srgb')\n\n        colors.push(_color.r, _color.g, _color.b)\n      }\n    }\n\n    this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3))\n    this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3))\n  }\n}\n\nexport { RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry }\n"],"names":["offset","fromPoint","toPoint"],"mappings":"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"}},
    {"offset": {"line": 1465, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/Timer.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/Timer.ts"],"sourcesContent":["class Timer {\n  private _previousTime: number\n  private _currentTime: number\n  private _delta: number\n  private _elapsed: number\n  private _timescale: number\n  private _useFixedDelta: boolean\n  private _fixedDelta: number\n  private _usePageVisibilityAPI: boolean\n  private _pageVisibilityHandler: ((...args: any[]) => void) | undefined\n\n  constructor() {\n    this._previousTime = 0\n    this._currentTime = 0\n    this._delta = 0\n    this._elapsed = 0\n    this._timescale = 1\n    this._useFixedDelta = false\n    this._fixedDelta = 16.67 // ms, corresponds to approx. 60 FPS\n    this._usePageVisibilityAPI = typeof document !== 'undefined' && document.hidden !== undefined\n  }\n\n  // https://github.com/mrdoob/three.js/issues/20575\n  // use Page Visibility API to avoid large time delta values\n  connect(): this {\n    if (this._usePageVisibilityAPI) {\n      this._pageVisibilityHandler = handleVisibilityChange.bind(this)\n      document.addEventListener('visibilitychange', this._pageVisibilityHandler, false)\n    }\n    return this\n  }\n\n  dispose(): this {\n    if (this._usePageVisibilityAPI && this._pageVisibilityHandler) {\n      document.removeEventListener('visibilitychange', this._pageVisibilityHandler)\n    }\n    return this\n  }\n\n  disableFixedDelta(): this {\n    this._useFixedDelta = false\n    return this\n  }\n\n  enableFixedDelta(): this {\n    this._useFixedDelta = true\n    return this\n  }\n\n  getDelta(): number {\n    return this._delta / 1000\n  }\n\n  getElapsedTime(): number {\n    return this._elapsed / 1000\n  }\n\n  getFixedDelta(): number {\n    return this._fixedDelta / 1000\n  }\n\n  getTimescale(): number {\n    return this._timescale\n  }\n\n  reset(): this {\n    this._currentTime = this._now()\n    return this\n  }\n\n  setFixedDelta(fixedDelta: number): this {\n    this._fixedDelta = fixedDelta * 1000\n    return this\n  }\n\n  setTimescale(timescale: number): this {\n    this._timescale = timescale\n    return this\n  }\n\n  update(): this {\n    if (this._useFixedDelta === true) {\n      this._delta = this._fixedDelta\n    } else {\n      this._previousTime = this._currentTime\n      this._currentTime = this._now()\n      this._delta = this._currentTime - this._previousTime\n    }\n    this._delta *= this._timescale\n    this._elapsed += this._delta // _elapsed is the accumulation of all previous deltas\n    return this\n  }\n\n  // For THREE.Clock backward compatibility\n  get elapsedTime(): number {\n    return this.getElapsedTime()\n  }\n\n  // private\n\n  private _now(): number {\n    return (typeof performance === 'undefined' ? Date : performance).now()\n  }\n}\n\nfunction handleVisibilityChange(this: Timer): void {\n  if (document.hidden === false) this.reset()\n}\n\nexport { Timer }\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,MAAM,MAAM;IAWV,aAAc;QAVN,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGN,IAAA,CAAK,aAAA,GAAgB;QACrB,IAAA,CAAK,YAAA,GAAe;QACpB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,cAAA,GAAiB;QACtB,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,qBAAA,GAAwB,OAAO,aAAa,eAAe,SAAS,MAAA,KAAW,KAAA;IACtF;IAAA,kDAAA;IAAA,2DAAA;IAIA,UAAgB;QACd,IAAI,IAAA,CAAK,qBAAA,EAAuB;YACzB,IAAA,CAAA,sBAAA,GAAyB,uBAAuB,IAAA,CAAK,IAAI;YAC9D,SAAS,gBAAA,CAAiB,oBAAoB,IAAA,CAAK,sBAAA,EAAwB,KAAK;QAClF;QACO,OAAA,IAAA;IACT;IAEA,UAAgB;QACV,IAAA,IAAA,CAAK,qBAAA,IAAyB,IAAA,CAAK,sBAAA,EAAwB;YACpD,SAAA,mBAAA,CAAoB,oBAAoB,IAAA,CAAK,sBAAsB;QAC9E;QACO,OAAA,IAAA;IACT;IAEA,oBAA0B;QACxB,IAAA,CAAK,cAAA,GAAiB;QACf,OAAA,IAAA;IACT;IAEA,mBAAyB;QACvB,IAAA,CAAK,cAAA,GAAiB;QACf,OAAA,IAAA;IACT;IAEA,WAAmB;QACjB,OAAO,IAAA,CAAK,MAAA,GAAS;IACvB;IAEA,iBAAyB;QACvB,OAAO,IAAA,CAAK,QAAA,GAAW;IACzB;IAEA,gBAAwB;QACtB,OAAO,IAAA,CAAK,WAAA,GAAc;IAC5B;IAEA,eAAuB;QACrB,OAAO,IAAA,CAAK,UAAA;IACd;IAEA,QAAc;QACP,IAAA,CAAA,YAAA,GAAe,IAAA,CAAK,IAAA;QAClB,OAAA,IAAA;IACT;IAEA,cAAc,UAAA,EAA0B;QACtC,IAAA,CAAK,WAAA,GAAc,aAAa;QACzB,OAAA,IAAA;IACT;IAEA,aAAa,SAAA,EAAyB;QACpC,IAAA,CAAK,UAAA,GAAa;QACX,OAAA,IAAA;IACT;IAEA,SAAe;QACT,IAAA,IAAA,CAAK,cAAA,KAAmB,MAAM;YAChC,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,WAAA;QAAA,OACd;YACL,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,YAAA;YACrB,IAAA,CAAA,YAAA,GAAe,IAAA,CAAK,IAAA;YACpB,IAAA,CAAA,MAAA,GAAS,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,aAAA;QACzC;QACA,IAAA,CAAK,MAAA,IAAU,IAAA,CAAK,UAAA;QACpB,IAAA,CAAK,QAAA,IAAY,IAAA,CAAK,MAAA;QACf,OAAA,IAAA;IACT;IAAA,yCAAA;IAGA,IAAI,cAAsB;QACxB,OAAO,IAAA,CAAK,cAAA;IACd;IAAA,UAAA;IAIQ,OAAe;QACrB,OAAA,CAAQ,OAAO,gBAAgB,cAAc,OAAO,WAAA,EAAa,GAAA;IACnE;AACF;AAEA,SAAS,yBAA0C;IACjD,IAAI,SAAS,MAAA,KAAW,OAAO,IAAA,CAAK,KAAA,CAAM;AAC5C"}},
    {"offset": {"line": 1577, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/WebGL.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/WebGL.ts"],"sourcesContent":["let webGLAvailable: boolean, webGL2Available: boolean\n\nexport function isWebGLAvailable(): boolean {\n  if (webGLAvailable !== undefined) return webGLAvailable\n  try {\n    let gl\n    const canvas = document.createElement('canvas')\n    webGLAvailable = !!(window.WebGLRenderingContext && (gl = canvas.getContext('webgl')))\n    if (gl) gl.getExtension('WEBGL_lose_context')?.loseContext()\n    return webGLAvailable\n  } catch (e) {\n    return (webGLAvailable = false)\n  }\n}\n\nexport function isWebGL2Available(): boolean {\n  if (webGL2Available !== undefined) return webGL2Available\n  try {\n    let gl\n    const canvas = document.createElement('canvas')\n    webGL2Available = !!(window.WebGL2RenderingContext && (gl = canvas.getContext('webgl2')))\n    if (gl) gl.getExtension('WEBGL_lose_context')?.loseContext()\n    return webGL2Available\n  } catch (e) {\n    return (webGL2Available = false)\n  }\n}\n\nexport function getWebGLErrorMessage(): HTMLDivElement {\n  return getErrorMessage(1)\n}\n\nexport function getWebGL2ErrorMessage(): HTMLDivElement {\n  return getErrorMessage(2)\n}\n\nexport function getErrorMessage(version: 1 | 2): HTMLDivElement {\n  const names = {\n    1: 'WebGL',\n    2: 'WebGL 2',\n  }\n\n  const contexts = {\n    1: window.WebGLRenderingContext,\n    2: window.WebGL2RenderingContext,\n  }\n\n  const element = document.createElement('div')\n  element.id = 'webglmessage'\n  element.style.fontFamily = 'monospace'\n  element.style.fontSize = '13px'\n  element.style.fontWeight = 'normal'\n  element.style.textAlign = 'center'\n  element.style.background = '#fff'\n  element.style.color = '#000'\n  element.style.padding = '1.5em'\n  element.style.width = '400px'\n  element.style.margin = '5em auto 0'\n\n  let message =\n    'Your $0 does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">$1</a>'\n\n  if (contexts[version]) {\n    message = message.replace('$0', 'graphics card')\n  } else {\n    message = message.replace('$0', 'browser')\n  }\n\n  message = message.replace('$1', names[version])\n  element.innerHTML = message\n  return element\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAI,gBAAyB;AAEtB,SAAS,mBAA4B;IAF5C,IAAA;IAGE,IAAI,mBAAmB,KAAA,GAAkB,OAAA;IACrC,IAAA;QACE,IAAA;QACE,MAAA,SAAS,SAAS,aAAA,CAAc,QAAQ;QAC9C,iBAAiB,CAAC,CAAA,CAAE,OAAO,qBAAA,IAAA,CAA0B,KAAK,OAAO,UAAA,CAAW,OAAO,CAAA,CAAA;QAC/E,IAAA,IAAO,CAAA,KAAA,GAAA,YAAA,CAAa,oBAAoB,CAAA,KAAjC,OAAA,KAAA,IAAA,GAAoC,WAAA;QACxC,OAAA;IAAA,EAAA,OACA,GAAA;QACP,OAAQ,iBAAiB;IAC3B;AACF;AAEO,SAAS,oBAA6B;IAf7C,IAAA;IAgBE,IAAI,oBAAoB,KAAA,GAAkB,OAAA;IACtC,IAAA;QACE,IAAA;QACE,MAAA,SAAS,SAAS,aAAA,CAAc,QAAQ;QAC9C,kBAAkB,CAAC,CAAA,CAAE,OAAO,sBAAA,IAAA,CAA2B,KAAK,OAAO,UAAA,CAAW,QAAQ,CAAA,CAAA;QAClF,IAAA,IAAO,CAAA,KAAA,GAAA,YAAA,CAAa,oBAAoB,CAAA,KAAjC,OAAA,KAAA,IAAA,GAAoC,WAAA;QACxC,OAAA;IAAA,EAAA,OACA,GAAA;QACP,OAAQ,kBAAkB;IAC5B;AACF;AAEO,SAAS,uBAAuC;IACrD,OAAO,gBAAgB,CAAC;AAC1B;AAEO,SAAS,wBAAwC;IACtD,OAAO,gBAAgB,CAAC;AAC1B;AAEO,SAAS,gBAAgB,OAAA,EAAgC;IAC9D,MAAM,QAAQ;QACZ,GAAG;QACH,GAAG;IAAA;IAGL,MAAM,WAAW;QACf,GAAG,OAAO,qBAAA;QACV,GAAG,OAAO,sBAAA;IAAA;IAGN,MAAA,UAAU,SAAS,aAAA,CAAc,KAAK;IAC5C,QAAQ,EAAA,GAAK;IACb,QAAQ,KAAA,CAAM,UAAA,GAAa;IAC3B,QAAQ,KAAA,CAAM,QAAA,GAAW;IACzB,QAAQ,KAAA,CAAM,UAAA,GAAa;IAC3B,QAAQ,KAAA,CAAM,SAAA,GAAY;IAC1B,QAAQ,KAAA,CAAM,UAAA,GAAa;IAC3B,QAAQ,KAAA,CAAM,KAAA,GAAQ;IACtB,QAAQ,KAAA,CAAM,OAAA,GAAU;IACxB,QAAQ,KAAA,CAAM,KAAA,GAAQ;IACtB,QAAQ,KAAA,CAAM,MAAA,GAAS;IAEvB,IAAI,UACF;IAEE,IAAA,QAAA,CAAS,OAAO,CAAA,EAAG;QACX,UAAA,QAAQ,OAAA,CAAQ,MAAM,eAAe;IAAA,OAC1C;QACK,UAAA,QAAQ,OAAA,CAAQ,MAAM,SAAS;IAC3C;IAEA,UAAU,QAAQ,OAAA,CAAQ,MAAM,KAAA,CAAM,OAAO,CAAC;IAC9C,QAAQ,SAAA,GAAY;IACb,OAAA;AACT"}},
    {"offset": {"line": 1658, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/MD2Character.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/MD2Character.js"],"sourcesContent":["import { AnimationMixer, Box3, Mesh, MeshLambertMaterial, Object3D, TextureLoader, UVMapping } from 'three'\nimport { MD2Loader } from '../loaders/MD2Loader'\n\nclass MD2Character {\n  constructor() {\n    this.scale = 1\n    this.animationFPS = 6\n\n    this.root = new Object3D()\n\n    this.meshBody = null\n    this.meshWeapon = null\n\n    this.skinsBody = []\n    this.skinsWeapon = []\n\n    this.weapons = []\n\n    this.activeAnimation = null\n\n    this.mixer = null\n\n    this.onLoadComplete = function () {}\n\n    this.loadCounter = 0\n  }\n\n  loadParts(config) {\n    const scope = this\n\n    function createPart(geometry, skinMap) {\n      const materialWireframe = new MeshLambertMaterial({\n        color: 0xffaa00,\n        wireframe: true,\n        morphTargets: true,\n        morphNormals: true,\n      })\n      const materialTexture = new MeshLambertMaterial({\n        color: 0xffffff,\n        wireframe: false,\n        map: skinMap,\n        morphTargets: true,\n        morphNormals: true,\n      })\n\n      //\n\n      const mesh = new Mesh(geometry, materialTexture)\n      mesh.rotation.y = -Math.PI / 2\n\n      mesh.castShadow = true\n      mesh.receiveShadow = true\n\n      //\n\n      mesh.materialTexture = materialTexture\n      mesh.materialWireframe = materialWireframe\n\n      return mesh\n    }\n\n    function loadTextures(baseUrl, textureUrls) {\n      const textureLoader = new TextureLoader()\n      const textures = []\n\n      for (let i = 0; i < textureUrls.length; i++) {\n        textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete)\n        textures[i].mapping = UVMapping\n        textures[i].name = textureUrls[i]\n        if ('colorSpace' in textures[i]) textures[i].colorSpace = 'srgb'\n        else textures[i].encoding = 3001 // sRGBEncoding\n      }\n\n      return textures\n    }\n\n    function checkLoadingComplete() {\n      scope.loadCounter -= 1\n\n      if (scope.loadCounter === 0) scope.onLoadComplete()\n    }\n\n    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1\n\n    const weaponsTextures = []\n    for (let i = 0; i < config.weapons.length; i++) weaponsTextures[i] = config.weapons[i][1]\n    // SKINS\n\n    this.skinsBody = loadTextures(config.baseUrl + 'skins/', config.skins)\n    this.skinsWeapon = loadTextures(config.baseUrl + 'skins/', weaponsTextures)\n\n    // BODY\n\n    const loader = new MD2Loader()\n\n    loader.load(config.baseUrl + config.body, function (geo) {\n      const boundingBox = new Box3()\n      boundingBox.setFromBufferAttribute(geo.attributes.position)\n\n      scope.root.position.y = -scope.scale * boundingBox.min.y\n\n      const mesh = createPart(geo, scope.skinsBody[0])\n      mesh.scale.set(scope.scale, scope.scale, scope.scale)\n\n      scope.root.add(mesh)\n\n      scope.meshBody = mesh\n\n      scope.meshBody.clipOffset = 0\n      scope.activeAnimationClipName = mesh.geometry.animations[0].name\n\n      scope.mixer = new AnimationMixer(mesh)\n\n      checkLoadingComplete()\n    })\n\n    // WEAPONS\n\n    const generateCallback = function (index, name) {\n      return function (geo) {\n        const mesh = createPart(geo, scope.skinsWeapon[index])\n        mesh.scale.set(scope.scale, scope.scale, scope.scale)\n        mesh.visible = false\n\n        mesh.name = name\n\n        scope.root.add(mesh)\n\n        scope.weapons[index] = mesh\n        scope.meshWeapon = mesh\n\n        checkLoadingComplete()\n      }\n    }\n\n    for (let i = 0; i < config.weapons.length; i++) {\n      loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]))\n    }\n  }\n\n  setPlaybackRate(rate) {\n    if (rate !== 0) {\n      this.mixer.timeScale = 1 / rate\n    } else {\n      this.mixer.timeScale = 0\n    }\n  }\n\n  setWireframe(wireframeEnabled) {\n    if (wireframeEnabled) {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe\n    } else {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture\n    }\n  }\n\n  setSkin(index) {\n    if (this.meshBody && this.meshBody.material.wireframe === false) {\n      this.meshBody.material.map = this.skinsBody[index]\n    }\n  }\n\n  setWeapon(index) {\n    for (let i = 0; i < this.weapons.length; i++) this.weapons[i].visible = false\n\n    const activeWeapon = this.weapons[index]\n\n    if (activeWeapon) {\n      activeWeapon.visible = true\n      this.meshWeapon = activeWeapon\n\n      this.syncWeaponAnimation()\n    }\n  }\n\n  setAnimation(clipName) {\n    if (this.meshBody) {\n      if (this.meshBody.activeAction) {\n        this.meshBody.activeAction.stop()\n        this.meshBody.activeAction = null\n      }\n\n      const action = this.mixer.clipAction(clipName, this.meshBody)\n\n      if (action) {\n        this.meshBody.activeAction = action.play()\n      }\n    }\n\n    this.activeClipName = clipName\n\n    this.syncWeaponAnimation()\n  }\n\n  syncWeaponAnimation() {\n    const clipName = this.activeClipName\n\n    if (this.meshWeapon) {\n      if (this.meshWeapon.activeAction) {\n        this.meshWeapon.activeAction.stop()\n        this.meshWeapon.activeAction = null\n      }\n\n      const action = this.mixer.clipAction(clipName, this.meshWeapon)\n\n      if (action) {\n        this.meshWeapon.activeAction = action.syncWith(this.meshBody.activeAction).play()\n      }\n    }\n  }\n\n  update(delta) {\n    if (this.mixer) this.mixer.update(delta)\n  }\n}\n\nexport { MD2Character }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1823, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/VolumeSlice.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/VolumeSlice.js"],"sourcesContent":["import { ClampToEdgeWrapping, DoubleSide, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, Texture } from 'three'\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\nclass VolumeSlice {\n  constructor(volume, index, axis) {\n    const slice = this\n    /**\n     * @member {Volume} volume The associated volume\n     */\n    this.volume = volume\n    /**\n     * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n     */\n    index = index || 0\n    Object.defineProperty(this, 'index', {\n      get: function () {\n        return index\n      },\n      set: function (value) {\n        index = value\n        slice.geometryNeedsUpdate = true\n        return index\n      },\n    })\n    /**\n     * @member {String} axis The normal axis\n     */\n    this.axis = axis || 'z'\n\n    /**\n     * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n     */\n    /**\n     * @member {CanvasRenderingContext2D} ctx Context of the canvas\n     */\n    this.canvas = document.createElement('canvas')\n    /**\n     * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n     */\n    /**\n     * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n     */\n    this.canvasBuffer = document.createElement('canvas')\n    this.updateGeometry()\n\n    const canvasMap = new Texture(this.canvas)\n    canvasMap.minFilter = LinearFilter\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping\n    if ('colorSpace' in canvasMap) canvasMap.colorSpace = 'srgb'\n    else canvasMap.encoding = 3001 // sRGBEncoding\n    const material = new MeshBasicMaterial({ map: canvasMap, side: DoubleSide, transparent: true })\n    /**\n     * @member {Mesh} mesh The mesh ready to get used in the scene\n     */\n    this.mesh = new Mesh(this.geometry, material)\n    this.mesh.matrixAutoUpdate = false\n    /**\n     * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n     */\n    this.geometryNeedsUpdate = true\n    this.repaint()\n\n    /**\n     * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n     */\n\n    /**\n     * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n     */\n\n    /**\n     * @member {Function} sliceAccess Function that allow the slice to access right data\n     * @see Volume.extractPerpendicularPlane\n     * @param {Number} i The first coordinate\n     * @param {Number} j The second coordinate\n     * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n     */\n  }\n\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry()\n    }\n\n    const iLength = this.iLength,\n      jLength = this.jLength,\n      sliceAccess = this.sliceAccess,\n      volume = this.volume,\n      canvas = this.canvasBuffer,\n      ctx = this.ctxBuffer\n\n    // get the imageData and pixel array from the canvas\n    const imgData = ctx.getImageData(0, 0, iLength, jLength)\n    const data = imgData.data\n    const volumeData = volume.data\n    const upperThreshold = volume.upperThreshold\n    const lowerThreshold = volume.lowerThreshold\n    const windowLow = volume.windowLow\n    const windowHigh = volume.windowHigh\n\n    // manipulate some pixel elements\n    let pixelCount = 0\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let label = volumeData[sliceAccess(i, j)]\n          label = label >= this.colorMap.length ? (label % this.colorMap.length) + 1 : label\n          const color = this.colorMap[label]\n          data[4 * pixelCount] = (color >> 24) & 0xff\n          data[4 * pixelCount + 1] = (color >> 16) & 0xff\n          data[4 * pixelCount + 2] = (color >> 8) & 0xff\n          data[4 * pixelCount + 3] = color & 0xff\n          pixelCount++\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)]\n          let alpha = 0xff\n          //apply threshold\n          alpha = upperThreshold >= value ? (lowerThreshold <= value ? alpha : 0) : 0\n          //apply window level\n          value = Math.floor((255 * (value - windowLow)) / (windowHigh - windowLow))\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0\n\n          data[4 * pixelCount] = value\n          data[4 * pixelCount + 1] = value\n          data[4 * pixelCount + 2] = value\n          data[4 * pixelCount + 3] = alpha\n          pixelCount++\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0)\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height)\n\n    this.mesh.material.map.needsUpdate = true\n  }\n\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index)\n    this.sliceAccess = extracted.sliceAccess\n    this.jLength = extracted.jLength\n    this.iLength = extracted.iLength\n    this.matrix = extracted.matrix\n\n    this.canvas.width = extracted.planeWidth\n    this.canvas.height = extracted.planeHeight\n    this.canvasBuffer.width = this.iLength\n    this.canvasBuffer.height = this.jLength\n    this.ctx = this.canvas.getContext('2d')\n    this.ctxBuffer = this.canvasBuffer.getContext('2d')\n\n    if (this.geometry) this.geometry.dispose() // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight)\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry\n      //reset mesh matrix\n      this.mesh.matrix.identity()\n      this.mesh.applyMatrix4(this.matrix)\n    }\n\n    this.geometryNeedsUpdate = false\n  }\n}\n\nexport { VolumeSlice }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1944, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/TubePainter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/TubePainter.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  DynamicDrawUsage,\n  Matrix4,\n  Mesh,\n  MeshStandardMaterial,\n  Vector3,\n} from 'three'\n\nfunction TubePainter() {\n  const BUFFER_SIZE = 1000000 * 3\n\n  const positions = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3)\n  positions.usage = DynamicDrawUsage\n\n  const normals = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3)\n  normals.usage = DynamicDrawUsage\n\n  const colors = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3)\n  colors.usage = DynamicDrawUsage\n\n  const geometry = new BufferGeometry()\n  geometry.setAttribute('position', positions)\n  geometry.setAttribute('normal', normals)\n  geometry.setAttribute('color', colors)\n  geometry.drawRange.count = 0\n\n  const material = new MeshStandardMaterial({\n    vertexColors: true,\n  })\n\n  const mesh = new Mesh(geometry, material)\n  mesh.frustumCulled = false\n\n  //\n\n  function getPoints(size) {\n    const PI2 = Math.PI * 2\n\n    const sides = 10\n    const array = []\n    const radius = 0.01 * size\n\n    for (let i = 0; i < sides; i++) {\n      const angle = (i / sides) * PI2\n      array.push(new Vector3(Math.sin(angle) * radius, Math.cos(angle) * radius, 0))\n    }\n\n    return array\n  }\n\n  //\n\n  const vector1 = new Vector3()\n  const vector2 = new Vector3()\n  const vector3 = new Vector3()\n  const vector4 = new Vector3()\n\n  const color = new Color(0xffffff)\n  let size = 1\n\n  function stroke(position1, position2, matrix1, matrix2) {\n    if (position1.distanceToSquared(position2) === 0) return\n\n    let count = geometry.drawRange.count\n\n    const points = getPoints(size)\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      const vertex1 = points[i]\n      const vertex2 = points[(i + 1) % il]\n\n      // positions\n\n      vector1.copy(vertex1).applyMatrix4(matrix2).add(position2)\n      vector2.copy(vertex2).applyMatrix4(matrix2).add(position2)\n      vector3.copy(vertex2).applyMatrix4(matrix1).add(position1)\n      vector4.copy(vertex1).applyMatrix4(matrix1).add(position1)\n\n      vector1.toArray(positions.array, (count + 0) * 3)\n      vector2.toArray(positions.array, (count + 1) * 3)\n      vector4.toArray(positions.array, (count + 2) * 3)\n\n      vector2.toArray(positions.array, (count + 3) * 3)\n      vector3.toArray(positions.array, (count + 4) * 3)\n      vector4.toArray(positions.array, (count + 5) * 3)\n\n      // normals\n\n      vector1.copy(vertex1).applyMatrix4(matrix2).normalize()\n      vector2.copy(vertex2).applyMatrix4(matrix2).normalize()\n      vector3.copy(vertex2).applyMatrix4(matrix1).normalize()\n      vector4.copy(vertex1).applyMatrix4(matrix1).normalize()\n\n      vector1.toArray(normals.array, (count + 0) * 3)\n      vector2.toArray(normals.array, (count + 1) * 3)\n      vector4.toArray(normals.array, (count + 2) * 3)\n\n      vector2.toArray(normals.array, (count + 3) * 3)\n      vector3.toArray(normals.array, (count + 4) * 3)\n      vector4.toArray(normals.array, (count + 5) * 3)\n\n      // colors\n\n      color.toArray(colors.array, (count + 0) * 3)\n      color.toArray(colors.array, (count + 1) * 3)\n      color.toArray(colors.array, (count + 2) * 3)\n\n      color.toArray(colors.array, (count + 3) * 3)\n      color.toArray(colors.array, (count + 4) * 3)\n      color.toArray(colors.array, (count + 5) * 3)\n\n      count += 6\n    }\n\n    geometry.drawRange.count = count\n  }\n\n  //\n\n  const up = new Vector3(0, 1, 0)\n\n  const point1 = new Vector3()\n  const point2 = new Vector3()\n\n  const matrix1 = new Matrix4()\n  const matrix2 = new Matrix4()\n\n  function moveTo(position) {\n    point1.copy(position)\n    matrix1.lookAt(point2, point1, up)\n\n    point2.copy(position)\n    matrix2.copy(matrix1)\n  }\n\n  function lineTo(position) {\n    point1.copy(position)\n    matrix1.lookAt(point2, point1, up)\n\n    stroke(point1, point2, matrix1, matrix2)\n\n    point2.copy(point1)\n    matrix2.copy(matrix1)\n  }\n\n  function setSize(value) {\n    size = value\n  }\n\n  //\n\n  let count = 0\n\n  function update() {\n    const start = count\n    const end = geometry.drawRange.count\n\n    if (start === end) return\n\n    positions.updateRange.offset = start * 3\n    positions.updateRange.count = (end - start) * 3\n    positions.needsUpdate = true\n\n    normals.updateRange.offset = start * 3\n    normals.updateRange.count = (end - start) * 3\n    normals.needsUpdate = true\n\n    colors.updateRange.offset = start * 3\n    colors.updateRange.count = (end - start) * 3\n    colors.needsUpdate = true\n\n    count = geometry.drawRange.count\n  }\n\n  return {\n    mesh: mesh,\n    moveTo: moveTo,\n    lineTo: lineTo,\n    setSize: setSize,\n    update: update,\n  }\n}\n\nexport { TubePainter }\n"],"names":["size","matrix1","matrix2","count"],"mappings":"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"}},
    {"offset": {"line": 2073, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/Volume.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/Volume.js"],"sourcesContent":["import { Matrix3, Matrix4, Vector3 } from 'three'\nimport { VolumeSlice } from '../misc/VolumeSlice'\n\n/**\n * This class had been written to handle the output of the NRRD loader.\n * It contains a volume of data and informations about it.\n * For now it only handles 3 dimensional data.\n * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.\n * @class\n * @param   {number}        xLength         Width of the volume\n * @param   {number}        yLength         Length of the volume\n * @param   {number}        zLength         Depth of the volume\n * @param   {string}        type            The type of data (uint8, uint16, ...)\n * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data\n */\nclass Volume {\n  constructor(xLength, yLength, zLength, type, arrayBuffer) {\n    if (xLength !== undefined) {\n      /**\n       * @member {number} xLength Width of the volume in the IJK coordinate system\n       */\n      this.xLength = Number(xLength) || 1\n      /**\n       * @member {number} yLength Height of the volume in the IJK coordinate system\n       */\n      this.yLength = Number(yLength) || 1\n      /**\n       * @member {number} zLength Depth of the volume in the IJK coordinate system\n       */\n      this.zLength = Number(zLength) || 1\n      /**\n       * @member {Array<string>} The order of the Axis dictated by the NRRD header\n       */\n      this.axisOrder = ['x', 'y', 'z']\n      /**\n       * @member {TypedArray} data Data of the volume\n       */\n\n      switch (type) {\n        case 'Uint8':\n        case 'uint8':\n        case 'uchar':\n        case 'unsigned char':\n        case 'uint8_t':\n          this.data = new Uint8Array(arrayBuffer)\n          break\n        case 'Int8':\n        case 'int8':\n        case 'signed char':\n        case 'int8_t':\n          this.data = new Int8Array(arrayBuffer)\n          break\n        case 'Int16':\n        case 'int16':\n        case 'short':\n        case 'short int':\n        case 'signed short':\n        case 'signed short int':\n        case 'int16_t':\n          this.data = new Int16Array(arrayBuffer)\n          break\n        case 'Uint16':\n        case 'uint16':\n        case 'ushort':\n        case 'unsigned short':\n        case 'unsigned short int':\n        case 'uint16_t':\n          this.data = new Uint16Array(arrayBuffer)\n          break\n        case 'Int32':\n        case 'int32':\n        case 'int':\n        case 'signed int':\n        case 'int32_t':\n          this.data = new Int32Array(arrayBuffer)\n          break\n        case 'Uint32':\n        case 'uint32':\n        case 'uint':\n        case 'unsigned int':\n        case 'uint32_t':\n          this.data = new Uint32Array(arrayBuffer)\n          break\n        case 'longlong':\n        case 'long long':\n        case 'long long int':\n        case 'signed long long':\n        case 'signed long long int':\n        case 'int64':\n        case 'int64_t':\n        case 'ulonglong':\n        case 'unsigned long long':\n        case 'unsigned long long int':\n        case 'uint64':\n        case 'uint64_t':\n          throw new Error('Error in Volume constructor : this type is not supported in JavaScript')\n          break\n        case 'Float32':\n        case 'float32':\n        case 'float':\n          this.data = new Float32Array(arrayBuffer)\n          break\n        case 'Float64':\n        case 'float64':\n        case 'double':\n          this.data = new Float64Array(arrayBuffer)\n          break\n        default:\n          this.data = new Uint8Array(arrayBuffer)\n      }\n\n      if (this.data.length !== this.xLength * this.yLength * this.zLength) {\n        throw new Error('Error in Volume constructor, lengths are not matching arrayBuffer size')\n      }\n    }\n\n    /**\n     * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system\n     */\n    this.spacing = [1, 1, 1]\n    /**\n     * @member {Array}  offset Offset of the volume in the RAS coordinate system\n     */\n    this.offset = [0, 0, 0]\n    /**\n     * @member {Martrix3} matrix The IJK to RAS matrix\n     */\n    this.matrix = new Matrix3()\n    this.matrix.identity()\n    /**\n     * @member {Martrix3} inverseMatrix The RAS to IJK matrix\n     */\n    /**\n     * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.\n     *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n     */\n    let lowerThreshold = -Infinity\n    Object.defineProperty(this, 'lowerThreshold', {\n      get: function () {\n        return lowerThreshold\n      },\n      set: function (value) {\n        lowerThreshold = value\n        this.sliceList.forEach(function (slice) {\n          slice.geometryNeedsUpdate = true\n        })\n      },\n    })\n    /**\n     * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.\n     *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n     */\n    let upperThreshold = Infinity\n    Object.defineProperty(this, 'upperThreshold', {\n      get: function () {\n        return upperThreshold\n      },\n      set: function (value) {\n        upperThreshold = value\n        this.sliceList.forEach(function (slice) {\n          slice.geometryNeedsUpdate = true\n        })\n      },\n    })\n\n    /**\n     * @member {Array} sliceList The list of all the slices associated to this volume\n     */\n    this.sliceList = []\n\n    /**\n     * @member {boolean} segmentation in segmentation mode, it can load 16-bits nrrds correctly\n     */\n    this.segmentation = false\n\n    /**\n     * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space\n     */\n  }\n\n  /**\n   * @member {Function} getData Shortcut for data[access(i,j,k)]\n   * @memberof Volume\n   * @param {number} i    First coordinate\n   * @param {number} j    Second coordinate\n   * @param {number} k    Third coordinate\n   * @returns {number}  value in the data array\n   */\n  getData(i, j, k) {\n    return this.data[k * this.xLength * this.yLength + j * this.xLength + i]\n  }\n\n  /**\n   * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system\n   * @memberof Volume\n   * @param {number} i    First coordinate\n   * @param {number} j    Second coordinate\n   * @param {number} k    Third coordinate\n   * @returns {number}  index\n   */\n  access(i, j, k) {\n    return k * this.xLength * this.yLength + j * this.xLength + i\n  }\n\n  /**\n   * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data\n   * @memberof Volume\n   * @param {number} index index of the voxel\n   * @returns {Array}  [x,y,z]\n   */\n  reverseAccess(index) {\n    const z = Math.floor(index / (this.yLength * this.xLength))\n    const y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength)\n    const x = index - z * this.yLength * this.xLength - y * this.xLength\n    return [x, y, z]\n  }\n\n  /**\n   * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced\n   * @memberof Volume\n   * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :\n   *                                 value of the voxel\n   *                                 index of the voxel\n   *                                 the data (TypedArray)\n   * @param {Object}   context    You can specify a context in which call the function, default if this Volume\n   * @returns {Volume}   this\n   */\n  map(functionToMap, context) {\n    const length = this.data.length\n    context = context || this\n\n    for (let i = 0; i < length; i++) {\n      this.data[i] = functionToMap.call(context, this.data[i], i, this.data)\n    }\n\n    return this\n  }\n\n  /**\n   * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n   * @memberof Volume\n   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n   * @param {number}            index the index of the slice\n   * @returns {Object} an object containing all the usefull information on the geometry of the slice\n   */\n  extractPerpendicularPlane(axis, RASIndex) {\n    let firstSpacing, secondSpacing, positionOffset, IJKIndex\n\n    const axisInIJK = new Vector3(),\n      firstDirection = new Vector3(),\n      secondDirection = new Vector3(),\n      planeMatrix = new Matrix4().identity(),\n      volume = this\n\n    const dimensions = new Vector3(this.xLength, this.yLength, this.zLength)\n\n    switch (axis) {\n      case 'x':\n        axisInIJK.set(1, 0, 0)\n        firstDirection.set(0, 0, -1)\n        secondDirection.set(0, -1, 0)\n        firstSpacing = this.spacing[this.axisOrder.indexOf('z')]\n        secondSpacing = this.spacing[this.axisOrder.indexOf('y')]\n        IJKIndex = new Vector3(RASIndex, 0, 0)\n\n        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2))\n        positionOffset = (volume.RASDimensions[0] - 1) / 2\n        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0))\n        break\n      case 'y':\n        axisInIJK.set(0, 1, 0)\n        firstDirection.set(1, 0, 0)\n        secondDirection.set(0, 0, 1)\n        firstSpacing = this.spacing[this.axisOrder.indexOf('x')]\n        secondSpacing = this.spacing[this.axisOrder.indexOf('z')]\n        IJKIndex = new Vector3(0, RASIndex, 0)\n\n        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2))\n        positionOffset = (volume.RASDimensions[1] - 1) / 2\n        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0))\n        break\n      case 'z':\n      default:\n        axisInIJK.set(0, 0, 1)\n        firstDirection.set(1, 0, 0)\n        secondDirection.set(0, -1, 0)\n        firstSpacing = this.spacing[this.axisOrder.indexOf('x')]\n        secondSpacing = this.spacing[this.axisOrder.indexOf('y')]\n        IJKIndex = new Vector3(0, 0, RASIndex)\n\n        positionOffset = (volume.RASDimensions[2] - 1) / 2\n        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset))\n        break\n    }\n\n    let iLength, jLength\n\n    if (!this.segmentation) {\n      firstDirection.applyMatrix4(volume.inverseMatrix).normalize()\n      secondDirection.applyMatrix4(volume.inverseMatrix).normalize()\n      axisInIJK.applyMatrix4(volume.inverseMatrix).normalize()\n    }\n    firstDirection.arglet = 'i'\n    secondDirection.arglet = 'j'\n    iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)))\n    jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)))\n    const planeWidth = Math.abs(iLength * firstSpacing)\n    const planeHeight = Math.abs(jLength * secondSpacing)\n\n    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)))\n    const base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]\n    const iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[0])) > 0.9\n    })\n    const jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[1])) > 0.9\n    })\n    const kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[2])) > 0.9\n    })\n\n    function sliceAccess(i, j) {\n      const si = iDirection === axisInIJK ? IJKIndex : iDirection.arglet === 'i' ? i : j\n      const sj = jDirection === axisInIJK ? IJKIndex : jDirection.arglet === 'i' ? i : j\n      const sk = kDirection === axisInIJK ? IJKIndex : kDirection.arglet === 'i' ? i : j\n\n      // invert indices if necessary\n\n      const accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si\n      const accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj\n      const accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk\n\n      return volume.access(accessI, accessJ, accessK)\n    }\n\n    return {\n      iLength: iLength,\n      jLength: jLength,\n      sliceAccess: sliceAccess,\n      matrix: planeMatrix,\n      planeWidth: planeWidth,\n      planeHeight: planeHeight,\n    }\n  }\n\n  /**\n   * @member {Function} extractSlice Returns a slice corresponding to the given axis and index\n   *                        The coordinate are given in the Right Anterior Superior coordinate format\n   * @memberof Volume\n   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n   * @param {number}            index the index of the slice\n   * @returns {VolumeSlice} the extracted slice\n   */\n  extractSlice(axis, index) {\n    const slice = new VolumeSlice(this, index, axis)\n    this.sliceList.push(slice)\n    return slice\n  }\n\n  /**\n   * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume\n   * @see VolumeSlice.repaint\n   * @memberof Volume\n   * @returns {Volume} this\n   */\n  repaintAllSlices() {\n    this.sliceList.forEach(function (slice) {\n      slice.repaint()\n    })\n\n    return this\n  }\n\n  /**\n   * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume\n   * @memberof Volume\n   * @returns {Array} [min,max]\n   */\n  computeMinMax() {\n    let min = Infinity\n    let max = -Infinity\n\n    // buffer the length\n    const datasize = this.data.length\n\n    let i = 0\n\n    for (i = 0; i < datasize; i++) {\n      if (!isNaN(this.data[i])) {\n        const value = this.data[i]\n        min = Math.min(min, value)\n        max = Math.max(max, value)\n      }\n    }\n\n    this.min = min\n    this.max = max\n\n    return [min, max]\n  }\n}\n\nexport { Volume }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2413, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/misc/ProgressiveLightmap.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/misc/ProgressiveLightmap.js"],"sourcesContent":["import {\n  Scene,\n  WebGLRenderTarget,\n  FloatType,\n  MeshBasicMaterial,\n  MeshPhongMaterial,\n  DoubleSide,\n  PlaneGeometry,\n  Mesh,\n} from 'three'\nimport potpack from 'potpack'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer\n    this.res = res\n    this.lightMapContainers = []\n    this.compiled = false\n    this.scene = new Scene()\n    this.scene.background = null\n    this.tinyTarget = new WebGLRenderTarget(1, 1)\n    this.buffer1Active = false\n    this.firstUpdate = true\n    this.warned = false\n\n    // Create the Progressive LightMap Texture\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, { type: format })\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, { type: format })\n\n    // Inject some spicy new logic into a standard phong material\n    this.uvMat = new MeshPhongMaterial()\n    this.uvMat.uniforms = {}\n    this.uvMat.onBeforeCompile = (shader) => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader =\n        '#define USE_LIGHTMAP\\n' +\n        shader.vertexShader.slice(0, -1) +\n        `\tgl_Position = vec4((${UV1} - 0.5) * 2.0, 1.0, 1.0); }`\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {')\n      shader.fragmentShader =\n        `varying vec2 v${UV1 === 'uv1' ? UV1 : 'Uv2'};\\n` +\n        shader.fragmentShader.slice(0, bodyStart) +\n        '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n        shader.fragmentShader.slice(bodyStart - 1, -1) +\n        `\\nvec3 texelOld = texture2D(previousShadowMap, v${UV1 === 'uv1' ? UV1 : 'Uv2'}).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture }\n      shader.uniforms.averagingWindow = { value: 100 }\n\n      this.uvMat.uniforms = shader.uniforms\n\n      // Set the new Shader to this\n      this.uvMat.userData.shader = shader\n\n      this.compiled = true\n    }\n  }\n\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = []\n    const padding = 3 / this.res\n\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]\n\n      // If this object is a light, simply add it to the internal scene\n      if (object.isLight) {\n        this.scene.attach(object)\n        continue\n      }\n\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!')\n        continue\n      }\n\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1)\n      }\n\n      // Apply the lightmap to the object\n      object.material.lightMap = this.progressiveLightMap2.texture\n      object.material.dithering = true\n      object.castShadow = true\n      object.receiveShadow = true\n      object.renderOrder = 1000 + ob\n\n      // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n      this.uv_boxes.push({ w: 1 + padding * 2, h: 1 + padding * 2, index: ob })\n\n      this.lightMapContainers.push({ basicMat: object.material, object: object })\n\n      this.compiled = false\n    }\n\n    // Pack the objects' lightmap UVs into the same global space\n    const dimensions = potpack(this.uv_boxes)\n    this.uv_boxes.forEach((box) => {\n      const uv1 = objects[box.index].geometry.getAttribute('uv').clone()\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h\n      }\n\n      objects[box.index].geometry.setAttribute(UV1, uv1)\n      objects[box.index].geometry.getAttribute(UV1).needsUpdate = true\n    })\n  }\n\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return\n    }\n\n    // Store the original Render Target\n    const oldTarget = this.renderer.getRenderTarget()\n\n    // The blurring plane applies blur to the seams of the lightmap\n    this.blurringPlane.visible = blurEdges\n\n    // Steal the Object3D from the real world to our special dimension\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent\n      this.scene.attach(this.lightMapContainers[l].object)\n    }\n\n    // Render once normally to initialize everything\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget) // Tiny for Speed\n      this.renderer.render(this.scene, camera)\n      this.firstUpdate = false\n    }\n\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = { value: blendWindow }\n      this.lightMapContainers[l].object.material = this.uvMat\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled\n      this.lightMapContainers[l].object.frustumCulled = false\n    }\n\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1\n\n    // Render the object's surface maps\n    this.renderer.setRenderTarget(activeMap)\n    this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture }\n    this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture }\n    this.buffer1Active = !this.buffer1Active\n    this.renderer.render(this.scene, camera)\n\n    // Restore the object's Real-time Material and add it back to the original world\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object)\n    }\n\n    // Restore the original Render Target\n    this.renderer.setRenderTarget(oldTarget)\n  }\n\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!')\n        this.warned = true\n      }\n\n      return\n    }\n\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide,\n      })\n      this.labelPlane = new PlaneGeometry(100, 100)\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial)\n      this.labelMesh.position.y = 250\n      this.lightMapContainers[0].object.parent.add(this.labelMesh)\n    }\n\n    if (position != undefined) {\n      this.labelMesh.position.copy(position)\n    }\n\n    this.labelMesh.visible = visible\n  }\n\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial()\n    blurMaterial.uniforms = {\n      previousShadowMap: { value: null },\n      pixelOffset: { value: 1.0 / res },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0,\n    }\n    blurMaterial.onBeforeCompile = (shader) => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader =\n        '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'\n\n      // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {')\n      shader.fragmentShader =\n        '#define USE_UV\\n' +\n        shader.fragmentShader.slice(0, bodyStart) +\n        '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n        shader.fragmentShader.slice(bodyStart - 1, -1) +\n        `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`\n\n      // Set the LightMap Accumulation Buffer\n      shader.uniforms.previousShadowMap = { value: lightMap.texture }\n      shader.uniforms.pixelOffset = { value: 0.5 / res }\n      blurMaterial.uniforms = shader.uniforms\n\n      // Set the new Shader to this\n      blurMaterial.userData.shader = shader\n\n      this.compiled = true\n    }\n\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial)\n    this.blurringPlane.name = 'Blurring Plane'\n    this.blurringPlane.frustumCulled = false\n    this.blurringPlane.renderOrder = 0\n    this.blurringPlane.material.depthWrite = false\n    this.scene.add(this.blurringPlane)\n  }\n}\n\nexport { ProgressiveLightMap }\n"],"names":[],"mappings":"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"}}]
}