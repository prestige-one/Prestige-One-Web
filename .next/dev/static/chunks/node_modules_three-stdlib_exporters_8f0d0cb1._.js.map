{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/GLTFExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/GLTFExporter.js"],"sourcesContent":["import {\n  REVISION,\n  BufferAttribute,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  MathUtils,\n  Matrix4,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  PropertyBinding,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  Texture,\n  CompressedTexture,\n  Vector3,\n  PlaneGeometry,\n  ShaderMaterial,\n  Uniform,\n  Mesh,\n  PerspectiveCamera,\n  WebGLRenderer,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer()\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)))\n  return `data:${blob.type || ''};base64,${data}`\n}\n\nlet _renderer\nlet fullscreenQuadGeometry\nlet fullscreenQuadMaterial\nlet fullscreenQuad\n\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1)\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: /* glsl */ `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `,\n      fragmentShader: /* glsl */ `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `,\n    })\n\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture\n  fullscreenQuadMaterial.defines.IS_SRGB =\n    'colorSpace' in texture ? texture.colorSpace === 'srgb' : texture.encoding === 3001\n  fullscreenQuadMaterial.needsUpdate = true\n\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial)\n    fullscreenQuad.frustrumCulled = false\n  }\n\n  const _camera = new PerspectiveCamera()\n  const _scene = new Scene()\n  _scene.add(fullscreenQuad)\n\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false })\n  }\n\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize))\n  renderer.clear()\n  renderer.render(_scene, _camera)\n\n  const readableTexture = new Texture(renderer.domElement)\n\n  readableTexture.minFilter = texture.minFilter\n  readableTexture.magFilter = texture.magFilter\n  readableTexture.wrapS = texture.wrapS\n  readableTexture.wrapT = texture.wrapT\n  readableTexture.name = texture.name\n\n  if (_renderer) {\n    _renderer.dispose()\n    _renderer = null\n  }\n\n  return readableTexture\n}\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    'byte',\n    'byte normalized',\n    'unsigned byte',\n    'unsigned byte normalized',\n    'short',\n    'short normalized',\n    'unsigned short',\n    'unsigned short normalized',\n  ],\n  NORMAL: ['byte normalized', 'short normalized'],\n  TANGENT: ['byte normalized', 'short normalized'],\n  TEXCOORD: ['byte', 'byte normalized', 'unsigned byte', 'short', 'short normalized', 'unsigned short'],\n}\n\nconst GLTFExporter = /* @__PURE__ */ (() => {\n  class GLTFExporter {\n    /**\n     * Static utility functions\n     */\n    static Utils = {\n      insertKeyframe: function (track, time) {\n        const tolerance = 0.001 // 1ms\n        const valueSize = track.getValueSize()\n\n        const times = new track.TimeBufferType(track.times.length + 1)\n        const values = new track.ValueBufferType(track.values.length + valueSize)\n        const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize))\n\n        let index\n\n        if (track.times.length === 0) {\n          times[0] = time\n\n          for (let i = 0; i < valueSize; i++) {\n            values[i] = 0\n          }\n\n          index = 0\n        } else if (time < track.times[0]) {\n          if (Math.abs(track.times[0] - time) < tolerance) return 0\n\n          times[0] = time\n          times.set(track.times, 1)\n\n          values.set(interpolant.evaluate(time), 0)\n          values.set(track.values, valueSize)\n\n          index = 0\n        } else if (time > track.times[track.times.length - 1]) {\n          if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n            return track.times.length - 1\n          }\n\n          times[times.length - 1] = time\n          times.set(track.times, 0)\n\n          values.set(track.values, 0)\n          values.set(interpolant.evaluate(time), track.values.length)\n\n          index = times.length - 1\n        } else {\n          for (let i = 0; i < track.times.length; i++) {\n            if (Math.abs(track.times[i] - time) < tolerance) return i\n\n            if (track.times[i] < time && track.times[i + 1] > time) {\n              times.set(track.times.slice(0, i + 1), 0)\n              times[i + 1] = time\n              times.set(track.times.slice(i + 1), i + 2)\n\n              values.set(track.values.slice(0, (i + 1) * valueSize), 0)\n              values.set(interpolant.evaluate(time), (i + 1) * valueSize)\n              values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize)\n\n              index = i + 1\n\n              break\n            }\n          }\n        }\n\n        track.times = times\n        track.values = values\n\n        return index\n      },\n\n      mergeMorphTargetTracks: function (clip, root) {\n        const tracks = []\n        const mergedTracks = {}\n        const sourceTracks = clip.tracks\n\n        for (let i = 0; i < sourceTracks.length; ++i) {\n          let sourceTrack = sourceTracks[i]\n          const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name)\n          const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName)\n\n          if (\n            sourceTrackBinding.propertyName !== 'morphTargetInfluences' ||\n            sourceTrackBinding.propertyIndex === undefined\n          ) {\n            // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n            tracks.push(sourceTrack)\n            continue\n          }\n\n          if (\n            sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete &&\n            sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear\n          ) {\n            if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n              // This should never happen, because glTF morph target animations\n              // affect all targets already.\n              throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.')\n            }\n\n            console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.')\n\n            sourceTrack = sourceTrack.clone()\n            sourceTrack.setInterpolation(InterpolateLinear)\n          }\n\n          const targetCount = sourceTrackNode.morphTargetInfluences.length\n          const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex]\n\n          if (targetIndex === undefined) {\n            throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex)\n          }\n\n          let mergedTrack\n\n          // If this is the first time we've seen this object, create a new\n          // track to store merged keyframe data for each morph target.\n          if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n            mergedTrack = sourceTrack.clone()\n\n            const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length)\n\n            for (let j = 0; j < mergedTrack.times.length; j++) {\n              values[j * targetCount + targetIndex] = mergedTrack.values[j]\n            }\n\n            // We need to take into consideration the intended target node\n            // of our original un-merged morphTarget animation.\n            mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences'\n            mergedTrack.values = values\n\n            mergedTracks[sourceTrackNode.uuid] = mergedTrack\n            tracks.push(mergedTrack)\n\n            continue\n          }\n\n          const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1))\n\n          mergedTrack = mergedTracks[sourceTrackNode.uuid]\n\n          // For every existing keyframe of the merged track, write a (possibly\n          // interpolated) value from the source track.\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j])\n          }\n\n          // For every existing keyframe of the source track, write a (possibly\n          // new) keyframe to the merged track. Values from the previous loop may\n          // be written again, but keyframes are de-duplicated.\n          for (let j = 0; j < sourceTrack.times.length; j++) {\n            const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j])\n            mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j]\n          }\n        }\n\n        clip.tracks = tracks\n\n        return clip\n      },\n    }\n\n    constructor() {\n      this.pluginCallbacks = []\n\n      this.register(function (writer) {\n        return new GLTFLightExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsUnlitExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsTransmissionExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsVolumeExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsIorExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsSpecularExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsClearcoatExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsIridescenceExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsSheenExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsAnisotropyExtension(writer)\n      })\n\n      this.register(function (writer) {\n        return new GLTFMaterialsEmissiveStrengthExtension(writer)\n      })\n    }\n\n    register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback)\n      }\n\n      return this\n    }\n\n    unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n      }\n\n      return this\n    }\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n    parse(input, onDone, onError, options) {\n      const writer = new GLTFWriter()\n      const plugins = []\n\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer))\n      }\n\n      writer.setPlugins(plugins)\n      writer.write(input, onDone, options).catch(onError)\n    }\n\n    parseAsync(input, options) {\n      const scope = this\n\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options)\n      })\n    }\n  }\n\n  return GLTFExporter\n})()\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497,\n}\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization'\n\nconst THREE_TO_WEBGL = {}\n\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights',\n}\n\nconst DEFAULT_SPECULAR_COLOR = /* @__PURE__ */ new Color()\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12\nconst GLB_HEADER_MAGIC = 0x46546c67\nconst GLB_VERSION = 2\n\nconst GLB_CHUNK_PREFIX_BYTES = 8\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return (\n    array1.length === array2.length &&\n    array1.every(function (element, index) {\n      return element === array2[index]\n    })\n  )\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY),\n  }\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a]\n      } else {\n        if (a === 0) value = attribute.getX(i)\n        else if (a === 1) value = attribute.getY(i)\n        else if (a === 2) value = attribute.getZ(i)\n        else if (a === 3) value = attribute.getW(i)\n\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array)\n        }\n      }\n\n      output.min[a] = Math.min(output.min[a], value)\n      output.max[a] = Math.max(output.max[a], value)\n    }\n  }\n\n  return output\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength)\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength)\n    array.set(new Uint8Array(arrayBuffer))\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte\n      }\n    }\n\n    return array.buffer\n  }\n\n  return arrayBuffer\n}\n\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1)\n  }\n\n  return document.createElement('canvas')\n}\n\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType))\n  }\n\n  let quality\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8\n  }\n\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality,\n  })\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = []\n\n    this.options = {}\n    this.pending = []\n    this.buffers = []\n\n    this.byteOffset = 0\n    this.buffers = []\n    this.nodeMap = new Map()\n    this.skins = []\n\n    this.extensionsUsed = {}\n    this.extensionsRequired = {}\n\n    this.uids = new Map()\n    this.uid = 0\n\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter',\n      },\n    }\n\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map(),\n    }\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false,\n      },\n      options,\n    )\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true\n    }\n\n    this.processInput(input)\n\n    await Promise.all(this.pending)\n\n    const writer = this\n    const buffers = writer.buffers\n    const json = writer.json\n    options = writer.options\n\n    const extensionsUsed = writer.extensionsUsed\n    const extensionsRequired = writer.extensionsRequired\n\n    // Merge buffers.\n    const blob = new Blob(buffers, { type: 'application/octet-stream' })\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed)\n    const extensionsRequiredList = Object.keys(extensionsRequired)\n\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size\n\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      blob.arrayBuffer().then((result) => {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(result)\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true)\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true)\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20)\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true)\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true)\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES)\n        const headerView = new DataView(header)\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true)\n        headerView.setUint32(4, GLB_VERSION, true)\n        const totalByteLength =\n          GLB_HEADER_BYTES +\n          jsonChunkPrefix.byteLength +\n          jsonChunk.byteLength +\n          binaryChunkPrefix.byteLength +\n          binaryChunk.byteLength\n        headerView.setUint32(8, totalByteLength, true)\n\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream',\n        })\n\n        glbBlob.arrayBuffer().then(onDone)\n      })\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then((uri) => {\n          json.buffers[0].uri = uri\n          onDone(json)\n        })\n      } else {\n        onDone(json)\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return\n\n    const options = this.options\n    const extensionsUsed = this.extensionsUsed\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData))\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {}\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName]\n          extensionsUsed[extensionName] = true\n        }\n\n        delete json.gltfExtensions\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" +\n          object.name +\n          \"' \" +\n          \"won't be serialized because of JSON.stringify error - \" +\n          error.message,\n      )\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map()\n\n      uids.set(true, this.uid++)\n      uids.set(false, this.uid++)\n\n      this.uids.set(attribute, uids)\n    }\n\n    const uids = this.uids.get(attribute)\n\n    return uids.get(isRelativeCopy)\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return false\n\n    const v = new Vector3()\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false\n    }\n\n    return true\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal)\n\n    const attribute = normal.clone()\n    const v = new Vector3()\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i)\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0)\n      } else {\n        v.normalize()\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z)\n    }\n\n    cache.attributesNormalized.set(normal, attribute)\n\n    return attribute\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false\n    const transformDef = {}\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray()\n      didTransform = true\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation\n      didTransform = true\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray()\n      didTransform = true\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {}\n      mapDef.extensions['KHR_texture_transform'] = transformDef\n      this.extensionsUsed['KHR_texture_transform'] = true\n    }\n  }\n\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap\n\n    function getEncodingConversion(map) {\n      if ('colorSpace' in map ? map.colorSpace === 'srgb' : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)\n        }\n      }\n\n      return function LinearToLinear(c) {\n        return c\n      }\n    }\n\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.')\n\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap)\n    }\n\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap)\n    }\n\n    const metalness = metalnessMap ? metalnessMap.image : null\n    const roughness = roughnessMap ? roughnessMap.image : null\n\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0)\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0)\n\n    const canvas = getCanvas()\n    canvas.width = width\n    canvas.height = height\n\n    const context = canvas.getContext('2d')\n    context.fillStyle = '#00ffff'\n    context.fillRect(0, 0, width, height)\n\n    const composite = context.getImageData(0, 0, width, height)\n\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(metalnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(roughnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    context.putImageData(composite, 0, 0)\n\n    //\n\n    const reference = metalnessMap || roughnessMap\n\n    const texture = reference.clone()\n\n    // TODO Use new Source() instead?\n    texture.source = new Texture(canvas).source\n    if ('colorSpace' in texture) texture.colorSpace = ''\n    else texture.encoding = 3000\n    texture.channel = (metalnessMap || roughnessMap).channel\n\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn('THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.')\n    }\n\n    return texture\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json\n    const buffers = this.buffers\n\n    if (!json.buffers) json.buffers = [{ byteLength: 0 }]\n\n    // All buffers are merged before export.\n    buffers.push(buffer)\n\n    return 0\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize\n\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1\n\n        break\n\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2\n\n        break\n\n      default:\n        componentSize = 4\n    }\n\n    let byteStride = attribute.itemSize * componentSize\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n      // inside a bufferView\n      byteStride = Math.ceil(byteStride / 4) * 4\n    }\n    const byteLength = getPaddedBufferSize(count * byteStride)\n    const dataView = new DataView(new ArrayBuffer(byteLength))\n    let offset = 0\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a]\n        } else {\n          if (a === 0) value = attribute.getX(i)\n          else if (a === 1) value = attribute.getY(i)\n          else if (a === 2) value = attribute.getZ(i)\n          else if (a === 3) value = attribute.getW(i)\n\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array)\n          }\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value)\n        }\n\n        offset += componentSize\n      }\n      if (offset % byteStride !== 0) {\n        offset += byteStride - (offset % byteStride)\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength,\n    }\n\n    if (target !== undefined) bufferViewDef.target = target\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = byteStride\n    }\n\n    this.byteOffset += byteLength\n\n    json.bufferViews.push(bufferViewDef)\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0,\n    }\n\n    return output\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this\n    const json = writer.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    return blob.arrayBuffer().then((result) => {\n      const buffer = getPaddedArrayBuffer(result)\n\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength,\n      }\n\n      writer.byteOffset += buffer.byteLength\n      return json.bufferViews.push(bufferViewDef) - 1\n    })\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json\n\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      9: 'MAT3',\n      16: 'MAT4',\n    }\n\n    let componentType\n\n    // Detect the component type of the attribute array\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE\n    } else {\n      throw new Error(\n        'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name,\n      )\n    }\n\n    if (start === undefined) start = 0\n    if (count === undefined) count = attribute.count\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null\n\n    const minMax = getMinMax(attribute, start, count)\n    let bufferViewTarget\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget =\n        attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER\n    }\n\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget)\n\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize],\n    }\n\n    if (attribute.normalized === true) accessorDef.normalized = true\n    if (!json.accessors) json.accessors = []\n\n    return json.accessors.push(accessorDef) - 1\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    if (image !== null) {\n      const writer = this\n      const cache = writer.cache\n      const json = writer.json\n      const options = writer.options\n      const pending = writer.pending\n\n      if (!cache.images.has(image)) cache.images.set(image, {})\n\n      const cachedImages = cache.images.get(image)\n\n      const key = mimeType + ':flipY/' + flipY.toString()\n\n      if (cachedImages[key] !== undefined) return cachedImages[key]\n\n      if (!json.images) json.images = []\n\n      const imageDef = { mimeType: mimeType }\n\n      const canvas = getCanvas()\n\n      canvas.width = Math.min(image.width, options.maxTextureSize)\n      canvas.height = Math.min(image.height, options.maxTextureSize)\n\n      const ctx = canvas.getContext('2d')\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height)\n        ctx.scale(1, -1)\n      }\n\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.', format)\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image)\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4)\n\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0]\n          data[i + 1] = image.data[i + 1]\n          data[i + 2] = image.data[i + 2]\n          data[i + 3] = image.data[i + 3]\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0)\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height)\n      }\n\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType)\n            .then((blob) => writer.processBufferViewImage(blob))\n            .then((bufferViewIndex) => {\n              imageDef.bufferView = bufferViewIndex\n            }),\n        )\n      } else {\n        if (canvas.toDataURL !== undefined) {\n          imageDef.uri = canvas.toDataURL(mimeType)\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType)\n              .then(readAsDataURL)\n              .then((uri) => {\n                imageDef.uri = uri\n              }),\n          )\n        }\n      }\n\n      const index = json.images.push(imageDef) - 1\n      cachedImages[key] = index\n      return index\n    } else {\n      throw new Error('THREE.GLTFExporter: No valid image data found. Unable to process texture.')\n    }\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json\n\n    if (!json.samplers) json.samplers = []\n\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT],\n    }\n\n    return json.samplers.push(samplerDef) - 1\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this\n    const options = writer.options\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.textures.has(map)) return cache.textures.get(map)\n\n    if (!json.textures) json.textures = []\n\n    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize)\n    }\n\n    let mimeType = map.userData.mimeType\n\n    if (mimeType === 'image/webp') mimeType = 'image/png'\n\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType),\n    }\n\n    if (map.name) textureDef.name = map.name\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef)\n    })\n\n    const index = json.textures.push(textureDef) - 1\n    cache.textures.set(map, index)\n    return index\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.materials.has(material)) return cache.materials.get(material)\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.')\n      return null\n    }\n\n    if (!json.materials) json.materials = []\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = { pbrMetallicRoughness: {} }\n\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.')\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity])\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap)\n\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel,\n      }\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture)\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef\n    }\n\n    // pbrMetallicRoughness.baseColorTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel,\n      }\n      this.applyTextureTransform(baseColorMapDef, material.map)\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef\n    }\n\n    if (material.emissive) {\n      const emissive = material.emissive\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b)\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray()\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel,\n        }\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap)\n        materialDef.emissiveTexture = emissiveMapDef\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel,\n      }\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap)\n      materialDef.normalTexture = normalMapDef\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel,\n      }\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap)\n      materialDef.occlusionTexture = occlusionMapDef\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND'\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK'\n        materialDef.alphaCutoff = material.alphaTest\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true\n    if (material.name !== '') materialDef.name = material.name\n\n    this.serializeUserData(material, materialDef)\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef)\n    })\n\n    const index = json.materials.push(materialDef) - 1\n    cache.materials.set(material, index)\n    return index\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache\n    const json = this.json\n\n    const meshCacheKeyParts = [mesh.geometry.uuid]\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid)\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid)\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':')\n\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey)\n\n    const geometry = mesh.geometry\n\n    let mode\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES\n    }\n\n    const meshDef = {}\n    const attributes = {}\n    const primitives = []\n    const targets = []\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      ...(version >= 152\n        ? {\n            uv: 'TEXCOORD_0',\n            uv1: 'TEXCOORD_1',\n            uv2: 'TEXCOORD_2',\n            uv3: 'TEXCOORD_3',\n          }\n        : {\n            uv: 'TEXCOORD_0',\n            uv2: 'TEXCOORD_1',\n          }),\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0',\n    }\n\n    const originalNormal = geometry.getAttribute('normal')\n\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.')\n\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal))\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue\n\n      const attribute = geometry.attributes[attributeName]\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase()\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/\n\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute))\n        continue\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null\n      const array = attribute.array\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.')\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized)\n      }\n\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry)\n\n      if (accessor !== null) {\n        if (!attributeName.startsWith('_')) {\n          this.detectMeshQuantization(attributeName, attribute)\n        }\n\n        attributes[attributeName] = accessor\n        cache.attributes.set(this.getUID(attribute), accessor)\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal)\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = []\n      const targetNames = []\n      const reverseDictionary = {}\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {}\n        let warned = false\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.')\n              warned = true\n            }\n\n            continue\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i]\n          const gltfAttributeName = attributeName.toUpperCase()\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName]\n\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true))\n            continue\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone()\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j))\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j))\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j))\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j))\n              }\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry)\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName])\n        }\n\n        targets.push(target)\n\n        weights.push(mesh.morphTargetInfluences[i])\n\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i])\n      }\n\n      meshDef.weights = weights\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {}\n        meshDef.extras.targetNames = targetNames\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material)\n\n    if (isMultiMaterial && geometry.groups.length === 0) return null\n\n    const materials = isMultiMaterial ? mesh.material : [mesh.material]\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }]\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes,\n      }\n\n      this.serializeUserData(geometry, primitive)\n\n      if (targets.length > 0) primitive.targets = targets\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index)\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey)\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count)\n          cache.attributes.set(cacheKey, primitive.indices)\n        }\n\n        if (primitive.indices === null) delete primitive.indices\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex])\n\n      if (material !== null) primitive.material = material\n\n      primitives.push(primitive)\n    }\n\n    meshDef.primitives = primitives\n\n    if (!json.meshes) json.meshes = []\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef)\n    })\n\n    const index = json.meshes.push(meshDef) - 1\n    cache.meshes.set(meshCacheKey, index)\n    return index\n  }\n\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return\n\n    let attrType = undefined\n\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = 'byte'\n\n        break\n\n      case Uint8Array:\n        attrType = 'unsigned byte'\n\n        break\n\n      case Int16Array:\n        attrType = 'short'\n\n        break\n\n      case Uint16Array:\n        attrType = 'unsigned short'\n\n        break\n\n      default:\n        return\n    }\n\n    if (attribute.normalized) attrType += ' normalized'\n\n    const attrNamePrefix = attributeName.split('_', 1)[0]\n\n    if (\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] &&\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)\n    ) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true\n    }\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json\n\n    if (!json.cameras) json.cameras = []\n\n    const isOrtho = camera.isOrthographicCamera\n\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective',\n    }\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type\n\n    return json.cameras.push(cameraDef) - 1\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    if (!json.animations) json.animations = []\n\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root)\n\n    const tracks = clip.tracks\n    const channels = []\n    const samplers = []\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i]\n      const trackBinding = PropertyBinding.parseTrackName(track.name)\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName)\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName]\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex)\n        } else {\n          trackNode = undefined\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name)\n        return null\n      }\n\n      const inputItemSize = 1\n      let outputItemSize = track.values.length / track.times.length\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length\n      }\n\n      let interpolation\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE'\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP'\n      } else {\n        interpolation = 'LINEAR'\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation,\n      })\n\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty,\n        },\n      })\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels,\n    })\n\n    return json.animations.length - 1\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    const node = json.nodes[nodeMap.get(object)]\n\n    const skeleton = object.skeleton\n\n    if (skeleton === undefined) return null\n\n    const rootJoint = object.skeleton.bones[0]\n\n    if (rootJoint === undefined) return null\n\n    const joints = []\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16)\n    const temporaryBoneInverse = new Matrix4()\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]))\n      temporaryBoneInverse.copy(skeleton.boneInverses[i])\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16)\n    }\n\n    if (json.skins === undefined) json.skins = []\n\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint),\n    })\n\n    const skinIndex = (node.skin = json.skins.length - 1)\n\n    return skinIndex\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json\n    const options = this.options\n    const nodeMap = this.nodeMap\n\n    if (!json.nodes) json.nodes = []\n\n    const nodeDef = {}\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray()\n      const position = object.position.toArray()\n      const scale = object.scale.toArray()\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix()\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name)\n\n    this.serializeUserData(object, nodeDef)\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object)\n\n      if (meshIndex !== null) nodeDef.mesh = meshIndex\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object)\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object)\n\n    if (object.children.length > 0) {\n      const children = []\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i]\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child)\n\n          if (nodeIndex !== null) children.push(nodeIndex)\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef)\n    })\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1\n    nodeMap.set(object, nodeIndex)\n    return nodeIndex\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json\n    const options = this.options\n\n    if (!json.scenes) {\n      json.scenes = []\n      json.scene = 0\n    }\n\n    const sceneDef = {}\n\n    if (scene.name !== '') sceneDef.name = scene.name\n\n    json.scenes.push(sceneDef)\n\n    const nodes = []\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i]\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child)\n\n        if (nodeIndex !== null) nodes.push(nodeIndex)\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes\n\n    this.serializeUserData(scene, sceneDef)\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene()\n    scene.name = 'AuxScene'\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i])\n    }\n\n    this.processScene(scene)\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options\n\n    input = input instanceof Array ? input : [input]\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input)\n    })\n\n    const objectsWithoutScene = []\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i])\n      } else {\n        objectsWithoutScene.push(input[i])\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene)\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i])\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0])\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input)\n    })\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i])\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_lights_punctual'\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return\n\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light)\n      return\n    }\n\n    const writer = this.writer\n    const json = writer.json\n    const extensionsUsed = writer.extensionsUsed\n\n    const lightDef = {}\n\n    if (light.name) lightDef.name = light.name\n\n    lightDef.color = light.color.toArray()\n\n    lightDef.intensity = light.intensity\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional'\n    } else if (light.isPointLight) {\n      lightDef.type = 'point'\n\n      if (light.distance > 0) lightDef.range = light.distance\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot'\n\n      if (light.distance > 0) lightDef.range = light.distance\n\n      lightDef.spot = {}\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0\n      lightDef.spot.outerConeAngle = light.angle\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn(\n        'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.',\n      )\n    }\n\n    if (\n      light.target &&\n      (light.target.parent !== light ||\n        light.target.position.x !== 0 ||\n        light.target.position.y !== 0 ||\n        light.target.position.z !== -1)\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Light direction may be lost. For best results, ' +\n          'make light.target a child of the light with position 0,0,-1.',\n      )\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {}\n      json.extensions[this.name] = { lights: [] }\n      extensionsUsed[this.name] = true\n    }\n\n    const lights = json.extensions[this.name].lights\n    lights.push(lightDef)\n\n    nodeDef.extensions = nodeDef.extensions || {}\n    nodeDef.extensions[this.name] = { light: lights.length - 1 }\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_unlit'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = {}\n\n    extensionsUsed[this.name] = true\n\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_clearcoat'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.clearcoatFactor = material.clearcoat\n\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap)\n      extensionDef.clearcoatTexture = clearcoatMapDef\n    }\n\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness\n\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap)\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef\n    }\n\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap)\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_iridescence'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.iridescenceFactor = material.iridescence\n\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap)\n      extensionDef.iridescenceTexture = iridescenceMapDef\n    }\n\n    extensionDef.iridescenceIor = material.iridescenceIOR\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0]\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1]\n\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap)\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_transmission'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.transmissionFactor = material.transmission\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel,\n      }\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap)\n      extensionDef.transmissionTexture = transmissionMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_volume'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.thicknessFactor = material.thickness\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel,\n      }\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap)\n      extensionDef.thicknessTexture = thicknessMapDef\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance\n    extensionDef.attenuationColor = material.attenuationColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_ior'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.ior = material.ior\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_specular'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (\n      !material.isMeshPhysicalMaterial ||\n      (material.specularIntensity === 1.0 &&\n        material.specularColor.equals(DEFAULT_SPECULAR_COLOR) &&\n        !material.specularIntensityMap &&\n        !material.specularColorTexture)\n    )\n      return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel,\n      }\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap)\n      extensionDef.specularTexture = specularIntensityMapDef\n    }\n\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel,\n      }\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap)\n      extensionDef.specularColorTexture = specularColorMapDef\n    }\n\n    extensionDef.specularFactor = material.specularIntensity\n    extensionDef.specularColorFactor = material.specularColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_sheen'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap)\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef\n    }\n\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel,\n      }\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap)\n      extensionDef.sheenColorTexture = sheenColorMapDef\n    }\n\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness\n    extensionDef.sheenColorFactor = material.sheenColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_anisotropy'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) }\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap)\n      extensionDef.anisotropyTexture = anisotropyMapDef\n    }\n\n    extensionDef.anisotropyStrength = material.anisotropy\n    extensionDef.anisotropyRotation = material.anisotropyRotation\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_emissive_strength'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.emissiveStrength = material.emissiveIntensity\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\nexport { GLTFExporter }\n"],"names":["GLTFExporter","uids","nodeIndex"],"mappings":"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"}},
    {"offset": {"line": 1897, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/USDZExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/USDZExporter.ts"],"sourcesContent":["import { zipSync, strToU8, Zippable } from 'fflate'\nimport {\n  BufferGeometry,\n  Color,\n  Matrix4,\n  Mesh,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  Object3D,\n  Texture,\n  Vector2,\n} from 'three'\nimport { Nullable } from '../types/utils'\n\ntype MaterialRepresentaion = MeshStandardMaterial | MeshPhysicalMaterial\n\nclass USDZExporter {\n  private readonly PRECISION = 7\n\n  private materials: { [key: string]: MaterialRepresentaion }\n  private textures: { [key: string]: Texture }\n\n  private files: Nullable<Zippable>\n\n  constructor() {\n    this.materials = {}\n    this.textures = {}\n\n    this.files = {}\n  }\n\n  public async parse(scene: Object3D): Promise<Uint8Array> {\n    const modelFileName = 'model.usda'\n\n    // model file should be first in USDZ archive so we init it here\n    this.files[modelFileName] = null\n\n    let output: string | null = this.buildHeader()\n\n    scene.traverseVisible((object) => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry: BufferGeometry = object.geometry\n        const material: MaterialRepresentaion = object.material\n\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd'\n\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry)\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject)\n        }\n\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material\n        }\n\n        output += this.buildXform(object, geometry, material)\n      }\n    })\n\n    output += this.buildMaterials(this.materials)\n\n    this.files[modelFileName] = strToU8(output)\n    output = null\n\n    for (const id in this.textures) {\n      const texture = this.textures[id]\n      const color = id.split('_')[1]\n      const isRGBA = texture.format === 1023\n\n      const canvas = this.imageToCanvas(texture.image, color)\n      const blob = await new Promise<Blob | null>((resolve) =>\n        canvas?.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1),\n      )\n\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(await blob.arrayBuffer())\n      }\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0\n\n    for (const filename in this.files) {\n      const file = this.files[filename]\n      const headerSize = 34 + filename.length\n\n      offset += headerSize\n\n      const offsetMod64 = offset & 63\n\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64\n        const padding = new Uint8Array(padLength)\n\n        this.files[filename] = [file, { extra: { 12345: padding } }]\n      }\n\n      if (file && typeof file.length === 'number') {\n        offset = file.length\n      }\n    }\n\n    return zipSync(this.files as Zippable, { level: 0 })\n  }\n\n  private imageToCanvas(\n    image: HTMLImageElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap,\n    color: string,\n  ): HTMLCanvasElement | undefined {\n    if (\n      (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||\n      (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas) ||\n      (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n    ) {\n      const scale = 1024 / Math.max(image.width, image.height)\n\n      const canvas = document.createElement('canvas')\n      canvas.width = image.width * Math.min(1, scale)\n      canvas.height = image.height * Math.min(1, scale)\n\n      const context = canvas.getContext('2d')\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height)\n\n      if (color !== undefined) {\n        const hex = parseInt(color, 16)\n\n        const r = ((hex >> 16) & 255) / 255\n        const g = ((hex >> 8) & 255) / 255\n        const b = (hex & 255) / 255\n\n        const imagedata = context?.getImageData(0, 0, canvas.width, canvas.height)\n        if (imagedata) {\n          const data = imagedata?.data\n\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r\n            data[i + 1] = data[i + 1] * g\n            data[i + 2] = data[i + 2] * b\n          }\n\n          context?.putImageData(imagedata, 0, 0)\n        }\n      }\n\n      return canvas\n    }\n  }\n\n  private buildHeader(): string {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`\n  }\n\n  private buildUSDFileAsString(dataToInsert: string): Uint8Array {\n    let output = this.buildHeader()\n    output += dataToInsert\n    return strToU8(output)\n  }\n\n  // Xform\n  private buildXform(object: Object3D, geometry: BufferGeometry, material: MaterialRepresentaion): string {\n    const name = 'Object_' + object.id\n    const transform = this.buildMatrix(object.matrixWorld)\n\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn('THREE.USDZExporter: USDZ does not support negative scales', object)\n    }\n\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`\n  }\n\n  private buildMatrix(matrix: Matrix4): string {\n    const array = matrix.elements\n\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(\n      array,\n      8,\n    )}, ${this.buildMatrixRow(array, 12)} )`\n  }\n\n  private buildMatrixRow(array: number[], offset: number): string {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`\n  }\n\n  // Mesh\n  private buildMeshObject(geometry: BufferGeometry): string {\n    const mesh = this.buildMesh(geometry)\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`\n  }\n\n  private buildMesh(geometry: BufferGeometry): string {\n    const name = 'Geometry'\n    const attributes = geometry.attributes\n    const count = attributes.position.count\n\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`\n  }\n\n  private buildMeshVertexCount(geometry: BufferGeometry): string {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count\n\n    return Array(count / 3)\n      .fill(3)\n      .join(', ')\n  }\n\n  private buildMeshVertexIndices(geometry: BufferGeometry): string {\n    if (geometry.index !== null) {\n      // @ts-ignore\n      return geometry.index.array.join(', ')\n    }\n\n    const array: number[] = []\n    const length = geometry.attributes.position.count\n\n    for (let i = 0; i < length; i++) {\n      array.push(i)\n    }\n\n    return array.join(', ')\n  }\n\n  private buildVector3Array(attribute: BufferGeometry['attributes'][number], count: number): string {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: Normals missing.')\n      return Array(count).fill('(0, 0, 0)').join(', ')\n    }\n\n    const array: string[] = []\n    const data = attribute.array\n\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(\n        `(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[\n          i + 2\n        ].toPrecision(this.PRECISION)})`,\n      )\n    }\n\n    return array.join(', ')\n  }\n\n  private buildVector2Array(attribute: BufferGeometry['attributes'][number], count: number): string {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: UVs missing.')\n      return Array(count).fill('(0, 0)').join(', ')\n    }\n\n    const array: string[] = []\n    const data = attribute.array\n\n    for (let i = 0; i < data.length; i += 2) {\n      // @ts-ignore\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`)\n    }\n\n    return array.join(', ')\n  }\n\n  // Materials\n  private buildMaterials(materials: USDZExporter['materials']): string {\n    const array: string[] = []\n\n    for (const uuid in materials) {\n      const material = materials[uuid]\n\n      array.push(this.buildMaterial(material))\n    }\n\n    return `def \"Materials\"\n{\n${array.join('')}\n}\n`\n  }\n\n  private buildMaterial(material: MaterialRepresentaion): string {\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n    const pad = '            '\n    const inputs = []\n    const samplers = []\n\n    if (material.map !== null) {\n      inputs.push(\n        `${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`,\n      )\n\n      // Include alpha input\n      if (material.transparent || material.alphaTest > 0.0) {\n        inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n      }\n\n      // Check if alpha test is bigger than minimum of 0.01, if not and it is transparent still apply a 0.01 alpha clip in order to remove white blur in transparent place.\n      if (material.alphaTest > 0.01) {\n        inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);\n      }\n      else if(material.transparent || material.alphaTest > 0.0) {\n        inputs.push(`${pad}float inputs:opacityThreshold = 0.01`);\n      }\n      \n      samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color))\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`)\n    }\n\n    if (material.emissiveMap !== null) {\n      inputs.push(\n        `${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'))\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`)\n    }\n\n    if (material.normalMap !== null) {\n      inputs.push(\n        `${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.normalMap, 'normal'))\n    }\n\n    if (material.aoMap !== null) {\n      inputs.push(\n        `${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'))\n    }\n\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(\n        `${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'))\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`)\n    }\n\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(\n        `${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'))\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`)\n    }\n\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`)\n\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`)\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`)\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`)\n    }\n\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join('\\n')}\n    }\n`\n  }\n\n  private buildTexture(material: MaterialRepresentaion, texture: Texture, mapType: string, color?: Color): string {\n    const id = texture.id + (color ? '_' + color.getHexString() : '')\n    const isRGBA = texture.format === 1023\n\n    this.textures[id] = texture\n\n    // Add the alpha output for when transparency is set or the alpha test is above 0\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n          ${material.transparent || material.alphaTest > 0.0 ? 'float outputs:a' : ''}\n      }`\n  }\n\n  private buildColor(color: Color): string {\n    return `(${color.r}, ${color.g}, ${color.b})`\n  }\n\n  private buildVector2(vector: Vector2): string {\n    return `(${vector.x}, ${vector.y})`\n  }\n}\n\nexport { USDZExporter }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2250, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/PLYExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/PLYExporter.ts"],"sourcesContent":["import { BufferGeometry, Matrix3, Mesh, Object3D, Vector3 } from 'three'\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nexport interface PLYExporterOptions {\n  binary?: boolean\n  excludeAttributes?: string[]\n  littleEndian?: boolean\n}\n\nclass PLYExporter {\n  public parse(\n    object: Object3D,\n    onDone: ((res: string) => void) | undefined,\n    options: PLYExporterOptions,\n  ): string | ArrayBuffer | null {\n    if (onDone && typeof onDone === 'object') {\n      console.warn(\n        'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.',\n      )\n      options = onDone\n      onDone = undefined\n    }\n\n    // Default options\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [], // normal, uv, color, index\n      littleEndian: false,\n    }\n\n    options = Object.assign(defaultOptions, options)\n\n    const excludeAttributes = options.excludeAttributes\n    let includeNormals = false\n    let includeColors = false\n    let includeUVs = false\n\n    // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n    let vertexCount = 0\n    let faceCount = 0\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child\n        const geometry = mesh.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        if (vertices === undefined) {\n          return\n        }\n\n        vertexCount += vertices.count\n        faceCount += indices ? indices.count / 3 : vertices.count / 3\n\n        if (normals !== undefined) includeNormals = true\n\n        if (uvs !== undefined) includeUVs = true\n\n        if (colors !== undefined) includeColors = true\n      }\n    })\n\n    const includeIndices = excludeAttributes?.indexOf('index') === -1\n    includeNormals = includeNormals && excludeAttributes?.indexOf('normal') === -1\n    includeColors = includeColors && excludeAttributes?.indexOf('color') === -1\n    includeUVs = includeUVs && excludeAttributes?.indexOf('uv') === -1\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error(\n        'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n          'number of indices is not divisible by 3.',\n      )\n\n      return null\n    }\n\n    const indexByteCount = 4\n\n    let header =\n      'ply\\n' +\n      `format ${\n        options.binary ? (options.littleEndian ? 'binary_little_endian' : 'binary_big_endian') : 'ascii'\n      } 1.0\\n` +\n      `element vertex ${vertexCount}\\n` +\n      // position\n      'property float x\\n' +\n      'property float y\\n' +\n      'property float z\\n'\n\n    if (includeNormals) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n'\n    }\n\n    if (includeUVs) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n'\n    }\n\n    if (includeColors) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n'\n    }\n\n    if (includeIndices) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`\n    }\n\n    header += 'end_header\\n'\n\n    // Generate attribute data\n    const vertex = new Vector3()\n    const normalMatrixWorld = new Matrix3()\n    let result: string | ArrayBuffer | null = null\n\n    if (options.binary) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header)\n\n      // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n      const vertexListLength =\n        vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0))\n\n      // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength))\n      new Uint8Array(output.buffer).set(headerBin, 0)\n\n      let vOffset = headerBin.length\n      let fOffset = headerBin.length + vertexListLength\n      let writtenVertices = 0\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i)\n          vertex.y = vertices.getY(i)\n          vertex.z = vertices.getZ(i)\n\n          vertex.applyMatrix4(mesh.matrixWorld)\n\n          // Position information\n          output.setFloat32(vOffset, vertex.x, options.littleEndian)\n          vOffset += 4\n\n          output.setFloat32(vOffset, vertex.y, options.littleEndian)\n          vOffset += 4\n\n          output.setFloat32(vOffset, vertex.z, options.littleEndian)\n          vOffset += 4\n\n          // Normal information\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i)\n              vertex.y = normals.getY(i)\n              vertex.z = normals.getZ(i)\n\n              vertex.applyMatrix3(normalMatrixWorld).normalize()\n\n              output.setFloat32(vOffset, vertex.x, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, vertex.y, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, vertex.z, options.littleEndian)\n              vOffset += 4\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n            }\n          }\n\n          // UV information\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian)\n              vOffset += 4\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n            }\n          }\n\n          // Color information\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255))\n              vOffset += 1\n\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255))\n              vOffset += 1\n\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255))\n              vOffset += 1\n            } else {\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n            }\n          }\n        }\n\n        if (includeIndices) {\n          // Create the face list\n\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3)\n              fOffset += 1\n\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3)\n              fOffset += 1\n\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian)\n              fOffset += indexByteCount\n            }\n          }\n        }\n\n        // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n        writtenVertices += vertices.count\n      })\n\n      result = output.buffer\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      let writtenVertices = 0\n      let vertexList = ''\n      let faceList = ''\n\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n        // form each line\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i)\n          vertex.y = vertices.getY(i)\n          vertex.z = vertices.getZ(i)\n\n          vertex.applyMatrix4(mesh.matrixWorld)\n\n          // Position information\n          let line = vertex.x + ' ' + vertex.y + ' ' + vertex.z\n\n          // Normal information\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i)\n              vertex.y = normals.getY(i)\n              vertex.z = normals.getZ(i)\n\n              vertex.applyMatrix3(normalMatrixWorld).normalize()\n\n              line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z\n            } else {\n              line += ' 0 0 0'\n            }\n          }\n\n          // UV information\n          if (includeUVs) {\n            if (uvs != null) {\n              line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i)\n            } else if (includeUVs) {\n              line += ' 0 0'\n            }\n          }\n\n          // Color information\n          if (includeColors) {\n            if (colors != null) {\n              line +=\n                ' ' +\n                Math.floor(colors.getX(i) * 255) +\n                ' ' +\n                Math.floor(colors.getY(i) * 255) +\n                ' ' +\n                Math.floor(colors.getZ(i) * 255)\n            } else {\n              line += ' 255 255 255'\n            }\n          }\n\n          vertexList += line + '\\n'\n        }\n\n        // Create the face list\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3\n        }\n\n        writtenVertices += vertices.count\n      })\n\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone && onDone(typeof result === 'string' ? result : ''))\n    }\n\n    return result\n  }\n\n  // Iterate over the valid meshes in the object\n  private traverseMeshes(object: Object3D, cb: (mesh: Mesh, geometry: BufferGeometry) => void): void {\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child\n        const geometry = mesh.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        if (geometry.hasAttribute('position')) {\n          cb(mesh, geometry)\n        }\n      }\n    })\n  }\n}\n\nexport { PLYExporter }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2531, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/DRACOExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/DRACOExporter.js"],"sourcesContent":["import { BufferGeometry, Mesh, Points } from 'three'\n\n/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\nconst DRACOExporter = /* @__PURE__ */ (() => {\n  class DRACOExporter {\n    // Encoder methods\n\n    static MESH_EDGEBREAKER_ENCODING = 1\n    static MESH_SEQUENTIAL_ENCODING = 0\n\n    // Geometry type\n\n    static POINT_CLOUD = 0\n    static TRIANGULAR_MESH = 1\n\n    // Attribute type\n    static INVALID = -1\n    static POSITION = 0\n    static NORMAL = 1\n    static COLOR = 2\n    static TEX_COORD = 3\n    static GENERIC = 4\n\n    parse(\n      object,\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false,\n      },\n    ) {\n      if (object instanceof BufferGeometry && object.isBufferGeometry) {\n        throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.')\n      }\n\n      if (DracoEncoderModule === undefined) {\n        throw new Error('THREE.DRACOExporter: required the draco_encoder to work.')\n      }\n\n      const geometry = object.geometry\n\n      const dracoEncoder = DracoEncoderModule()\n      const encoder = new dracoEncoder.Encoder()\n      let builder\n      let dracoObject\n\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\n          'THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.',\n        )\n      }\n\n      if (object instanceof Mesh && object.isMesh) {\n        builder = new dracoEncoder.MeshBuilder()\n        dracoObject = new dracoEncoder.Mesh()\n\n        const vertices = geometry.getAttribute('position')\n        // @ts-ignore\n        builder.AddFloatAttributeToMesh(\n          dracoObject,\n          dracoEncoder.POSITION,\n          vertices.count,\n          vertices.itemSize,\n          vertices.array,\n        )\n\n        const faces = geometry.getIndex()\n\n        if (faces !== null) {\n          builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array)\n        } else {\n          const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count)\n\n          for (let i = 0; i < faces.length; i++) {\n            faces[i] = i\n          }\n\n          builder.AddFacesToMesh(dracoObject, vertices.count, faces)\n        }\n\n        if (options.exportNormals) {\n          const normals = geometry.getAttribute('normal')\n\n          if (normals !== undefined) {\n            // @ts-ignore\n            builder.AddFloatAttributeToMesh(\n              dracoObject,\n              dracoEncoder.NORMAL,\n              normals.count,\n              normals.itemSize,\n              normals.array,\n            )\n          }\n        }\n\n        if (options.exportUvs) {\n          const uvs = geometry.getAttribute('uv')\n\n          if (uvs !== undefined) {\n            // @ts-ignore\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array)\n          }\n        }\n\n        if (options.exportColor) {\n          const colors = geometry.getAttribute('color')\n\n          if (colors !== undefined) {\n            // @ts-ignore\n            builder.AddFloatAttributeToMesh(\n              dracoObject,\n              dracoEncoder.COLOR,\n              colors.count,\n              colors.itemSize,\n              colors.array,\n            )\n          }\n        }\n      } else if (object instanceof Points && object.isPoints) {\n        // @ts-ignore\n        builder = new dracoEncoder.PointCloudBuilder()\n        // @ts-ignore\n        dracoObject = new dracoEncoder.PointCloud()\n\n        const vertices = geometry.getAttribute('position')\n        builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array)\n\n        if (options.exportColor) {\n          const colors = geometry.getAttribute('color')\n\n          if (colors !== undefined) {\n            builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array)\n          }\n        }\n      } else {\n        throw new Error('DRACOExporter: Unsupported object type.')\n      }\n\n      //Compress using draco encoder\n\n      const encodedData = new dracoEncoder.DracoInt8Array()\n\n      //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n      const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5\n      const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5\n\n      encoder.SetSpeedOptions(encodeSpeed, decodeSpeed)\n\n      // Sets the desired encoding method for a given geometry.\n\n      if (options.encoderMethod !== undefined) {\n        encoder.SetEncodingMethod(options.encoderMethod)\n      }\n\n      // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n      // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n      if (options.quantization !== undefined) {\n        for (let i = 0; i < 5; i++) {\n          if (options.quantization[i] !== undefined) {\n            encoder.SetAttributeQuantization(i, options.quantization[i])\n          }\n        }\n      }\n\n      let length\n\n      if (object instanceof Mesh && object.isMesh) {\n        length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData)\n      } else {\n        // @ts-ignore\n        length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData)\n      }\n\n      dracoEncoder.destroy(dracoObject)\n\n      if (length === 0) {\n        throw new Error('THREE.DRACOExporter: Draco encoding failed.')\n      }\n\n      //Copy encoded data to buffer.\n      const outputData = new Int8Array(new ArrayBuffer(length))\n\n      for (let i = 0; i < length; i++) {\n        outputData[i] = encodedData.GetValue(i)\n      }\n\n      dracoEncoder.destroy(encodedData)\n      dracoEncoder.destroy(encoder)\n      dracoEncoder.destroy(builder)\n\n      return outputData\n    }\n  }\n\n  return DRACOExporter\n})()\n\nexport { DRACOExporter }\n"],"names":["faces","DRACOExporter"],"mappings":"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"}},
    {"offset": {"line": 2682, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/ColladaExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/ColladaExporter.ts"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  InterleavedBufferAttribute,\n  Material,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Texture,\n} from 'three'\nimport type { TypedArray, TypedArrayConstructors } from '../types/shared'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nexport interface ColladaExporterOptions {\n  author?: string\n  textureDirectory?: string\n  version?: string\n}\n\nexport interface ColladaExporterResult {\n  data: string\n  textures: object[]\n}\n\ntype GeometryInfo = { meshid: string; bufferGeometry: BufferGeometry }\n\ntype MaterialRepresentation = MeshPhongMaterial | MeshBasicMaterial | MeshLambertMaterial\n\nclass ColladaExporter {\n  private options: {\n    version: string\n    author: string | null\n    textureDirectory: string\n    upAxis: string\n    unitName: string | null\n    unitMeter: string | null\n  }\n\n  private geometryInfo: WeakMap<BufferGeometry, GeometryInfo>\n  private materialMap: WeakMap<MaterialRepresentation, string>\n  private imageMap: WeakMap<Texture, string>\n  private textures: {\n    directory: string\n    name: string\n    ext: string\n    data: Uint8Array\n    original: Texture\n  }[]\n\n  private libraryImages: string[]\n  private libraryGeometries: string[]\n  private libraryEffects: string[]\n  private libraryMaterials: string[]\n\n  private canvas: HTMLCanvasElement | null\n  private ctx: CanvasRenderingContext2D | null\n\n  private transMat: Matrix4 | null\n\n  private getFuncs = ['getX', 'getY', 'getZ', 'getW'] as const\n\n  constructor() {\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null,\n    }\n\n    this.geometryInfo = new WeakMap()\n    this.materialMap = new WeakMap()\n    this.imageMap = new WeakMap()\n    this.textures = []\n\n    this.libraryImages = []\n    this.libraryGeometries = []\n    this.libraryEffects = []\n    this.libraryMaterials = []\n\n    this.canvas = null\n    this.ctx = null\n\n    this.transMat = null\n  }\n\n  public parse(\n    object: Object3D,\n    onDone: (res: ColladaExporterResult) => void,\n    options: ColladaExporterOptions = {},\n  ): ColladaExporterResult | null {\n    this.options = { ...this.options, ...options }\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.')\n      return null\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.')\n      return null\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.')\n      return null\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/')\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`)\n      return null\n    }\n\n    const libraryVisualScenes = this.processObject(object)\n\n    const specLink =\n      this.options.version === '1.4.1'\n        ? 'http://www.collada.org/2005/11/COLLADASchema'\n        : 'https://www.khronos.org/collada/'\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${\n      this.options.author !== null ? `<author>${this.options.author}</author>` : ''\n    }</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`\n\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`\n\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`\n\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`\n\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`\n\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`\n\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>'\n\n    dae += '</COLLADA>'\n\n    const res = {\n      data: this.format(dae),\n      textures: this.textures,\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res))\n    }\n\n    return res\n  }\n\n  // Convert the urdf xml into a well-formatted, indented format\n  private format(urdf: string): string {\n    const IS_END_TAG = /^<\\//\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/\n\n    const pad = (ch: string, num: number): string => (num > 0 ? ch + pad(ch, num - 1) : '')\n\n    let tagnum = 0\n\n    return (\n      urdf\n        .match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)\n        ?.map((tag) => {\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n            tagnum--\n          }\n\n          const res = `${pad('  ', tagnum)}${tag}`\n\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n            tagnum++\n          }\n\n          return res\n        })\n        .join('\\n') ?? ''\n    )\n  }\n\n  // Convert an image into a png format for saving\n  private base64ToBuffer(str: string): Uint8Array {\n    const b = atob(str)\n    const buf = new Uint8Array(b.length)\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i)\n    }\n\n    return buf\n  }\n\n  private imageToData(image: CanvasImageSource, ext: string): Uint8Array {\n    this.canvas = this.canvas || document.createElement('canvas')\n    this.ctx = this.ctx || this.canvas.getContext('2d')\n\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height\n\n    this.ctx?.drawImage(image, 0, 0)\n\n    // Get the base64 encoded data\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, '')\n\n    // Convert to a uint8 array\n    return this.base64ToBuffer(base64data)\n  }\n\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  private attrBufferToArray(attr: InterleavedBufferAttribute | BufferAttribute): number[] | ArrayLike<number> {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor: TypedArrayConstructors = attr.array.constructor\n      // @ts-ignore\n      const arr: number[] = new TypedArrayConstructor(attr.count * attr.itemSize)\n      const size = attr.itemSize\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i)\n        }\n      }\n\n      return arr\n    } else {\n      return attr.array\n    }\n  }\n\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  private subArray(arr: number[] | ArrayLike<number>, st: number, ct: number): TypedArray | number[] {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct)\n    } else {\n      const TypedArrayConstructor: TypedArrayConstructors = arr.constructor\n      // @ts-ignore\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct)\n    }\n  }\n\n  // Returns the string for a geometry's attribute\n  private getAttribute(\n    attr: InterleavedBufferAttribute | BufferAttribute,\n    name: string,\n    params: string[],\n    type: string,\n  ): string {\n    const array = this.attrBufferToArray(attr)\n    const res = Array.isArray(array)\n      ? `${\n          `<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')\n        }</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(\n          array.length / attr.itemSize,\n        )}\" stride=\"${attr.itemSize}\">`}${params\n          .map((n) => `<param name=\"${n}\" type=\"${type}\" />`)\n          .join('')}</accessor></technique_common></source>`\n      : ''\n\n    return res\n  }\n\n  // Returns the string for a node's transform information\n  private getTransform(o: Object3D): string {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix()\n\n    this.transMat = this.transMat || new Matrix4()\n    this.transMat.copy(o.matrix)\n    this.transMat.transpose()\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`\n  }\n\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  private processGeometry(g: BufferGeometry): GeometryInfo {\n    let info = this.geometryInfo.get(g)\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.')\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`\n\n      const indexCount = bufferGeometry.index\n        ? bufferGeometry.index.count * bufferGeometry.index.itemSize\n        : bufferGeometry.attributes.position.count\n\n      const groups =\n        bufferGeometry.groups != null && bufferGeometry.groups.length !== 0\n          ? bufferGeometry.groups\n          : [{ start: 0, count: indexCount, materialIndex: 0 }]\n\n      const gname = g.name ? ` name=\"${g.name}\"` : ''\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`\n\n      // define the geometry node and the vertices for the geometry\n      const posName = `${meshid}-position`\n      const vertName = `${meshid}-vertices`\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float')\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`\n\n      // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n      // serialize normals\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float')\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`\n      }\n\n      // serialize uvs\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`\n      }\n\n      // serialize lightmap uvs\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`\n      }\n\n      // serialize colors\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8')\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`\n      }\n\n      let indexArray: number[] | ArrayLike<number> | null = null\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index)\n      } else {\n        indexArray = new Array(indexCount)\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i]\n        const subarr = this.subArray(indexArray, group.start, group.count)\n        const polycount = subarr.length / 3\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`\n        gnode += triangleInputs\n\n        gnode += `<p>${subarr.join(' ')}</p>`\n        gnode += '</triangles>'\n      }\n\n      gnode += '</mesh></geometry>'\n\n      this.libraryGeometries.push(gnode)\n\n      info = { meshid, bufferGeometry }\n      this.geometryInfo.set(g, info)\n    }\n\n    return info\n  }\n\n  // Process the given texture into the image library\n  // Returns the image library\n  private processTexture(tex: Texture): string {\n    let texid = this.imageMap.get(tex)\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`\n\n      const ext = 'png'\n      const name = tex.name || texid\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`\n      }\n\n      imageNode += '</image>'\n\n      this.libraryImages.push(imageNode)\n      this.imageMap.set(tex, texid)\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex,\n      })\n    }\n\n    return texid\n  }\n\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  private processMaterial(m: MaterialRepresentation): string {\n    let matid = this.materialMap.get(m)\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`\n\n      let type = 'phong'\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert'\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant'\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.')\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0)\n        const diffuse = m.color ? m.color : new Color(0, 0, 0)\n        const specular = m.specular ? m.specular : new Color(1, 1, 1)\n        const shininess = m.shininess || 0\n        const reflectivity = m.reflectivity || 0\n\n        // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n        let transparencyNode = ''\n        if (m.transparent) {\n          transparencyNode += `<transparent>${\n            m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'\n          }</transparent>`\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${\n          m.emissiveMap\n            ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />'\n            : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`\n        }</emission>${\n          type !== 'constant'\n            ? `<diffuse>${\n                m.map\n                  ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`\n              }</diffuse>`\n            : ''\n        }${\n          type !== 'constant'\n            ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>`\n            : ''\n        }${\n          type === 'phong'\n            ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${\n                m.specularMap\n                  ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<float sid=\"shininess\">${shininess}</float>`\n              }</shininess>`\n            : ''\n        }${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`\n\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${\n          m.map\n            ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.map,\n              )}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.specularMap\n            ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.specularMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.emissiveMap\n            ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.emissiveMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.normalMap\n            ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.normalMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>`\n            : ''\n        }${techniqueNode}${\n          m.side === DoubleSide\n            ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>'\n            : ''\n        }</profile_COMMON></effect>`\n\n        const materialName = m.name ? ` name=\"${m.name}\"` : ''\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`\n\n        this.libraryMaterials.push(materialNode)\n        this.libraryEffects.push(effectnode)\n        this.materialMap.set(m, matid)\n      }\n    }\n\n    return matid\n  }\n\n  // Recursively process the object into a scene\n  private processObject(o: Object3D): string {\n    let node = `<node name=\"${o.name}\">`\n\n    node += this.getTransform(o)\n    const a: Mesh<BufferGeometry, Material | Material[]> = new Mesh()\n    a.geometry\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry)\n      const meshid = geomInfo.meshid\n      const geometry = geomInfo.bufferGeometry\n\n      // ids of the materials to bind to the geometry\n      let matids = null\n      let matidsArray\n\n      // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n      const mat: MaterialRepresentation | MaterialRepresentation[] = o.material || new MeshBasicMaterial()\n      const materials = Array.isArray(mat) ? mat : [mat]\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length)\n      } else {\n        matidsArray = new Array(materials.length)\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]))\n\n      node += `${\n        `<instance_geometry url=\"#${meshid}\">` +\n        (matids != null\n          ? `<bind_material><technique_common>${matids\n              .map(\n                (id, i) =>\n                  `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`,\n              )\n              .join('')}</technique_common></bind_material>`\n          : '')\n      }</instance_geometry>`\n    }\n\n    o.children.forEach((c) => (node += this.processObject(c)))\n\n    node += '</node>'\n\n    return node\n  }\n}\n\nexport { ColladaExporter }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3052, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/MMDExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/MMDExporter.ts"],"sourcesContent":["import { Matrix4, Quaternion, Vector3, Bone, SkinnedMesh } from 'three'\n// @ts-ignore\nimport { CharsetEncoder } from '../libs/mmdparser'\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nclass MMDExporter {\n  /* TODO: implement\n\t// mesh -> pmd\n\tthis.parsePmd = function ( object ) {\n\t};\n\t*/\n\n  /* TODO: implement\n\t// mesh -> pmx\n\tthis.parsePmx = function ( object ) {\n\t};\n\t*/\n\n  /* TODO: implement\n\t// animation + skeleton -> vmd\n\tthis.parseVmd = function ( object ) {\n\t};\n\t*/\n\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n  public parseVpd(skin: SkinnedMesh, outputShiftJis: boolean, useOriginalBones: boolean): Uint8Array | string | null {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.')\n      return null\n    }\n\n    function toStringsFromNumber(num: number): string {\n      if (Math.abs(num) < 1e-6) num = 0\n\n      let a = num.toString()\n\n      if (a.indexOf('.') === -1) {\n        a += '.'\n      }\n\n      a += '000000'\n\n      const index = a.indexOf('.')\n\n      const d = a.slice(0, index)\n      const p = a.slice(index + 1, index + 7)\n\n      return d + '.' + p\n    }\n\n    function toStringsFromArray(array: number[]): string {\n      const a = []\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        a.push(toStringsFromNumber(array[i]))\n      }\n\n      return a.join(',')\n    }\n\n    skin.updateMatrixWorld(true)\n\n    const bones = skin.skeleton.bones\n    const bones2 = this.getBindBones(skin)\n\n    const position = new Vector3()\n    const quaternion = new Quaternion()\n    const quaternion2 = new Quaternion()\n    const matrix = new Matrix4()\n\n    const array = []\n    array.push('Vocaloid Pose Data file')\n    array.push('')\n    array.push((skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin') + '.osm;')\n    array.push(bones.length + ';')\n    array.push('')\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      const bone2 = bones2[i]\n\n      /*\n       * use the bone matrix saved before solving IK.\n       * see CCDIKSolver for the detail.\n       */\n      if (\n        useOriginalBones === true &&\n        bone.userData.ik !== undefined &&\n        bone.userData.ik.originalMatrix !== undefined\n      ) {\n        matrix.fromArray(bone.userData.ik.originalMatrix)\n      } else {\n        matrix.copy(bone.matrix)\n      }\n\n      position.setFromMatrixPosition(matrix)\n      quaternion.setFromRotationMatrix(matrix)\n\n      const pArray = position.sub(bone2.position).toArray()\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray()\n\n      // right to left\n      pArray[2] = -pArray[2]\n      qArray[0] = -qArray[0]\n      qArray[1] = -qArray[1]\n\n      array.push('Bone' + i + '{' + bone.name)\n      array.push('  ' + toStringsFromArray(pArray) + ';')\n      array.push('  ' + toStringsFromArray(qArray) + ';')\n      array.push('}')\n      array.push('')\n    }\n\n    array.push('')\n\n    const lines = array.join('\\n')\n\n    return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines\n  }\n\n  // Unicode to Shift_JIS table\n  private u2sTable: { [key: string]: number | undefined } | undefined\n\n  private unicodeToShiftjis(str: string): Uint8Array {\n    if (this.u2sTable === undefined) {\n      const encoder = new CharsetEncoder()\n      const table = encoder.s2uTable\n      this.u2sTable = {}\n\n      const keys = Object.keys(table)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i]\n\n        const value = table[key]\n\n        this.u2sTable[value] = parseInt(key)\n      }\n    }\n\n    const array = []\n\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i)\n\n      const value = this.u2sTable[code]\n\n      if (value === undefined) {\n        throw 'cannot convert charcode 0x' + code.toString(16)\n      } else if (value > 0xff) {\n        array.push((value >> 8) & 0xff)\n        array.push(value & 0xff)\n      } else {\n        array.push(value & 0xff)\n      }\n    }\n\n    return new Uint8Array(array)\n  }\n\n  private getBindBones(skin: SkinnedMesh): Bone[] {\n    // any more efficient ways?\n    const poseSkin = skin.clone()\n    poseSkin.pose()\n    return poseSkin.skeleton.bones\n  }\n}\n\nexport { MMDExporter }\n"],"names":["array"],"mappings":"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"}},
    {"offset": {"line": 3192, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/STLExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/STLExporter.ts"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  InterleavedBufferAttribute,\n  Mesh,\n  Object3D,\n  SkinnedMesh,\n  Vector3,\n} from 'three'\n\nexport interface STLExporterOptionsBinary {\n  binary: true\n}\n\nexport interface STLExporterOptionsString {\n  binary?: false\n}\n\nexport interface STLExporterOptions {\n  binary?: boolean\n}\n\nconst isMesh = (object: unknown): object is Mesh => (object as any).isMesh\n\nexport class STLExporter {\n  private binary = false\n\n  private output: string | DataView = ''\n  private offset: number = 80 // skip header\n\n  private objects: { object3d: Object3D; geometry: BufferGeometry }[] = []\n  private triangles: number = 0\n\n  private vA = new Vector3()\n  private vB = new Vector3()\n  private vC = new Vector3()\n  private cb = new Vector3()\n  private ab = new Vector3()\n  private normal = new Vector3()\n\n  parse(scene: Object3D, options: STLExporterOptionsBinary): DataView\n  parse(scene: Object3D, options?: STLExporterOptionsString): string\n  parse(scene: Object3D, options?: STLExporterOptions): string | DataView {\n    this.binary = options?.binary !== undefined ? options?.binary : false\n\n    scene.traverse((object: Object3D) => {\n      if (isMesh(object)) {\n        const geometry = object.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const index = geometry.index\n        const positionAttribute = geometry.getAttribute('position') || null\n        if (!positionAttribute) return\n\n        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3\n\n        this.objects.push({\n          object3d: object,\n          geometry: geometry,\n        })\n      }\n    })\n\n    if (this.binary) {\n      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4\n      const arrayBuffer = new ArrayBuffer(bufferLength)\n      this.output = new DataView(arrayBuffer)\n      this.output.setUint32(this.offset, this.triangles, true)\n      this.offset += 4\n    } else {\n      this.output = ''\n      this.output += 'solid exported\\n'\n    }\n\n    for (let i = 0, il = this.objects.length; i < il; i++) {\n      const object = this.objects[i].object3d\n      const geometry = this.objects[i].geometry\n\n      const index = geometry.index\n      const positionAttribute = geometry.getAttribute('position')\n\n      if (index !== null) {\n        // indexed geometry\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0)\n          const b = index.getX(j + 1)\n          const c = index.getX(j + 2)\n\n          this.writeFace(a, b, c, positionAttribute, object as SkinnedMesh)\n        }\n      } else {\n        // non-indexed geometry\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0\n          const b = j + 1\n          const c = j + 2\n\n          this.writeFace(a, b, c, positionAttribute, object as SkinnedMesh)\n        }\n      }\n    }\n\n    if (!this.binary) {\n      this.output += 'endsolid exported\\n'\n    }\n\n    return this.output\n  }\n\n  private writeFace(\n    a: number,\n    b: number,\n    c: number,\n    positionAttribute: BufferAttribute | InterleavedBufferAttribute,\n    object: SkinnedMesh,\n  ): void {\n    this.vA.fromBufferAttribute(positionAttribute, a)\n    this.vB.fromBufferAttribute(positionAttribute, b)\n    this.vC.fromBufferAttribute(positionAttribute, c)\n\n    if (object.isSkinnedMesh) {\n      const mesh = object as Omit<SkinnedMesh, 'boneTransform' | 'applyBoneTransform'> &\n        (\n          | {\n              boneTransform(index: number, vector: Vector3): Vector3\n            }\n          | {\n              applyBoneTransform(index: number, vector: Vector3): Vector3\n            }\n        )\n\n      // r151 https://github.com/mrdoob/three.js/pull/25586\n      if ('applyBoneTransform' in mesh) {\n        mesh.applyBoneTransform(a, this.vA)\n        mesh.applyBoneTransform(b, this.vB)\n        mesh.applyBoneTransform(c, this.vC)\n      } else {\n        mesh.boneTransform(a, this.vA)\n        mesh.boneTransform(b, this.vB)\n        mesh.boneTransform(c, this.vC)\n      }\n    }\n\n    this.vA.applyMatrix4(object.matrixWorld)\n    this.vB.applyMatrix4(object.matrixWorld)\n    this.vC.applyMatrix4(object.matrixWorld)\n\n    this.writeNormal(this.vA, this.vB, this.vC)\n\n    this.writeVertex(this.vA)\n    this.writeVertex(this.vB)\n    this.writeVertex(this.vC)\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setUint16(this.offset, 0, true)\n      this.offset += 2\n    } else {\n      this.output += '\\t\\tendloop\\n'\n      this.output += '\\tendfacet\\n'\n    }\n  }\n\n  private writeNormal(vA: Vector3, vB: Vector3, vC: Vector3): void {\n    this.cb.subVectors(vC, vB)\n    this.ab.subVectors(vA, vB)\n    this.cb.cross(this.ab).normalize()\n\n    this.normal.copy(this.cb).normalize()\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, this.normal.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      this.output += '\\t\\touter loop\\n'\n    }\n  }\n\n  private writeVertex(vertex: Vector3): void {\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, vertex.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\t\\t\\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\\n`\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3348, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/exporters/OBJExporter.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/exporters/OBJExporter.ts"],"sourcesContent":["import { BufferAttribute, Color, Line, Matrix3, Mesh, Object3D, Points, Vector2, Vector3 } from 'three'\n\nclass OBJExporter {\n  private output\n\n  private indexVertex\n  private indexVertexUvs\n  private indexNormals\n\n  private vertex\n  private color\n  private normal\n  private uv\n\n  private face: string[]\n\n  constructor() {\n    this.output = ''\n\n    this.indexVertex = 0\n    this.indexVertexUvs = 0\n    this.indexNormals = 0\n\n    this.vertex = new Vector3()\n    this.color = new Color()\n    this.normal = new Vector3()\n    this.uv = new Vector2()\n\n    this.face = []\n  }\n\n  public parse(object: Object3D): string {\n    object.traverse((child) => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child)\n      }\n\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child)\n      }\n\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child)\n      }\n    })\n\n    return this.output\n  }\n\n  private parseMesh(mesh: Mesh): void {\n    let nbVertex = 0\n    let nbNormals = 0\n    let nbVertexUvs = 0\n\n    const geometry = mesh.geometry\n\n    const normalMatrixWorld = new Matrix3()\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n    const normals = geometry.getAttribute('normal')\n    const uvs = geometry.getAttribute('uv')\n    const indices = geometry.getIndex()\n\n    // name of the mesh object\n    this.output += `o ${mesh.name}\\n`\n\n    // name of the mesh material\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\\n`\n    }\n\n    // vertices\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(mesh.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    // uvs\n\n    if (uvs !== undefined) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i)\n        this.uv.y = uvs.getY(i)\n\n        // transform the uv to export format\n        this.output += `vt ${this.uv.x} ${this.uv.y}\\n`\n      }\n    }\n\n    // normals\n\n    if (normals !== undefined) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i)\n        this.normal.y = normals.getY(i)\n        this.normal.z = normals.getZ(i)\n\n        // transform the normal to world space\n        this.normal.applyMatrix3(normalMatrixWorld).normalize()\n\n        // transform the normal to export format\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      }\n    }\n\n    // faces\n\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n    this.indexVertexUvs += nbVertexUvs\n    this.indexNormals += nbNormals\n  }\n\n  private parseLine(line: Line): void {\n    let nbVertex = 0\n\n    const geometry = line.geometry\n    const type = line.type\n\n    if (geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n\n    // name of the line object\n    this.output += `o ${line.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(line.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    if (type === 'Line') {\n      this.output += 'l '\n\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `\n      }\n\n      this.output += '\\n'\n    }\n\n    if (type === 'LineSegments') {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n\n  private parsePoints(points: Points): void {\n    let nbVertex = 0\n\n    const geometry = points.geometry\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    const vertices = geometry.getAttribute('position')\n    const colors = geometry.getAttribute('color')\n\n    this.output += `o ${points.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i)\n        this.vertex.applyMatrix4(points.matrixWorld)\n\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`\n\n        if (colors !== undefined && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i)\n\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`\n        }\n\n        this.output += '\\n'\n      }\n    }\n\n    this.output += 'p '\n\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `\n    }\n\n    this.output += '\\n'\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n}\n\nexport { OBJExporter }\n"],"names":[],"mappings":"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"}}]
}