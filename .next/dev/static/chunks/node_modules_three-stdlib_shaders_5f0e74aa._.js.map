{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/UnpackDepthRGBAShader.ts"],"sourcesContent":["/**\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nexport const UnpackDepthRGBAShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float opacity;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    void main() {\n\n    \tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\n    \tgl_FragColor = vec4( vec3( depth ), opacity );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAKO,MAAM,wBAAwB;IACnC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAI;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;EAAA,CAAA;AAgB7B"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/BokehShader2.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/BokehShader2.ts"],"sourcesContent":["import { IUniform, Texture, Vector2 } from 'three'\n\nexport interface BokehShader2Uniforms {\n  textureWidth: IUniform<number>\n  textureHeight: IUniform<number>\n\n  focalDepth: IUniform<number>\n  focalLength: IUniform<number>\n  fstop: IUniform<number>\n\n  tColor: IUniform<Texture | null>\n  tDepth: IUniform<Texture | null>\n\n  maxblur: IUniform<number>\n\n  showFocus: IUniform<number>\n  manualdof: IUniform<number>\n  vignetting: IUniform<number>\n  depthblur: IUniform<number>\n\n  threshold: IUniform<number>\n  gain: IUniform<number>\n  bias: IUniform<number>\n  fringe: IUniform<number>\n\n  znear: IUniform<number>\n  zfar: IUniform<number>\n\n  noise: IUniform<number>\n  dithering: IUniform<number>\n  pentagon: IUniform<number>\n\n  shaderFocus: IUniform<number>\n  focusCoords: IUniform<Vector2>\n}\n\n/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nexport const BokehShader2: {\n  uniforms: BokehShader2Uniforms\n  vertexShader: string\n  fragmentShader: string\n} = {\n  uniforms: {\n    textureWidth: { value: 1.0 },\n    textureHeight: { value: 1.0 },\n\n    focalDepth: { value: 1.0 },\n    focalLength: { value: 24.0 },\n    fstop: { value: 0.9 },\n\n    tColor: { value: null },\n    tDepth: { value: null },\n\n    maxblur: { value: 1.0 },\n\n    showFocus: { value: 0 },\n    manualdof: { value: 0 },\n    vignetting: { value: 0 },\n    depthblur: { value: 0 },\n\n    threshold: { value: 0.5 },\n    gain: { value: 2.0 },\n    bias: { value: 0.5 },\n    fringe: { value: 0.7 },\n\n    znear: { value: 0.1 },\n    zfar: { value: 100 },\n\n    noise: { value: 1 },\n    dithering: { value: 0.0001 },\n    pentagon: { value: 0 },\n\n    shaderFocus: { value: 1 },\n    focusCoords: { value: /* @__PURE__ */ new Vector2() },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    varying vec2 vUv;\n\n    uniform sampler2D tColor;\n    uniform sampler2D tDepth;\n    uniform float textureWidth;\n    uniform float textureHeight;\n\n    uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\n    uniform float focalLength; //focal length in mm\n    uniform float fstop; //f-stop value\n    uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n\n    /*\n    make sure that these two values are the same for your camera, otherwise distances will be wrong.\n    */\n\n    uniform float znear; // camera clipping start\n    uniform float zfar; // camera clipping end\n\n    //------------------------------------------\n    //user variables\n\n    const int samples = SAMPLES; //samples on the first ring\n    const int rings = RINGS; //ring count\n\n    const int maxringsamples = rings * samples;\n\n    uniform bool manualdof; // manual dof calculation\n    float ndofstart = 1.0; // near dof blur start\n    float ndofdist = 2.0; // near dof blur falloff distance\n    float fdofstart = 1.0; // far dof blur start\n    float fdofdist = 3.0; // far dof blur falloff distance\n\n    float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\n\n    uniform bool vignetting; // use optical lens vignetting\n\n    float vignout = 1.3; // vignetting outer border\n    float vignin = 0.0; // vignetting inner border\n    float vignfade = 22.0; // f-stops till vignete fades\n\n    uniform bool shaderFocus;\n    // disable if you use external focalDepth value\n\n    uniform vec2 focusCoords;\n    // autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n    // if center of screen use vec2(0.5, 0.5);\n\n    uniform float maxblur;\n    //clamp value of max blur (0.0 = no blur, 1.0 default)\n\n    uniform float threshold; // highlight threshold;\n    uniform float gain; // highlight gain;\n\n    uniform float bias; // bokeh edge bias\n    uniform float fringe; // bokeh chromatic aberration / fringing\n\n    uniform bool noise; //use noise instead of pattern for sample dithering\n\n    uniform float dithering;\n\n    uniform bool depthblur; // blur the depth buffer\n    float dbsize = 1.25; // depth blur size\n\n    /*\n    next part is experimental\n    not looking good with small sample and ring count\n    looks okay starting from samples = 4, rings = 4\n    */\n\n    uniform bool pentagon; //use pentagon as bokeh shape?\n    float feather = 0.4; //pentagon shape feather\n\n    //------------------------------------------\n\n    float penta(vec2 coords) {\n    \t//pentagonal shape\n    \tfloat scale = float(rings) - 1.3;\n    \tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\n    \tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\n    \tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\n    \tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\n    \tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\n    \tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\n\n    \tvec4  one = vec4( 1.0 );\n\n    \tvec4 P = vec4((coords),vec2(scale, scale));\n\n    \tvec4 dist = vec4(0.0);\n    \tfloat inorout = -4.0;\n\n    \tdist.x = dot( P, HS0 );\n    \tdist.y = dot( P, HS1 );\n    \tdist.z = dot( P, HS2 );\n    \tdist.w = dot( P, HS3 );\n\n    \tdist = smoothstep( -feather, feather, dist );\n\n    \tinorout += dot( dist, one );\n\n    \tdist.x = dot( P, HS4 );\n    \tdist.y = HS5.w - abs( P.z );\n\n    \tdist = smoothstep( -feather, feather, dist );\n    \tinorout += dist.x;\n\n    \treturn clamp( inorout, 0.0, 1.0 );\n    }\n\n    float bdepth(vec2 coords) {\n    \t// Depth buffer blur\n    \tfloat d = 0.0;\n    \tfloat kernel[9];\n    \tvec2 offset[9];\n\n    \tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\n\n    \toffset[0] = vec2(-wh.x,-wh.y);\n    \toffset[1] = vec2( 0.0, -wh.y);\n    \toffset[2] = vec2( wh.x -wh.y);\n\n    \toffset[3] = vec2(-wh.x,  0.0);\n    \toffset[4] = vec2( 0.0,   0.0);\n    \toffset[5] = vec2( wh.x,  0.0);\n\n    \toffset[6] = vec2(-wh.x, wh.y);\n    \toffset[7] = vec2( 0.0,  wh.y);\n    \toffset[8] = vec2( wh.x, wh.y);\n\n    \tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\n    \tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\n    \tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\n\n    \tfor( int i=0; i<9; i++ ) {\n    \t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\n    \t\td += tmp * kernel[i];\n    \t}\n\n    \treturn d;\n    }\n\n    vec3 color(vec2 coords,float blur) {\n    \t//processing the sample\n\n    \tvec3 col = vec3(0.0);\n    \tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\n\n    \tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n    \tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n    \tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\n    \tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n    \tfloat lum = dot(col.rgb, lumcoeff);\n    \tfloat thresh = max((lum-threshold)*gain, 0.0);\n    \treturn col+mix(vec3(0.0),col,thresh*blur);\n    }\n\n    vec3 debugFocus(vec3 col, float blur, float depth) {\n    \tfloat edge = 0.002*depth; //distance based edge smoothing\n    \tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\n    \tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\n\n    \tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\n    \tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n\n    \treturn col;\n    }\n\n    float linearize(float depth) {\n    \treturn -zfar * znear / (depth * (zfar - znear) - zfar);\n    }\n\n    float vignette() {\n    \tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\n    \tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\n    \treturn clamp(dist,0.0,1.0);\n    }\n\n    float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n    \tfloat rings2 = float(rings);\n    \tfloat step = PI*2.0 / float(ringsamples);\n    \tfloat pw = cos(j*step)*i;\n    \tfloat ph = sin(j*step)*i;\n    \tfloat p = 1.0;\n    \tif (pentagon) {\n    \t\tp = penta(vec2(pw,ph));\n    \t}\n    \tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n    \treturn 1.0 * mix(1.0, i /rings2, bias) * p;\n    }\n\n    void main() {\n    \t//scene depth calculation\n\n    \tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\n\n    \t// Blur depth?\n    \tif ( depthblur ) {\n    \t\tdepth = linearize(bdepth(vUv.xy));\n    \t}\n\n    \t//focal plane calculation\n\n    \tfloat fDepth = focalDepth;\n\n    \tif (shaderFocus) {\n\n    \t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\n\n    \t}\n\n    \t// dof blur factor calculation\n\n    \tfloat blur = 0.0;\n\n    \tif (manualdof) {\n    \t\tfloat a = depth-fDepth; // Focal plane\n    \t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\n    \t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\n    \t\tblur = (a>0.0) ? b : c;\n    \t} else {\n    \t\tfloat f = focalLength; // focal length in mm\n    \t\tfloat d = fDepth*1000.0; // focal plane in mm\n    \t\tfloat o = depth*1000.0; // depth in mm\n\n    \t\tfloat a = (o*f)/(o-f);\n    \t\tfloat b = (d*f)/(d-f);\n    \t\tfloat c = (d-f)/(d*fstop*CoC);\n\n    \t\tblur = abs(a-b)*c;\n    \t}\n\n    \tblur = clamp(blur,0.0,1.0);\n\n    \t// calculation of pattern for dithering\n\n    \tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\n\n    \t// getting blur x and y step factor\n\n    \tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\n    \tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\n\n    \t// calculation of final color\n\n    \tvec3 col = vec3(0.0);\n\n    \tif(blur < 0.05) {\n    \t\t//some optimization thingy\n    \t\tcol = texture2D(tColor, vUv.xy).rgb;\n    \t} else {\n    \t\tcol = texture2D(tColor, vUv.xy).rgb;\n    \t\tfloat s = 1.0;\n    \t\tint ringsamples;\n\n    \t\tfor (int i = 1; i <= rings; i++) {\n    \t\t\t/*unboxstart*/\n    \t\t\tringsamples = i * samples;\n\n    \t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\n    \t\t\t\tif (j >= ringsamples) break;\n    \t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\n    \t\t\t}\n    \t\t\t/*unboxend*/\n    \t\t}\n\n    \t\tcol /= s; //divide by sample count\n    \t}\n\n    \tif (showFocus) {\n    \t\tcol = debugFocus(col, blur, depth);\n    \t}\n\n    \tif (vignetting) {\n    \t\tcol *= vignette();\n    \t}\n\n    \tgl_FragColor.rgb = col;\n    \tgl_FragColor.a = 1.0;\n    } \n  `,\n}\n\nexport const BokehDepthShader = {\n  uniforms: {\n    mNear: { value: 1.0 },\n    mFar: { value: 1000.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying float vViewZDepth;\n\n    void main() {\n\n    \t#include <begin_vertex>\n    \t#include <project_vertex>\n\n    \tvViewZDepth = - mvPosition.z;\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float mNear;\n    uniform float mFar;\n\n    varying float vViewZDepth;\n\n    void main() {\n\n    \tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\n    \tgl_FragColor = vec4( vec3( color ), 1.0 );\n\n    } \n  `,\n}\n"],"names":[],"mappings":";;;;;;;;AA4CO,MAAM,eAIT;IACF,UAAU;QACR,cAAc;YAAE,OAAO;QAAI;QAC3B,eAAe;YAAE,OAAO;QAAI;QAE5B,YAAY;YAAE,OAAO;QAAI;QACzB,aAAa;YAAE,OAAO;QAAK;QAC3B,OAAO;YAAE,OAAO;QAAI;QAEpB,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QAEtB,SAAS;YAAE,OAAO;QAAI;QAEtB,WAAW;YAAE,OAAO;QAAE;QACtB,WAAW;YAAE,OAAO;QAAE;QACtB,YAAY;YAAE,OAAO;QAAE;QACvB,WAAW;YAAE,OAAO;QAAE;QAEtB,WAAW;YAAE,OAAO;QAAI;QACxB,MAAM;YAAE,OAAO;QAAI;QACnB,MAAM;YAAE,OAAO;QAAI;QACnB,QAAQ;YAAE,OAAO;QAAI;QAErB,OAAO;YAAE,OAAO;QAAI;QACpB,MAAM;YAAE,OAAO;QAAI;QAEnB,OAAO;YAAE,OAAO;QAAE;QAClB,WAAW;YAAE,OAAO;QAAO;QAC3B,UAAU;YAAE,OAAO;QAAE;QAErB,aAAa;YAAE,OAAO;QAAE;QACxB,aAAa;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;IACtD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA6R7B;AAEO,MAAM,mBAAmB;IAC9B,UAAU;QACR,OAAO;YAAE,OAAO;QAAI;QACpB,MAAM;YAAE,OAAO;QAAO;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;EAAA,CAAA;IAazB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;EAAA,CAAA;AAa7B"}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/DigitalGlitch.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/DigitalGlitch.ts"],"sourcesContent":["export const DigitalGlitch = {\n  uniforms: {\n    tDiffuse: { value: null }, //diffuse texture\n    tDisp: { value: null }, //displacement texture for digital glitch squares\n    byp: { value: 0 }, //apply the glitch ?\n    amount: { value: 0.08 },\n    angle: { value: 0.02 },\n    seed: { value: 0.02 },\n    seed_x: { value: 0.02 }, //-1,1\n    seed_y: { value: 0.02 }, //-1,1\n    distortion_x: { value: 0.5 },\n    distortion_y: { value: 0.6 },\n    col_s: { value: 0.05 },\n  },\n\n  vertexShader: /* glsl */ `\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n\t`,\n\n  fragmentShader: /* glsl */ `\n\t\tuniform int byp; //should we apply the glitch ?\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDisp;\n\t\tuniform float amount;\n\t\tuniform float angle;\n\t\tuniform float seed;\n\t\tuniform float seed_x;\n\t\tuniform float seed_y;\n\t\tuniform float distortion_x;\n\t\tuniform float distortion_y;\n\t\tuniform float col_s;\n\n\t\tvarying vec2 vUv;\n\n\t\tfloat rand(vec2 co){\n\t\t\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tif(byp<1) {\n\t\t\t\tvec2 p = vUv;\n\t\t\t\tfloat xs = floor(gl_FragCoord.x / 0.5);\n\t\t\t\tfloat ys = floor(gl_FragCoord.y / 0.5);\n\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\t\tvec4 normal = texture2D (tDisp, p*seed*seed);\n\t\t\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\n\t\t\t\t\tif(seed_x>0.){\n\t\t\t\t\t\tp.y = 1. - (p.y + distortion_y);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.y = distortion_y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\n\t\t\t\t\tif(seed_y>0.){\n\t\t\t\t\t\tp.x=distortion_x;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.x = 1. - (p.x + distortion_x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.x+=normal.x*seed_x*(seed/5.);\n\t\t\t\tp.y+=normal.y*seed_y*(seed/5.);\n\t\t//base from RGB shift shader\n\t\t\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\n\t\t\t\tvec4 cr = texture2D(tDiffuse, p + offset);\n\t\t\t\tvec4 cga = texture2D(tDiffuse, p);\n\t\t\t\tvec4 cb = texture2D(tDiffuse, p - offset);\n\t\t\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\t\t//add noise\n\t\t\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\n\t\t\t\tgl_FragColor = gl_FragColor+ snow;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgl_FragColor=texture2D (tDiffuse, vUv);\n\t\t\t}\n\t\t}\n`,\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM,gBAAgB;IAC3B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QAAA,iBAAA;QACxB,OAAO;YAAE,OAAO;QAAK;QAAA,iDAAA;QACrB,KAAK;YAAE,OAAO;QAAE;QAAA,oBAAA;QAChB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAK;QACrB,MAAM;YAAE,OAAO;QAAK;QACpB,QAAQ;YAAE,OAAO;QAAK;QAAA,MAAA;QACtB,QAAQ;YAAE,OAAO;QAAK;QAAA,MAAA;QACtB,cAAc;YAAE,OAAO;QAAI;QAC3B,cAAc;YAAE,OAAO;QAAI;QAC3B,OAAO;YAAE,OAAO;QAAK;IACvB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;CAAA,CAAA;IASzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAA;AA2D7B"}},
    {"offset": {"line": 586, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/HalftoneShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/HalftoneShader.ts"],"sourcesContent":["/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\n\nexport const HalftoneShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    shape: { value: 1 },\n    radius: { value: 4 },\n    rotateR: { value: (Math.PI / 12) * 1 },\n    rotateG: { value: (Math.PI / 12) * 2 },\n    rotateB: { value: (Math.PI / 12) * 3 },\n    scatter: { value: 0 },\n    width: { value: 1 },\n    height: { value: 1 },\n    blending: { value: 1 },\n    blendingMode: { value: 1 },\n    greyscale: { value: false },\n    disable: { value: false },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUV;\n\n    void main() {\n\n    \tvUV = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #define SQRT2_MINUS_ONE 0.41421356\n    #define SQRT2_HALF_MINUS_ONE 0.20710678\n    #define PI2 6.28318531\n    #define SHAPE_DOT 1\n    #define SHAPE_ELLIPSE 2\n    #define SHAPE_LINE 3\n    #define SHAPE_SQUARE 4\n    #define BLENDING_LINEAR 1\n    #define BLENDING_MULTIPLY 2\n    #define BLENDING_ADD 3\n    #define BLENDING_LIGHTER 4\n    #define BLENDING_DARKER 5\n    uniform sampler2D tDiffuse;\n    uniform float radius;\n    uniform float rotateR;\n    uniform float rotateG;\n    uniform float rotateB;\n    uniform float scatter;\n    uniform float width;\n    uniform float height;\n    uniform int shape;\n    uniform bool disable;\n    uniform float blending;\n    uniform int blendingMode;\n    varying vec2 vUV;\n    uniform bool greyscale;\n    const int samples = 8;\n\n    float blend( float a, float b, float t ) {\n\n    // linear blend\n    \treturn a * ( 1.0 - t ) + b * t;\n\n    }\n\n    float hypot( float x, float y ) {\n\n    // vector magnitude\n    \treturn sqrt( x * x + y * y );\n\n    }\n\n    float rand( vec2 seed ){\n\n    // get pseudo-random number\n    return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\n    }\n\n    float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\n\n    // apply shape-specific transforms\n    \tfloat dist = hypot( coord.x - p.x, coord.y - p.y );\n    \tfloat rad = channel;\n\n    \tif ( shape == SHAPE_DOT ) {\n\n    \t\trad = pow( abs( rad ), 1.125 ) * rad_max;\n\n    \t} else if ( shape == SHAPE_ELLIPSE ) {\n\n    \t\trad = pow( abs( rad ), 1.125 ) * rad_max;\n\n    \t\tif ( dist != 0.0 ) {\n    \t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\n    \t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\n    \t\t}\n\n    \t} else if ( shape == SHAPE_LINE ) {\n\n    \t\trad = pow( abs( rad ), 1.5) * rad_max;\n    \t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\n    \t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );\n\n    \t} else if ( shape == SHAPE_SQUARE ) {\n\n    \t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\n    \t\tfloat sin_t = abs( sin( theta ) );\n    \t\tfloat cos_t = abs( cos( theta ) );\n    \t\trad = pow( abs( rad ), 1.4 );\n    \t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\n\n    \t}\n\n    \treturn rad - dist;\n\n    }\n\n    struct Cell {\n\n    // grid sample positions\n    \tvec2 normal;\n    \tvec2 p1;\n    \tvec2 p2;\n    \tvec2 p3;\n    \tvec2 p4;\n    \tfloat samp2;\n    \tfloat samp1;\n    \tfloat samp3;\n    \tfloat samp4;\n\n    };\n\n    vec4 getSample( vec2 point ) {\n\n    // multi-sampled point\n    \tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\n    \tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\n    \tfloat step = PI2 / float( samples );\n    \tfloat dist = radius * 0.66;\n\n    \tfor ( int i = 0; i < samples; ++i ) {\n\n    \t\tfloat r = base + step * float( i );\n    \t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\n    \t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\n\n    \t}\n\n    \ttex /= float( samples ) + 1.0;\n    \treturn tex;\n\n    }\n\n    float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\n\n    // get colour for given point\n    \tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\n\n    \tif ( channel == 0 ) {\n\n    \t\tc.samp1 = getSample( c.p1 ).r;\n    \t\tc.samp2 = getSample( c.p2 ).r;\n    \t\tc.samp3 = getSample( c.p3 ).r;\n    \t\tc.samp4 = getSample( c.p4 ).r;\n\n    \t} else if (channel == 1) {\n\n    \t\tc.samp1 = getSample( c.p1 ).g;\n    \t\tc.samp2 = getSample( c.p2 ).g;\n    \t\tc.samp3 = getSample( c.p3 ).g;\n    \t\tc.samp4 = getSample( c.p4 ).g;\n\n    \t} else {\n\n    \t\tc.samp1 = getSample( c.p1 ).b;\n    \t\tc.samp3 = getSample( c.p3 ).b;\n    \t\tc.samp2 = getSample( c.p2 ).b;\n    \t\tc.samp4 = getSample( c.p4 ).b;\n\n    \t}\n\n    \tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\n    \tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\n    \tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\n    \tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\n    \tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\n    \tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\n    \tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\n    \tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\n    \tres = clamp( res, 0.0, 1.0 );\n\n    \treturn res;\n\n    }\n\n    Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\n\n    // get containing cell\n    \tCell c;\n\n    // calc grid\n    \tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\n    \tfloat threshold = step * 0.5;\n    \tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\n    \tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\n    \tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\n    \tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );\n    \tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\n    \tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\n    \tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\n    \tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\n    \tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\n\n    // get closest corner\n    \tc.normal = n;\n    \tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\n    \tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\n\n    // scatter\n    \tif ( scatter != 0.0 ) {\n\n    \t\tfloat off_mag = scatter * threshold * 0.5;\n    \t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\n    \t\tc.p1.x += cos( off_angle ) * off_mag;\n    \t\tc.p1.y += sin( off_angle ) * off_mag;\n\n    \t}\n\n    // find corners\n    \tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\n    \tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\n    \tc.p2.x = c.p1.x - n.x * normal_step;\n    \tc.p2.y = c.p1.y - n.y * normal_step;\n    \tc.p3.x = c.p1.x + n.y * line_step;\n    \tc.p3.y = c.p1.y - n.x * line_step;\n    \tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\n    \tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\n\n    \treturn c;\n\n    }\n\n    float blendColour( float a, float b, float t ) {\n\n    // blend colours\n    \tif ( blendingMode == BLENDING_LINEAR ) {\n    \t\treturn blend( a, b, 1.0 - t );\n    \t} else if ( blendingMode == BLENDING_ADD ) {\n    \t\treturn blend( a, min( 1.0, a + b ), t );\n    \t} else if ( blendingMode == BLENDING_MULTIPLY ) {\n    \t\treturn blend( a, max( 0.0, a * b ), t );\n    \t} else if ( blendingMode == BLENDING_LIGHTER ) {\n    \t\treturn blend( a, max( a, b ), t );\n    \t} else if ( blendingMode == BLENDING_DARKER ) {\n    \t\treturn blend( a, min( a, b ), t );\n    \t} else {\n    \t\treturn blend( a, b, 1.0 - t );\n    \t}\n\n    }\n\n    void main() {\n\n    \tif ( ! disable ) {\n\n    // setup\n    \t\tvec2 p = vec2( vUV.x * width, vUV.y * height );\n    \t\tvec2 origin = vec2( 0, 0 );\n    \t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\n\n    // get channel samples\n    \t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );\n    \t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );\n    \t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );\n    \t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );\n    \t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );\n    \t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );\n\n    // blend with original\n    \t\tvec4 colour = texture2D( tDiffuse, vUV );\n    \t\tr = blendColour( r, colour.r, blending );\n    \t\tg = blendColour( g, colour.g, blending );\n    \t\tb = blendColour( b, colour.b, blending );\n\n    \t\tif ( greyscale ) {\n    \t\t\tr = g = b = (r + b + g) / 3.0;\n    \t\t}\n\n    \t\tgl_FragColor = vec4( r, g, b, 1.0 );\n\n    \t} else {\n\n    \t\tgl_FragColor = texture2D( tDiffuse, vUV );\n\n    \t}\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAOO,MAAM,iBAAiB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAE;QAClB,QAAQ;YAAE,OAAO;QAAE;QACnB,SAAS;YAAE,OAAQ,KAAK,EAAA,GAAK,KAAM;QAAE;QACrC,SAAS;YAAE,OAAQ,KAAK,EAAA,GAAK,KAAM;QAAE;QACrC,SAAS;YAAE,OAAQ,KAAK,EAAA,GAAK,KAAM;QAAE;QACrC,SAAS;YAAE,OAAO;QAAE;QACpB,OAAO;YAAE,OAAO;QAAE;QAClB,QAAQ;YAAE,OAAO;QAAE;QACnB,UAAU;YAAE,OAAO;QAAE;QACrB,cAAc;YAAE,OAAO;QAAE;QACzB,WAAW;YAAE,OAAO;QAAM;QAC1B,SAAS;YAAE,OAAO;QAAM;IAC1B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA8Q7B"}},
    {"offset": {"line": 919, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SMAAShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SMAAShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8\n * Preset: SMAA 1x Medium (with color edge detection)\n * https://github.com/iryoku/smaa/releases/tag/v2.8\n */\n\nexport const SMAAEdgesShader = {\n  defines: {\n    SMAA_THRESHOLD: '0.1',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: /* glsl */ `\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 3 ];\n\n    void SMAAEdgeDetectionVS( vec2 texcoord ) {\n    \tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n    \tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n    \tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n    }\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tSMAAEdgeDetectionVS( vUv );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 3 ];\n\n    vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n    \tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n    // Calculate color deltas:\n    \tvec4 delta;\n    \tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n    \tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n    \tvec3 t = abs( C - Cleft );\n    \tdelta.x = max( max( t.r, t.g ), t.b );\n\n    \tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n    \tt = abs( C - Ctop );\n    \tdelta.y = max( max( t.r, t.g ), t.b );\n\n    // We do the usual threshold:\n    \tvec2 edges = step( threshold, delta.xy );\n\n    // Then discard if there is no edge:\n    \tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n    \t\tdiscard;\n\n    // Calculate right and bottom deltas:\n    \tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n    \tt = abs( C - Cright );\n    \tdelta.z = max( max( t.r, t.g ), t.b );\n\n    \tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n    \tt = abs( C - Cbottom );\n    \tdelta.w = max( max( t.r, t.g ), t.b );\n\n    // Calculate the maximum delta in the direct neighborhood:\n    \tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n    // Calculate left-left and top-top deltas:\n    \tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n    \tt = abs( C - Cleftleft );\n    \tdelta.z = max( max( t.r, t.g ), t.b );\n\n    \tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n    \tt = abs( C - Ctoptop );\n    \tdelta.w = max( max( t.r, t.g ), t.b );\n\n    // Calculate the final maximum delta:\n    \tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n    // Local contrast adaptation in action:\n    \tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n    \treturn vec4( edges, 0.0, 0.0 );\n    }\n\n    void main() {\n\n    \tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n    }\n  `,\n}\n\nexport const SMAAWeightsShader = {\n  defines: {\n    SMAA_MAX_SEARCH_STEPS: '8',\n    SMAA_AREATEX_MAX_DISTANCE: '16',\n    SMAA_AREATEX_PIXEL_SIZE: '( 1.0 / vec2( 160.0, 560.0 ) )',\n    SMAA_AREATEX_SUBTEX_SIZE: '( 1.0 / 7.0 )',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tArea: { value: null },\n    tSearch: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: /* glsl */ `\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 3 ];\n    varying vec2 vPixcoord;\n\n    void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n    \tvPixcoord = texcoord / resolution;\n\n    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n    \tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n    \tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n    // And these for the searches, they indicate the ends of the loops:\n    \tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n    }\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tSMAABlendingWeightCalculationVS( vUv );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tArea;\n    uniform sampler2D tSearch;\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[3];\n    varying vec2 vPixcoord;\n\n    #if __VERSION__ == 100\n    vec2 round( vec2 x ) {\n    \treturn sign( x ) * floor( abs( x ) + 0.5 );\n    }\n    #endif\n\n    float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n    // Not required if searchTex accesses are set to point:\n    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n    \te.r = bias + e.r * scale;\n    \treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n    }\n\n    float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    /**\n     * @PSEUDO_GATHER4\n     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n     * sample between edge, thus fetching four edges in a row.\n     * Sampling with different offsets in each direction allows to disambiguate\n     * which edges are active from the four fetched ones.\n     */\n    \tvec2 e = vec2( 0.0, 1.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n    \t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n    \t}\n\n    // We correct the previous (-0.25, -0.125) offset we applied:\n    \ttexcoord.x += 0.25 * resolution.x;\n\n    // The searches are bias by 1, so adjust the coords accordingly:\n    \ttexcoord.x += resolution.x;\n\n    // Disambiguate the length added by the last step:\n    \ttexcoord.x += 2.0 * resolution.x; // Undo last step\n    \ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n    \treturn texcoord.x;\n    }\n\n    float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    \tvec2 e = vec2( 0.0, 1.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n    \t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n    \t}\n\n    \ttexcoord.x -= 0.25 * resolution.x;\n    \ttexcoord.x -= resolution.x;\n    \ttexcoord.x -= 2.0 * resolution.x;\n    \ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n    \treturn texcoord.x;\n    }\n\n    float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    \tvec2 e = vec2( 1.0, 0.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n    \t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n    \t}\n\n    \ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n    \treturn texcoord.y;\n    }\n\n    float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    \tvec2 e = vec2( 1.0, 0.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n    \t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n    \t}\n\n    \ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n    \treturn texcoord.y;\n    }\n\n    vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n    // Rounding prevents precision errors of bilinear filtering:\n    \tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n    // We do a scale and bias for mapping to texel space:\n    \ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n    // Move to proper place, according to the subpixel offset:\n    \ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n    \treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n    }\n\n    vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n    \tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n    \tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n    \tif ( e.g > 0.0 ) { // Edge at north\n    \t\tvec2 d;\n\n    // Find the distance to the left:\n    \t\tvec2 coords;\n    \t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n    \t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n    \t\td.x = coords.x;\n\n    // Now fetch the left crossing edges, two at a time using bilinear\n    // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n    // discern what value each edge has:\n    \t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n    // Find the distance to the right:\n    \t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n    \t\td.y = coords.x;\n\n    // We want the distances to be in pixel units (doing this here allow to\n    // better interleave arithmetic and memory accesses):\n    \t\td = d / resolution.x - pixcoord.x;\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    \t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n    // Fetch the right crossing edges:\n    \t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n    \t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n    // Ok, we know how this pattern looks like, now it is time for getting\n    // the actual area:\n    \t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n    \t}\n\n    \tif ( e.r > 0.0 ) { // Edge at west\n    \t\tvec2 d;\n\n    // Find the distance to the top:\n    \t\tvec2 coords;\n\n    \t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n    \t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n    \t\td.x = coords.y;\n\n    // Fetch the top crossing edges:\n    \t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n    // Find the distance to the bottom:\n    \t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n    \t\td.y = coords.y;\n\n    // We want the distances to be in pixel units:\n    \t\td = d / resolution.y - pixcoord.y;\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    \t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n    // Fetch the bottom crossing edges:\n    \t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n    \t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n    // Get the area for this direction:\n    \t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n    \t}\n\n    \treturn weights;\n    }\n\n    void main() {\n\n    \tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n    }\n  `,\n}\n\nexport const SMAABlendShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    tColor: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: /* glsl */ `\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 2 ];\n\n    void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n    \tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n    \tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n    }\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tSMAANeighborhoodBlendingVS( vUv );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tColor;\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 2 ];\n\n    vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n    // Fetch the blending weights for current pixel:\n    \tvec4 a;\n    \ta.xz = texture2D( blendTex, texcoord ).xz;\n    \ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n    \ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n    // Is there any blending weight with a value greater than 0.0?\n    \tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n    \t\treturn texture2D( colorTex, texcoord, 0.0 );\n    \t} else {\n    // Up to 4 lines can be crossing a pixel (one through each edge). We\n    // favor blending by choosing the line with the maximum weight for each\n    // direction:\n    \t\tvec2 offset;\n    \t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n    \t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n    // Then we go in the direction that has the maximum weight:\n    \t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n    \t\t\toffset.y = 0.0;\n    \t\t} else {\n    \t\t\toffset.x = 0.0;\n    \t\t}\n\n    // Fetch the opposite color and lerp by hand:\n    \t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n    \t\ttexcoord += sign( offset ) * resolution;\n    \t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n    \t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n    // WebGL port note: Added gamma correction\n    \t\tC.xyz = pow(C.xyz, vec3(2.2));\n    \t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n    \t\tvec4 mixed = mix(C, Cop, s);\n    \t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n    \t\treturn mixed;\n    \t}\n    }\n\n    void main() {\n\n    \tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;;;;;AAQO,MAAM,kBAAkB;IAC7B,SAAS;QACP,gBAAgB;IAClB;IAEA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,IAAI,MAAM,IAAI,GAAG;QAAE;IACtE;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;IAuBzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAgE7B;AAEO,MAAM,oBAAoB;IAC/B,SAAS;QACP,uBAAuB;QACvB,2BAA2B;QAC3B,yBAAyB;QACzB,0BAA0B;IAC5B;IAEA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAK;QACrB,SAAS;YAAE,OAAO;QAAK;QACvB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,IAAI,MAAM,IAAI,GAAG;QAAE;IACtE;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;IA8BzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyM7B;AAEO,MAAM,kBAAkB;IAC7B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,IAAI,MAAM,IAAI,GAAG;QAAE;IACtE;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;IAsBzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAuD7B"}},
    {"offset": {"line": 1375, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/FilmShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/FilmShader.ts"],"sourcesContent":["/**\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nexport const FilmShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    time: { value: 0.0 },\n    nIntensity: { value: 0.5 },\n    sIntensity: { value: 0.05 },\n    sCount: { value: 4096 },\n    grayscale: { value: 1 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    // control parameter\n    uniform float time;\n\n    uniform bool grayscale;\n\n    // noise effect intensity value (0 = no effect, 1 = full effect)\n    uniform float nIntensity;\n\n    // scanlines effect intensity value (0 = no effect, 1 = full effect)\n    uniform float sIntensity;\n\n    // scanlines effect count value (0 = no effect, 4096 = full effect)\n    uniform float sCount;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    // sample the source\n    \tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\n\n    // make some noise\n    \tfloat dx = rand( vUv + time );\n\n    // add noise\n    \tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\n\n    // get us a sine and cosine\n    \tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\n\n    // add scanlines\n    \tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\n\n    // interpolate between source and result by intensity\n    \tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\n\n    // convert to grayscale if desired\n    \tif( grayscale ) {\n\n    \t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n\n    \t}\n\n    \tgl_FragColor =  vec4( cResult, cTextureScreen.a );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAoBO,MAAM,aAAa;IACxB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,MAAM;YAAE,OAAO;QAAI;QACnB,YAAY;YAAE,OAAO;QAAI;QACzB,YAAY;YAAE,OAAO;QAAK;QAC1B,QAAQ;YAAE,OAAO;QAAK;QACtB,WAAW;YAAE,OAAO;QAAE;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAoD7B"}},
    {"offset": {"line": 1469, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/CopyShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/CopyShader.ts"],"sourcesContent":["/**\n * Full-screen textured quad shader\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type CopyShaderUniforms = {\n  opacity: IUniform<number>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface ICopyShader extends IShader<CopyShaderUniforms> {}\n\nexport const CopyShader: ICopyShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float opacity;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n    \tgl_FragColor = opacity * texel;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAcO,MAAM,aAA0B;IACrC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAI;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;EAAA,CAAA;AAc7B"}},
    {"offset": {"line": 1513, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SSAOShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SSAOShader.ts"],"sourcesContent":["import { Matrix4, Vector2 } from 'three'\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nexport const SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32,\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 0.005 },\n    maxDistance: { value: 0.05 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tNormal;\n    uniform sampler2D tDepth;\n    uniform sampler2D tNoise;\n\n    uniform vec3 kernel[ KERNEL_SIZE ];\n\n    uniform vec2 resolution;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform mat4 cameraProjectionMatrix;\n    uniform mat4 cameraInverseProjectionMatrix;\n\n    uniform float kernelRadius;\n    uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n    uniform float maxDistance; // avoid the influence of fragments which are too far away\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getDepth( const in vec2 screenPosition ) {\n\n    \treturn texture2D( tDepth, screenPosition ).x;\n\n    }\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    float getViewZ( const in float depth ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#endif\n\n    }\n\n    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n    \tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n    \tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n    \tclipPosition *= clipW; // unprojection.\n\n    \treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n    }\n\n    vec3 getViewNormal( const in vec2 screenPosition ) {\n\n    \treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n    }\n\n    void main() {\n\n    \tfloat depth = getDepth( vUv );\n    \tfloat viewZ = getViewZ( depth );\n\n    \tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n    \tvec3 viewNormal = getViewNormal( vUv );\n\n     vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n    \tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\n    // compute matrix used to reorient a kernel vector\n\n    \tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n    \tvec3 bitangent = cross( viewNormal, tangent );\n    \tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n     float occlusion = 0.0;\n\n     for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n    \t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n    \t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n    \t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n    \t\tsamplePointNDC /= samplePointNDC.w;\n\n    \t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n    \t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n    \t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n    \t\tfloat delta = sampleDepth - realDepth;\n\n    \t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n    \t\t\tocclusion += 1.0;\n\n    \t\t}\n\n    \t}\n\n    \tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n    \tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n    }\n  `,\n}\n\nexport const SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n    \tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n    }\n  `,\n}\n\nexport const SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n    \tfloat result = 0.0;\n\n    \tfor ( int i = - 2; i <= 2; i ++ ) {\n\n    \t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n    \t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n    \t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;;;;;AASO,MAAM,aAAa;IACxB,SAAS;QACP,oBAAoB;QACpB,aAAa;IACf;IAEA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAK;QACvB,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAK;QACzB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACnD,wBAAwB;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QAC/D,+BAA+B;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACtE,cAAc;YAAE,OAAO;QAAE;QACzB,aAAa;YAAE,OAAO;QAAM;QAC5B,aAAa;YAAE,OAAO;QAAK;IAC7B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA4H7B;AAEO,MAAM,kBAAkB;IAC7B,SAAS;QACP,oBAAoB;IACtB;IAEA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAK;IAC3B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAiC7B;AAEO,MAAM,iBAAiB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;IACrD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2B7B"}},
    {"offset": {"line": 1817, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/BokehShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/BokehShader.ts"],"sourcesContent":["/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type BokehShaderDefines = {\n  DEPTH_PACKING: number\n  PERSPECTIVE_CAMERA: number\n}\n\nexport type BokehShaderUniforms = {\n  aperture: IUniform<number>\n  aspect: IUniform<number>\n  farClip: IUniform<number>\n  focus: IUniform<number>\n  maxblur: IUniform<number>\n  nearClip: IUniform<number>\n  tColor: IUniform<Texture | null>\n  tDepth: IUniform<Texture | null>\n}\n\nexport interface IBokehShader extends IShader<BokehShaderUniforms, BokehShaderDefines> {}\n\nexport const BokehShader: IBokehShader = {\n  defines: {\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tColor: { value: null },\n    tDepth: { value: null },\n    focus: { value: 1.0 },\n    aspect: { value: 1.0 },\n    aperture: { value: 0.025 },\n    maxblur: { value: 0.01 },\n    nearClip: { value: 1.0 },\n    farClip: { value: 1000.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    varying vec2 vUv;\n\n    uniform sampler2D tColor;\n    uniform sampler2D tDepth;\n\n    uniform float maxblur; // max blur amount\n    uniform float aperture; // aperture - bigger values for shallower depth of field\n\n    uniform float nearClip;\n    uniform float farClip;\n\n    uniform float focus;\n    uniform float aspect;\n\n    #include <packing>\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n    \t#endif\n    }\n\n    void main() {\n\n    \tvec2 aspectcorrect = vec2( 1.0, aspect );\n\n    \tfloat viewZ = getViewZ( getDepth( vUv ) );\n\n    \tfloat factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation\n\n    \tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\n\n    \tvec2 dofblur9 = dofblur * 0.9;\n    \tvec2 dofblur7 = dofblur * 0.7;\n    \tvec2 dofblur4 = dofblur * 0.4;\n\n    \tvec4 col = vec4( 0.0 );\n\n    \tcol += texture2D( tColor, vUv.xy );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\n    \tgl_FragColor = col / 41.0;\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AA2BO,MAAM,cAA4B;IACvC,SAAS;QACP,eAAe;QACf,oBAAoB;IACtB;IAEA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAI;QACpB,QAAQ;YAAE,OAAO;QAAI;QACrB,UAAU;YAAE,OAAO;QAAM;QACzB,SAAS;YAAE,OAAO;QAAK;QACvB,UAAU;YAAE,OAAO;QAAI;QACvB,SAAS;YAAE,OAAO;QAAO;IAC3B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAqG7B"}},
    {"offset": {"line": 1970, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/LuminosityShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/LuminosityShader.ts"],"sourcesContent":["/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nexport const LuminosityShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tfloat l = linearToRelativeLuminance( texel.rgb );\n\n    \tgl_FragColor = vec4( l, l, l, texel.w );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAKO,MAAM,mBAAmB;IAC9B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;IAC1B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;EAAA,CAAA;AAiB7B"}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ToneMapShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ToneMapShader.ts"],"sourcesContent":["/**\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n */\n\nexport const ToneMapShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    averageLuminance: { value: 1.0 },\n    luminanceMap: { value: null },\n    maxLuminance: { value: 16.0 },\n    minLuminance: { value: 0.01 },\n    middleGrey: { value: 0.6 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    uniform float middleGrey;\n    uniform float minLuminance;\n    uniform float maxLuminance;\n    #ifdef ADAPTED_LUMINANCE\n    \tuniform sampler2D luminanceMap;\n    #else\n    \tuniform float averageLuminance;\n    #endif\n\n    vec3 ToneMap( vec3 vColor ) {\n    \t#ifdef ADAPTED_LUMINANCE\n    // Get the calculated average luminance\n    \t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\n    \t#else\n    \t\tfloat fLumAvg = averageLuminance;\n    \t#endif\n\n    // Calculate the luminance of the current pixel\n    \tfloat fLumPixel = linearToRelativeLuminance( vColor );\n\n    // Apply the modified operator (Eq. 4)\n    \tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\n\n    \tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\n    \treturn fLumCompressed * vColor;\n    }\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAIO,MAAM,gBAAgB;IAC3B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,kBAAkB;YAAE,OAAO;QAAI;QAC/B,cAAc;YAAE,OAAO;QAAK;QAC5B,cAAc;YAAE,OAAO;QAAK;QAC5B,cAAc;YAAE,OAAO;QAAK;QAC5B,YAAY;YAAE,OAAO;QAAI;IAC3B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA0C7B"}},
    {"offset": {"line": 2099, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/LuminosityHighPassShader.ts"],"sourcesContent":["import { Color } from 'three'\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nexport const LuminosityHighPassShader = {\n  shaderID: 'luminosityHighPass',\n\n  uniforms: {\n    tDiffuse: { value: null },\n    luminosityThreshold: { value: 1.0 },\n    smoothWidth: { value: 1.0 },\n    defaultColor: { value: /* @__PURE__ */ new Color(0x000000) },\n    defaultOpacity: { value: 0.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n    \tfloat v = dot( texel.xyz, luma );\n\n    \tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n    \tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n    \tgl_FragColor = mix( outputColor, texel, alpha );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAOO,MAAM,2BAA2B;IACtC,UAAU;IAEV,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,qBAAqB;YAAE,OAAO;QAAI;QAClC,aAAa;YAAE,OAAO;QAAI;QAC1B,cAAc;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;QAC3D,gBAAgB;YAAE,OAAO;QAAI;IAC/B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyB7B"}},
    {"offset": {"line": 2167, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SAOShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SAOShader.ts"],"sourcesContent":["import { Matrix4, Vector2 } from 'three'\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type SAOShaderDefines = Record<\n  'DEPTH_PACKING' | 'DIFFUSE_TEXTURE' | 'NORMAL_TEXTURE' | 'NUM_RINGS' | 'NUM_SAMPLES' | 'PERSPECTIVE_CAMERA',\n  number\n>\n\nexport type SAOShaderUniforms = {\n  bias: IUniform<number>\n  cameraFar: IUniform<number>\n  cameraInverseProjectionMatrix: IUniform<Matrix4>\n  cameraNear: IUniform<number>\n  cameraProjectionMatrix: IUniform<Matrix4>\n  intensity: IUniform<number>\n  kernelRadius: IUniform<number>\n  minResolution: IUniform<number>\n  randomSeed: IUniform<number>\n  scale: IUniform<number>\n  size: IUniform<Vector2>\n  tDepth: IUniform<Texture | null>\n  tDiffuse: IUniform<Texture | null>\n  tNormal: IUniform<Texture | null>\n}\n\nexport interface ISAOShader extends IShader<SAOShaderUniforms, SAOShaderDefines> {\n  defines: SAOShaderDefines\n  needsUpdate?: boolean\n}\n\nexport const SAOShader: ISAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n  uniforms: {\n    tDepth: { value: null },\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n\n    cameraNear: { value: 1 },\n    cameraFar: { value: 100 },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n\n    scale: { value: 1.0 },\n    intensity: { value: 0.1 },\n    bias: { value: 0.5 },\n\n    minResolution: { value: 0.0 },\n    kernelRadius: { value: 100.0 },\n    randomSeed: { value: 0.0 },\n  },\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `,\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    varying vec2 vUv;\n\n    #if DIFFUSE_TEXTURE == 1\n    uniform sampler2D tDiffuse;\n    #endif\n\n    uniform sampler2D tDepth;\n\n    #if NORMAL_TEXTURE == 1\n    uniform sampler2D tNormal;\n    #endif\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform mat4 cameraProjectionMatrix;\n    uniform mat4 cameraInverseProjectionMatrix;\n\n    uniform float scale;\n    uniform float intensity;\n    uniform float bias;\n    uniform float kernelRadius;\n    uniform float minResolution;\n    uniform vec2 size;\n    uniform float randomSeed;\n\n    // RGBA depth\n\n    #include <packing>\n\n    vec4 getDefaultColor( const in vec2 screenPosition ) {\n    \t#if DIFFUSE_TEXTURE == 1\n    \treturn texture2D( tDiffuse, vUv );\n    \t#else\n    \treturn vec4( 1.0 );\n    \t#endif\n    }\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n    \tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n    \tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n    \tclipPosition *= clipW; // unprojection.\n\n    \treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n    }\n\n    vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n    \t#if NORMAL_TEXTURE == 1\n    \treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n    \t#else\n    \treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n    \t#endif\n    }\n\n    float scaleDividedByCameraFar;\n    float minResolutionMultipliedByCameraFar;\n\n    float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n    \tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n    \tfloat viewDistance = length( viewDelta );\n    \tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\n    \treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n    }\n\n    // moving costly divides into consts\n    const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n    const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n    float getAmbientOcclusion( const in vec3 centerViewPosition ) {\n    \t// precompute some variables require in getOcclusion.\n    \tscaleDividedByCameraFar = scale / cameraFar;\n    \tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n    \tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\n    \t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n    \tfloat angle = rand( vUv + randomSeed ) * PI2;\n    \tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n    \tvec2 radiusStep = radius;\n\n    \tfloat occlusionSum = 0.0;\n    \tfloat weightSum = 0.0;\n\n    \tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n    \t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n    \t\tradius += radiusStep;\n    \t\tangle += ANGLE_STEP;\n\n    \t\tfloat sampleDepth = getDepth( sampleUv );\n    \t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n    \t\t\tcontinue;\n    \t\t}\n\n    \t\tfloat sampleViewZ = getViewZ( sampleDepth );\n    \t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n    \t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n    \t\tweightSum += 1.0;\n    \t}\n\n    \tif( weightSum == 0.0 ) discard;\n\n    \treturn occlusionSum * ( intensity / weightSum );\n    }\n\n    void main() {\n    \tfloat centerDepth = getDepth( vUv );\n    \tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = getViewZ( centerDepth );\n    \tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\n    \tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\n    \tgl_FragColor = getDefaultColor( vUv );\n    \tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAgCO,MAAM,YAAwB;IACnC,SAAS;QACP,aAAa;QACb,WAAW;QACX,gBAAgB;QAChB,iBAAiB;QACjB,eAAe;QACf,oBAAoB;IACtB;IACA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAK;QACvB,MAAM;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,KAAK,GAAG;QAAE;QAErD,YAAY;YAAE,OAAO;QAAE;QACvB,WAAW;YAAE,OAAO;QAAI;QACxB,wBAAwB;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QAC/D,+BAA+B;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QAEtE,OAAO;YAAE,OAAO;QAAI;QACpB,WAAW;YAAE,OAAO;QAAI;QACxB,MAAM;YAAE,OAAO;QAAI;QAEnB,eAAe;YAAE,OAAO;QAAI;QAC5B,cAAc;YAAE,OAAO;QAAM;QAC7B,YAAY;YAAE,OAAO;QAAI;IAC3B;IACA,cAAA,QAAA,GAAyB,CAAA;;;;;;;EAAA,CAAA;IAQzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyI7B"}},
    {"offset": {"line": 2378, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/DepthLimitedBlurShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type DepthLimitedBlurShaderDefines = {\n  DEPTH_PACKING: number\n  KERNEL_RADIUS: number\n  PERSPECTIVE_CAMERA: number\n}\n\nexport type DepthLimitedBlurShaderUniforms = {\n  cameraFar: IUniform<number>\n  cameraNear: IUniform<number>\n  depthCutoff: IUniform<number>\n  sampleUvOffsets: IUniform<Vector2[]>\n  sampleWeights: IUniform<number[]>\n  size: IUniform<Vector2>\n  tDepth: IUniform<Texture | null>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IDepthLimitedBlurShader\n  extends IShader<DepthLimitedBlurShaderUniforms, DepthLimitedBlurShaderDefines> {\n  defines: DepthLimitedBlurShaderDefines\n  needsUpdate?: boolean\n}\n\nexport const DepthLimitedBlurShader: IDepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    sampleUvOffsets: { value: [/* @__PURE__ */ new Vector2(0, 0)] },\n    sampleWeights: { value: [1.0] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1000 },\n    depthCutoff: { value: 10 },\n  },\n  vertexShader: /* glsl */ `\n    #include <common>\n\n    uniform vec2 size;\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    void main() {\n    \tvUv = uv;\n    \tvInvSize = 1.0 / size;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `,\n  fragmentShader: /* glsl */ `\n    #include <common>\n    #include <packing>\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform float depthCutoff;\n\n    uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n    uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    void main() {\n    \tfloat depth = getDepth( vUv );\n    \tif( depth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = -getViewZ( depth );\n    \tbool rBreak = false, lBreak = false;\n\n    \tfloat weightSum = sampleWeights[0];\n    \tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n    \tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n    \t\tfloat sampleWeight = sampleWeights[i];\n    \t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n    \t\tvec2 sampleUv = vUv + sampleUvOffset;\n    \t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n    \t\tif( ! rBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t\tsampleUv = vUv - sampleUvOffset;\n    \t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n    \t\tif( ! lBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = diffuseSum / weightSum;\n    }\n  `,\n}\n\nexport const BlurShaderUtils = {\n  createSampleWeights: (kernelRadius: number, stdDev: number): number[] => {\n    const gaussian = (x: number, stdDev: number): number => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev)\n    }\n\n    const weights: number[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev))\n    }\n\n    return weights\n  },\n\n  createSampleOffsets: (kernelRadius: number, uvIncrement: Vector2): Vector2[] => {\n    const offsets: Vector2[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i))\n    }\n\n    return offsets\n  },\n\n  configure: (shader: IDepthLimitedBlurShader, kernelRadius: number, stdDev: number, uvIncrement: Vector2): void => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement)\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev)\n    shader.needsUpdate = true\n  },\n}\n"],"names":["stdDev"],"mappings":";;;;;;;;AA2BO,MAAM,yBAAkD;IAC7D,SAAS;QACP,eAAe;QACf,eAAe;QACf,oBAAoB;IACtB;IACA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,MAAM;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,KAAK,GAAG;QAAE;QACrD,iBAAiB;YAAE,OAAO;gBAAA,aAAA,GAAA,IAAqB,6JAAA,CAAQ,GAAG,CAAC,CAAC;aAAA;QAAE;QAC9D,eAAe;YAAE,OAAO;gBAAC,CAAG;aAAA;QAAE;QAC9B,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAG;QACxB,WAAW;YAAE,OAAO;QAAK;QACzB,aAAa;YAAE,OAAO;QAAG;IAC3B;IACA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;EAAA,CAAA;IAezB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2E7B;AAEO,MAAM,kBAAkB;IAC7B,qBAAqB,CAAC,cAAsB,WAA6B;QACjE,MAAA,WAAW,CAAC,GAAWA,YAA2B;YACtD,OAAO,KAAK,GAAA,CAAI,CAAA,CAAE,IAAI,CAAA,IAAA,CAAM,IAAA,CAAOA,UAASA,OAAAA,CAAAA,CAAQ,IAAA,CAAK,KAAK,IAAA,CAAK,IAAM,KAAK,EAAE,IAAIA,OAAAA;QAAA;QAGtF,MAAM,UAAoB,CAAA,CAAA;QAE1B,IAAA,IAAS,IAAI,GAAG,KAAK,cAAc,IAAK;YACtC,QAAQ,IAAA,CAAK,SAAS,GAAG,MAAM,CAAC;QAClC;QAEO,OAAA;IACT;IAEA,qBAAqB,CAAC,cAAsB,gBAAoC;QAC9E,MAAM,UAAqB,CAAA,CAAA;QAE3B,IAAA,IAAS,IAAI,GAAG,KAAK,cAAc,IAAK;YACtC,QAAQ,IAAA,CAAK,YAAY,KAAA,CAAQ,EAAA,cAAA,CAAe,CAAC,CAAC;QACpD;QAEO,OAAA;IACT;IAEA,WAAW,CAAC,QAAiC,cAAsB,QAAgB,gBAA+B;QACzG,OAAA,OAAA,CAAQ,eAAe,CAAA,GAAI;QAClC,OAAO,QAAA,CAAS,iBAAiB,CAAA,CAAE,KAAA,GAAQ,gBAAgB,mBAAA,CAAoB,cAAc,WAAW;QACxG,OAAO,QAAA,CAAS,eAAe,CAAA,CAAE,KAAA,GAAQ,gBAAgB,mBAAA,CAAoB,cAAc,MAAM;QACjG,OAAO,WAAA,GAAc;IACvB;AACF"}},
    {"offset": {"line": 2544, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/AfterimageShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/AfterimageShader.ts"],"sourcesContent":["/**\n * Afterimage shader\n * I created this effect inspired by a demo on codepen:\n * https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type AfterimageShaderUniforms = {\n  damp: IUniform<number>\n  tNew: IUniform<Texture | null>\n  tOld: IUniform<Texture | null>\n}\n\nexport interface IAfterimageShader extends IShader<AfterimageShaderUniforms> {}\n\nexport const AfterimageShader: IAfterimageShader = {\n  uniforms: {\n    damp: { value: 0.96 },\n    tOld: { value: null },\n    tNew: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float damp;\n\n    uniform sampler2D tOld;\n    uniform sampler2D tNew;\n\n    varying vec2 vUv;\n\n    vec4 when_gt( vec4 x, float y ) {\n\n    \treturn max( sign( x - y ), 0.0 );\n\n    }\n\n    void main() {\n\n    \tvec4 texelOld = texture2D( tOld, vUv );\n    \tvec4 texelNew = texture2D( tNew, vUv );\n\n    \ttexelOld *= damp * when_gt( texelOld, 0.1 );\n\n    \tgl_FragColor = max(texelNew, texelOld);\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAiBO,MAAM,mBAAsC;IACjD,UAAU;QACR,MAAM;YAAE,OAAO;QAAK;QACpB,MAAM;YAAE,OAAO;QAAK;QACpB,MAAM;YAAE,OAAO;QAAK;IACtB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyB7B"}},
    {"offset": {"line": 2602, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/DotScreenShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/DotScreenShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nexport const DotScreenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    tSize: { value: /* @__PURE__ */ new Vector2(256, 256) },\n    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },\n    angle: { value: 1.57 },\n    scale: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec2 center;\n    uniform float angle;\n    uniform float scale;\n    uniform vec2 tSize;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    float pattern() {\n\n    \tfloat s = sin( angle ), c = cos( angle );\n\n    \tvec2 tex = vUv * tSize - center;\n    \tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\n\n    \treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n\n    }\n\n    void main() {\n\n    \tvec4 color = texture2D( tDiffuse, vUv );\n\n    \tfloat average = ( color.r + color.g + color.b ) / 3.0;\n\n    \tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAQO,MAAM,kBAAkB;IAC7B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,KAAK,GAAG;QAAE;QACtD,QAAQ;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,KAAK,GAAG;QAAE;QACvD,OAAO;YAAE,OAAO;QAAK;QACrB,OAAO;YAAE,OAAO;QAAI;IACtB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA+B7B"}},
    {"offset": {"line": 2674, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SSRShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SSRShader.ts"],"sourcesContent":["import { Matrix4, Vector2 } from 'three'\n/**\n * References:\n * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html\n */\n\nexport const SSRShader = {\n  defines: {\n    MAX_STEP: 0,\n    isPerspectiveCamera: true,\n    isDistanceAttenuation: true,\n    isFresnel: true,\n    isInfiniteThick: false,\n    isSelective: false,\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tMetalness: { value: null },\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    opacity: { value: 0.5 },\n    maxDistance: { value: 180 },\n    cameraRange: { value: 0 },\n    surfDist: { value: 0.007 },\n    thickTolerance: { value: 0.03 },\n  },\n\n  vertexShader: /* glsl */ `\n\n    varying vec2 vUv;\n\n    void main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n\n  fragmentShader: /* glsl */ `\n\t\t// precision highp float;\n\t\tprecision highp sampler2D;\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tMetalness;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float cameraRange;\n\t\tuniform vec2 resolution;\n\t\tuniform float opacity;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float maxDistance;\n\t\tuniform float surfDist;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\t\tuniform float thickTolerance;\n\t\t#include <packing>\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\n\t\t}\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\n\t\t\tfloat d=-(a*x+b*y+c*z);\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\n\t\t\treturn distance;\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\n\t\t}\n\t\tvec3 getViewNormal( const in vec2 uv ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n\t\t}\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\n\t\t\tvec2 xy;\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\n\t\t\txy=clip.xy;//clip\n\t\t\tfloat clipW=clip.w;\n\t\t\txy/=clipW;//NDC\n\t\t\txy=(xy+1.)/2.;//uv\n\t\t\txy*=resolution;//screen\n\t\t\treturn xy;\n\t\t}\n\t\tvoid main(){\n\t\t\t#ifdef isSelective\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\n\t\t\t\tif(metalness==0.) return;\n\t\t\t#endif\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\tif(-viewZ>=cameraFar) return;\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\n\n\t\t\tvec2 d0=gl_FragCoord.xy;\n\t\t\tvec2 d1;\n\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\n\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tvec3 viewIncidenceDir=normalize(viewPosition);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#else\n\t\t\t\tvec3 viewIncidenceDir=vec3(0,0,-1);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#endif\n\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\n\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\td1=viewPositionToXY(d1viewPosition);\n\n\t\t\tfloat totalLen=length(d1-d0);\n\t\t\tfloat xLen=d1.x-d0.x;\n\t\t\tfloat yLen=d1.y-d0.y;\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\n\t\t\tfloat xSpan=xLen/totalStep;\n\t\t\tfloat ySpan=yLen/totalStep;\n\t\t\tfor(float i=0.;i<MAX_STEP;i++){\n\t\t\t\tif(i>=totalStep) break;\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\n\t\t\t\tvec2 uv=xy/resolution;\n\n\t\t\t\tfloat d = getDepth(uv);\n\t\t\t\tfloat vZ = getViewZ( d );\n\t\t\t\tif(-vZ>=cameraFar) continue;\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\n\n\t\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\t\t// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\n\t\t\t\t\tfloat sD=surfDist*cW;\n\t\t\t\t#else\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\n\t\t\t\t\tfloat sD=surfDist;\n\t\t\t\t#endif\n\t\t\t\tif(viewReflectRayZ-sD>vZ) continue;\n\n\t\t\t\t#ifdef isInfiniteThick\n\t\t\t\t\tif(viewReflectRayZ+thickTolerance*clipW<vP.z) break;\n\t\t\t\t#endif\n\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\n\n\t\t\t\tfloat op=opacity;\n\n\t\t\t\tif(away<sD){\n\t\t\t\t\tvec3 vN=getViewNormal( uv );\n\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\n\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\n\t\t\t\t\tif(distance>maxDistance) break;\n\t\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\n\t\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef isFresnel\n\t\t\t\t\t\tfloat fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;\n\t\t\t\t\t\top*=fresnel;\n\t\t\t\t\t#endif\n\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\n\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\n\t\t\t\t\tgl_FragColor.a=op;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`,\n}\n\nexport const SSRDepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n\n  fragmentShader: /* glsl */ `\n\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 uv ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, uv ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n\t\t\tfloat d = 1.0 - depth;\n\t\t\t// d=(d-.999)*1000.;\n    \tgl_FragColor = vec4( vec3( d ), 1.0 );\n\n    }\n\n  `,\n}\n\nexport const SSRBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    opacity: { value: 0.5 },\n  },\n\n  vertexShader: /* glsl */ `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n\n  fragmentShader: /* glsl */ `\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n    void main() {\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\n\n\t\t\tvec2 offset;\n\n\t\t\toffset=(vec2(-1,0))*texelSize;\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(1,0))*texelSize;\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,-1))*texelSize;\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,1))*texelSize;\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\n\n\t\t\t// float coeCenter=.5;\n\t\t\t// float coeSide=.125;\n\t\t\tfloat coeCenter=.2;\n\t\t\tfloat coeSide=.2;\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\n\t\t\tgl_FragColor=vec4(rgb,a);\n\n\t\t}\n\t`,\n}\n"],"names":[],"mappings":";;;;;;;;;;AAMO,MAAM,YAAY;IACvB,SAAS;QACP,UAAU;QACV,qBAAqB;QACrB,uBAAuB;QACvB,WAAW;QACX,iBAAiB;QACjB,aAAa;IACf;IAEA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAK;QACvB,YAAY;YAAE,OAAO;QAAK;QAC1B,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAK;QACzB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACnD,wBAAwB;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QAC/D,+BAA+B;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACtE,SAAS;YAAE,OAAO;QAAI;QACtB,aAAa;YAAE,OAAO;QAAI;QAC1B,aAAa;YAAE,OAAO;QAAE;QACxB,UAAU;YAAE,OAAO;QAAM;QACzB,gBAAgB;YAAE,OAAO;QAAK;IAChC;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;EAAA,CAAA;IAczB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA,CAAA;AAqK7B;AAEO,MAAM,iBAAiB;IAC5B,SAAS;QACP,oBAAoB;IACtB;IAEA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAK;IAC3B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;EAAA,CAAA;IAazB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAqC7B;AAEO,MAAM,gBAAgB;IAC3B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACnD,SAAS;YAAE,OAAO;QAAI;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;EAAA,CAAA;IAazB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA,CAAA;AAoC7B"}},
    {"offset": {"line": 3048, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ConvolutionShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ConvolutionShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type ConvolutionShaderDefines = {\n  KERNEL_SIZE_FLOAT: string\n  KERNEL_SIZE_INT: string\n}\n\nexport type ConvolutionShaderUniforms = {\n  cKernel: IUniform<number[]>\n  tDiffuse: IUniform<Texture | null>\n  uImageIncrement: IUniform<Vector2>\n}\n\nexport interface IConvolutionShader extends IShader<ConvolutionShaderUniforms, ConvolutionShaderDefines> {\n  buildKernel: (sigma: number) => number[]\n}\n\nexport const ConvolutionShader: IConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    uImageIncrement: { value: /* @__PURE__ */ new Vector2(0.001953125, 0.0) },\n    cKernel: { value: [] },\n  },\n\n  vertexShader: /* glsl */ `\n    uniform vec2 uImageIncrement;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float cKernel[ KERNEL_SIZE_INT ];\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 uImageIncrement;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 imageCoord = vUv;\n    \tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n    \tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n    \t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n    \t\timageCoord += uImageIncrement;\n\n    \t}\n\n    \tgl_FragColor = sum;\n\n    }\n  `,\n\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n    function gauss(x: number, sigma: number): number {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma))\n    }\n\n    const kMaxKernelSize = 25\n\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3.0) + 1, kMaxKernelSize)\n\n    const halfWidth = (kernelSize - 1) * 0.5\n\n    const values: number[] = new Array(kernelSize)\n\n    let sum = 0.0\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma)\n      sum += values[i]\n    }\n\n    // normalize the kernel\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum\n\n    return values\n  },\n}\n"],"names":["sigma"],"mappings":";;;;;;AA0BO,MAAM,oBAAwC;IACnD,SAAS;QACP,mBAAmB;QACnB,iBAAiB;IACnB;IAEA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,iBAAiB;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,YAAa,CAAG;QAAE;QACxE,SAAS;YAAE,OAAO,EAAA;QAAG;IACvB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;EAAA,CAAA;IAazB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;IAyB3B,aAAa,SAAU,KAAA,EAAO;QAGnB,SAAA,MAAM,CAAA,EAAWA,MAAAA,EAAuB;YAC/C,OAAO,KAAK,GAAA,CAAI,CAAA,CAAE,IAAI,CAAA,IAAA,CAAM,IAAMA,SAAQA,MAAAA,CAAM;QAClD;QAEA,MAAM,iBAAiB;QAEjB,MAAA,aAAa,KAAK,GAAA,CAAI,IAAI,KAAK,IAAA,CAAK,QAAQ,CAAG,IAAI,GAAG,cAAc;QAEpE,MAAA,YAAA,CAAa,aAAa,CAAA,IAAK;QAE/B,MAAA,SAAmB,IAAI,MAAM,UAAU;QAE7C,IAAI,MAAM;QAEV,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,EAAE,EAAG;YACnC,MAAA,CAAO,CAAC,CAAA,GAAI,MAAM,IAAI,WAAW,KAAK;YACtC,OAAO,MAAA,CAAO,CAAC,CAAA;QACjB;QAIA,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,EAAE,EAAG,MAAA,CAAO,CAAC,CAAA,IAAK;QAE3C,OAAA;IACT;AACF"}},
    {"offset": {"line": 3129, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ACESFilmicToneMappingShader.ts"],"sourcesContent":["/**\n * ACES Filmic Tone Mapping Shader by Stephen Hill\n * source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n *\n * this implementation of ACES is modified to accommodate a brighter viewing environment.\n * the scale factor of 1/0.6 is subjective. see discussion in #19621.\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type ACESFilmicToneMappingShaderUniforms = {\n  exposure: IUniform<number>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IACESFilmicToneMappingShader extends IShader<ACESFilmicToneMappingShaderUniforms> {}\n\nexport const ACESFilmicToneMappingShader: IACESFilmicToneMappingShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    exposure: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n  fragmentShader: /* glsl */ `\n    #define saturate(a) clamp( a, 0.0, 1.0 )\n\n    uniform sampler2D tDiffuse;\n\n    uniform float exposure;\n\n    varying vec2 vUv;\n\n    vec3 RRTAndODTFit( vec3 v ) {\n\n    \tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n    \tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n    \treturn a / b;\n\n    }\n\n    vec3 ACESFilmicToneMapping( vec3 color ) {\n\n      // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n    \tconst mat3 ACESInputMat = mat3(\n    \t\tvec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n    \t\tvec3( 0.35458, 0.90834, 0.13383 ),\n    \t\tvec3( 0.04823, 0.01566, 0.83777 )\n    \t);\n\n      // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    \tconst mat3 ACESOutputMat = mat3(\n    \t\tvec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n    \t\tvec3( -0.53108,  1.10813, -0.07276 ),\n    \t\tvec3( -0.07367, -0.00605,  1.07602 )\n    \t);\n\n    \tcolor = ACESInputMat * color;\n\n      // Apply RRT and ODT\n    \tcolor = RRTAndODTFit( color );\n\n    \tcolor = ACESOutputMat * color;\n\n      // Clamp to [0, 1]\n    \treturn saturate( color );\n\n    }\n\n    void main() {\n\n    \tvec4 tex = texture2D( tDiffuse, vUv );\n\n    \ttex.rgb *= exposure / 0.6; // pre-exposed, outside of the tone mapping function\n\n    \tgl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAkBO,MAAM,8BAA4D;IACvE,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,UAAU;YAAE,OAAO;QAAI;IACzB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAUzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAuD7B"}},
    {"offset": {"line": 3214, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/BasicShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/BasicShader.ts"],"sourcesContent":["/**\n * Simple test shader\n */\n\nimport type { IShader } from './types'\n\nexport type BasicShaderUniforms = {}\n\nexport interface IBasicShader extends IShader<BasicShaderUniforms> {}\n\nexport const BasicShader: IBasicShader = {\n  uniforms: {},\n\n  vertexShader: /* glsl */ `\n    void main() {\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    void main() {\n\n      gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAUO,MAAM,cAA4B;IACvC,UAAU,CAAC;IAEX,cAAA,QAAA,GAAyB,CAAA;;;;;;EAAA,CAAA;IAQzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;EAAA,CAAA;AAO7B"}},
    {"offset": {"line": 3241, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/BleachBypassShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/BleachBypassShader.ts"],"sourcesContent":["/**\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type BleachBypassShaderUniforms = {\n  opacity: IUniform<number>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IBleachBypassShader extends IShader<BleachBypassShaderUniforms> {}\n\nexport const BleachBypassShader: IBleachBypassShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float opacity;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 base = texture2D( tDiffuse, vUv );\n\n    \tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\n    \tfloat lum = dot( lumCoeff, base.rgb );\n    \tvec3 blend = vec3( lum );\n\n    \tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\n\n    \tvec3 result1 = 2.0 * base.rgb * blend;\n    \tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\n\n    \tvec3 newColor = mix( result1, result2, L );\n\n    \tfloat A2 = opacity * base.a;\n    \tvec3 mixRGB = A2 * newColor.rgb;\n    \tmixRGB += ( ( 1.0 - A2 ) * base.rgb );\n\n    \tgl_FragColor = vec4( mixRGB, base.a );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAgBO,MAAM,qBAA0C;IACrD,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAI;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA8B7B"}},
    {"offset": {"line": 3301, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/BlendShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/BlendShader.ts"],"sourcesContent":["/**\n * Blend two textures\n */\n\nexport const BlendShader = {\n  uniforms: {\n    tDiffuse1: { value: null },\n    tDiffuse2: { value: null },\n    mixRatio: { value: 0.5 },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float opacity;\n    uniform float mixRatio;\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel1 = texture2D( tDiffuse1, vUv );\n    \tvec4 texel2 = texture2D( tDiffuse2, vUv );\n    \tgl_FragColor = opacity * mix( texel1, texel2, mixRatio );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAIO,MAAM,cAAc;IACzB,UAAU;QACR,WAAW;YAAE,OAAO;QAAK;QACzB,WAAW;YAAE,OAAO;QAAK;QACzB,UAAU;YAAE,OAAO;QAAI;QACvB,SAAS;YAAE,OAAO;QAAI;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;EAAA,CAAA;AAiB7B"}},
    {"offset": {"line": 3354, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/BrightnessContrastShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/BrightnessContrastShader.ts"],"sourcesContent":["/**\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nexport const BrightnessContrastShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    brightness: { value: 0 },\n    contrast: { value: 0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float brightness;\n    uniform float contrast;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tgl_FragColor = texture2D( tDiffuse, vUv );\n\n    \tgl_FragColor.rgb += brightness;\n\n    \tif (contrast > 0.0) {\n    \t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\n    \t} else {\n    \t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\n    \t}\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAOO,MAAM,2BAA2B;IACtC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO;QAAE;QACvB,UAAU;YAAE,OAAO;QAAE;IACvB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAqB7B"}},
    {"offset": {"line": 3409, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ColorCorrectionShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ColorCorrectionShader.ts"],"sourcesContent":["import { Vector3 } from 'three'\n\n/**\n * Color correction\n */\n\nexport const ColorCorrectionShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    powRGB: { value: /* @__PURE__ */ new Vector3(2, 2, 2) },\n    mulRGB: { value: /* @__PURE__ */ new Vector3(1, 1, 1) },\n    addRGB: { value: /* @__PURE__ */ new Vector3(0, 0, 0) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform vec3 powRGB;\n    uniform vec3 mulRGB;\n    uniform vec3 addRGB;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tgl_FragColor = texture2D( tDiffuse, vUv );\n    \tgl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAMO,MAAM,wBAAwB;IACnC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,GAAG,GAAG,CAAC;QAAE;QACtD,QAAQ;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,GAAG,GAAG,CAAC;QAAE;QACtD,QAAQ;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,GAAG,GAAG,CAAC;QAAE;IACxD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;EAAA,CAAA;AAe7B"}},
    {"offset": {"line": 3463, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ColorifyShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ColorifyShader.ts"],"sourcesContent":["import { Color } from 'three'\n\n/**\n * Colorify shader\n */\n\nexport const ColorifyShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    color: { value: /* @__PURE__ */ new Color(0xffffff) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec3 color;\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n    \tfloat v = dot( texel.xyz, luma );\n\n    \tgl_FragColor = vec4( v * color, texel.w );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAMO,MAAM,iBAAiB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;IACtD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;EAAA,CAAA;AAiB7B"}},
    {"offset": {"line": 3512, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/DOFMipMapShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/DOFMipMapShader.ts"],"sourcesContent":["/**\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\n\nexport const DOFMipMapShader = {\n  uniforms: {\n    tColor: { value: null },\n    tDepth: { value: null },\n    focus: { value: 1.0 },\n    maxblur: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float focus;\n    uniform float maxblur;\n\n    uniform sampler2D tColor;\n    uniform sampler2D tDepth;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 depth = texture2D( tDepth, vUv );\n\n    \tfloat factor = depth.x - focus;\n\n    \tvec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\n\n    \tgl_FragColor = col;\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAMO,MAAM,kBAAkB;IAC7B,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAI;QACpB,SAAS;YAAE,OAAO;QAAI;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAsB7B"}},
    {"offset": {"line": 3570, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/FXAAShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/FXAAShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nexport const FXAAShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    precision highp float;\n    \n    uniform sampler2D tDiffuse;\n    \n    uniform vec2 resolution;\n    \n    varying vec2 vUv;\n    \n    // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n    \n    //----------------------------------------------------------------------------------\n    // File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n    // SDK Version: v3.00\n    // Email:       gameworks@nvidia.com\n    // Site:        http://developer.nvidia.com/\n    //\n    // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n    //\n    // Redistribution and use in source and binary forms, with or without\n    // modification, are permitted provided that the following conditions\n    // are met:\n    //  * Redistributions of source code must retain the above copyright\n    //    notice, this list of conditions and the following disclaimer.\n    //  * Redistributions in binary form must reproduce the above copyright\n    //    notice, this list of conditions and the following disclaimer in the\n    //    documentation and/or other materials provided with the distribution.\n    //  * Neither the name of NVIDIA CORPORATION nor the names of its\n    //    contributors may be used to endorse or promote products derived\n    //    from this software without specific prior written permission.\n    //\n    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AS IS AND ANY\n    // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n    // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n    // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n    // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    //\n    //----------------------------------------------------------------------------------\n    \n    #define FXAA_PC 1\n    #define FXAA_GLSL_100 1\n    #define FXAA_QUALITY_PRESET 12\n    \n    #define FXAA_GREEN_AS_LUMA 1\n    \n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_PC_CONSOLE\n        //\n        // The console algorithm for PC is included\n        // for developers targeting really low spec machines.\n        // Likely better to just run FXAA_PC, and use a really low preset.\n        //\n        #define FXAA_PC_CONSOLE 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GLSL_120\n        #define FXAA_GLSL_120 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GLSL_130\n        #define FXAA_GLSL_130 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_3\n        #define FXAA_HLSL_3 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_4\n        #define FXAA_HLSL_4 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_5\n        #define FXAA_HLSL_5 0\n    #endif\n    /*==========================================================================*/\n    #ifndef FXAA_GREEN_AS_LUMA\n        //\n        // For those using non-linear color,\n        // and either not able to get luma in alpha, or not wanting to,\n        // this enables FXAA to run using green as a proxy for luma.\n        // So with this enabled, no need to pack luma in alpha.\n        //\n        // This will turn off AA on anything which lacks some amount of green.\n        // Pure red and blue or combination of only R and B, will get no AA.\n        //\n        // Might want to lower the settings for both,\n        //    fxaaConsoleEdgeThresholdMin\n        //    fxaaQualityEdgeThresholdMin\n        // In order to insure AA does not get turned off on colors\n        // which contain a minor amount of green.\n        //\n        // 1 = On.\n        // 0 = Off.\n        //\n        #define FXAA_GREEN_AS_LUMA 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_EARLY_EXIT\n        //\n        // Controls algorithms early exit path.\n        // On PS3 turning this ON adds 2 cycles to the shader.\n        // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n        // Turning this off on console will result in a more blurry image.\n        // So this defaults to on.\n        //\n        // 1 = On.\n        // 0 = Off.\n        //\n        #define FXAA_EARLY_EXIT 1\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_DISCARD\n        //\n        // Only valid for PC OpenGL currently.\n        // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n        //\n        // 1 = Use discard on pixels which dont need AA.\n        //     For APIs which enable concurrent TEX+ROP from same surface.\n        // 0 = Return unchanged color on pixels which dont need AA.\n        //\n        #define FXAA_DISCARD 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        //\n        // Used for GLSL 120 only.\n        //\n        // 1 = GL API supports fast pixel offsets\n        // 0 = do not use fast pixel offsets\n        //\n        #ifdef GL_EXT_gpu_shader4\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifndef FXAA_FAST_PIXEL_OFFSET\n            #define FXAA_FAST_PIXEL_OFFSET 0\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GATHER4_ALPHA\n        //\n        // 1 = API supports gather4 on alpha channel.\n        // 0 = API does not support gather4 on alpha channel.\n        //\n        #if (FXAA_HLSL_5 == 1)\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifndef FXAA_GATHER4_ALPHA\n            #define FXAA_GATHER4_ALPHA 0\n        #endif\n    #endif\n    \n    \n    /*============================================================================\n                            FXAA QUALITY - TUNING KNOBS\n    ------------------------------------------------------------------------------\n    NOTE the other tuning knobs are now in the shader function inputs!\n    ============================================================================*/\n    #ifndef FXAA_QUALITY_PRESET\n        //\n        // Choose the quality preset.\n        // This needs to be compiled into the shader as it effects code.\n        // Best option to include multiple presets is to\n        // in each shader define the preset, then include this file.\n        //\n        // OPTIONS\n        // -----------------------------------------------------------------------\n        // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n        // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n        // 39       - no dither, very expensive\n        //\n        // NOTES\n        // -----------------------------------------------------------------------\n        // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n        // 13 = about same speed as FXAA 3.9 and better than 12\n        // 23 = closest to FXAA 3.9 visually and performance wise\n        //  _ = the lowest digit is directly related to performance\n        // _  = the highest digit is directly related to style\n        //\n        #define FXAA_QUALITY_PRESET 12\n    #endif\n    \n    \n    /*============================================================================\n    \n                               FXAA QUALITY - PRESETS\n    \n    ============================================================================*/\n    \n    /*============================================================================\n                         FXAA QUALITY - MEDIUM DITHER PRESETS\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 10)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 3.0\n        #define FXAA_QUALITY_P2 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 11)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 3.0\n        #define FXAA_QUALITY_P3 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 12)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 4.0\n        #define FXAA_QUALITY_P4 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 13)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 4.0\n        #define FXAA_QUALITY_P5 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 14)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 4.0\n        #define FXAA_QUALITY_P6 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 15)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 12.0\n    #endif\n    \n    /*============================================================================\n                         FXAA QUALITY - LOW DITHER PRESETS\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 20)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 2.0\n        #define FXAA_QUALITY_P2 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 21)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 22)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 23)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 24)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 3.0\n        #define FXAA_QUALITY_P6 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 25)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 26)\n        #define FXAA_QUALITY_PS 9\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 4.0\n        #define FXAA_QUALITY_P8 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 27)\n        #define FXAA_QUALITY_PS 10\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 4.0\n        #define FXAA_QUALITY_P9 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 28)\n        #define FXAA_QUALITY_PS 11\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 4.0\n        #define FXAA_QUALITY_P10 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 29)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n    #endif\n    \n    /*============================================================================\n                         FXAA QUALITY - EXTREME QUALITY\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 39)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.0\n        #define FXAA_QUALITY_P2 1.0\n        #define FXAA_QUALITY_P3 1.0\n        #define FXAA_QUALITY_P4 1.0\n        #define FXAA_QUALITY_P5 1.5\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n    #endif\n    \n    \n    \n    /*============================================================================\n    \n                                    API PORTING\n    \n    ============================================================================*/\n    #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n        #define FxaaBool bool\n        #define FxaaDiscard discard\n        #define FxaaFloat float\n        #define FxaaFloat2 vec2\n        #define FxaaFloat3 vec3\n        #define FxaaFloat4 vec4\n        #define FxaaHalf float\n        #define FxaaHalf2 vec2\n        #define FxaaHalf3 vec3\n        #define FxaaHalf4 vec4\n        #define FxaaInt2 ivec2\n        #define FxaaSat(x) clamp(x, 0.0, 1.0)\n        #define FxaaTex sampler2D\n    #else\n        #define FxaaBool bool\n        #define FxaaDiscard clip(-1)\n        #define FxaaFloat float\n        #define FxaaFloat2 float2\n        #define FxaaFloat3 float3\n        #define FxaaFloat4 float4\n        #define FxaaHalf half\n        #define FxaaHalf2 half2\n        #define FxaaHalf3 half3\n        #define FxaaHalf4 half4\n        #define FxaaSat(x) saturate(x)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_100 == 1)\n      #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_120 == 1)\n        // Requires,\n        //  #version 120\n        // And at least,\n        //  #extension GL_EXT_gpu_shader4 : enable\n        //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n        #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n        #if (FXAA_FAST_PIXEL_OFFSET == 1)\n            #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n        #else\n            #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n        #endif\n        #if (FXAA_GATHER4_ALPHA == 1)\n            // use #extension GL_ARB_gpu_shader5 : enable\n            #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n            #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n            #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n            #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_130 == 1)\n        // Requires \"#version 130\" or better\n        #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n        #if (FXAA_GATHER4_ALPHA == 1)\n            // use #extension GL_ARB_gpu_shader5 : enable\n            #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n            #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n            #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n            #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_3 == 1)\n        #define FxaaInt2 float2\n        #define FxaaTex sampler2D\n        #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n        #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_4 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex { SamplerState smpl; Texture2D tex; };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_5 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex { SamplerState smpl; Texture2D tex; };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n        #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n        #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n        #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n        #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n    #endif\n    \n    \n    /*============================================================================\n                       GREEN AS LUMA OPTION SUPPORT FUNCTION\n    ============================================================================*/\n    #if (FXAA_GREEN_AS_LUMA == 0)\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n    #else\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n    #endif\n    \n    \n    \n    \n    /*============================================================================\n    \n                                 FXAA3 QUALITY - PC\n    \n    ============================================================================*/\n    #if (FXAA_PC == 1)\n    /*--------------------------------------------------------------------------*/\n    FxaaFloat4 FxaaPixelShader(\n        //\n        // Use noperspective interpolation here (turn off perspective interpolation).\n        // {xy} = center of pixel\n        FxaaFloat2 pos,\n        //\n        // Used only for FXAA Console, and not used on the 360 version.\n        // Use noperspective interpolation here (turn off perspective interpolation).\n        // {xy_} = upper left of pixel\n        // {_zw} = lower right of pixel\n        FxaaFloat4 fxaaConsolePosPos,\n        //\n        // Input color texture.\n        // {rgb_} = color in linear or perceptual color space\n        // if (FXAA_GREEN_AS_LUMA == 0)\n        //     {__a} = luma in perceptual color space (not linear)\n        FxaaTex tex,\n        //\n        // Only used on the optimized 360 version of FXAA Console.\n        // For everything but 360, just use the same input here as for \"tex\".\n        // For 360, same texture, just alias with a 2nd sampler.\n        // This sampler needs to have an exponent bias of -1.\n        FxaaTex fxaaConsole360TexExpBiasNegOne,\n        //\n        // Only used on the optimized 360 version of FXAA Console.\n        // For everything but 360, just use the same input here as for \"tex\".\n        // For 360, same texture, just alias with a 3nd sampler.\n        // This sampler needs to have an exponent bias of -2.\n        FxaaTex fxaaConsole360TexExpBiasNegTwo,\n        //\n        // Only used on FXAA Quality.\n        // This must be from a constant/uniform.\n        // {x_} = 1.0/screenWidthInPixels\n        // {_y} = 1.0/screenHeightInPixels\n        FxaaFloat2 fxaaQualityRcpFrame,\n        //\n        // Only used on FXAA Console.\n        // This must be from a constant/uniform.\n        // This effects sub-pixel AA quality and inversely sharpness.\n        //   Where N ranges between,\n        //     N = 0.50 (default)\n        //     N = 0.33 (sharper)\n        // {x__} = -N/screenWidthInPixels\n        // {_y_} = -N/screenHeightInPixels\n        // {_z_} =  N/screenWidthInPixels\n        // {__w} =  N/screenHeightInPixels\n        FxaaFloat4 fxaaConsoleRcpFrameOpt,\n        //\n        // Only used on FXAA Console.\n        // Not used on 360, but used on PS3 and PC.\n        // This must be from a constant/uniform.\n        // {x__} = -2.0/screenWidthInPixels\n        // {_y_} = -2.0/screenHeightInPixels\n        // {_z_} =  2.0/screenWidthInPixels\n        // {__w} =  2.0/screenHeightInPixels\n        FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n        //\n        // Only used on FXAA Console.\n        // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n        // This must be from a constant/uniform.\n        // {x__} =  8.0/screenWidthInPixels\n        // {_y_} =  8.0/screenHeightInPixels\n        // {_z_} = -4.0/screenWidthInPixels\n        // {__w} = -4.0/screenHeightInPixels\n        FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_SUBPIX define.\n        // It is here now to allow easier tuning.\n        // Choose the amount of sub-pixel aliasing removal.\n        // This can effect sharpness.\n        //   1.00 - upper limit (softer)\n        //   0.75 - default amount of filtering\n        //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n        //   0.25 - almost off\n        //   0.00 - completely off\n        FxaaFloat fxaaQualitySubpix,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n        // It is here now to allow easier tuning.\n        // The minimum amount of local contrast required to apply algorithm.\n        //   0.333 - too little (faster)\n        //   0.250 - low quality\n        //   0.166 - default\n        //   0.125 - high quality\n        //   0.063 - overkill (slower)\n        FxaaFloat fxaaQualityEdgeThreshold,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n        // It is here now to allow easier tuning.\n        // Trims the algorithm from processing darks.\n        //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n        //   0.0625 - high quality (faster)\n        //   0.0312 - visible limit (slower)\n        // Special notes when using FXAA_GREEN_AS_LUMA,\n        //   Likely want to set this to zero.\n        //   As colors that are mostly not-green\n        //   will appear very dark in the green channel!\n        //   Tune by looking at mostly non-green content,\n        //   then start at zero and increase until aliasing is a problem.\n        FxaaFloat fxaaQualityEdgeThresholdMin,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n        // It is here now to allow easier tuning.\n        // This does not effect PS3, as this needs to be compiled in.\n        //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n        //   Due to the PS3 being ALU bound,\n        //   there are only three safe values here: 2 and 4 and 8.\n        //   These options use the shaders ability to a free *|/ by 2|4|8.\n        // For all other platforms can be a non-power of two.\n        //   8.0 is sharper (default!!!)\n        //   4.0 is softer\n        //   2.0 is really soft (good only for vector graphics inputs)\n        FxaaFloat fxaaConsoleEdgeSharpness,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n        // It is here now to allow easier tuning.\n        // This does not effect PS3, as this needs to be compiled in.\n        //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n        //   Due to the PS3 being ALU bound,\n        //   there are only two safe values here: 1/4 and 1/8.\n        //   These options use the shaders ability to a free *|/ by 2|4|8.\n        // The console setting has a different mapping than the quality setting.\n        // Other platforms can use other values.\n        //   0.125 leaves less aliasing, but is softer (default!!!)\n        //   0.25 leaves more aliasing, and is sharper\n        FxaaFloat fxaaConsoleEdgeThreshold,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n        // It is here now to allow easier tuning.\n        // Trims the algorithm from processing darks.\n        // The console setting has a different mapping than the quality setting.\n        // This only applies when FXAA_EARLY_EXIT is 1.\n        // This does not apply to PS3,\n        // PS3 was simplified to avoid more shader instructions.\n        //   0.06 - faster but more aliasing in darks\n        //   0.05 - default\n        //   0.04 - slower and less aliasing in darks\n        // Special notes when using FXAA_GREEN_AS_LUMA,\n        //   Likely want to set this to zero.\n        //   As colors that are mostly not-green\n        //   will appear very dark in the green channel!\n        //   Tune by looking at mostly non-green content,\n        //   then start at zero and increase until aliasing is a problem.\n        FxaaFloat fxaaConsoleEdgeThresholdMin,\n        //\n        // Extra constants for 360 FXAA Console only.\n        // Use zeros or anything else for other platforms.\n        // These must be in physical constant registers and NOT immediates.\n        // Immediates will result in compiler un-optimizing.\n        // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n        FxaaFloat4 fxaaConsole360ConstDir\n    ) {\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posM;\n        posM.x = pos.x;\n        posM.y = pos.y;\n        #if (FXAA_GATHER4_ALPHA == 1)\n            #if (FXAA_DISCARD == 0)\n                FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n                #if (FXAA_GREEN_AS_LUMA == 0)\n                    #define lumaM rgbyM.w\n                #else\n                    #define lumaM rgbyM.y\n                #endif\n            #endif\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n                FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n            #else\n                FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n                FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n            #endif\n            #if (FXAA_DISCARD == 1)\n                #define lumaM luma4A.w\n            #endif\n            #define lumaE luma4A.z\n            #define lumaS luma4A.x\n            #define lumaSE luma4A.y\n            #define lumaNW luma4B.w\n            #define lumaN luma4B.z\n            #define lumaW luma4B.x\n        #else\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n            #if (FXAA_GLSL_100 == 1)\n              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n            #else\n              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n            #endif\n        #endif\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat maxSM = max(lumaS, lumaM);\n        FxaaFloat minSM = min(lumaS, lumaM);\n        FxaaFloat maxESM = max(lumaE, maxSM);\n        FxaaFloat minESM = min(lumaE, minSM);\n        FxaaFloat maxWN = max(lumaN, lumaW);\n        FxaaFloat minWN = min(lumaN, lumaW);\n        FxaaFloat rangeMax = max(maxWN, maxESM);\n        FxaaFloat rangeMin = min(minWN, minESM);\n        FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n        FxaaFloat range = rangeMax - rangeMin;\n        FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n        FxaaBool earlyExit = range < rangeMaxClamped;\n    /*--------------------------------------------------------------------------*/\n        if(earlyExit)\n            #if (FXAA_DISCARD == 1)\n                FxaaDiscard;\n            #else\n                return rgbyM;\n            #endif\n    /*--------------------------------------------------------------------------*/\n        #if (FXAA_GATHER4_ALPHA == 0)\n            #if (FXAA_GLSL_100 == 1)\n              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n            #else\n              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n            #endif\n        #else\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNS = lumaN + lumaS;\n        FxaaFloat lumaWE = lumaW + lumaE;\n        FxaaFloat subpixRcpRange = 1.0/range;\n        FxaaFloat subpixNSWE = lumaNS + lumaWE;\n        FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n        FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNESE = lumaNE + lumaSE;\n        FxaaFloat lumaNWNE = lumaNW + lumaNE;\n        FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n        FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNWSW = lumaNW + lumaSW;\n        FxaaFloat lumaSWSE = lumaSW + lumaSE;\n        FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n        FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n        FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n        FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n        FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n        FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n        FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n        FxaaBool horzSpan = edgeHorz >= edgeVert;\n        FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    /*--------------------------------------------------------------------------*/\n        if(!horzSpan) lumaN = lumaW;\n        if(!horzSpan) lumaS = lumaE;\n        if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n        FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat gradientN = lumaN - lumaM;\n        FxaaFloat gradientS = lumaS - lumaM;\n        FxaaFloat lumaNN = lumaN + lumaM;\n        FxaaFloat lumaSS = lumaS + lumaM;\n        FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n        FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n        if(pairN) lengthSign = -lengthSign;\n        FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posB;\n        posB.x = posM.x;\n        posB.y = posM.y;\n        FxaaFloat2 offNP;\n        offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n        offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n        if(!horzSpan) posB.x += lengthSign * 0.5;\n        if( horzSpan) posB.y += lengthSign * 0.5;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posN;\n        posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n        posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n        FxaaFloat2 posP;\n        posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n        posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n        FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n        FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n        FxaaFloat subpixE = subpixC * subpixC;\n        FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n    /*--------------------------------------------------------------------------*/\n        if(!pairN) lumaNN = lumaSS;\n        FxaaFloat gradientScaled = gradient * 1.0/4.0;\n        FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n        FxaaFloat subpixF = subpixD * subpixE;\n        FxaaBool lumaMLTZero = lumaMM < 0.0;\n    /*--------------------------------------------------------------------------*/\n        lumaEndN -= lumaNN * 0.5;\n        lumaEndP -= lumaNN * 0.5;\n        FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n        FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n        FxaaBool doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    /*--------------------------------------------------------------------------*/\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n    /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 3)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n    /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 4)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 5)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n    /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 6)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n    /*--------------------------------------------------------------------------*/\n                            #if (FXAA_QUALITY_PS > 7)\n                            if(doneNP) {\n                                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                doneN = abs(lumaEndN) >= gradientScaled;\n                                doneP = abs(lumaEndP) >= gradientScaled;\n                                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                                doneNP = (!doneN) || (!doneP);\n                                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    /*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 8)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n    /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 9)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n    /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 10)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 11)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n    /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 12)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n    /*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n    /*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n    /*--------------------------------------------------------------------------*/\n                }\n                #endif\n    /*--------------------------------------------------------------------------*/\n            }\n            #endif\n    /*--------------------------------------------------------------------------*/\n        }\n        #endif\n    /*--------------------------------------------------------------------------*/\n                            }\n                            #endif\n    /*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n    /*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n    /*--------------------------------------------------------------------------*/\n                }\n                #endif\n    /*--------------------------------------------------------------------------*/\n            }\n            #endif\n    /*--------------------------------------------------------------------------*/\n        }\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat dstN = posM.x - posN.x;\n        FxaaFloat dstP = posP.x - posM.x;\n        if(!horzSpan) dstN = posM.y - posN.y;\n        if(!horzSpan) dstP = posP.y - posM.y;\n    /*--------------------------------------------------------------------------*/\n        FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n        FxaaFloat spanLength = (dstP + dstN);\n        FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n        FxaaFloat spanLengthRcp = 1.0/spanLength;\n    /*--------------------------------------------------------------------------*/\n        FxaaBool directionN = dstN < dstP;\n        FxaaFloat dst = min(dstN, dstP);\n        FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n        FxaaFloat subpixG = subpixF * subpixF;\n        FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n        FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n        FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n        if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n        if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n        #if (FXAA_DISCARD == 1)\n            return FxaaTexTop(tex, posM);\n        #else\n            return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n        #endif\n    }\n    /*==========================================================================*/\n    #endif\n    \n    void main() {\n      gl_FragColor = FxaaPixelShader(\n        vUv,\n        vec4(0.0),\n        tDiffuse,\n        tDiffuse,\n        tDiffuse,\n        resolution,\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        0.75,\n        0.166,\n        0.0833,\n        0.0,\n        0.0,\n        0.0,\n        vec4(0.0)\n      );\n    \n      // TODO avoid querying texture twice for same texel\n      gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AASO,MAAM,aAAa;IACxB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,IAAI,MAAM,IAAI,GAAG;QAAE;IACtE;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyjC7B"}},
    {"offset": {"line": 4683, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/FocusShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/FocusShader.ts"],"sourcesContent":["/**\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nexport const FocusShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    screenWidth: { value: 1024 },\n    screenHeight: { value: 1024 },\n    sampleDistance: { value: 0.94 },\n    waveFactor: { value: 0.00125 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float screenWidth;\n    uniform float screenHeight;\n    uniform float sampleDistance;\n    uniform float waveFactor;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 color, org, tmp, add;\n    \tfloat sample_dist, f;\n    \tvec2 vin;\n    \tvec2 uv = vUv;\n\n    \tadd = color = org = texture2D( tDiffuse, uv );\n\n    \tvin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\n    \tsample_dist = dot( vin, vin ) * 2.0;\n\n    \tf = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\n\n    \tvec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tcolor = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\n    \tcolor = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\n\n    \tgl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAMO,MAAM,cAAc;IACzB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,aAAa;YAAE,OAAO;QAAK;QAC3B,cAAc;YAAE,OAAO;QAAK;QAC5B,gBAAgB;YAAE,OAAO;QAAK;QAC9B,YAAY;YAAE,OAAO;QAAQ;IAC/B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAsD7B"}},
    {"offset": {"line": 4776, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/FreiChenShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/FreiChenShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nexport const FreiChenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    aspect: { value: /* @__PURE__ */ new Vector2(512, 512) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n\n    uniform vec2 aspect;\n\n    vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\n\n    mat3 G[9];\n\n    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n    const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\n    const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\n    const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\n    const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\n    const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\n    const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\n    const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\n    const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\n    const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\n\n    void main(void)\n    {\n\n    \tG[0] = g0,\n    \tG[1] = g1,\n    \tG[2] = g2,\n    \tG[3] = g3,\n    \tG[4] = g4,\n    \tG[5] = g5,\n    \tG[6] = g6,\n    \tG[7] = g7,\n    \tG[8] = g8;\n\n    \tmat3 I;\n    \tfloat cnv[9];\n    \tvec3 sample;\n\n    /* fetch the 3x3 neighbourhood and use the RGB vectors length as intensity value */\n    \tfor (float i=0.0; i<3.0; i++) {\n    \t\tfor (float j=0.0; j<3.0; j++) {\n    \t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\n    \t\t\tI[int(i)][int(j)] = length(sample);\n    \t\t}\n    \t}\n\n    /* calculate the convolution values for all the masks */\n    \tfor (int i=0; i<9; i++) {\n    \t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\n    \t\tcnv[i] = dp3 * dp3;\n    \t}\n\n    \tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\n    \tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\n\n    \tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AASO,MAAM,iBAAiB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,KAAK,GAAG;QAAE;IACzD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2D7B"}},
    {"offset": {"line": 4867, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/FresnelShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/FresnelShader.ts"],"sourcesContent":["/**\n * Based on Nvidia Cg tutorial\n */\n\nexport const FresnelShader = {\n  uniforms: {\n    mRefractionRatio: { value: 1.02 },\n    mFresnelBias: { value: 0.1 },\n    mFresnelPower: { value: 2.0 },\n    mFresnelScale: { value: 1.0 },\n    tCube: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    uniform float mRefractionRatio;\n    uniform float mFresnelBias;\n    uniform float mFresnelScale;\n    uniform float mFresnelPower;\n\n    varying vec3 vReflect;\n    varying vec3 vRefract[3];\n    varying float vReflectionFactor;\n\n    void main() {\n\n    \tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    \tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\n    \tvec3 I = worldPosition.xyz - cameraPosition;\n\n    \tvReflect = reflect( I, worldNormal );\n    \tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\n    \tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\n    \tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\n    \tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\n\n    \tgl_Position = projectionMatrix * mvPosition;\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform samplerCube tCube;\n\n    varying vec3 vReflect;\n    varying vec3 vRefract[3];\n    varying float vReflectionFactor;\n\n    void main() {\n\n    \tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n    \tvec4 refractedColor = vec4( 1.0 );\n\n    \trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\n    \trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\n    \trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\n\n    \tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAIO,MAAM,gBAAgB;IAC3B,UAAU;QACR,kBAAkB;YAAE,OAAO;QAAK;QAChC,cAAc;YAAE,OAAO;QAAI;QAC3B,eAAe;YAAE,OAAO;QAAI;QAC5B,eAAe;YAAE,OAAO;QAAI;QAC5B,OAAO;YAAE,OAAO;QAAK;IACvB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;IA8BzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAoB7B"}},
    {"offset": {"line": 4945, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/GammaCorrectionShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/GammaCorrectionShader.ts"],"sourcesContent":["/**\n * Gamma Correction Shader\n * http://en.wikipedia.org/wiki/gamma_correction\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type GammaCorrectionShaderUniforms = {\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IGammaCorrectionShader extends IShader<GammaCorrectionShaderUniforms> {}\n\nexport const GammaCorrectionShader: IGammaCorrectionShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 tex = texture2D( tDiffuse, vUv );\n\n    \t#ifdef LinearTosRGB\n    \t\tgl_FragColor = LinearTosRGB( tex );\n    \t#else\n    \t\tgl_FragColor = sRGBTransferOETF( tex );\n    \t#endif\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAcO,MAAM,wBAAgD;IAC3D,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;IAC1B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;EAAA,CAAA;AAiB7B"}},
    {"offset": {"line": 4989, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/GodRaysShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/GodRaysShader.ts"],"sourcesContent":["import { Color, Vector3 } from 'three'\n\n/**\n * God-rays (crepuscular rays)\n *\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\n * Blurs a mask generated from the depth map along radial lines emanating from the light\n * source. The blur repeatedly applies a blur filter of increasing support but constant\n * sample count to produce a blur filter with large support.\n *\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\n * with decreasing filter support. The result is equivalent to a single pass with\n * 6*6*6 = 216 samples.\n *\n * References:\n *\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\n */\n\nexport const GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null,\n    },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n     vUv = uv;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    varying vec2 vUv;\n\n    uniform sampler2D tInput;\n\n    void main() {\n\n    \tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\n\n    }\n  `,\n}\n\n/**\n * The god-ray generation shader.\n *\n * First pass:\n *\n * The depth map is blurred along radial lines towards the \"sun\". The\n * output is written to a temporary render target (I used a 1/4 sized\n * target).\n *\n * Pass two & three:\n *\n * The results of the previous pass are re-blurred, each time with a\n * decreased distance between samples.\n */\n\nexport const GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null,\n    },\n    fStepSize: {\n      value: 1.0,\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3(),\n    },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n     vUv = uv;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #define TAPS_PER_PASS 6.0\n\n    varying vec2 vUv;\n\n    uniform sampler2D tInput;\n\n    uniform vec3 vSunPositionScreenSpace;\n    uniform float fStepSize; // filter step size\n\n    void main() {\n\n    // delta from current pixel to \"sun\" position\n\n    \tvec2 delta = vSunPositionScreenSpace.xy - vUv;\n    \tfloat dist = length( delta );\n\n    // Step vector (uv space)\n\n    \tvec2 stepv = fStepSize * delta / dist;\n\n    // Number of iterations between pixel and sun\n\n    \tfloat iters = dist/fStepSize;\n\n    \tvec2 uv = vUv.xy;\n    \tfloat col = 0.0;\n\n    // This breaks ANGLE in Chrome 22\n    //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n    /*\n\t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t\t// so ive just left the loop\n\n\t\tfor ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t// mode, with a black border color. I dont think this is currently\n\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t// not specifically handled.\n\n\t\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\n\t\tuv += stepv;\n\n\t\t}\n\t\t*/\n\n    // Unrolling loop manually makes it work in ANGLE\n\n    \tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays\n\n    \tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    // Should technically be dividing by iters but TAPS_PER_PASS smooths out\n    // objectionable artifacts, in particular near the sun position. The side\n    // effect is that the result is darker than it should be around the sun, as\n    // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n    // When the result is inverted (in the shader godrays_combine this produces\n    // a slight bright spot at the position of the sun, even when it is occluded.\n\n    \tgl_FragColor = vec4( col/TAPS_PER_PASS );\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `,\n}\n\n/**\n * Additively applies god rays from texture tGodRays to a background (tColors).\n * fGodRayIntensity attenuates the god rays.\n */\n\nexport const GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null,\n    },\n\n    tGodRays: {\n      value: null,\n    },\n\n    fGodRayIntensity: {\n      value: 0.69,\n    },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    varying vec2 vUv;\n\n    uniform sampler2D tColors;\n    uniform sampler2D tGodRays;\n\n    uniform float fGodRayIntensity;\n\n    void main() {\n\n    // Since THREE.MeshDepthMaterial renders foreground objects white and background\n    // objects black, the god-rays will be white streaks. Therefore value is inverted\n    // before being combined with tColors\n\n    \tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `,\n}\n\n/**\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\n * cheaper/faster/simpler to implement this as a simple sun sprite.\n */\n\nexport const GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3(),\n    },\n\n    fAspect: {\n      value: 1.0,\n    },\n\n    sunColor: {\n      value: /* @__PURE__ */ new Color(0xffee00),\n    },\n\n    bgColor: {\n      value: /* @__PURE__ */ new Color(0x000000),\n    },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    varying vec2 vUv;\n\n    uniform vec3 vSunPositionScreenSpace;\n    uniform float fAspect;\n\n    uniform vec3 sunColor;\n    uniform vec3 bgColor;\n\n    void main() {\n\n    \tvec2 diff = vUv - vSunPositionScreenSpace.xy;\n\n    // Correct for aspect ratio\n\n    \tdiff.x *= fAspect;\n\n    \tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n    \tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n    \tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\n    \tgl_FragColor.w = 1.0;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAoBO,MAAM,yBAAyB;IACpC,UAAU;QACR,QAAQ;YACN,OAAO;QACT;IACF;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;EAAA,CAAA;AAW7B;AAiBO,MAAM,wBAAwB;IACnC,UAAU;QACR,QAAQ;YACN,OAAO;QACT;QACA,WAAW;YACT,OAAO;QACT;QACA,yBAAyB;YACvB,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ;QACrC;IACF;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAqF7B;AAOO,MAAM,uBAAuB;IAClC,UAAU;QACR,SAAS;YACP,OAAO;QACT;QAEA,UAAU;YACR,OAAO;QACT;QAEA,kBAAkB;YAChB,OAAO;QACT;IACF;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAmB7B;AAOO,MAAM,uBAAuB;IAClC,UAAU;QACR,yBAAyB;YACvB,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ;QACrC;QAEA,SAAS;YACP,OAAO;QACT;QAEA,UAAU;YACR,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAC3C;QAEA,SAAS;YACP,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAC3C;IACF;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyB7B"}},
    {"offset": {"line": 5236, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/HorizontalBlurShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/HorizontalBlurShader.ts"],"sourcesContent":["/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type HorizontalBlurShaderUniforms = {\n  tDiffuse: IUniform<Texture | null>\n  h: IUniform<number>\n}\n\nexport interface IHorizontalBlurShader extends IShader<HorizontalBlurShaderUniforms> {}\n\nexport const HorizontalBlurShader: IHorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1.0 / 512.0 },\n  },\n  vertexShader: /* glsl */ `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAoBO,MAAM,uBAA8C;IACzD,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,GAAG;YAAE,OAAO,IAAM;QAAM;IAC1B;IACA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAUzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAwB7B"}},
    {"offset": {"line": 5290, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/HorizontalTiltShiftShader.ts"],"sourcesContent":["/**\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nexport const HorizontalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1.0 / 512.0 },\n    r: { value: 0.35 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n    uniform float r;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tfloat hh = h * abs( r - vUv.y );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AASO,MAAM,4BAA4B;IACvC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,GAAG;YAAE,OAAO,IAAM;QAAM;QACxB,GAAG;YAAE,OAAO;QAAK;IACnB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2B7B"}},
    {"offset": {"line": 5350, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/HueSaturationShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/HueSaturationShader.ts"],"sourcesContent":["/**\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nexport const HueSaturationShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    hue: { value: 0 },\n    saturation: { value: 0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float hue;\n    uniform float saturation;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tgl_FragColor = texture2D( tDiffuse, vUv );\n\n    // hue\n    \tfloat angle = hue * 3.14159265;\n    \tfloat s = sin(angle), c = cos(angle);\n    \tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n    \tfloat len = length(gl_FragColor.rgb);\n    \tgl_FragColor.rgb = vec3(\n    \t\tdot(gl_FragColor.rgb, weights.xyz),\n    \t\tdot(gl_FragColor.rgb, weights.zxy),\n    \t\tdot(gl_FragColor.rgb, weights.yzx)\n    \t);\n\n    // saturation\n    \tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n    \tif (saturation > 0.0) {\n    \t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n    \t} else {\n    \t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\n    \t}\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAOO,MAAM,sBAAsB;IACjC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,KAAK;YAAE,OAAO;QAAE;QAChB,YAAY;YAAE,OAAO;QAAE;IACzB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAgC7B"}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/KaleidoShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/KaleidoShader.ts"],"sourcesContent":["/**\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\n\nexport const KaleidoShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    sides: { value: 6.0 },\n    angle: { value: 0.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float sides;\n    uniform float angle;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 p = vUv - 0.5;\n    \tfloat r = length(p);\n    \tfloat a = atan(p.y, p.x) + angle;\n    \tfloat tau = 2. * 3.1416 ;\n    \ta = mod(a, tau/sides);\n    \ta = abs(a - tau/sides/2.) ;\n    \tp = r * vec2(cos(a), sin(a));\n    \tvec4 color = texture2D(tDiffuse, p + 0.5);\n    \tgl_FragColor = color;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAUO,MAAM,gBAAgB;IAC3B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAI;QACpB,OAAO;YAAE,OAAO;QAAI;IACtB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAqB7B"}},
    {"offset": {"line": 5470, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/MirrorShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/MirrorShader.ts"],"sourcesContent":["/**\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\n\nexport const MirrorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    side: { value: 1 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform int side;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 p = vUv;\n    \tif (side == 0){\n    \t\tif (p.x > 0.5) p.x = 1.0 - p.x;\n    \t}else if (side == 1){\n    \t\tif (p.x < 0.5) p.x = 1.0 - p.x;\n    \t}else if (side == 2){\n    \t\tif (p.y < 0.5) p.y = 1.0 - p.y;\n    \t}else if (side == 3){\n    \t\tif (p.y > 0.5) p.y = 1.0 - p.y;\n    \t} \n    \tvec4 color = texture2D(tDiffuse, p);\n    \tgl_FragColor = color;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAOO,MAAM,eAAe;IAC1B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,MAAM;YAAE,OAAO;QAAE;IACnB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAuB7B"}},
    {"offset": {"line": 5523, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/NormalMapShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/NormalMapShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Normal map shader\n * - compute normals from heightmap\n */\n\nexport const NormalMapShader = {\n  uniforms: {\n    heightMap: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    scale: { value: /* @__PURE__ */ new Vector2(1, 1) },\n    height: { value: 0.05 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float height;\n    uniform vec2 resolution;\n    uniform sampler2D heightMap;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tfloat val = texture2D( heightMap, vUv ).x;\n\n    \tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\n    \tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\n\n    \tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAOO,MAAM,kBAAkB;IAC7B,UAAU;QACR,WAAW;YAAE,OAAO;QAAK;QACzB,YAAY;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,KAAK,GAAG;QAAE;QAC3D,OAAO;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,GAAG,CAAC;QAAE;QAClD,QAAQ;YAAE,OAAO;QAAK;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;EAAA,CAAA;AAkB7B"}},
    {"offset": {"line": 5579, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ParallaxShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ParallaxShader.ts"],"sourcesContent":["// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\nexport const ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX',\n  },\n\n  uniforms: {\n    bumpMap: { value: null },\n    map: { value: null },\n    parallaxScale: { value: null },\n    parallaxMinLayers: { value: null },\n    parallaxMaxLayers: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n    varying vec3 vViewPosition;\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tvUv = uv;\n    \tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \tvViewPosition = -mvPosition.xyz;\n    \tvNormal = normalize( normalMatrix * normal );\n    \tgl_Position = projectionMatrix * mvPosition;\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D bumpMap;\n    uniform sampler2D map;\n\n    uniform float parallaxScale;\n    uniform float parallaxMinLayers;\n    uniform float parallaxMaxLayers;\n\n    varying vec2 vUv;\n    varying vec3 vViewPosition;\n    varying vec3 vNormal;\n\n    #ifdef USE_BASIC_PARALLAX\n\n    \tvec2 parallaxMap( in vec3 V ) {\n\n    \t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;\n\n    // No Offset Limitting: messy, floating output at grazing angles.\n    //vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\n\n    // Offset Limiting\n    \t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\n    \t\treturn vUv - texCoordOffset;\n\n    \t}\n\n    #else\n\n    \tvec2 parallaxMap( in vec3 V ) {\n\n    // Determine number of layers from angle between V and N\n    \t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\n\n    \t\tfloat layerHeight = 1.0 / numLayers;\n    \t\tfloat currentLayerHeight = 0.0;\n    // Shift of texture coordinates for each iteration\n    \t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;\n\n    \t\tvec2 currentTextureCoords = vUv;\n\n    \t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\n\n    // while ( heightFromTexture > currentLayerHeight )\n    // Infinite loops are not well supported. Do a \"large\" finite\n    // loop, but not too large, as it slows down some compilers.\n    \t\tfor ( int i = 0; i < 30; i += 1 ) {\n    \t\t\tif ( heightFromTexture <= currentLayerHeight ) {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tcurrentLayerHeight += layerHeight;\n    // Shift texture coordinates along vector V\n    \t\t\tcurrentTextureCoords -= dtex;\n    \t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\n    \t\t}\n\n    \t\t#ifdef USE_STEEP_PARALLAX\n\n    \t\t\treturn currentTextureCoords;\n\n    \t\t#elif defined( USE_RELIEF_PARALLAX )\n\n    \t\t\tvec2 deltaTexCoord = dtex / 2.0;\n    \t\t\tfloat deltaHeight = layerHeight / 2.0;\n\n    // Return to the mid point of previous layer\n    \t\t\tcurrentTextureCoords += deltaTexCoord;\n    \t\t\tcurrentLayerHeight -= deltaHeight;\n\n    // Binary search to increase precision of Steep Parallax Mapping\n    \t\t\tconst int numSearches = 5;\n    \t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {\n\n    \t\t\t\tdeltaTexCoord /= 2.0;\n    \t\t\t\tdeltaHeight /= 2.0;\n    \t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\n    // Shift along or against vector V\n    \t\t\t\tif( heightFromTexture > currentLayerHeight ) { // Below the surface\n\n    \t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;\n    \t\t\t\t\tcurrentLayerHeight += deltaHeight;\n\n    \t\t\t\t} else { // above the surface\n\n    \t\t\t\t\tcurrentTextureCoords += deltaTexCoord;\n    \t\t\t\t\tcurrentLayerHeight -= deltaHeight;\n\n    \t\t\t\t}\n\n    \t\t\t}\n    \t\t\treturn currentTextureCoords;\n\n    \t\t#elif defined( USE_OCLUSION_PARALLAX )\n\n    \t\t\tvec2 prevTCoords = currentTextureCoords + dtex;\n\n    // Heights for linear interpolation\n    \t\t\tfloat nextH = heightFromTexture - currentLayerHeight;\n    \t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\n\n    // Proportions for linear interpolation\n    \t\t\tfloat weight = nextH / ( nextH - prevH );\n\n    // Interpolation of texture coordinates\n    \t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\n\n    \t\t#else // NO_PARALLAX\n\n    \t\t\treturn vUv;\n\n    \t\t#endif\n\n    \t}\n    #endif\n\n    vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\n\n    \tvec2 texDx = dFdx( vUv );\n    \tvec2 texDy = dFdy( vUv );\n\n    \tvec3 vSigmaX = dFdx( surfPosition );\n    \tvec3 vSigmaY = dFdy( surfPosition );\n    \tvec3 vR1 = cross( vSigmaY, surfNormal );\n    \tvec3 vR2 = cross( surfNormal, vSigmaX );\n    \tfloat fDet = dot( vSigmaX, vR1 );\n\n    \tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\n    \tvec3 vProjVtex;\n    \tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\n    \tvProjVtex.z = dot( surfNormal, viewPosition );\n\n    \treturn parallaxMap( vProjVtex );\n    }\n\n    void main() {\n\n    \tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\n    \tgl_FragColor = texture2D( map, mapUv );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAKO,MAAM,iBAAiB;IAAA,wCAAA;IAE5B,OAAO;QACL,MAAM;QACN,OAAO;QACP,OAAO;QACP,WAAW;QAAA,aAAA;QACX,QAAQ;IACV;IAEA,UAAU;QACR,SAAS;YAAE,OAAO;QAAK;QACvB,KAAK;YAAE,OAAO;QAAK;QACnB,eAAe;YAAE,OAAO;QAAK;QAC7B,mBAAmB;YAAE,OAAO;QAAK;QACjC,mBAAmB;YAAE,OAAO;QAAK;IACnC;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;EAAA,CAAA;IAgBzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA6I7B"}},
    {"offset": {"line": 5773, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/PixelShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/PixelShader.ts"],"sourcesContent":["/**\n * Pixelation shader\n */\n\nexport const PixelShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: null },\n    pixelSize: { value: 1 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying highp vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float pixelSize;\n    uniform vec2 resolution;\n\n    varying highp vec2 vUv;\n\n    void main(){\n\n      vec2 dxy = pixelSize / resolution;\n      vec2 coord = dxy * floor( vUv / dxy );\n      gl_FragColor = texture2D(tDiffuse, coord);\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAIO,MAAM,cAAc;IACzB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAE;IACxB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;EAAA,CAAA;AAe7B"}},
    {"offset": {"line": 5821, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/RGBShiftShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/RGBShiftShader.ts"],"sourcesContent":["/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nexport const RGBShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    amount: { value: 0.005 },\n    angle: { value: 0.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float amount;\n    uniform float angle;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 offset = amount * vec2( cos(angle), sin(angle));\n    \tvec4 cr = texture2D(tDiffuse, vUv + offset);\n    \tvec4 cga = texture2D(tDiffuse, vUv);\n    \tvec4 cb = texture2D(tDiffuse, vUv - offset);\n    \tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAUO,MAAM,iBAAiB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAM;QACvB,OAAO;YAAE,OAAO;QAAI;IACtB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;EAAA,CAAA;AAiB7B"}},
    {"offset": {"line": 5871, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SepiaShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SepiaShader.ts"],"sourcesContent":["/**\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nexport const SepiaShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    amount: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float amount;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 color = texture2D( tDiffuse, vUv );\n    \tvec3 c = color.rgb;\n\n    \tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n    \tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n    \tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n\n    \tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAMO,MAAM,cAAc;IACzB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAI;IACvB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAoB7B"}},
    {"offset": {"line": 5921, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SobelOperatorShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SobelOperatorShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nexport const SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\n\n    // kernel definition (in glsl matrices are filled in column-major order)\n\n    \tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel\n    \tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel\n\n    // fetch the 3x3 neighbourhood of a fragment\n\n    // first column\n\n    \tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\n    \tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\n    \tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\n\n    // second column\n\n    \tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\n    \tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\n    \tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\n\n    // third column\n\n    \tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\n    \tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\n    \tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\n\n    // gradient value in x direction\n\n    \tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \n    \t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \n    \t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \n\n    // gradient value in y direction\n\n    \tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \n    \t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \n    \t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \n\n    // magnitute of the total gradient\n\n    \tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\n\n    \tgl_FragColor = vec4( vec3( G ), 1 );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AASO,MAAM,sBAAsB;IACjC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;IACrD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;EAAA,CAAA;IAYzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAsD7B"}},
    {"offset": {"line": 6008, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/SubsurfaceScatteringShader.ts"],"sourcesContent":["import { Color, ShaderChunk, ShaderLib, UniformsUtils } from 'three'\n\n/**\n * ------------------------------------------------------------------------------------------\n * Subsurface Scattering shader\n * Based on GDC 2011  Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n *------------------------------------------------------------------------------------------\n */\n\nlet _SubsurfaceScatteringShader: any\n\nfunction get() {\n  if (_SubsurfaceScatteringShader) return _SubsurfaceScatteringShader\n\n  const meshphong_frag_head = ShaderChunk['meshphong_frag'].slice(\n    0,\n    ShaderChunk['meshphong_frag'].indexOf('void main() {'),\n  )\n  const meshphong_frag_body = ShaderChunk['meshphong_frag'].slice(\n    ShaderChunk['meshphong_frag'].indexOf('void main() {'),\n  )\n\n  _SubsurfaceScatteringShader = {\n    uniforms: UniformsUtils.merge([\n      ShaderLib['phong'].uniforms,\n      {\n        thicknessMap: { value: null },\n        thicknessColor: { value: new Color(0xffffff) },\n        thicknessDistortion: { value: 0.1 },\n        thicknessAmbient: { value: 0.0 },\n        thicknessAttenuation: { value: 0.1 },\n        thicknessPower: { value: 2.0 },\n        thicknessScale: { value: 10.0 },\n      },\n    ]),\n\n    vertexShader: /* glsl */ `\n    #define USE_UV\n    ${ShaderChunk['meshphong_vert']}\n  `,\n    fragmentShader: /* glsl */ `\n    #define USE_UV',\n    #define SUBSURFACE',\n\n    ${meshphong_frag_head}\n\n    uniform sampler2D thicknessMap;\n    uniform float thicknessPower;\n    uniform float thicknessScale;\n    uniform float thicknessDistortion;\n    uniform float thicknessAmbient;\n    uniform float thicknessAttenuation;\n    uniform vec3 thicknessColor;\n\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n    \tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\n    \tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n    \tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n    \tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n    \treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n    }\n\n    ${meshphong_frag_body.replace(\n      '#include <lights_fragment_begin>',\n      ShaderChunk['lights_fragment_begin'].replace(\n        /RE_Direct\\( directLight, geometry, material, reflectedLight \\);/g,\n        /* glsl */ `\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n        #if defined( SUBSURFACE ) && defined( USE_UV )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      `,\n      ),\n    )}\n  `,\n  }\n\n  return _SubsurfaceScatteringShader\n}\n\nexport const SubsurfaceScatteringShader = {\n  get uniforms() {\n    return get().uniforms\n  },\n  set uniforms(value) {\n    get().uniforms = value\n  },\n  get vertexShader() {\n    return get().vertexShader\n  },\n  set vertexShader(value) {\n    get().vertexShader = value\n  },\n  get fragmentShader() {\n    return get().vertexShader\n  },\n  set fragmentShader(value) {\n    get().vertexShader = value\n  },\n}\n"],"names":[],"mappings":";;;;;;;AAUA,IAAI;AAEJ,SAAS,MAAM;IACT,IAAA,6BAAoC,OAAA;IAElC,MAAA,sBAAsB,mLAAA,CAAY,gBAAgB,CAAA,CAAE,KAAA,CACxD,GACA,mLAAA,CAAY,gBAAgB,CAAA,CAAE,OAAA,CAAQ,eAAe;IAEjD,MAAA,sBAAsB,mLAAA,CAAY,gBAAgB,CAAA,CAAE,KAAA,CACxD,mLAAA,CAAY,gBAAgB,CAAA,CAAE,OAAA,CAAQ,eAAe;IAGzB,8BAAA;QAC5B,UAAU,mKAAA,CAAc,KAAA,CAAM;YAC5B,iLAAA,CAAU,OAAO,CAAA,CAAE,QAAA;YACnB;gBACE,cAAc;oBAAE,OAAO;gBAAK;gBAC5B,gBAAgB;oBAAE,OAAO,IAAI,2JAAA,CAAM,QAAQ;gBAAE;gBAC7C,qBAAqB;oBAAE,OAAO;gBAAI;gBAClC,kBAAkB;oBAAE,OAAO;gBAAI;gBAC/B,sBAAsB;oBAAE,OAAO;gBAAI;gBACnC,gBAAgB;oBAAE,OAAO;gBAAI;gBAC7B,gBAAgB;oBAAE,OAAO;gBAAK;YAChC;SACD;QAED,cAAA,QAAA,GAAyB,CAAA;;IAAA,EAEvB,mLAAA,CAAY,gBAAgB,CAAA,CAAA;EAAA,CAAA;QAE9B,gBAAA,QAAA,GAA2B,CAAA;;;;IAAA,EAIzB,oBAAA;;;;;;;;;;;;;;;;;;IAAA,EAkBA,oBAAoB,OAAA,CACpB,oCACA,mLAAA,CAAY,uBAAuB,CAAA,CAAE,OAAA,CACnC,oEAAA,QAAA,GACW,CAAA;;;;;;MAAA,CAAA,GAOb;EAAA,CAAA;IACF;IAIK,OAAA;AACT;AAEO,MAAM,6BAA6B;IACxC,IAAI,YAAW;QACb,OAAO,IAAM,EAAA,QAAA;IACf;IACA,IAAI,UAAS,MAAO;QAClB,MAAM,QAAA,GAAW;IACnB;IACA,IAAI,gBAAe;QACjB,OAAO,IAAM,EAAA,YAAA;IACf;IACA,IAAI,cAAa,MAAO;QACtB,MAAM,YAAA,GAAe;IACvB;IACA,IAAI,kBAAiB;QACnB,OAAO,IAAM,EAAA,YAAA;IACf;IACA,IAAI,gBAAe,MAAO;QACxB,MAAM,YAAA,GAAe;IACvB;AACF"}},
    {"offset": {"line": 6110, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/TechnicolorShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/TechnicolorShader.ts"],"sourcesContent":["/**\n * Technicolor Shader\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n */\n\nexport const TechnicolorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\n    \tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\n\n    \tgl_FragColor = newTex;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAOO,MAAM,oBAAoB;IAC/B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;IAC1B;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;EAAA,CAAA;AAa7B"}},
    {"offset": {"line": 6150, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/ToonShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/ToonShader.ts"],"sourcesContent":["import { Color, Vector3 } from 'three'\n\n/**\n * Currently contains:\n *\n *\ttoon1\n *\ttoon2\n *\thatching\n *\tdotted\n */\n\nexport const ToonShader1 = {\n  uniforms: {\n    uDirLightPos: { value: /* @__PURE__ */ new Vector3() },\n    uDirLightColor: { value: /* @__PURE__ */ new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: /* @__PURE__ */ new Color(0x050505) },\n\n    uBaseColor: { value: /* @__PURE__ */ new Color(0xffffff) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec3 vNormal;\n    varying vec3 vRefract;\n\n    void main() {\n\n    \tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    \tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \tvec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\n    \tvNormal = normalize( normalMatrix * normal );\n\n    \tvec3 I = worldPosition.xyz - cameraPosition;\n    \tvRefract = refract( normalize( I ), worldNormal, 1.02 );\n\n    \tgl_Position = projectionMatrix * mvPosition;\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec3 uBaseColor;\n\n    uniform vec3 uDirLightPos;\n    uniform vec3 uDirLightColor;\n\n    uniform vec3 uAmbientLightColor;\n\n    varying vec3 vNormal;\n\n    varying vec3 vRefract;\n\n    void main() {\n\n    \tfloat directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);\n    \tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\n\n    \tfloat intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );\n    \tintensity += length(lightWeighting) * 0.2;\n\n    \tfloat cameraWeighting = dot( normalize( vNormal ), vRefract );\n    \tintensity += pow( 1.0 - length( cameraWeighting ), 6.0 );\n    \tintensity = intensity * 0.2 + 0.3;\n\n    \tif ( intensity < 0.50 ) {\n\n    \t\tgl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );\n\n    \t} else {\n\n    \t\tgl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );\n\n    }\n\n    }\n  `,\n}\n\nexport const ToonShader2 = {\n  uniforms: {\n    uDirLightPos: { value: /* @__PURE__ */ new Vector3() },\n    uDirLightColor: { value: /* @__PURE__ */ new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: /* @__PURE__ */ new Color(0x050505) },\n\n    uBaseColor: { value: /* @__PURE__ */ new Color(0xeeeeee) },\n    uLineColor1: { value: /* @__PURE__ */ new Color(0x808080) },\n    uLineColor2: { value: /* @__PURE__ */ new Color(0x000000) },\n    uLineColor3: { value: /* @__PURE__ */ new Color(0x000000) },\n    uLineColor4: { value: /* @__PURE__ */ new Color(0x000000) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    \tvNormal = normalize( normalMatrix * normal );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec3 uBaseColor;\n    uniform vec3 uLineColor1;\n    uniform vec3 uLineColor2;\n    uniform vec3 uLineColor3;\n    uniform vec3 uLineColor4;\n\n    uniform vec3 uDirLightPos;\n    uniform vec3 uDirLightColor;\n\n    uniform vec3 uAmbientLightColor;\n\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tfloat camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);\n    \tfloat light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);\n\n    \tgl_FragColor = vec4( uBaseColor, 1.0 );\n\n    \tif ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {\n\n    \t\tgl_FragColor *= vec4( uLineColor1, 1.0 );\n\n    \t}\n\n    \tif ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {\n\n    \t\tgl_FragColor *= vec4( uLineColor2, 1.0 );\n\n    \t}\n\n    }\n  `,\n}\n\nexport const ToonShaderHatching = {\n  uniforms: {\n    uDirLightPos: { value: /* @__PURE__ */ new Vector3() },\n    uDirLightColor: { value: /* @__PURE__ */ new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: /* @__PURE__ */ new Color(0x050505) },\n\n    uBaseColor: { value: /* @__PURE__ */ new Color(0xffffff) },\n    uLineColor1: { value: /* @__PURE__ */ new Color(0x000000) },\n    uLineColor2: { value: /* @__PURE__ */ new Color(0x000000) },\n    uLineColor3: { value: /* @__PURE__ */ new Color(0x000000) },\n    uLineColor4: { value: /* @__PURE__ */ new Color(0x000000) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    \tvNormal = normalize( normalMatrix * normal );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec3 uBaseColor;\n    uniform vec3 uLineColor1;\n    uniform vec3 uLineColor2;\n    uniform vec3 uLineColor3;\n    uniform vec3 uLineColor4;\n\n    uniform vec3 uDirLightPos;\n    uniform vec3 uDirLightColor;\n\n    uniform vec3 uAmbientLightColor;\n\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tfloat directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);\n    \tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\n\n    \tgl_FragColor = vec4( uBaseColor, 1.0 );\n\n    \tif ( length(lightWeighting) < 1.00 ) {\n\n    \t\tif ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {\n\n    \t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );\n\n    \t\t}\n\n    \t}\n\n    \tif ( length(lightWeighting) < 0.75 ) {\n\n    \t\tif (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {\n\n    \t\t\tgl_FragColor = vec4( uLineColor2, 1.0 );\n\n    \t\t}\n\n    \t}\n\n    \tif ( length(lightWeighting) < 0.50 ) {\n\n    \t\tif (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {\n\n    \t\t\tgl_FragColor = vec4( uLineColor3, 1.0 );\n\n    \t\t}\n\n    \t}\n\n    \tif ( length(lightWeighting) < 0.3465 ) {\n\n    \t\tif (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {\n\n    \t\t\tgl_FragColor = vec4( uLineColor4, 1.0 );\n\n    \t}\n\n    \t}\n\n    }\n  `,\n}\n\nexport const ToonShaderDotted = {\n  uniforms: {\n    uDirLightPos: { value: /* @__PURE__ */ new Vector3() },\n    uDirLightColor: { value: /* @__PURE__ */ new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: /* @__PURE__ */ new Color(0x050505) },\n\n    uBaseColor: { value: /* @__PURE__ */ new Color(0xffffff) },\n    uLineColor1: { value: /* @__PURE__ */ new Color(0x000000) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    \tvNormal = normalize( normalMatrix * normal );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec3 uBaseColor;\n    uniform vec3 uLineColor1;\n    uniform vec3 uLineColor2;\n    uniform vec3 uLineColor3;\n    uniform vec3 uLineColor4;\n\n    uniform vec3 uDirLightPos;\n    uniform vec3 uDirLightColor;\n\n    uniform vec3 uAmbientLightColor;\n\n    varying vec3 vNormal;\n\n    void main() {\n\n    float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);\n    vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\n\n    gl_FragColor = vec4( uBaseColor, 1.0 );\n\n    if ( length(lightWeighting) < 1.00 ) {\n\n    \t\tif ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {\n\n    \t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );\n\n    \t\t}\n\n    \t}\n\n    \tif ( length(lightWeighting) < 0.50 ) {\n\n    \t\tif ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {\n\n    \t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );\n\n    \t\t}\n\n    \t}\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAWO,MAAM,cAAc;IACzB,UAAU;QACR,cAAc;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACrD,gBAAgB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QAE7D,oBAAoB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,MAAQ;QAAE;QAEjE,YAAY;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;IAC3D;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;;;;EAAA,CAAA;IAoBzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAoC7B;AAEO,MAAM,cAAc;IACzB,UAAU;QACR,cAAc;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACrD,gBAAgB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QAE7D,oBAAoB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,MAAQ;QAAE;QAEjE,YAAY;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QACzD,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,OAAQ;QAAE;QAC1D,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;QAC1D,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;QAC1D,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;IAC5D;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAmC7B;AAEO,MAAM,qBAAqB;IAChC,UAAU;QACR,cAAc;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACrD,gBAAgB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QAE7D,oBAAoB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,MAAQ;QAAE;QAEjE,YAAY;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QACzD,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;QAC1D,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;QAC1D,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;QAC1D,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;IAC5D;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA+D7B;AAEO,MAAM,mBAAmB;IAC9B,UAAU;QACR,cAAc;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA;QAAU;QACrD,gBAAgB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QAE7D,oBAAoB;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,MAAQ;QAAE;QAEjE,YAAY;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,QAAQ;QAAE;QACzD,aAAa;YAAE,OAA2B,aAAA,GAAA,IAAA,2JAAA,CAAM,CAAQ;QAAE;IAC5D;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2C7B"}},
    {"offset": {"line": 6485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/TriangleBlurShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/TriangleBlurShader.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nexport const TriangleBlurShader = {\n  uniforms: {\n    texture: { value: null },\n    delta: { value: /* @__PURE__ */ new Vector2(1, 1) },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    #include <common>\n\n    #define ITERATIONS 10.0\n\n    uniform sampler2D texture;\n    uniform vec2 delta;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 color = vec4( 0.0 );\n\n    \tfloat total = 0.0;\n\n    // randomize the lookup values to hide the fixed number of samples\n\n    \tfloat offset = rand( vUv );\n\n    \tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\n\n    \t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;\n    \t\tfloat weight = 1.0 - abs( percent );\n\n    \t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;\n    \t\ttotal += weight;\n\n    \t}\n\n    \tgl_FragColor = color / total;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAYO,MAAM,qBAAqB;IAChC,UAAU;QACR,SAAS;YAAE,OAAO;QAAK;QACvB,OAAO;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,GAAG,CAAC;QAAE;IACpD;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAkC7B"}},
    {"offset": {"line": 6551, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/VerticalBlurShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/VerticalBlurShader.ts"],"sourcesContent":["/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type VerticalBlurShaderUniforms = {\n  tDiffuse: IUniform<Texture | null>\n  v: IUniform<number>\n}\n\nexport interface IVerticalBlurShader extends IShader<VerticalBlurShaderUniforms> {}\n\nexport const VerticalBlurShader: IVerticalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1.0 / 512.0 },\n  },\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n  fragmentShader: /* glsl */ `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `,\n}\n"],"names":[],"mappings":";;;;AAoBO,MAAM,qBAA0C;IACrD,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,GAAG;YAAE,OAAO,IAAM;QAAM;IAC1B;IACA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAUzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAyB7B"}},
    {"offset": {"line": 6606, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/VerticalTiltShiftShader.ts"],"sourcesContent":["/**\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nexport const VerticalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1.0 / 512.0 },\n    r: { value: 0.35 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float v;\n    uniform float r;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tfloat vv = v * abs( r - vUv.y );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AASO,MAAM,0BAA0B;IACrC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,GAAG;YAAE,OAAO,IAAM;QAAM;QACxB,GAAG;YAAE,OAAO;QAAK;IACnB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2B7B"}},
    {"offset": {"line": 6666, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/VignetteShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/VignetteShader.ts"],"sourcesContent":["/**\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nexport const VignetteShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    offset: { value: 1.0 },\n    darkness: { value: 1.0 },\n  },\n\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform float offset;\n    uniform float darkness;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    // Eskils vignette\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n    \tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n    \tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n\n    /*\n\t\t// alternative version from glfx.js\n\t\t// this one makes more \"dusty\" look (as opposed to \"burned\")\n\n\t\tvec4 color = texture2D( tDiffuse, vUv );\n\t\tfloat dist = distance( vUv, vec2( 0.5 ) );\n\t\tcolor.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\n\t\tgl_FragColor = color;\n\t\t*/\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAMO,MAAM,iBAAiB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAI;QACrB,UAAU;YAAE,OAAO;QAAI;IACzB;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;EAAA,CAAA;IAWzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA4B7B"}},
    {"offset": {"line": 6727, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/VolumeShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/VolumeShader.ts"],"sourcesContent":["import { Vector2, Vector3 } from 'three'\n\n/**\n * Shaders to render 3D volumes using raycasting.\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n * This is not the only approach, therefore it's marked 1.\n */\n\nexport const VolumeRenderShader1 = {\n  uniforms: {\n    u_size: { value: /* @__PURE__ */ new Vector3(1, 1, 1) },\n    u_renderstyle: { value: 0 },\n    u_renderthreshold: { value: 0.5 },\n    u_clim: { value: /* @__PURE__ */ new Vector2(1, 1) },\n    u_data: { value: null },\n    u_cmdata: { value: null },\n  },\n  vertexShader: /* glsl */ `\n\t\tvarying vec4 v_nearpos;\n\t\tvarying vec4 v_farpos;\n\t\tvarying vec3 v_position;\n\n\t\tvoid main() {\n\t\t\t// Prepare transforms to map to \"camera view\". See also:\n\t\t\t// https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n\t\t\tmat4 viewtransformf = modelViewMatrix;\n\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);\n\n\t\t\t// Project local vertex coordinate to camera position. Then do a step\n\t\t\t// backward (in cam coords) to the near clipping plane, and project back. Do\n\t\t\t// the same for the far clipping plane. This gives us all the information we\n\t\t\t// need to calculate the ray and truncate it to the viewing cone.\n\t\t\tvec4 position4 = vec4(position, 1.0);\n\t\t\tvec4 pos_in_cam = viewtransformf * position4;\n\n\t\t\t// Intersection of ray and near clipping plane (z = -1 in clip coords)\n\t\t\tpos_in_cam.z = -pos_in_cam.w;\n\t\t\tv_nearpos = viewtransformi * pos_in_cam;\n\n\t\t\t// Intersection of ray and far clipping plane (z = +1 in clip coords)\n\t\t\tpos_in_cam.z = pos_in_cam.w;\n\t\t\tv_farpos = viewtransformi * pos_in_cam;\n\n\t\t\t// Set varyings and output pos\n\t\t\tv_position = position;\n\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;\n\t\t}\n  `,\n  fragmentShader: /* glsl */ `\n\t\tprecision highp float;\n\t\tprecision mediump sampler3D;\n\n\t\tuniform vec3 u_size;\n\t\tuniform int u_renderstyle;\n\t\tuniform float u_renderthreshold;\n\t\tuniform vec2 u_clim;\n\n\t\tuniform sampler3D u_data;\n\t\tuniform sampler2D u_cmdata;\n\n\t\tvarying vec3 v_position;\n\t\tvarying vec4 v_nearpos;\n\t\tvarying vec4 v_farpos;\n\n\t// The maximum distance through our rendering volume is sqrt(3).\n\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3\n\t\tconst int REFINEMENT_STEPS = 4;\n\t\tconst float relative_step_size = 1.0;\n\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);\n\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);\n\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);\n\t\tconst float shininess = 40.0;\n\n\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\n\t\tfloat sample1(vec3 texcoords);\n\t\tvec4 apply_colormap(float val);\n\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\n\n\t\tvoid main() {\n\t// Normalize clipping plane info\n\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;\n\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;\n\n\t// Calculate unit vector pointing in the view direction through this fragment.\n\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);\n\n\t// Compute the (negative) distance to the front surface or near clipping plane.\n\t// v_position is the back face of the cuboid, so the initial distance calculated in the dot\n\t// product below is the distance from near clip plane to the back of the cuboid\n\t\t\tfloat distance = dot(nearpos - v_position, view_ray);\n\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,\n\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));\n\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,\n\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));\n\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,\n\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));\n\n\t// Now we have the starting position on the front surface\n\t\t\tvec3 front = v_position + view_ray * distance;\n\n\t// Decide how many steps to take\n\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);\n\t\t\tif ( nsteps < 1 )\n\t\t\t\tdiscard;\n\n\t// Get starting location and step vector in texture coordinates\n\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);\n\t\t\tvec3 start_loc = front / u_size;\n\n\t// For testing: show the number of steps. This helps to establish\n\t// whether the rays are correctly oriented\n\t//gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);\n\t//return;\n\n\t\t\tif (u_renderstyle == 0)\n\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);\n\t\t\telse if (u_renderstyle == 1)\n\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);\n\n\t\t\tif (gl_FragColor.a < 0.05)\n\t\t\t\tdiscard;\n\t\t}\n\n\t\tfloat sample1(vec3 texcoords) {\n\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */\n\t\t\treturn texture(u_data, texcoords.xyz).r;\n\t\t}\n\n\t\tvec4 apply_colormap(float val) {\n\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);\n\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));\n\t\t}\n\n\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n\n\t\t\tfloat max_val = -1e6;\n\t\t\tint max_i = 100;\n\t\t\tvec3 loc = start_loc;\n\n\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t// inside the loop.\n\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\n\t\t\t\tif (iter >= nsteps)\n\t\t\t\t\tbreak;\n\t// Sample from the 3D texture\n\t\t\t\tfloat val = sample1(loc);\n\t// Apply MIP operation\n\t\t\t\tif (val > max_val) {\n\t\t\t\t\tmax_val = val;\n\t\t\t\t\tmax_i = iter;\n\t\t\t\t}\n\t// Advance location deeper into the volume\n\t\t\t\tloc += step;\n\t\t\t}\n\n\t// Refine location, gives crispier images\n\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);\n\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\n\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\n\t\t\t\tmax_val = max(max_val, sample1(iloc));\n\t\t\t\tiloc += istep;\n\t\t\t}\n\n\t// Resolve final color\n\t\t\tgl_FragColor = apply_colormap(max_val);\n\t\t}\n\n\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n\n\t\t\tgl_FragColor = vec4(0.0);\t// init transparent\n\t\t\tvec4 color3 = vec4(0.0);\t// final color\n\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative\n\t\t\tvec3 loc = start_loc;\n\n\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);\n\n\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t// inside the loop.\n\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\n\t\t\t\tif (iter >= nsteps)\n\t\t\t\t\tbreak;\n\n\t// Sample from the 3D texture\n\t\t\t\tfloat val = sample1(loc);\n\n\t\t\t\tif (val > low_threshold) {\n\t// Take the last interval in smaller steps\n\t\t\t\t\tvec3 iloc = loc - 0.5 * step;\n\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\n\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\n\t\t\t\t\t\tval = sample1(iloc);\n\t\t\t\t\t\tif (val > u_renderthreshold) {\n\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tiloc += istep;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t// Advance location deeper into the volume\n\t\t\t\tloc += step;\n\t\t\t}\n\t\t}\n\n\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)\n\t\t{\n\t// Calculate color by incorporating lighting\n\n\t// View direction\n\t\t\tvec3 V = normalize(view_ray);\n\n\t// calculate normal vector from gradient\n\t\t\tvec3 N;\n\t\t\tfloat val1, val2;\n\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));\n\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));\n\t\t\tN[0] = val1 - val2;\n\t\t\tval = max(max(val1, val2), val);\n\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));\n\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));\n\t\t\tN[1] = val1 - val2;\n\t\t\tval = max(max(val1, val2), val);\n\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));\n\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));\n\t\t\tN[2] = val1 - val2;\n\t\t\tval = max(max(val1, val2), val);\n\n\t\t\tfloat gm = length(N); // gradient magnitude\n\t\t\tN = normalize(N);\n\n\t// Flip normal so it points towards viewer\n\t\t\tfloat Nselect = float(dot(N, V) > 0.0);\n\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;\n\n\t// Init colors\n\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);\n\n\t// note: could allow multiple lights\n\t\t\tfor (int i=0; i<1; i++)\n\t\t\t{\n\t// Get light direction (make sure to prevent zero devision)\n\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];\n\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );\n\t\t\t\tL = normalize(L + (1.0 - lightEnabled));\n\n\t// Calculate lighting properties\n\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);\n\t\t\t\tvec3 H = normalize(L+V); // Halfway vector\n\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);\n\n\t// Calculate mask\n\t\t\t\tfloat mask1 = lightEnabled;\n\n\t// Calculate colors\n\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;\n\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;\n\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;\n\t\t\t}\n\n\t// Calculate final color by componing different components\n\t\t\tvec4 final_color;\n\t\t\tvec4 color = apply_colormap(val);\n\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;\n\t\t\tfinal_color.a = color.a;\n\t\t\treturn final_color;\n\t\t}\n  `,\n}\n"],"names":[],"mappings":";;;;;;AAQO,MAAM,sBAAsB;IACjC,UAAU;QACR,QAAQ;YAAE,OAAuB,aAAA,GAAA,IAAI,6JAAA,CAAQ,GAAG,GAAG,CAAC;QAAE;QACtD,eAAe;YAAE,OAAO;QAAE;QAC1B,mBAAmB;YAAE,OAAO;QAAI;QAChC,QAAQ;YAAE,OAAA,aAAA,GAAA,IAA2B,6JAAA,CAAQ,GAAG,CAAC;QAAE;QACnD,QAAQ;YAAE,OAAO;QAAK;QACtB,UAAU;YAAE,OAAO;QAAK;IAC1B;IACA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;IA+BzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AAiO7B"}},
    {"offset": {"line": 7017, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/shaders/WaterRefractionShader.js","sources":["file:///C:/Users/sumith/OneDrive%20-%20Prestigeoneluxury/Documents/PrestigeOne%20Projects/VS%20Projects/prestigeone/quadplex80.com/node_modules/src/shaders/WaterRefractionShader.ts"],"sourcesContent":["export const WaterRefractionShader = {\n  uniforms: {\n    color: {\n      value: null,\n    },\n\n    time: {\n      value: 0,\n    },\n\n    tDiffuse: {\n      value: null,\n    },\n\n    tDudv: {\n      value: null,\n    },\n\n    textureMatrix: {\n      value: null,\n    },\n  },\n\n  vertexShader: /* glsl */ `\n    uniform mat4 textureMatrix;\n\n    varying vec2 vUv;\n    varying vec4 vUvRefraction;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tvUvRefraction = textureMatrix * vec4( position, 1.0 );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n\n  fragmentShader: /* glsl */ `\n    uniform vec3 color;\n    uniform float time;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDudv;\n\n    varying vec2 vUv;\n    varying vec4 vUvRefraction;\n\n    float blendOverlay( float base, float blend ) {\n\n    \treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n    }\n\n    vec3 blendOverlay( vec3 base, vec3 blend ) {\n\n    \treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );\n\n    }\n\n    void main() {\n\n     float waveStrength = 0.1;\n     float waveSpeed = 0.03;\n\n    // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\n\n    \tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;\n    \tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );\n    \tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;\n\n    // new uv coords\n\n     vec4 uv = vec4( vUvRefraction );\n     uv.xy += distortion;\n\n    \tvec4 base = texture2DProj( tDiffuse, uv );\n\n    \tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n    }\n  `,\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM,wBAAwB;IACnC,UAAU;QACR,OAAO;YACL,OAAO;QACT;QAEA,MAAM;YACJ,OAAO;QACT;QAEA,UAAU;YACR,OAAO;QACT;QAEA,OAAO;YACL,OAAO;QACT;QAEA,eAAe;YACb,OAAO;QACT;IACF;IAEA,cAAA,QAAA,GAAyB,CAAA;;;;;;;;;;;;;;;EAAA,CAAA;IAiBzB,gBAAA,QAAA,GAA2B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,CAAA;AA2C7B"}}]
}