<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Cloud Fly-through with Building Behind</title>

  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet"/>

  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html.lenis,html.lenis body{height:auto}
    .lenis.lenis-smooth{scroll-behavior:auto!important}

    body{font-family:"Inter",sans-serif;color:#000;min-height:100vh}

    /* Sky background (lowest layer) */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: #c8c0b8;
      z-index: 0;
    }

    /* Building image (middle layer - behind clouds) */
    #building_image{
      position:fixed;top:50%;left:50%;
      transform:translate(-50%,-50%) scale(0.2);
      width:500vw;height:500vh;
      background-image:url('https://wordpress-1188165-5928879.cloudwaysapps.com/3js/1743602009-og-image.jpg');
      background-repeat:no-repeat;
      background-position:center center;
      background-size:cover;
      z-index:2;                /* above sky, behind clouds */
      opacity:0;                /* hidden initially */
      pointer-events:none;
      will-change:transform,opacity;
    }

    /* Clouds canvas (IN FRONT of building) */
    #cloud_container{
      position:fixed;inset:0;width:100%;height:100%;
      z-index:5;                /* in front of building */
      pointer-events:none;
      background:transparent;   /* NO background - see through to building */
      opacity:1;                /* will fade out near the end */
      will-change:opacity;
    }
    canvas{display:block;width:100%;height:100%}
    .loading{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      color:#fff;font:18px/1 Arial, sans-serif;text-shadow:0 2px 4px rgba(0,0,0,.3);z-index:10;
    }

    /* Content (above both layers for readability) */
    .scroll-content{position:relative;z-index:10;pointer-events:none}
    .scroll-content a,.scroll-content button{pointer-events:auto}

    .section{
      min-height:100vh;display:flex;align-items:center;justify-content:center;
      padding:60px 40px;opacity:0;transform:translateY(80px);
      transition:opacity .8s ease-out,transform .8s ease-out;pointer-events:auto;
    }
    .section.visible{opacity:1;transform:translateY(0)}
    .section-inner{max-width:1200px;width:100%}

    .hero-section{min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;opacity:1;transform:none}
    .hero-title{font-size:clamp(40px,8vw,70px);font-weight:700;letter-spacing:-2px;color:#fff;text-shadow:0 4px 20px rgba(0,0,0,.3);margin-bottom:20px}
    .hero-subtitle{font-size:clamp(16px,2vw,24px);font-weight:300;opacity:.95;color:#fff;text-shadow:0 2px 10px rgba(0,0,0,.3);margin-bottom:40px}

    .scroll-indicator{position:absolute;bottom:40px;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;align-items:center;gap:10px;animation:bounce 2s infinite}
    .scroll-indicator span{font-size:14px;text-transform:uppercase;letter-spacing:2px;color:#fff;opacity:.75}
    .scroll-indicator .arrow{width:24px;height:24px;border-right:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(45deg);opacity:.7}
    @keyframes bounce{
      0%,20%,50%,80%,100%{transform:translateX(-50%) translateY(0)}
      40%{transform:translateX(-50%) translateY(-10px)}
      60%{transform:translateX(-50%) translateY(-5px)}
    }

    .enter-button{
      padding:18px 48px;background:rgba(255,255,255,.15);
      backdrop-filter:blur(20px);border:2px solid rgba(255,255,255,.3);
      border-radius:50px;color:#fff;font-size:16px;font-weight:600;text-transform:uppercase;letter-spacing:2px;cursor:pointer;transition:all .3s ease;z-index:5;
    }
    .enter-button:hover{background:rgba(255,255,255,.25);border-color:rgba(255,255,255,.5);transform:scale(1.05);box-shadow:0 10px 40px rgba(0,0,0,.2)}
    .enter-button.hidden{opacity:0;pointer-events:none}

    .content-card{
      background:rgba(255,255,255,.1);backdrop-filter:blur(20px);
      border:1px solid rgba(255,255,255,.2);border-radius:24px;padding:60px;color:#fff;
      box-shadow:0 25px 50px rgba(0,0,0,.15)
    }
    .content-card h2{font-size:clamp(32px,5vw,56px);font-weight:600;margin-bottom:24px;letter-spacing:-1px}
    .content-card p{font-size:clamp(16px,1.5vw,20px);line-height:1.7;opacity:.95;margin-bottom:20px}
  </style>
</head>
<body>
  <!-- Building image (BEHIND) -->
  <div id="building_image"></div>

  <!-- Clouds canvas (FRONT) -->
  <div id="cloud_container">
    <div class="loading" id="loading_text">Loading clouds...</div>
  </div>

  <!-- Content -->
  <div class="scroll-content">
    <section class="section hero-section">
      <h1 class="hero-title">Lorem ipsum dolor sit amet</h1>
      <p class="hero-subtitle">Fly through the clouds — then gradually reveal the building as you arrive.</p>
      <button class="enter-button" id="enterButton">Enter Experience</button>
      <div class="scroll-indicator"><span>Scroll</span><div class="arrow"></div></div>
    </section>

    <section class="section">
      <div class="section-inner">
        <div class="content-card">
          <h2>Sequence Design</h2>
          <p>Clouds stay in front while flying. The building fades/scales behind, then clouds fade out near the end so the building comes through gradually.</p>
        </div>
      </div>
    </section>
  </div>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
  <script src="https://unpkg.com/lenis@1.1.13/dist/lenis.min.js"></script>

  <script>
    /* Lenis smooth scroll (page nicety; hero zoom is time-based) */
    const lenis = new Lenis({
      duration: 1.0,
      easing: (t)=>Math.min(1, 1.001 - Math.pow(2, -10*t)),
      smoothWheel: true, wheelMultiplier: 1, touchMultiplier: 1, syncTouch: true,
    });
    function raf(t){ lenis.raf(t); requestAnimationFrame(raf) }
    requestAnimationFrame(raf);

    /* Reveal sections on enter */
    const io = new IntersectionObserver((ents)=>{
      ents.forEach(en=>{ if(en.isIntersecting) en.target.classList.add('visible'); });
    }, {threshold:.20});
    document.querySelectorAll('.section').forEach(s=>io.observe(s));

    class CloudEffect{
      constructor(){
        this.scene=null; this.camera=null; this.renderer=null;
        this.mouse_x=0; this.mouse_y=0; this.start_time=Date.now();
        this.window_half_x=innerWidth/2; this.window_half_y=innerHeight/2;
        this.animation_id=null; this.container=null;
        this.base_speed=0.03;

        // Button-triggered zoom timeline
        this.zoom_animation_active=false;
        this.zoom_animation_progress=0;   // 0→1 linear
        this.zoom_animation_duration=16;  // seconds
        this.zoom_start_time=0;

        // Cloud fade timing (clouds IN FRONT fade out near the end)
        this.clouds_fade_start = 0.70;    // 70% → start reducing clouds opacity
        this.clouds_fade_end   = 1.00;    // 100% → clouds fully transparent

        this.init();
      }

      ease_in_out_cubic(t){ return t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

      init(){
        this.container = document.getElementById('cloud_container');
        this.scene     = new THREE.Scene();
        this.camera    = new THREE.PerspectiveCamera(30, innerWidth/innerHeight, 1, 3000);
        this.renderer  = new THREE.WebGLRenderer({ antialias:false, alpha:true });

        new THREE.TextureLoader().load(
          "https://mrdoob.com/lab/javascript/webgl/clouds/cloud10.png",
          (texture)=>this.setup_scene(texture),
          undefined,
          (err)=>console.error("Cloud texture load error", err)
        );
      }

      setup_scene(texture){
        this.camera.position.z = 6000;

        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearMipmapLinearFilter;

        const fog = new THREE.Fog(0xc8c0b8, -100, 3000);
        this.scene.fog = fog;

        const material = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: texture },
            fogColor: { value: fog.color },
            fogNear: { value: fog.near },
            fogFar: { value: fog.far }
          },
          vertexShader: `
            varying vec2 vUv;
            void main(){
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }`,
          fragmentShader: `
            uniform sampler2D map;
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            varying vec2 vUv;
            void main(){
              float depth = gl_FragCoord.z / gl_FragCoord.w;
              float fogFactor = smoothstep(fogNear, fogFar, depth);
              gl_FragColor = texture2D(map, vUv);
              gl_FragColor.w *= pow(gl_FragCoord.z, 20.0);
              gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);
            }`,
          depthWrite:false, depthTest:false, transparent:true
        });

        const plane = new THREE.PlaneGeometry(64,64);
        const o     = new THREE.Object3D();
        const geos  = [];

        for(let i=0;i<8000;i++){
          o.position.x = Math.random()*1000 - 500;
          // Better fill bottom area: extend range and add bias toward lower positions
          o.position.y = -Math.random()*Math.random()*500 - 50;
          o.position.z = i;
          o.rotation.z = Math.random()*Math.PI;
          o.scale.x = o.scale.y = Math.random()*Math.random()*1.5 + 0.5;
          o.updateMatrix();

          const g = plane.clone();
          g.applyMatrix4(o.matrix);
          geos.push(g);
        }

        const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(geos);
        const m1 = new THREE.Mesh(merged, material); m1.renderOrder = 2;
        const m2 = m1.clone(); m2.position.z = -8000; m2.renderOrder = 1;
        this.scene.add(m1); this.scene.add(m2);

        this.renderer.setSize(innerWidth, innerHeight);
        this.container.appendChild(this.renderer.domElement);

        // Events
        addEventListener('mousemove', e=>this.on_mouse(e));
        addEventListener('resize',   ()=>this.on_resize());

        // Button
        const btn = document.getElementById('enterButton');
        if(btn){ btn.addEventListener('click', ()=>this.start_zoom()); }

        // Go
        this.hide_loader();
        this.loop();
      }

      start_zoom(){
        if(this.zoom_animation_active) return;
        this.zoom_animation_active = true;
        this.zoom_start_time = Date.now();

        const btn = document.getElementById('enterButton');
        if(btn) btn.classList.add('hidden');
      }

      on_mouse(e){
        this.mouse_x = (e.clientX - this.window_half_x) * 0.25;
        this.mouse_y = (e.clientY - this.window_half_y) * 0.15;
      }

      on_resize(){
        this.window_half_x = innerWidth/2;
        this.window_half_y = innerHeight/2;
        this.camera.aspect = innerWidth/innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(innerWidth, innerHeight);
      }

      loop(){
        this.animation_id = requestAnimationFrame(()=>this.loop());

        // base cloud drift
        const drift = ((Date.now() - this.start_time) * this.base_speed) % 8000;
        let camZ = 6000;

        // progress & easing for the hero zoom
        let easedProgress = 0;
        if(this.zoom_animation_active){
          const elapsed = (Date.now() - this.zoom_start_time) / 1000;     // seconds
          this.zoom_animation_progress = Math.min(elapsed / this.zoom_animation_duration, 1); // 0→1
          easedProgress = this.ease_in_out_cubic(this.zoom_animation_progress);

          // Camera Z: approach and finish without snap
          const start_z = 6000, end_z = 220;
          camZ = start_z - (easedProgress * (start_z - end_z));

          // ---- Building (BEHIND) reveal & approach ----
          const buildingImg = document.getElementById('building_image');
          if (buildingImg){
            // Opacity: building appears early (5%→25%) so user sees it far away
            const fadeStart = 0.05, fadeEnd = 0.25;
            let opacity = 0;
            if (this.zoom_animation_progress >= fadeStart){
              const t0 = (this.zoom_animation_progress - fadeStart) / (fadeEnd - fadeStart);
              const t  = Math.max(0, Math.min(1, t0));
              const smooth = t * t * (3 - 2 * t);
              opacity = smooth;
            }
            if (this.zoom_animation_progress > fadeEnd) opacity = 1;
            buildingImg.style.opacity = opacity;

            // Scale: 0.2 → 0.6 - starts very small (far away), zooms as approaching
            const minScale = 0.2, maxScale = 0.6;
            const scale = minScale + (maxScale - minScale) * easedProgress;
            buildingImg.style.transform = `translate(-50%, -50%) scale(${scale})`;

            buildingImg.style.transition = 'transform 0s, opacity 0s';
          }

          // ---- Clouds (FRONT) fade OUT near the end so building becomes clear ----
          const cloudWrap = document.getElementById('cloud_container');
          if (cloudWrap){
            const cs = this.clouds_fade_start; // 0.70
            const ce = this.clouds_fade_end;   // 1.00
            let cOpacity = 1;
            if (this.zoom_animation_progress >= cs){
              const t0 = (this.zoom_animation_progress - cs) / (ce - cs);
              const t  = Math.max(0, Math.min(1, t0));
              const smooth = t * t * (3 - 2 * t);   // smoothstep fade-out
              cOpacity = 1 - smooth;                // 1 → 0
            }
            cloudWrap.style.opacity = cOpacity;
          }
        }

        // subtle mouse parallax
        this.camera.position.x += (this.mouse_x - this.camera.position.x) * 0.01;
        this.camera.position.y += (-this.mouse_y - this.camera.position.y) * 0.01;

        // combine drift + zoom
        this.camera.position.z = -drift + camZ;

        this.renderer.render(this.scene, this.camera);
      }

      hide_loader(){
        const el = document.getElementById('loading_text');
        if(el) el.style.display = 'none';
      }
    }

    // Start
    window.addEventListener('DOMContentLoaded', ()=>{ new CloudEffect(); });
  </script>
</body>
</html>
